diff -ru --new-file iproute2/Config iproute2-linkdelays/Config
--- iproute2/Config	Sun Apr 16 11:42:46 2000
+++ iproute2-linkdelays/Config	Tue Jun 17 14:23:53 2003
@@ -1,2 +1,4 @@
 TC_CONFIG_DIFFSERV=n
+TC_CONFIG_DELAY=y
+TC_CONFIG_PLR=y
 TC_CONFIG_ATM=n
diff -ru --new-file iproute2/examples/delay.eth0 iproute2-linkdelays/examples/delay.eth0
--- iproute2/examples/delay.eth0	Wed Dec 31 17:00:00 1969
+++ iproute2-linkdelays/examples/delay.eth0	Tue May 13 16:46:57 2003
@@ -0,0 +1,17 @@
+#! /bin/sh
+
+##
+# Point this to your tc binary.
+#
+TC=/home/root/tc
+##
+# Affect all packets on eth0
+#
+DEVICE=eth0
+##
+# Approx 1 second packet delay.
+#
+USECS=1000000
+
+${TC} qdisc add dev ${DEVICE} root delay ${USECS}
+
diff -ru --new-file iproute2/tc/Makefile iproute2-linkdelays/tc/Makefile
--- iproute2/tc/Makefile	Wed Jan  9 20:08:18 2002
+++ iproute2-linkdelays/tc/Makefile	Tue Jun 17 14:23:17 2003
@@ -13,6 +13,12 @@
 TCMODULES += f_u32.o
 TCMODULES += f_route.o
 TCMODULES += f_fw.o
+ifeq ($(TC_CONFIG_DELAY),y)
+	TCMODULES += q_delay.o
+endif
+ifeq ($(TC_CONFIG_PLR),y)
+	TCMODULES += q_plr.o
+endif
 ifeq ($(TC_CONFIG_DIFFSERV),y)
   TCMODULES += q_dsmark.o
   TCMODULES += q_gred.o
@@ -25,6 +31,7 @@
 endif
 
 #TCMODULES += q_csz.o
+TCMODULES += q_htb.o
 #TCMODULES += q_hpfq.o
 #TCMODULES += q_hfsc.o
 
diff -ru --new-file iproute2/tc/q_delay.c iproute2-linkdelays/tc/q_delay.c
--- iproute2/tc/q_delay.c	Wed Dec 31 17:00:00 1969
+++ iproute2-linkdelays/tc/q_delay.c	Thu Jul 10 18:19:51 2003
@@ -0,0 +1,133 @@
+/*
+ * q_delay.c		Delay.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ * Authors:	David T. McWherter, <dtm@vramp.net>
+ *			Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <syslog.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <string.h>
+
+#include "utils.h"
+#include "tc_util.h"
+
+static void explain(void)
+{
+	fprintf(stderr, "Usage: ... delay <microseconds> [reset_time (0|1)]\n");
+}
+
+static void explain1(char *arg)
+{
+	fprintf(stderr, "Illegal \"%s\"\n", arg);
+}
+
+
+#define usage() return(-1)
+
+static int 
+delay_parse_opt
+	(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
+{
+	struct tc_delay_qopt opt;
+        char *end;
+
+	memset(&opt, 0, sizeof(opt));
+
+	if ( argc > 4 ) { 
+          fprintf(stderr, "Too many arguments (seen: %d, expected: 2 or 4)\n",
+                  argc);
+          return -1;
+	} else if ( argc < 2 ) { 
+          fprintf(stderr, "Too few arguments (seen: %d, expected: 2 or 4)\n",
+                  argc);
+          return -1;
+	} else {
+
+          while ( argc > 0 ) { 
+            if (!strcmp(*argv, "usecs")) {
+              NEXT_ARG();
+              opt.delay_usec = strtoul(*argv,&end,0);
+              if (*end) {
+                explain1("microseconds");
+                return -1;
+              }
+              fprintf( stdout, "Usecs: %u\n", opt.delay_usec );
+            }
+            else if (!strcmp(*argv, "reset_time")) {
+              NEXT_ARG();
+              opt.reset_time = strtoul(*argv,&end,0);
+              if (*end) {
+                explain1("reset_time");
+                return -1;
+              }
+              fprintf( stdout, "reset_time: %u\n", opt.reset_time );
+            }
+            argc--;
+            argv++;
+          }
+        }
+
+	addattr_l(n, 1024, TCA_OPTIONS, &opt, sizeof(opt));
+
+	return 0;
+}
+
+static int 
+delay_print_opt
+	(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
+{
+	struct tc_delay_qopt *qopt;
+
+	if (opt == NULL)
+		return 0;
+
+	if ( RTA_PAYLOAD(opt) < sizeof(*qopt))
+		return -1;
+	
+	qopt = RTA_DATA(opt);
+	fprintf( f, "delay { %u } reset_time { %u }", 
+                 qopt->delay_usec,
+                 qopt->reset_time
+		);
+
+	return 0;
+}
+
+
+static int delay_print_xstats(struct qdisc_util *qu, FILE *f, struct rtattr *xstats)
+{
+	return 0;
+}
+
+
+static int 
+delay_parse_class_opt(struct qdisc_util *qu, int argc, char **argv,
+   struct nlmsghdr *n)
+{
+  return 0;
+}
+
+
+struct qdisc_util delay_util = {
+	NULL,
+	"delay",
+	delay_parse_opt,
+	delay_print_opt,
+	delay_print_xstats,
+
+        delay_parse_class_opt,
+        delay_print_opt,
+};
+
diff -ru --new-file iproute2/tc/q_htb.c iproute2-linkdelays/tc/q_htb.c
--- iproute2/tc/q_htb.c	Wed Dec 31 17:00:00 1969
+++ iproute2-linkdelays/tc/q_htb.c	Fri Jun 13 11:05:52 2003
@@ -0,0 +1,306 @@
+/*
+ * q_htb.c		HTB.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ * Authors:	Martin Devera, devik@cdi.cz
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <syslog.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <string.h>
+
+#include "utils.h"
+#include "tc_util.h"
+
+#define HTB_TC_VER 0x30003
+#if HTB_TC_VER >> 16 != TC_HTB_PROTOVER
+#error "Different kernel and TC HTB versions"
+#endif
+
+static void explain(void)
+{
+	fprintf(stderr, "Usage: ... qdisc add ... htb [default N] [r2q N]\n"
+		" default  minor id of class to which unclassified packets are sent {0}\n"
+		" r2q      DRR quantums are computed as rate in Bps/r2q {10}\n"
+		" debug    string of 16 numbers each 0-3 {0}\n\n"
+		"... class add ... htb rate R1 burst B1 [prio P] [slot S] [pslot PS]\n"
+		"                      [ceil R2] [cburst B2] [mtu MTU] [quantum Q]\n"
+		" rate     rate allocated to this class (class can still borrow)\n"
+		" burst    max bytes burst which can be accumulated during idle period {computed}\n"
+		" ceil     definite upper class rate (no borrows) {rate}\n"
+		" cburst   burst but for ceil {computed}\n"
+		" mtu      max packet size we create rate map for {1600}\n"
+		" prio     priority of leaf; lower are served first {0}\n"
+		" quantum  how much bytes to serve from leaf at once {use r2q}\n"
+		"\nTC HTB version %d.%d\n",HTB_TC_VER>>16,HTB_TC_VER&0xffff
+		);
+}
+
+static void explain1(char *arg)
+{
+    fprintf(stderr, "Illegal \"%s\"\n", arg);
+    explain();
+}
+
+
+#define usage() return(-1)
+
+static int htb_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
+{
+	struct tc_htb_glob opt;
+	struct rtattr *tail;
+	unsigned i; char *p;
+	memset(&opt,0,sizeof(opt));
+	opt.rate2quantum = 10;
+	opt.version = 3;
+
+	while (argc > 0) {
+		if (matches(*argv, "r2q") == 0) {
+		    NEXT_ARG();
+		    if (get_u32(&opt.rate2quantum, *argv, 10)) {
+			explain1("r2q"); return -1;
+		    }
+		} else if (matches(*argv, "default") == 0) {
+		    NEXT_ARG();
+		    if (get_u32(&opt.defcls, *argv, 16)) {
+			explain1("default"); return -1;
+		    }
+		} else if (matches(*argv, "debug") == 0) {
+		    NEXT_ARG(); p = *argv;
+		    for (i=0; i<16; i++,p++) {
+			if (*p<'0' || *p>'3') break;
+			opt.debug |= (*p-'0')<<(2*i);
+		    }
+		} else {
+			fprintf(stderr, "What is \"%s\"?\n", *argv);
+			explain();
+			return -1;
+		}
+		argc--; argv++;
+	}
+	tail = (struct rtattr*)(((void*)n)+NLMSG_ALIGN(n->nlmsg_len));
+	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
+	addattr_l(n, 2024, TCA_HTB_INIT, &opt, NLMSG_ALIGN(sizeof(opt)));
+	tail->rta_len = (((void*)n)+NLMSG_ALIGN(n->nlmsg_len)) - (void*)tail;
+	return 0;
+}
+
+static int htb_parse_class_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
+{
+	int ok=0;
+	struct tc_htb_opt opt;
+	__u32 rtab[256],ctab[256];
+	unsigned buffer=0,cbuffer=0;
+	int cell_log=-1,ccell_log = -1,mtu;
+	struct rtattr *tail;
+
+	memset(&opt, 0, sizeof(opt)); mtu = 1600; /* eth packet len */
+
+	while (argc > 0) {
+		if (matches(*argv, "prio") == 0) {
+			NEXT_ARG();
+			if (get_u32(&opt.prio, *argv, 10)) {
+				explain1("prio"); return -1;
+			}
+			ok++;
+		} else if (matches(*argv, "mtu") == 0) {
+			NEXT_ARG();
+			if (get_u32(&mtu, *argv, 10)) {
+				explain1("mtu"); return -1;
+			}
+		} else if (matches(*argv, "quantum") == 0) {
+			NEXT_ARG();
+			if (get_u32(&opt.quantum, *argv, 10)) {
+				explain1("quantum"); return -1;
+			}
+		} else if (matches(*argv, "burst") == 0 ||
+			strcmp(*argv, "buffer") == 0 ||
+			strcmp(*argv, "maxburst") == 0) {
+			NEXT_ARG();
+			if (get_size_and_cell(&buffer, &cell_log, *argv) < 0) {
+				explain1("buffer");
+				return -1;
+			}
+			ok++;
+		} else if (matches(*argv, "cburst") == 0 ||
+			strcmp(*argv, "cbuffer") == 0 ||
+			strcmp(*argv, "cmaxburst") == 0) {
+			NEXT_ARG();
+			if (get_size_and_cell(&cbuffer, &ccell_log, *argv) < 0) {
+				explain1("cbuffer");
+				return -1;
+			}
+			ok++;
+		} else if (strcmp(*argv, "ceil") == 0) {
+			NEXT_ARG();
+			if (opt.ceil.rate) {
+				fprintf(stderr, "Double \"ceil\" spec\n");
+				return -1;
+			}
+			if (get_rate(&opt.ceil.rate, *argv)) {
+				explain1("ceil");
+				return -1;
+			}
+			ok++;
+		} else if (strcmp(*argv, "rate") == 0) {
+			NEXT_ARG();
+			if (opt.rate.rate) {
+				fprintf(stderr, "Double \"rate\" spec\n");
+				return -1;
+			}
+			if (get_rate(&opt.rate.rate, *argv)) {
+				explain1("rate");
+				return -1;
+			}
+			ok++;
+		} else if (strcmp(*argv, "help") == 0) {
+			explain();
+			return -1;
+		} else {
+			fprintf(stderr, "What is \"%s\"?\n", *argv);
+			explain();
+			return -1;
+		}
+		argc--; argv++;
+	}
+
+/*	if (!ok)
+		return 0;*/
+
+	if (opt.rate.rate == 0) {
+		fprintf(stderr, "\"rate\" is required.\n");
+		return -1;
+	}
+	/* if ceil params are missing, use the same as rate */
+	if (!opt.ceil.rate) opt.ceil = opt.rate;
+
+	/* compute minimal allowed burst from rate; mtu is added here to make
+	   sute that buffer is larger than mtu and to have some safeguard space */
+	if (!buffer) buffer = opt.rate.rate / HZ + mtu;
+	if (!cbuffer) cbuffer = opt.ceil.rate / HZ + mtu;
+
+	if ((cell_log = tc_calc_rtable(opt.rate.rate, rtab, cell_log, mtu, 0)) < 0) {
+		fprintf(stderr, "htb: failed to calculate rate table.\n");
+		return -1;
+	}
+	opt.buffer = tc_calc_xmittime(opt.rate.rate, buffer);
+	opt.rate.cell_log = cell_log;
+	
+	if ((ccell_log = tc_calc_rtable(opt.ceil.rate, ctab, cell_log, mtu, 0)) < 0) {
+		fprintf(stderr, "htb: failed to calculate ceil rate table.\n");
+		return -1;
+	}
+	opt.cbuffer = tc_calc_xmittime(opt.ceil.rate, cbuffer);
+	opt.ceil.cell_log = ccell_log;
+
+	tail = (struct rtattr*)(((void*)n)+NLMSG_ALIGN(n->nlmsg_len));
+	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
+	addattr_l(n, 2024, TCA_HTB_PARMS, &opt, sizeof(opt));
+	addattr_l(n, 3024, TCA_HTB_RTAB, rtab, 1024);
+	addattr_l(n, 4024, TCA_HTB_CTAB, ctab, 1024);
+	tail->rta_len = (((void*)n)+NLMSG_ALIGN(n->nlmsg_len)) - (void*)tail;
+	return 0;
+}
+
+static int htb_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
+{
+	struct rtattr *tb[TCA_HTB_RTAB+1];
+	struct tc_htb_opt *hopt;
+	struct tc_htb_glob *gopt;
+	double buffer,cbuffer;
+	SPRINT_BUF(b1);
+	SPRINT_BUF(b2);
+
+	if (opt == NULL)
+		return 0;
+
+	memset(tb, 0, sizeof(tb));
+	parse_rtattr(tb, TCA_HTB_RTAB, RTA_DATA(opt), RTA_PAYLOAD(opt));
+
+	if (tb[TCA_HTB_PARMS]) {
+
+	    hopt = RTA_DATA(tb[TCA_HTB_PARMS]);
+	    if (RTA_PAYLOAD(tb[TCA_HTB_PARMS])  < sizeof(*hopt)) return -1;
+
+		if (!hopt->level) {
+			fprintf(f, "prio %d ", (int)hopt->prio);
+			if (show_details)
+				fprintf(f, "quantum %d ", (int)hopt->quantum);
+		}
+	    fprintf(f, "rate %s ", sprint_rate(hopt->rate.rate, b1));
+	    buffer = ((double)hopt->rate.rate*tc_core_tick2usec(hopt->buffer))/1000000;
+	    fprintf(f, "ceil %s ", sprint_rate(hopt->ceil.rate, b1));
+	    cbuffer = ((double)hopt->ceil.rate*tc_core_tick2usec(hopt->cbuffer))/1000000;
+	    if (show_details) {
+		fprintf(f, "burst %s/%u mpu %s ", sprint_size(buffer, b1),
+			1<<hopt->rate.cell_log, sprint_size(hopt->rate.mpu, b2));
+		fprintf(f, "cburst %s/%u mpu %s ", sprint_size(cbuffer, b1),
+			1<<hopt->ceil.cell_log, sprint_size(hopt->ceil.mpu, b2));
+		fprintf(f, "level %d ", (int)hopt->level);
+	    } else {
+		fprintf(f, "burst %s ", sprint_size(buffer, b1));
+		fprintf(f, "cburst %s ", sprint_size(cbuffer, b1));
+	    }
+	    if (show_raw)
+		fprintf(f, "buffer [%08x] cbuffer [%08x] ", 
+			hopt->buffer,hopt->cbuffer);
+	}
+	if (tb[TCA_HTB_INIT]) {
+	    gopt = RTA_DATA(tb[TCA_HTB_INIT]);
+	    if (RTA_PAYLOAD(tb[TCA_HTB_INIT])  < sizeof(*gopt)) return -1;
+
+	    fprintf(f, "r2q %d default %x direct_packets_stat %u", 
+		    gopt->rate2quantum,gopt->defcls,gopt->direct_pkts);
+		if (show_details)
+			fprintf(f," ver %d.%d",gopt->version >> 16,gopt->version & 0xffff);
+	}
+	return 0;
+}
+
+static int htb_print_xstats(struct qdisc_util *qu, FILE *f, struct rtattr *xstats)
+{
+	struct tc_htb_xstats *st;
+	if (xstats == NULL)
+		return 0;
+
+	if (RTA_PAYLOAD(xstats) < sizeof(*st))
+		return -1;
+
+	st = RTA_DATA(xstats);
+	fprintf(f, " lended: %u borrowed: %u giants: %u\n", 
+		st->lends,st->borrows,st->giants);
+	fprintf(f, " tokens: %d ctokens: %d\n", st->tokens,st->ctokens);
+	return 0;
+}
+
+struct qdisc_util htb_util = {
+	NULL,
+	"htb",
+	htb_parse_opt,
+	htb_print_opt,
+	htb_print_xstats,
+	htb_parse_class_opt,
+	htb_print_opt,
+};
+
+/* for testing of old one */
+struct qdisc_util htb2_util = {
+	NULL,
+	"htb2",
+	htb_parse_opt,
+	htb_print_opt,
+	htb_print_xstats,
+	htb_parse_class_opt,
+	htb_print_opt,
+};
diff -ru --new-file iproute2/tc/q_plr.c iproute2-linkdelays/tc/q_plr.c
--- iproute2/tc/q_plr.c	Wed Dec 31 17:00:00 1969
+++ iproute2-linkdelays/tc/q_plr.c	Wed Jul  9 18:18:08 2003
@@ -0,0 +1,117 @@
+/*
+ * q_plr.c      packet loss qdisc
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ * Authors:	Kirk Webb, <kwebb@cs.utah.edu>
+ *			Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <syslog.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <string.h>
+
+#include "utils.h"
+#include "tc_util.h"
+
+static void explain(void)
+{
+	fprintf(stderr, "Usage: ... plr <rate (%% loss: 0-100)>\n");
+}
+
+static void explain1(char *arg)
+{
+	fprintf(stderr, "Illegal \"%s\"\n", arg);
+}
+
+
+#define usage() return(-1)
+
+static int 
+plr_parse_opt
+	(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
+{
+	struct tc_plr_qopt opt;
+	double plr_rate = 0;
+	char *p;
+
+	memset(&opt, 0, sizeof(opt));
+
+	if ( argc > 1 ) { 
+		fprintf(stderr, "Too many arguments (seen: %d, expected: %d)\n",
+			argc, 1);
+		return -1;
+	} else if ( argc < 1 ) { 
+		fprintf(stderr, "Too few arguments (seen: %d, expected: %d)\n",
+			argc, 1);
+		return -1;
+	} else if ( argc == 1 ) {
+	  plr_rate = strtod(*argv, &p);
+            if (p == *argv || plr_rate < 0 || plr_rate > 1) {
+	      explain1("fraction (range 0-1)");
+	      return -1;
+	    }
+	}
+
+	opt.plr = (unsigned int)(plr_rate*0xffffffffUL);
+	fprintf( stdout, "PLR: %u\n", opt.plr );
+
+	addattr_l(n, 1024, TCA_OPTIONS, &opt, sizeof(opt));
+
+	return 0;
+}
+
+static int 
+plr_print_opt
+	(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
+{
+	struct tc_plr_qopt *qopt;
+
+	if (opt == NULL)
+		return 0;
+
+	if ( RTA_PAYLOAD(opt) < sizeof(*qopt))
+		return -1;
+	
+	qopt = RTA_DATA(opt);
+	fprintf( f, "PLR: %f", 
+		 qopt->plr / (double) 0xffffffff
+		);
+
+	return 0;
+}
+
+static int plr_print_xstats(struct qdisc_util *qu, FILE *f, struct rtattr *xstats)
+{
+	return 0;
+}
+
+static int 
+plr_parse_class_opt(struct qdisc_util *qu, int argc, char **argv,
+   struct nlmsghdr *n)
+{
+  return 0;
+}
+
+
+
+struct qdisc_util plr_util = {
+	NULL,
+	"plr",
+	plr_parse_opt,
+	plr_print_opt,
+	plr_print_xstats,
+
+        plr_parse_class_opt,
+        plr_print_opt,
+};
+
diff -ru --new-file iproute2/tc/tc_qdisc.c iproute2-linkdelays/tc/tc_qdisc.c
--- iproute2/tc/tc_qdisc.c	Tue Jan 15 04:15:23 2002
+++ iproute2-linkdelays/tc/tc_qdisc.c	Tue Jun 17 14:49:01 2003
@@ -36,7 +36,7 @@
 	fprintf(stderr, "\n");
 	fprintf(stderr, "       tc qdisc show [ dev STRING ] [ingress]\n");
 	fprintf(stderr, "Where:\n");
-	fprintf(stderr, "QDISC_KIND := { [p|b]fifo | tbf | prio | cbq | red | etc. }\n");
+	fprintf(stderr, "QDISC_KIND := { [p|b]fifo | delay | plr | tbf | prio | cbq | red | etc. }\n");
 	fprintf(stderr, "OPTIONS := ... try tc qdisc add <desired QDISC_KIND> help\n");
 	exit(-1);
 }
