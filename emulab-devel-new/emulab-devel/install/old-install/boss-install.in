#!/usr/bin/perl -w

#
# Copyright (c) 2003-2012 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#

#
# boss-install - Script to do the initial install of a boss node
#
# The main things it does not do yet:
# * Figure out where to put directories such as /usr/testbed - they must
#   already exist
# * Set up named - we probably have to do that later, when the interfaces table
#   is filled in
# * Set up a sup tree. Not sure what the right thing to do here is!

#
# Configure variables
#
my $PREFIX     = '@prefix@';
my $SRCDIR     = '@srcdir@';
my $ERRORLOG_DBNAME = "@TBERRORLOGDBNAME@";
my $WINSUPPORT = @WINSUPPORT@;
my $MAILMANSUPPORT = @MAILMANSUPPORT@;
my $BUGDBSUPPORT = @BUGDBSUPPORT@;
my $ARCHSUPPORT = @ARCHIVESUPPORT@;
my $PGENISUPPORT = @PROTOGENI_SUPPORT@;
my $OURDOMAIN  = '@OURDOMAIN@';
my $EXPOSETEMPLATES = $ELABINELAB;

my $LOGFACIL   = '@TBLOGFACIL@';

my $USERNODE   = '@USERNODE@';
my $FSNODE     = '@FSNODE@';
my $BOSSNODE   = '@BOSSNODE@';
my $BOSSNODE_IP= '@BOSSNODE_IP@';
my $USERNODE_IP= '@USERNODE_IP@';
my $FSNODE_IP=   '@FSNODE_IP@';
my $SCRATCHDIR = '@FSDIR_SCRATCH@';
my $SHAREDIR   = '@FSDIR_SHARE@';
my $FRISADDR   = '@FRISEBEEMCASTADDR@';

my $NEEDMROUTED = @NEEDMROUTED@;

#
# Fixed paths for clients
#
my $GROUPROOT   = "@GROUPSROOT_DIR@";
my $USERROOT    = "@USERSROOT_DIR@";
my $SCRATCHROOT	= "@SCRATCHROOT_DIR@";
my $SHAREROOT	= "@SHAREROOT_DIR@";
my $NOSHAREDFS  = @NOSHAREDFS@;
my $ELVIN_COMPAT= @ELVIN_COMPAT@;

# True if we are also the FS node
my $ISFS	= ($BOSSNODE eq $FSNODE) ? 1 : 0;

# Is ops a VM on boss?
my $OPSVM_ENABLE     = @OPSVM_ENABLE@;
my $OPSVM_MOUNTPOINT = "@OPSVM_MOUNTPOINT@";

# For /share export below.
my $CONTROL_NETWORK = "@CONTROL_NETWORK@";
my $CONTROL_NETMASK = "@CONTROL_NETMASK@";

#
# Some programs we use
#
my $SH         = "/bin/sh";
my $CHMOD      = "/bin/chmod";
my $CHGRP      = "/usr/bin/chgrp";
my $CHOWN      = "/usr/sbin/chown";
my $PWD        = "/bin/pwd";
my $PW         = "/usr/sbin/pw";
my $PATCH      = "/usr/bin/patch";
my $SSH_KEYGEN = "/usr/bin/ssh-keygen";
my $PKG_ADD    = "/usr/sbin/pkg_add";
my $PKG_DEL    = "/usr/sbin/pkg_delete";
my $TOUCH      = "/usr/bin/touch";
my $SSH_INIT   = "/usr/bin/ssh -1";
my $SCP_INIT   = "/usr/bin/scp -1";
my $SSH        = "/usr/bin/ssh -2";
my $SCP        = "/usr/bin/scp -2";
my $CP         = "/bin/cp";
my $ENV        = "/usr/bin/env";
my $MOUNT      = "/sbin/mount";
my $SUDO       = "/usr/local/bin/sudo";
my $SUIDPERL   = "/usr/bin/suidperl";

my $MYSQLADMIN = "/usr/local/bin/mysqladmin";
my $MYSQLSHOW  = "/usr/local/bin/mysqlshow";
my $MYSQLDUMP  = "/usr/local/bin/mysqldump";
my $MYSQLINSTALL = "/usr/local/bin/mysql_install_db";
my $MYSQLDBDIR = "/var/db/mysql";

#
# Some files we edit/create
#
my $CRONTAB         = "/etc/crontab";
my $HOSTS           = "/etc/hosts";
my $FSTAB           = "/etc/fstab";
my $RCCONF          = "/etc/rc.conf";
my $SYSLOG_CONF     = "/etc/syslog.conf";
my $NEWSYSLOG_CONF  = "/etc/newsyslog.conf";
my $INETD_CONF      = "/etc/inetd.conf";
my $EXPORTS_FILE    = "/etc/exports";
my $EXPORTS_HEAD    = "$EXPORTS_FILE.head";

my $PROTOUSER_KEY   = "$TOP_SRCDIR/install/elabman_dsa.pub";
my $ROOT_PRIVKEY    = "/root/.ssh/id_rsa";
my $ROOT_PUBKEY     = "$ROOT_PRIVKEY.pub";
my $ROOT_AUTHKEY    = "/root/.ssh/authorized_keys";

my $CHECKUPUSER	    = "elabckup";

my $APACHE_ETCDIR   = "@INSTALL_APACHE_CONFIG@";
my $APACHE_VERSION  = @APACHE_VERSION@;
my $APACHE_START    = "@APACHE_START_COMMAND@";
my $SUDOERS         = "/usr/local/etc/sudoers";
my $HTTPD_CONF      = "$APACHE_ETCDIR/httpd.conf";
my $PHP_INI         = "/usr/local/etc/php.ini";
my $DHCPD_CONF	    = "/usr/local/etc/dhcpd.conf";
my $DHCPD_TEMPLATE  = "/usr/local/etc/dhcpd.conf.template";
my $DHCPD_LEASES    = "/var/db/dhcpd.leases";
my $DHCPD_MAKECONF  = "$PREFIX/sbin/dhcpd_makeconf";
my $BATCHEXP        = "$PREFIX/bin/batchexp";
my $NAMED_SETUP     = "$PREFIX/sbin/named_setup";
my $ADDPUBKEY       = "$PREFIX/sbin/addpubkey";
my $TBACCT          = "$PREFIX/sbin/tbacct";
my $GENTOPOFILE     = "$PREFIX/libexec/gentopofile";
my $WWWDIR          = "$PREFIX/www";

my $CRACKLIB_DICT   = "/usr/local/lib/pw_dict.pwd";

my $STL_PATCH       = "$TOP_SRCDIR/patches/g++.patch";
my $M2CRYPTO_PATCH  = "$TOP_SRCDIR/patches/m2crypto.patch";
my $MYSQL_PM_PATCH  = "$TOP_SRCDIR/patches/Mysql.pm.patch";
my $PHP4_PATCH      = "$TOP_SRCDIR/patches/php4-Makefile.patch";
my $SELFLOAD_PATCH  = "$TOP_SRCDIR/patches/SelfLoader.patch";
my $INIT_PRIVKEY    = "$TOP_SRCDIR/install/identity";

my $SSH_CONFIG      = "/etc/ssh/ssh_config";

my $LOADER_CONF	    = "/boot/loader.conf";

my $SYSCTL_CONF	    = "/etc/sysctl.conf";

my $EMULAB_PEM	    = "emulab.pem";
my $CLIENT_PEM	    = "client.pem";
my $CTRLNODE_PEM    = "ctrlnode.pem";
my $ETC_EMULAB_DIR  = "/etc/emulab";

# Apache certs on both boss and ops
my $APACHE_CERTPEM      = "apache.pem";
my $APACHE_KEYPEM       = "apache.pem";
my $APACHE_CERTFILE     = "$APACHE_ETCDIR/ssl.crt/www.${OURDOMAIN}.crt";
my $APACHE_KEYFILE      = "$APACHE_ETCDIR/ssl.key/www.${OURDOMAIN}.key";
my $APACHE_CERTPEM_OPS  = "apache-ops.pem";
my $APACHE_KEYPEM_OPS   = "apache-ops.pem";
my $APACHE_CERTFILE_OPS = "$APACHE_ETCDIR/ssl.crt/${USERNODE}.crt";
my $APACHE_KEYFILE_OPS  = "$APACHE_ETCDIR/ssl.key/${USERNODE}.key";

#
# XXX temporary for tftp
#
my $TFTPD_PKG	  = "emulab-tftp-hpa-0.48";

# XXX temporary for perl DBD mysql access
my $P5DBD_PKG	  = "p5-DBD-mysql50-3.0002";

#
# Named pid file.
#
my $NAMED_PIDFILE = "/var/run/named.pid";

#
# Some directories we care about
#
my $MYSQL_LOGDIR  = "$LOGDIR/mysql";
my $USERSVAR_DIR  = "$PREFIX/usersvar";
my $OPSDIR_DIR    = "$PREFIX/opsdir";
my $PORTSMISCDIR  = "$PORTSDIR/misc";
my $MIBPATH       = "/usr/local/share/snmp/mibs";
my $TFTP_DIR      = "$PREFIX/tftpboot";
my $TFTP_PROJ_DIR = "$TFTP_DIR/proj";
my $ETCSSH	  = "/etc/ssh";

#
# URLs
#
my $CISCO_MIB_FTP = "ftp://ftp.cisco.com/pub/mibs/v2";

#
# And some lists that we use
#
my @TESTBED_DIRS = ($PREFIX);
my @EXPORTDIRS   = ();

my @MOUNTPOINTS = ("$USERROOT", "$PROJROOT", "$GROUPROOT");
if ($SHAREDIR) {
    push(@MOUNTPOINTS, "$SHAREROOT");
}
if ($SCRATCHDIR) {
    push(@MOUNTPOINTS, "$SCRATCHROOT");
}
#
# If we are the FS, then the above dirs already exist, but we *do*
# have to export them. Note that the only reason to make boss the
# FSNODE, is if ops is a VM on boss and there is no actual FSNODE.
#
if ($ISFS) {
    @EXPORTDIRS = @MOUNTPOINTS;
    @MOUNTPOINTS = ();
}
# But these always have to be mounted no matter where ops is.
push(@MOUNTPOINTS, "$USERSVAR_DIR", "$OPSDIR_DIR")
    if (!$OPSVM_ENABLE);

my @LOGFILES = ("$LOGDIR/bootinfo.log", "$LOGDIR/tmcd.log",
    "$LOGDIR/capture.log", "$LOGDIR/dhcpd.log", "$LOGDIR/capserver.log",
    "$LOGDIR/frisbeed.log", "$LOGDIR/mfrisbeed.log", "$LOGDIR/proxydhcpd.log",
    "$LOGDIR/stated.log", "$LOGDIR/osselect.log", "$LOGDIR/power.log",
    "$LOGDIR/tftpd.log", "$LOGDIR/sdcollectd.log", "$LOGDIR/genlastlog.log",
    "$LOGDIR/sshxmlrpc.log", "$LOGDIR/plabgetfree.log", "$LOGDIR/xmlrpcbag.log",
    "$LOGDIR/plabrenew.log", "$LOGDIR/sslxmlrpc.log", "$LOGDIR/pubsubd.log");

my @CISCO_MIBS = ("CISCO-SMI", "CISCO-TC", "CISCO-VTP-MIB", "CISCO-PAGP-MIB",
    "CISCO-PRIVATE-VLAN-MIB", "CISCO-STACK-MIB", "CISCO-VLAN-MEMBERSHIP-MIB",
    "CISCO-C2900-MIB", "BRIDGE-MIB", "CISCO-CONFIG-COPY-MIB");

# Initial experiments to create. Indexed by eid.
my %EXPERIMENTS =
    ("hwdown"	     => {"pid"	       => "emulab-ops",
			 "description" => "Node reported as down"},
     "reloading"     => {"pid"	       => "emulab-ops",
			 "description" => "Nodes reloading images"},
     "reloadpending" => {"pid"	       => "emulab-ops",
			 "description" => "Nodes waiting for reload"},
     "oldreserved"   => {"pid"	       => "emulab-ops",
			 "description" => "Nodes in limbo during swap modify"},
     "nfree-leases"  => {"pid"	       => "emulab-ops",
			 "description" => "Nodes in limbo during nfree"},
     "nfree-locked"  => {"pid"	       => "emulab-ops",
			 "description" => "Nodes in limbo during nfree"},
     "opsnodes"	     => {"pid"	       => "emulab-ops",
			 "description" => "Nodes designated as Ops Nodes"},
     "holding"	     => {"pid"	       => "emulab-ops",
			 "description" => "Nodes in a holding pattern"},
     "shared-nodes"  => {"pid"	       => "emulab-ops",
			 "description" => "Nodes in shared mode"},
     "hwcheckup"     => {"pid"	       => "emulab-ops",
			 "description" => "Nodes being testing after failure"},
     "external-holding" => {"pid"      => "emulab-ops",
			 "description" => "Holding experiment for fake nodes"},
     "vlan-holding"  => {"pid"      => "emulab-ops",
			 "description" =>
			     "Holding experiment for internal vlans"},
    );

#
# List of names that goes into $HOSTS and which must resolve.
# 
my @OPS_NAMES = ($USERNODE, "users", "ops");
if ($USERNODE eq $FSNODE) {
    push(@OPS_NAMES, "fs");
}

# Version of FreeBSD.
my $FBSD_MAJOR = 4;
my $FBSD_MINOR = 10;
if (`uname -r` =~ /^(\d+)\.(\d+)/) {
    $FBSD_MAJOR = $1;
    $FBSD_MINOR = $2;
}
else {
    die("Could not determine what version of FreeBSD you are running!\n");
}

#
# The meta-ports (name and version) that drag in all the dependancies for
# a boss node. These are OS dependent as we upgrade.
#
my $BOSS_PORT = "emulab-boss-1.8";
my $FS_PORT = "emulab-fs-1.4";
if ($FBSD_MAJOR > 4) {
    if ($FBSD_MAJOR > 7) {
	$BOSS_PORT = "emulab-boss-4.0";
	$FS_PORT = "emulab-fs-4.0";
    } elsif ($FBSD_MAJOR == 7 && $FBSD_MINOR > 2) {
	$BOSS_PORT = "emulab-boss-3.1";
	$FS_PORT = "emulab-fs-3.1";
    } elsif ($FBSD_MAJOR == 7) {
	$BOSS_PORT = "emulab-boss-3.0";
	$FS_PORT = "emulab-fs-3.0";
    } elsif ($FBSD_MAJOR == 6 && $FBSD_MINOR > 2) {
	$BOSS_PORT = "emulab-boss-2.1";
	$FS_PORT = "emulab-fs-2.1";
    } else {
	$BOSS_PORT = "emulab-boss-2.0";
	$FS_PORT = "emulab-fs-2.0";
    }
}

# PHP5 is the only alternative at the moment and only for newer OSes
my $PHP_VERSION = 4;
my $PHP_PORT = "php4-extensions-1.0";
if ($FBSD_MAJOR > 7 || ($FBSD_MAJOR == 7 && $FBSD_MINOR > 2)) {
    $PHP_VERSION = 5;
    if ($FBSD_MAJOR > 7) {
	$PHP_PORT = "php5-extensions-1.4";
    }
    else {
	$PHP_PORT = "php5-extensions-1.3";
    }
}

#
# Version dependent python-fu 
#
my $PYM2_PKG = "py25-m2crypto-0.19.1";
my $PY_VER = "python2.5";
if ($FBSD_MAJOR > 7 || ($FBSD_MAJOR == 7 && $FBSD_MINOR > 2)) {
    $PYM2_PKG = "py26-m2crypto-0.20";
    $PY_VER = "python2.6";
}
# XXX temporary until someone extracts their head from the dark regions
my $EASYINSTALL	  = "/usr/local/bin/easy_install";

#
# XXX keep 4.x ElabInElab install limping along...
#
if ($FBSD_MAJOR == 4) {
    $SCP_INIT = "/usr/bin/scp -oProtocol=1";
    $SCP =      "/usr/bin/scp -oProtocol=2";
}

#
# Figure out which directory we live in, so that some stages can do thing
# relative to it.
#
my $OBJDIR = `/usr/bin/dirname $0`;
chomp $OBJDIR;
my $TOP_OBJDIR = "$OBJDIR/..";

#
# Allow this to work if the library is left in the source directory
#
use lib '@srcdir@';
   
use English;
use libinstall;
use Getopt::Std;
use Cwd qw(realpath);

#
# Handle command-line options
#
sub usage {
    print "Usage: boss-install [-b] [-p packagedir] [-s] [-P portname]\n";
    print "  Required: -p (for binary packages) or -s (for source makes.)\n";
    exit(1);
}

my $packagedir = "";
my $batchmode  = 0;
my $domakes  = 0;
my $password;
my %opts;

if (! getopts("P:p:bsw:F:", \%opts)) {
    usage();
}
if (defined($opts{p})) {
    $packagedir = $opts{p};
}
if (defined($opts{b})) {
    $batchmode = 1;
}
if (defined($opts{s})) {
    $domakes = 1;
}
if (defined($opts{w})) {
    $password = $opts{w};
}
if (defined($opts{F})) {
    $FS_PORT = $opts{F};
}
if (defined($opts{P})) {
    $BOSS_PORT = $opts{P};
}
# Don't just charge into making ports from source by default.
if ($packagedir eq "" and $domakes eq 0) {
    print "At least one of -p and -s must be given.\n";
    usage();
}
if ($packagedir ne "" and $domakes eq 1) {
    print "Only one of -p and -s can be given.\n";
    usage();
}
if (@ARGV) {
    usage();
}

#
# Make sure they know what they're getting into...
#
if (! $batchmode) {
    warn "***** Please run install-ops on ops, and reboot it, before running\n";
    warn "this script!\n\n";
    print STDERR
	"WARNING: This script is ONLY intended to be run on a machine\n";
    print STDERR
	"that is being set up as a dedicated boss node. Continue? [y/N] ";
    my $response = <>;
    die "Installation aborted!\n" unless ($response =~ /^y/i);
}

if ($UID != 0) {
    die "This script must be run as root.\n";
}

Phase "sperl", "Checking for setuid perl", sub {
    if (ExecQuiet("$PKG_INFO -L -x perl-5 | fgrep -q -s sperl") == 0) {
	PhaseSkip("Perl is okay");
    }
    PhaseFail("setuid perl is not set up properly. Read the wiki!");
};

Phase "usersgroups", "Creating users and groups", sub {
    Phase "tbadmin", "Creating tbadmin group", sub {
	if (getgrnam("tbadmin")) {
	    PhaseSkip("Group already exists");
	}
	ExecQuietFatal("$PW groupadd tbadmin -g 101");
    };
    Phase "root", "Creating root group", sub {
	if (getgrnam("root")) {
	    PhaseSkip("Group already exists");
	}
	ExecQuietFatal("$PW groupadd root -g 103");
    };
    # Added next two cause the mysql package does not do this (port does).
    Phase "mysqlgroup", "Creating mysql group", sub {
	if (getgrnam("mysql")) {
	    PhaseSkip("Group already exists");
	}
	ExecQuietFatal("$PW groupadd mysql -g 88");
    };
    Phase "mysqluser", "Creating mysql user", sub {
	if (getpwnam("mysql")) {
	    PhaseSkip("User already exists");
	}
	ExecQuietFatal("$PW useradd mysql -u 88 -g 88 -h - ".
		       "-d $MYSQLDBDIR -s /sbin/nologin -c 'MySQL Daemon'");
    };
    ExecQuietFatal("$CHOWN mysql:mysql $MYSQLDBDIR")
	if (-e $MYSQLDBDIR);
};

Phase "dirs", "Setting directory permissions", sub {
    foreach my $dir (@TESTBED_DIRS) {
	Phase $dir, $dir, sub {
	    if (!-d $dir) {
		PhaseFail("Directory $dir does not exist");
	    }
	    my ($mode,$group) = (stat($dir))[2,5];
	    # Fix up the mode (strip file type)
	    $mode = $mode & 0777;
	    if ($mode == 0775 && $group eq getgrnam("tbadmin")) {
		PhaseSkip("Already done");
	    }
	    ExecQuietFatal("$CHGRP tbadmin $dir");
	    ExecQuietFatal("$CHMOD 0775 $dir");
	};
    }
};

Phase "tftp", "Setting up directories for tftp", sub {
    Phase "tftpoff", "Disabling BSD tftpd", sub {
	PhaseSkip("No inetd.conf!?") unless (-e $INETD_CONF);
	PhaseSkip("Already disabled") unless `grep '^tftp' $INETD_CONF`;
	ExecQuietFatal("sed -i .orig -e '/^tftp/s/^/#/' $INETD_CONF");
	HUPDaemon("inetd");
    };
    Phase "tftpboot", "Creating $TFTP_DIR", sub {
	DoneIfExists($TFTP_DIR);
	mkdir $TFTP_DIR,0775 or
	    PhaseFail("Unable to create $TFTP_DIR : $!");
	ExecQuietFatal("$CHGRP tbadmin $TFTP_DIR");
    };
    Phase "tftpproj", "Creating $TFTP_PROJ_DIR", sub {
	DoneIfExists($TFTP_PROJ_DIR);
	mkdir $TFTP_PROJ_DIR,0775 or
	    PhaseFail("Unable to create $TFTP_PROJ_DIR : $!");
	ExecQuietFatal("$CHGRP tbadmin $TFTP_PROJ_DIR");
    };
    Phase "tftplink", "Linking /tftpboot", sub {
	DoneIfExists("/tftpboot");
	ExecQuietFatal("ln -s $TFTP_DIR /tftpboot");
    };
};

Phase "ports", "Installing ports", sub {
    Phase "packages", "Installing packages", sub {
	Phase "main", "Installing main package", sub {
	    if (!ExecQuiet("$PKG_INFO -e $BOSS_PORT")) {
		PhaseSkip("Package already installed");
	    }
	    if (!$packagedir) {
		PhaseSkip("No package directory provided");
	    }
	    ExecQuietFatal("$ENV PKG_PATH=$packagedir $PKG_ADD $BOSS_PORT");
	};
	if ($FBSD_MAJOR > 4) {
	    Phase "php", "Installing php${PHP_VERSION} package", sub {
		if (!ExecQuiet("$PKG_INFO -e $PHP_PORT")) {
		    PhaseSkip("Package already installed");
		}
		if (!$packagedir) {
		    PhaseSkip("No package directory provided");
		}
		# XXX ugh, make sure an older version is not installed
		if ($PHP_VERSION > 4) {
		    ExecQuiet("$PKG_DEL -f -x php4-");
		}
		ExecQuietFatal("$ENV PKG_PATH=$packagedir ".
			       "     $PKG_ADD $PHP_PORT");
	    };
	    # XXX temporary: only needed til emulab-boss package updated
	    Phase "tftpd", "Updating tftpd installation", sub {
		my $pname = `$PKG_INFO -E 'emulab-tftp-hpa-*' 2>/dev/null`;
		chomp($pname);
		if ($pname eq $TFTPD_PKG) {
		    PhaseSkip("tftpd already up to date");
		}
		if (!$packagedir) {
		    PhaseSkip("No package directory provided");
		}
		ExecQuietFatal("$ENV PKG_PATH=$packagedir $PKG_DEL -f $pname")
		    if ($pname);
		ExecQuietFatal("$ENV PKG_PATH=$packagedir $PKG_ADD $TFTPD_PKG");
	    };
	    # XXX Also temporary
	    Phase "pubsub", "Installing pubsub package", sub {
		my $pspkg = $ELVIN_COMPAT ? "pubsub-elvincompat" : "pubsub";
		if (!ExecQuiet("$PKG_INFO -x $pspkg")) {
		    PhaseSkip("$pspkg already installed");
		}
		my $pname = GetPackage($pspkg, $packagedir);
		ExecQuietFatal("$ENV PKG_PATH=$packagedir $PKG_ADD $pname");
	    };
	    # XXX Ditto
	    if ($FBSD_MAJOR > 6 || ($FBSD_MAJOR == 6 && $FBSD_MINOR > 2)) {
		if ($FBSD_MAJOR < 8) {
		    Phase "p5-DBD-mysql50", "Installing old Perl Mysql package", sub {
			my $pname = `$PKG_INFO -E 'p5-DBD-mysql50-*' 2>/dev/null`;
			chomp($pname);
			if ($pname eq $P5DBD_PKG) {
			    PhaseSkip("p5-DBD-mysql50 already up to date");
			}
			if (!$packagedir) {
			    PhaseSkip("No package directory provided");
			}
			ExecQuietFatal("$ENV PKG_PATH=$packagedir $PKG_DEL -f $pname")
			    if ($pname);
			ExecQuietFatal("$ENV PKG_PATH=$packagedir $PKG_ADD $P5DBD_PKG");
		    };
		}
		if ($FBSD_MAJOR > 6) {
		    Phase "py-m2crypto", "Installing python m2crypto package", sub {
			my $pname = `$PKG_INFO -E 'py*-m2crypto-*' 2>/dev/null`;
			chomp($pname);
			if ($pname eq $PYM2_PKG) {
			    PhaseSkip("py-m2crypto already up to date");
			}
			if (!$packagedir) {
			    PhaseSkip("No package directory provided");
			}
			ExecQuietFatal("$ENV PKG_PATH=$packagedir $PKG_DEL -f $pname")
			    if ($pname);
			ExecQuietFatal("$ENV PKG_PATH=$packagedir $PKG_ADD $PYM2_PKG");
		    };
		}
		if ($NEEDMROUTED &&
		    $FBSD_MAJOR > 7 || ($FBSD_MAJOR == 7 && $FBSD_MINOR > 2)) {
		    Phase "mrouted", "Installing mrouted", sub {
			if (!ExecQuiet("$PKG_INFO -x mrouted")) {
			    PhaseSkip("mrouted already installed");
			}
			my $pname = GetPackage("mrouted", $packagedir);
			ExecQuietFatal("$ENV PKG_PATH=$packagedir $PKG_ADD $pname");
		    };
		}
	    }
	}
	else {
	    # XXX Also temporary
	    Phase "pubsub", "Installing pubsub package", sub {
		my $pspkg = $ELVIN_COMPAT ? "pubsub-elvincompat" : "pubsub";
		if (!ExecQuiet("$PKG_INFO -x $pspkg")) {
		    PhaseSkip("$pspkg already installed");
		}
		my $pname = GetPackage($pspkg, $packagedir);
		ExecQuietFatal("$ENV PKG_PATH=$packagedir $PKG_ADD $pname");
	    }
	}
	if ($PGENISUPPORT) {
	    Phase "protogeni", "Installing protogeni packages", sub {
		if ($FBSD_MAJOR > 6 || ($FBSD_MAJOR == 6 && $FBSD_MINOR > 2)) {
		    if (!ExecQuiet("$PKG_INFO -x emulab-protogeni")) {
			PhaseSkip("Protogeni package already installed");
		    }
		    my $pname = GetPackage("emulab-protogeni", $packagedir);
		    ExecQuietFatal("$ENV PKG_PATH=$packagedir $PKG_ADD $pname");
		} else {
		    PhaseSkip("OS install too old for Protogeni");
		}
	    };
	}
    };
    if ($ISFS) {
	Phase "fs-packages", "Installing FS packages", sub {
	    if (!ExecQuiet("$PKG_INFO -e $FS_PORT")) {
		PhaseSkip("FS ports already installed");
	    }
	    if (!$packagedir) {
		PhaseSkip("No package directory provided");
	    }
	    ExecQuietFatal("$ENV PKG_PATH=$packagedir $PKG_ADD $FS_PORT");
	};
    }
    PhaseSkip("Package directory provided; not installing from sources")
	if ($packagedir);

    Phase "pcopy", "Copying ports into place", sub {
	DoneIfExists("$PORTSMISCDIR/emulab-boss");
	ExecQuietFatal("$SH $SRCDIR/ports/ports-install");
    };
    if ($FBSD_MAJOR == 4) {
	# Ick. The php4 port is broken with SSL, so we have to patch
	# it - hopefully it'll get fixed someday, and we remove this
	Phase "php4patch", "Patching php4 port", sub {
	    if (!ExecQuiet("$PATCH -C -f -l -R -p0 -i $PHP4_PATCH")) {
		PhaseSkip("Patch already applied");
	    }
	    ExecQuietFatal("$PATCH -f -l -p0 -i $PHP4_PATCH");
	};
    }
    if ($ISFS) {
	Phase "fs-pinstall", "Installing FS ports (may take a while)", sub {
	    if (!ExecQuiet("$PKG_INFO -e $FS_PORT")) {
		PhaseSkip("Ports already installed");
	    }
	    chdir "$PORTSMISCDIR/emulab-fs" or
		PhaseFail "Unable to change to $PORTSMISCDIR/emulab-fs: $!";
	    ExecQuietFatal("make -DBATCH install");
	};
    }
    PhaseFail("Please install ports manually, since some\n of them are " .
	      "interactive. Run: \n" .
	      "    cd $PORTSMISCDIR/emulab-boss && make install\n" .
	      "    cd $PORTSMISCDIR/emulab-php${PHP_VERSION} && make install\n" .
	      ($PGENISUPPORT ?
	      "    cd $PORTSMISCDIR/emulab-protogeni && make install\n" : "") .
	      "then re-run this script.");
};

Phase "portfixup", "Fixing up packages", sub {
    Phase "rsync", "Looking for rsync", sub {
	if (!ExecQuiet("$PKG_INFO -x rsync")) {
	    PhaseSkip("rsync already installed");
	}
	my $pname = GetPackage("rsync", $packagedir);
	ExecQuietFatal("$ENV PKG_PATH=$packagedir $PKG_ADD $pname");
    };
    if ($FBSD_MAJOR >= 6) {
	# Temporary for template stuff
	Phase "Simple", "Looking for Simple XML Parser", sub {
	    if (!ExecQuiet("$PKG_INFO -x p5-XML-Simple")) {
		PhaseSkip("p5-XML-Simple already installed");
	    }
	    my $pname = GetPackage("p5-XML-Simple", $packagedir);
	    ExecQuietFatal("$ENV PKG_PATH=$packagedir $PKG_ADD $pname");
	};
	if ($ARCHSUPPORT) {
	    Phase "Subversion", "Looking for Subversion", sub {
		if (!ExecQuiet("$PKG_INFO -x subversion")) {
		    PhaseSkip("subversion already installed");
		}
		my $pname;
		if ($FBSD_MAJOR > 6) {
		    $pname = GetPackage("py-subversion", $packagedir);
		} else {
		    $pname = GetPackage("subversion-python", $packagedir);
		}
		ExecQuietFatal("$ENV PKG_PATH=$packagedir $PKG_ADD $pname");
	    };
	}
    }
    if ($WINSUPPORT) {
	Phase "gcc30", "Looking for GCC 3.0 and installing", sub {
	    if ($FBSD_MAJOR > 4 ||
		!ExecQuiet("$PKG_INFO -x gcc30")) {
		PhaseSkip("GCC 3.0 or greater already installed");
	    }
	    my $pname = GetPackage("gcc30", $packagedir);
	    ExecQuietFatal("$ENV PKG_PATH=$packagedir $PKG_ADD $pname");
	};
    }
    if ($FBSD_MAJOR > 6) {
	#
	# What a crock!  First, that the FreeBSD ports system
	# defaults to installing the zipped .egg files that have
	# to be unzipped per-user before use.  Second, that it
	# offers no easy way at package creation to override this.
	# Third, that there is no easy way that I could find in
	# the python eggs system to set a global cache directory
	# into which to unpack all eggs; you have to set
	# PYTHON_EGG_CACHE in the environment of every script.
	# Fourth, that the per-user default value might be in an
	# unwritable location.
	#
	# So, I am reduced to manually unpacking all .egg files
	# into the corresponding .egg directories after the
	# install!  Since this would totally screw any attempt
	# to update those packages, I just do it to the one
	# package that I know will fail otherwise.
	#
	Phase "m2crypto-egg", "Unpacking python m2crypto .egg", sub {
	    my $pydir = "/usr/local/lib/$PY_VER/site-packages";
	    my $egg = `ls -d $pydir/M2Crypto-*-py*-*.egg 2>/dev/null | tail -1`;
	    chomp($egg);
	    if (! -x $EASYINSTALL) {
		PhaseSkip("python easy_install missing");
	    }
	    if ($egg eq "") {
		PhaseSkip("egg not found");
	    }
	    if (-d "$egg") {
		PhaseSkip("egg already unpacked");
	    }
	    # XXX swig must be installed for easyinstall to exit correctly
	    Phase "swig", "Installing swig", sub {
		DoneIfPackageInstalled("swig");
		my $pname = GetPackage("swig", $packagedir);
		ExecQuietFatal("$ENV PKG_PATH=$packagedir $PKG_ADD $pname");
	    };
	    ExecQuietFatal("mv $egg /var/tmp/");
	    $egg =~ s/$pydir//;
	    ExecQuietFatal("$EASYINSTALL -N -H None -Z /var/tmp$egg");
	    ExecQuietFatal("mv /var/tmp$egg $pydir/$egg.bak");
	};
    }
};

Phase "patches", "Applying patches", sub {
    if ($FBSD_MAJOR == 4) {
	Phase "g++patch", "Patching g++'s STL", sub {
	    if (!ExecQuiet("$PATCH -C -f -R -p0 -i $STL_PATCH")) {
		PhaseSkip("Patch already applied");
	    }
	    ExecQuietFatal("$PATCH -f -p0 -i $STL_PATCH");
	};
    }
    if ($FBSD_MAJOR < 7) {
	Phase "m2cryptopatch", "Patching m2crypto", sub {
	    my $patchfile = $M2CRYPTO_PATCH;
	
	    if (ExecQuiet("$PKG_INFO -I -x m2crypto | fgrep -q -s '0.17'") == 0) {
		$patchfile = "${patchfile}-0.17";
	    }
	    elsif (ExecQuiet("$PKG_INFO -I -x m2crypto | fgrep -q -s '0.13'") == 0) {
		$patchfile = "${patchfile}-0.13";
	    }
	    if (!ExecQuiet("$PATCH -C -f -l -R -p0 -i $patchfile")) {
		PhaseSkip("Patch already applied");
	    }
	    ExecQuietFatal("$PATCH -f -l -p0 -i $patchfile");
	};
    }
    if ($FBSD_MAJOR < 8) {
	Phase "Mysql.pm.patch", "Patching Mysql.pm", sub {
	    my $patchfile = $MYSQL_PM_PATCH;
	    $patchfile = realpath($patchfile);
	    chomp $patchfile;
	    
	    my $dir;
	    foreach $prefix (@INC) {
		if (-e "$prefix/Mysql.pm") {
		    $dir = $prefix;
		    last;
		}
	    }
	    if (!defined($dir)) {
		PhaseFail("Unable to find Mysql.pm");
	    }
	    
	    if (!ExecQuiet("$PATCH -d $dir -C -f -l -R -i $patchfile")) {
		PhaseSkip("Patch already applied");
	    }
	    ExecQuietFatal("$PATCH -d $dir -f -l -i $patchfile");
	};
    }
    Phase "perlselfloaderpatch", "Fixing perl self-loader", sub {
	my $perldir = "/usr/local/lib/perl5/5.10.1";
	DoneIfDoesntExist("$perldir/SelfLoader.pm");
	my $ver = `fgrep 'our \$VERSION =' $perldir/SelfLoader.pm 2>/dev/null`;
	if ($? == 0 && $ver =~ /1\.18/) {
	    PhaseSkip("Patch already applied");
	}
	ExecQuietFatal("$PATCH -d $perldir -i $SELFLOAD_PATCH");
    };
};

Phase "cracklib", "Installing cracklib", sub {
    DoneIfExists("$CRACKLIB_DICT");
    my $pwd = `$PWD`;
    chomp $pwd;
    chdir "$TOP_SRCDIR/tbsetup/checkpass/cracklib,2.7" or
	PhaseFail "Unable to change to " .
	    "$TOP_SRCDIR/tbsetup/checkpass/cracklib,2.7: $!";
    ExecQuietFatal("make install clean");
    chdir $pwd;
};

Phase "apache", "Installing apache config file", sub {
    DoneIfEdited("$HTTPD_CONF");
    # ICK!!! If we installed apache AFTER we unpacked the source tarball,
    # make will not properly install the new apache config file! So, we use
    # this shameful hack to force it to do so!
    ExecQuietFatal("$TOUCH -t 01010000 $HTTPD_CONF");
    ExecQuietFatal("$GMAKE -C $TOP_OBJDIR/apache install");
};

Phase "php.ini", "Installing php.ini file", sub {
    DoneIfEdited($PHP_INI);
    ExecQuietFatal("$GMAKE -C $TOP_OBJDIR/apache install-php-ini");
    AppendToFileFatal($PHP_INI, "# This file created by Emulab installaton");
};

Phase "rc.d", "Setting up rc.d scripts", sub {
    Phase "my-client", "Moving $RCDIR/mysql-client.sh", sub {
	DoneIfDoesntExist("$RCDIR/mysql-client.sh");
	ExecQuietFatal("mv $RCDIR/mysql-client.sh $RCDIR/1.mysql-client.sh");
    };
    Phase "my-server", "Removing $RCDIR/mysql-server.sh", sub {
	DoneIfDoesntExist("$RCDIR/mysql-server.sh");
	if (!unlink "$RCDIR/mysql-server.sh") {
	    PhaseFail("Unable to remove $RCDIR/mysql-server.sh: $!");
	}
    };
    Phase "my-server2", "Removing $RCDIR/mysql-server", sub {
	DoneIfDoesntExist("$RCDIR/mysql-server");
	if (!unlink "$RCDIR/mysql-server") {
	    PhaseFail("Unable to remove $RCDIR/mysql-server: $!");
	}
    };
    Phase "snmpd", "Removing snmpd startup script",  sub {
	DoneIfDoesntExist("$RCDIR/snmpd.sh");
	if (!unlink "$RCDIR/snmpd.sh") {
	    PhaseFail("Unable to remove $RCDIR/snmpd.sh: $!");
	}
    };
    Phase "rsyncd", "Removing rsyncd startup script",  sub {
	DoneIfDoesntExist("$RCDIR/rsyncd.sh");
	if (!unlink "$RCDIR/rsyncd.sh") {
	    PhaseFail("Unable to remove $RCDIR/rsyncd.sh: $!");
	}
    };
    Phase "dhcpd", "Removing isc-dhcpd startup script",  sub {
	DoneIfDoesntExist("$RCDIR/isc-dhcpd.sh");
	if (!unlink "$RCDIR/isc-dhcpd.sh") {
	    PhaseFail("Unable to remove $RCDIR/isc-dhcpd.sh: $!");
	}
    };
    Phase "rc.testbed", "Installing testbed RC scripts", sub {
	ExecQuietFatal("$GMAKE -C $TOP_OBJDIR/rc.d install");
    };
    Phase "unelvin", "Removing Elvin related startup scripts", sub {
        Phase "elvind.sh", "Removing elvind startup", sub {
            ExecQuietFatal("/bin/rm -f $RCDIR/elvind.sh $RCDIR/2.elvind.sh");
        };
        Phase "elvin_gateway.sh", "Removing elvin gateway startup", sub {
	    DoneIfDoesntExist("$RCDIR/3.elvin_gateway.sh");
            ExecQuietFatal("/bin/rm -f $RCDIR/3.elvin_gateway.sh");
        };
    };
};

Phase "syslog", "Setting up syslog", sub {
    Phase "sysconf", "Editing $SYSLOG_CONF", sub {
	DoneIfEdited($SYSLOG_CONF);

	#
	# Modify the /dev/console and /var/log/messages lines to exclude
	# testbed stuff
	#
	open(SC,"+<$SYSLOG_CONF") or
	    PhaseFail("Unable to open $SYSLOG_CONF : $!");
	my @sc = <SC>;
	if (scalar(grep(/$LOGFACIL/, @sc)) != 0) {
	    PhaseFail("Testbed chosen facility $LOGFACIL already in use in /etc/syslog.conf!");
	}
	seek(SC,0,0);
	truncate(SC,0);
	foreach my $line (@sc) {
	    my $cpat = q(\s+/dev/console);
	    my $mpat = q(\s+/var/log/messages);
	    if ($line =~ /^[^#].*$cpat/) {
		$line =~ s/($cpat)/\;$LOGFACIL.none$1/;
	    }
	    elsif ($line =~ /^[^#].*$mpat/) {
		$line =~ s/($mpat)/\;$LOGFACIL.none$1/;
	    }
	    print SC $line;
	}
	close(SC);

	AppendToFileFatal($SYSLOG_CONF,
	    "!bootinfo",  "*.*\t\t\t\t\t\t$LOGDIR/bootinfo.log",
	    "!tmcd",      "*.*\t\t\t\t\t\t$LOGDIR/tmcd.log",
	    "!capture",   "*.*\t\t\t\t\t\t$LOGDIR/capture.log",
	    "!dhcpd",     "*.*\t\t\t\t\t\t$LOGDIR/dhcpd.log",
	    "!proxydhcpd","*.*\t\t\t\t\t\t$LOGDIR/proxydhcpd.log",
	    "!tftpd",     "*.*\t\t\t\t\t\t$LOGDIR/tftpd.log",
	    "!capserver", "*.*\t\t\t\t\t\t$LOGDIR/capserver.log",
	    "!frisbeed",  "*.*\t\t\t\t\t\t$LOGDIR/frisbeed.log",
	    "!mfrisbeed", "*.*\t\t\t\t\t\t$LOGDIR/mfrisbeed.log",
	    "!pubsubd",   "*.*\t\t\t\t\t\t$LOGDIR/pubsubd.log",
	    "!osselect",  "*.*\t\t\t\t\t\t$LOGDIR/osselect.log",
	    "!power",     "*.*\t\t\t\t\t\t$LOGDIR/power.log",
	    "!genlastlog","*.*\t\t\t\t\t\t$LOGDIR/genlastlog.log",
	    "!sdcollectd","*.*\t\t\t\t\t\t$LOGDIR/sdcollectd.log",
	    "!plabgetfree","*.*\t\t\t\t\t\t$LOGDIR/plabgetfree.log",
	    "!plabrenew", "*.*\t\t\t\t\t\t$LOGDIR/plabrenew.log",
	    "!xmlrpcbag", "*.*\t\t\t\t\t\t$LOGDIR/xmlrpcbag.log",
	    "!sshxmlrpc", "*.*\t\t\t\t\t\t$LOGDIR/sshxmlrpc.log",
	    "!sslxmlrpc", "*.*\t\t\t\t\t\t$LOGDIR/sslxmlrpc.log");
    };

    Phase "logdir", "Creating log directory", sub {
	DoneIfExists($LOGDIR);
	mkdir $LOGDIR, 0775 or PhaseFail("Unable to create $LOGDIR : $!");
	ExecQuietFatal("$CHGRP tbadmin $LOGDIR");
	ExecQuietFatal("$CHMOD 775 $LOGDIR");
    };

    Phase "logdir", "Creating mysql log directory", sub {
	DoneIfExists($MYSQL_LOGDIR);
	mkdir $MYSQL_LOGDIR, 0775 or
	    PhaseFail("Unable to create $MYSQL_LOGDIR : $!");
	ExecQuietFatal("$CHOWN mysql:mysql $MYSQL_LOGDIR");
	ExecQuietFatal("$CHMOD 775 $MYSQL_LOGDIR");
    };

    Phase "logfiles", "Creating log files", sub {
	foreach my $logfile (@LOGFILES) {
	    Phase $logfile, $logfile, sub {
		DoneIfExists($logfile);
		CreateFileFatal($logfile);
		ExecQuietFatal("$CHGRP tbadmin $logfile");
		ExecQuietFatal("$CHMOD 640 $logfile");
	    };
	}
    };

    Phase "newsyslog", "Setting up $NEWSYSLOG_CONF", sub {
	DoneIfEdited($NEWSYSLOG_CONF);
	AppendToFileFatal($NEWSYSLOG_CONF,
	    "$LOGDIR/tmcd.log               640  9     1000 *     Z",
	    "$LOGDIR/stated.log             640  9     1000 *     Z ".
	        "/var/run/stated.pid 31",
	    "$LOGDIR/checknodes.log         640  14    300  *     Z ".
	        "/var/run/checknodes_daemon.pid",
	    "$LOGDIR/osselect.log           640  9     300  *     Z",
	    "$LOGDIR/power.log              640  7     300  *     Z",
	    "$LOGDIR/frisbeed.log           640  7     300  *     Z",
	    "$LOGDIR/mfrisbeed.log          640  7     300  *     Z",
	    "$LOGDIR/tftpd.log              640  7     200  *     Z",
	    "$LOGDIR/dhcpd.log              640  7     200  *     Z",
	    "$LOGDIR/bootinfo.log           640  7     200  *     Z",
	    "$LOGDIR/capserver.log          640  5     200  *     Z",
	    "$LOGDIR/pubsubd.log            640  5     1000 *     Z",
	    "$LOGDIR/suexec.log             640  3     200  *     Z",
	    "$LOGDIR/genlastlog.log         640  3     200  *     Z",
	    "$LOGDIR/genlastlog             640  3     200  *     Z " .
	        "/var/run/lastlog_daemon.pid",
	    "$LOGDIR/plabmetrics.log        640  7     1000 *     Z",
	    "$LOGDIR/plablinkdata.log       640  7     1000 *     Z",
	    "$LOGDIR/xmlrpcbag.log          640  7     300  *     Z",
	    "$LOGDIR/sshxmlrpc.log          640  7     300  *     Z",
	    "$LOGDIR/sslxmlrpc.log          640  7     300  *     Z",
	    "$LOGDIR/reloadlog              640  9     1000 *     Z ".
		"/var/run/reload_daemon.pid",
	    "$LOGDIR/checkuplog             640  9     1000 *     Z ".
		"/var/run/checkup_daemon.pid",
	    "$LOGDIR/poollog                640  9     1000 *     Z ".
		"/var/run/pool_daemon.pid",
	    "$LOGDIR/expire_daemon.log      640  9     1000 *     Z ".
		"/var/run/expire_daemon.pid",
	    "$LOGDIR/sa_daemon.log          640  9     1000 *     Z ".
		"/var/run/sa_daemon.pid");
    };
};

Phase "database", "Setting up database", sub {
    Phase "initialize", "Initializing mysql", sub {
	PhaseSkip("mysqld already initialzed")
	    if (-d "$MYSQLDBDIR/mysql");

	ExecQuietFatal("$MYSQLINSTALL --ldata=${MYSQLDBDIR}");
	ExecQuietFatal("$CHOWN -R mysql:mysql $MYSQLDBDIR");
    };
    Phase "mysql", "Starting mysqld", sub {
	if (!ExecQuiet("$MYSQLADMIN ping")) {
	    PhaseSkip("mysqld already running");
	}
	# XXX make sure client startup was done (setting ldpath)
	ExecQuietFatal("$RCDIR/1.mysql-client.sh start");
	ExecQuietFatal("$RCDIR/2.mysql-server.sh start");
	# Give mysqld some time to start, then make sure it did
	sleep 2;
	if (ExecQuiet("$MYSQLADMIN ping")) {
	    sleep 5;
	    ExecQuietFatal("$MYSQLADMIN ping");
	}
    };
    Phase "$DBNAME", "Creating $DBNAME", sub {
	if (!ExecQuiet("$MYSQLSHOW $DBNAME")) {
	    PhaseSkip("tbdb already exists");
	}
	ExecQuietFatal("$MYSQLADMIN create $DBNAME");
    };
    Phase "tables", "Creating tables in $DBNAME", sub {
	if (!ExecQuiet("$MYSQLDUMP -d $DBNAME users")) {
	    PhaseSkip("Tables have already been created");
	}
	if ($FBSD_MAJOR == 4) {
	    ExecQuietFatal("cp $TOP_SRCDIR/sql/database-create-old.sql $TOP_SRCDIR/sql/database-create.sql")
	    }
	ExecQuietFatal("$MYSQL $DBNAME < $TOP_SRCDIR/sql/database-create.sql");
    };
    Phase "dbdata", "Filling tables with initial data", sub {
	my ($exitval, @rows) = ExecQuiet("echo 'select * from " .
	    "exported_tables' | $MYSQL -s $DBNAME");
	if ($exitval) {
	    PhaseFail("Error running query");
	}
	if (scalar @rows) {
	    PhaseSkip("Already done");
	}
	ExecQuietFatal("$MYSQL $DBNAME < $TOP_SRCDIR/sql/database-fill.sql");
    };
    Phase "sdbdata", "Filling tables with supplemental data", sub {
	my ($exitval, @rows) = ExecQuiet("echo 'select * from " .
	    "os_info' | $MYSQL -s $DBNAME");
	if ($exitval) {
	    PhaseFail("Error running query");
	}
	if (scalar @rows) {
	    PhaseSkip("Already done");
	}
	ExecQuietFatal("$MYSQL $DBNAME < " .
	    "$TOP_SRCDIR/sql/database-fill-supplemental.sql");
    };
    Phase "sitevars", "Setting sitevars to default values", sub {
	my ($exitval, @rows) = ExecQuiet("echo 'select * from " .
	    "sitevariables' | $MYSQL -s $DBNAME");
	if ($exitval) {
	    PhaseFail("Error running query");
	}
	if (scalar @rows) {
	    PhaseSkip("Already done");
	}
	ExecQuietFatal("$MYSQL $DBNAME < $TOP_SRCDIR/sql/sitevars-create.sql");
	#
	# Make sure admincheck is on for new installs.  We leave it off
	# for upgrades (and elabinelab) where there are pre-existing user
	# and projects where admin isolation requires more work.
	#
	Phase "admincheck", "Enabling admin isolation sitevar", sub {
	    if (! $ELABINELAB) {
		PhaseSkip("Not enabling for elabinelab");
	    }
	    ExecQuietFatal("echo \"update sitevariables set value='1' where ".
			   "      name='general/joinproject/admincheck'\" | ".
			   "$MYSQL $DBNAME");
	};
    };
    Phase "knowlbase", "Filling knowledge_base_entries table", sub {
	my ($exitval, @rows) = ExecQuiet("echo 'select * from " .
	    "knowledge_base_entries' | $MYSQL -s $DBNAME");
	if ($exitval) {
	    PhaseFail("Error running query");
	}
	if (scalar @rows) {
	    PhaseSkip("Already done");
	}
	ExecQuietFatal("$MYSQL $DBNAME < ".
		       "$TOP_SRCDIR/sql/knowlbase-create.sql");
    };
    Phase "$ERRORLOG_DBNAME", "Creating $ERRORLOG_DBNAME", sub {
	if (!ExecQuiet("$MYSQLSHOW $ERRORLOG_DBNAME")) {
	    PhaseSkip("$ERRORLOG_DBNAME already exists");
	}
	ExecQuietFatal("$MYSQLADMIN create $ERRORLOG_DBNAME");
    };
    Phase "tables", "Creating tables in $ERRORLOG_DBNAME", sub {
	if (!ExecQuiet("$MYSQLDUMP -d $ERRORLOG_DBNAME users")) {
	    PhaseSkip("Tables have already been created");
	}
	if ($FBSD_MAJOR == 4) {
	    ExecQuietFatal("cp $TOP_SRCDIR/sql/database-create-old-errorlog.sql $TOP_SRCDIR/sql/database-create-errorlog.sql")
	}
	ExecQuietFatal("$MYSQL $ERRORLOG_DBNAME < $TOP_SRCDIR/sql/database-create-errorlog.sql");
    };
    Phase "version_info", "Initializing version_info table", sub {
	my $SQLUPDATES =
	    "$TOP_SRCDIR/sql/updates/$SQL_UPDATE_MAJOR_REVISION";
	my $INUPDATES  =
	    "$TOP_SRCDIR/install/updates/$INSTALL_UPDATE_MAJOR_REVISION";
	
	my ($exitval, @results) =
	    ExecQuiet("echo 'select * from version_info' | $MYSQL -s $DBNAME");
	if ($exitval) {
	    PhaseFail("Error running query");
	}
	if (scalar(@results)) {
	    PhaseSkip("Already done");
	}
	($exitval, @results) =
	    ExecQuiet("cd $SQLUPDATES ; ls | sort -n -r | head -1");
	if ($exitval) {
	    PhaseFail("Error getting sql update list");
	}
	my $sqlfile = $results[0];
	chomp($sqlfile);

	($exitval, @results) =
	    ExecQuiet("cd $INUPDATES ; ls | sort -n -r | head -1");
	if ($exitval) {
	    PhaseFail("Error getting install update list");
	}
	my $updatefile = $results[0];
	chomp($updatefile);

	my $sqlval = $SQL_UPDATE_MAJOR_REVISION . "." . $sqlfile;
	my $upval  = $INSTALL_UPDATE_MAJOR_REVISION . "." . $updatefile;

	ExecQuietFatal("echo 'insert into version_info set ".
		       "  name=\"dbrev\", value=\"$sqlval\"' ".
		       "| $MYSQL -s $DBNAME");
	ExecQuietFatal("echo 'insert into version_info set ".
		       "  name=\"install\", value=\"$upval\"' ".
		       "| $MYSQL -s $DBNAME");
    };
};

Phase "rc.conf", "Adding testbed content to $RCCONF", sub {
    DoneIfEdited($RCCONF);
    my @strings = (qq|rpcbind_enable="YES"|,
		   qq|mountd_enable="YES"|,
		   qq|nfs_server_enable="YES"|,
		   qq|nfs_server_flags="-u -t -n 16"|,
		   qq|nfs_client_enable="YES"|,
		   qq|inetd_enable="YES"|,
		   qq|inetd_flags="-wW -R 0"|,
		   qq|syslogd_flags=""|,
		   qq|tftpd_flags="-lvvvv -C 40 -s /tftpboot"|,
		   (("$APACHE_VERSION" eq "22") ?
		    (qq|apache22_enable="YES"|,
		     qq|apache22_flags="-DSSL"|) :
		    (qq|apache_enable="YES"|,
		     qq|apache_flags="-DSSL"|)),
		   qq|pubsubd_flags="-T 10"|);

    # Starting at FreeBSD 6 we use the default version of bind, not the port.
    if ($FBSD_MAJOR < 6) {
	push(@strings, qq|named_enable="NO"|);
    }
    else {
	push(@strings, (qq|named_enable="YES"|,
			qq|named_chrootdir=""|,
			qq|named_flags=""|,
			qq|named_uid="root"|,
			qq|named_pidfile="$NAMED_PIDFILE"|));
    }

    # At FreeBSD 6, they also changed the name of the ntp start var.
    if ($FBSD_MAJOR < 6) {
	push(@strings, qq|xntpd_enable="YES"|);
    } else {
	push(@strings, qq|ntpd_enable="YES"|);
    }

    # add multicast route for frisbee
    my ($o1) = split(/\./, $FRISADDR);
    push(@strings, (qq|static_routes="\$static_routes frisbee"|,
		    qq|route_frisbee="-net $o1.0.0.0/8 -iface $BOSSNODE_IP"|));

    # enable mrouted if needed
    if ($NEEDMROUTED) {
	push(@strings, qq|mrouted_enable="YES"|);
    }

    AppendToFileFatal($RCCONF, @strings);
};

#
# New version perl does not appear to require this anymore. In fact, it
# seems to break things if it is!
#
if ($FBSD_MAJOR == 4) {
    Phase "suidperl", "Setting the suid bit on $SUIDPERL", sub {
	PhaseSkip("Already done") if (-u $SUIDPERL);
	ExecQuietFatal("$CHMOD u+s $SUIDPERL");
    };
}
else {
    Phase "suidperl", "UnSetting the suid bit on $SUIDPERL", sub {
	PhaseSkip("Already done") if (! -u $SUIDPERL);
	ExecQuietFatal("$CHMOD u-s $SUIDPERL");
    };
}

Phase "hosts", "Adding boss/ops/fs IP addresses to $HOSTS", sub {
    DoneIfEdited($HOSTS);
    my $hstr = "${BOSSNODE_IP}\t${BOSSNODE} boss";
    if ($ISFS) {
	$hstr .= " fs";
    }
    $hstr .= "\n${USERNODE_IP}\t@OPS_NAMES";
    if ($USERNODE ne $FSNODE && $BOSSNODE ne $FSNODE) {
	$hstr .= "\n${FSNODE_IP}\t${FSNODE} fs";
    }
    AppendToFileFatal($HOSTS, $hstr);
};

Phase "resolve", "Checking to make sure names for boss/ops/fs resolve", sub {
    my @hnames = (@OPS_NAMES, ${BOSSNODE}, "boss");
    if ($USERNODE ne $FSNODE && !$ISFS) {
	push @hnames, ${FSNODE}, "fs";
    }
    foreach my $name (@hnames) {
	Phase $name, $name, sub {
	    if (gethostbyname($name)) {
		PhaseSucceed("$name resolves");
	    } else {
		PhaseFail("$name does not resolve - please see setup.txt\n" .
		    "for further instructions!");
	    }
	};
    }
};

Phase "exports", "Setting up exports", sub {
    if (!$ISFS) {
	PhaseSkip("Not FS Node");
    }
    Phase "ex.head", "Creating $EXPORTS_HEAD", sub {
	DoneIfExists($EXPORTS_HEAD);

	#
	# Figure out which of these directories are on the same
	# filesystems.  Note: we cannot do /share on the same exports line
	# as the other filesystems because of the RO mount below (trust me).
	#
	my @dirs;
	# XXX /share is not a separate partition when opsvm/elabinelab
	if (!($OPSVM_ENABLE && $ELABINELAB)) {
	    @dirs = grep(!/^$SHAREROOT$/, @EXPORTDIRS);
	}
	else {
	    @dirs = @EXPORTDIRS;
	}
	@dirs = map {realpath($_)} @dirs;
	chomp @dirs;
	my %filesystems;
	foreach my $dir (@dirs) {
	    my ($dev,@junk) = stat $dir;
	    push @{$filesystems{$dev}}, $dir;
	}

	#
	# Use that knowledge to create lines for /etc/exports.head
	#
	my @exports_lines;
	foreach my $key (keys %filesystems) {
	    push @exports_lines,
		join(" ",@{$filesystems{$key}}) .
		    "\t$BOSSNODE -maproot=root";
	}

	# XXX /share is not a separate partition when opsvm/elabinelab
	if (!($OPSVM_ENABLE && $ELABINELAB)) {
	    #
	    # /share is special. We want to export to boss read-write,
	    # but to the control network read-only.
	    #
	    my $realdir = realpath($SHAREROOT);
	    chomp($realdir);
	    push(@exports_lines,
		 "$realdir\t$BOSSNODE -maproot=root");
	    if (!$NOSHAREDFS) {
		my ($a,$b,$c,$d) =
		    ($CONTROL_NETWORK =~ /^(\d*)\.(\d*)\.(\d*)\.(\d*)/);
		push(@exports_lines,
		     "$realdir\t-network ${a}.${b}.${c} ".
		     "-mask $CONTROL_NETMASK -maproot=root -ro -alldirs");
	    }
	}

	#
	# Put them in exports.head, and copy that to /etc/exports
	#
	CreateFileFatal($EXPORTS_HEAD, @exports_lines);
	ExecQuietFatal("cp $EXPORTS_HEAD $EXPORTS_FILE");
    };

    # XXX Newhup
    Phase "mountd", "HUPing mountd", sub {
	PhaseSkip("No new exports file") if PhaseWasSkipped("ex.head");
	PhaseSkip("mountd not running")
	    unless `ps -auxw | grep mountd | grep -v grep`;
	ExecQuietFatal("killall -HUP mountd");
    };
};

Phase "Mounts", "Setting up NFS mounts", sub {
    Phase "mountpoints", "Creating mountpoints", sub {
	foreach my $dir (@MOUNTPOINTS) {
	    Phase $dir, $dir, sub {
		DoneIfExists($dir);
		mkdir $dir, 0777 or
		    PhaseFail("Unable to create $dir : $!");
	    };
	}
    };
    Phase "fstab", "Adding NFS mounts to $FSTAB", sub {
	DoneIfEdited($FSTAB);
	my $nfsopt = "nosuid";
	$nfsopt .= ",nodev"
	    if ($FBSD_MAJOR < 7);
	
	my @lines = ();
	if (! $ISFS) {
	    @lines = ("$FSNODE:$USERROOT\t\t$USERROOT\tnfs\trw,$nfsopt\t0\t0",
		     "$FSNODE:$PROJROOT\t\t$PROJROOT\tnfs\trw,$nfsopt\t0\t0",
		     "$FSNODE:$GROUPROOT\t\t$GROUPROOT\tnfs\trw,$nfsopt\t0\t0",
		     "$FSNODE:$SHAREROOT\t\t$SHAREROOT\tnfs\trw,$nfsopt\t0\t0");
	    push(@lines,
		 "$FSNODE:$SCRATCHROOT\t\t$SCRATCHROOT\tnfs\trw,$nfsopt\t0\t0")
		if ($SCRATCHDIR);
	}
	if (!$OPSVM_ENABLE) {
	    push(@lines,
	     "$USERNODE:/usr/testbed\t\t$OPSDIR_DIR\tnfs\trw,soft,-b,$nfsopt\t0\t0",
	     "$USERNODE:/var\t\t$USERSVAR_DIR\tnfs\tro,soft,-b,$nfsopt\t0\t0");
	}
	AppendToFileFatal($FSTAB, @lines);
    };
    Phase "mounts", "Mounting filesystems", sub {
	foreach my $dir (@MOUNTPOINTS) {
	    Phase $dir, $dir, sub {
		DoneIfMounted($dir);
		ExecQuietFatal("$MOUNT -o '-R 1' $dir");
	    };
	}
    };
    if ($OPSVM_ENABLE) {
	Phase "symlinks", "Symlinking to OPS VM", sub {
	    Phase $OPSDIR_DIR, $OPSDIR_DIR, sub {
		PhaseSkip("exists")
		    if (-e $OPSDIR_DIR && -l $OPSDIR_DIR);
		ExecQuietFatal("ln -s ${OPSVM_MOUNTPOINT}/usr/testbed $OPSDIR_DIR");
	    };
	    Phase $USERSVAR_DIR, $USERSVAR_DIR, sub {
		PhaseSkip("exists")
		    if (-e $USERSVAR_DIR && -l $USERSVAR_DIR);
		ExecQuietFatal("ln -s ${OPSVM_MOUNTPOINT}/var $USERSVAR_DIR");
	    };
	};
    }
};

#
# Not needed in an inner elab, and it takes a long time.
#
if (! $ELABINELAB) {
    Phase "mibs", "Fetching Cisco MIBs", sub {
	foreach my $mib (@CISCO_MIBS) {
	    my $localfile = "$MIBPATH/$mib.txt";
	    my $mibURL = "$CISCO_MIB_FTP/$mib.my";
	    Phase "$mib", "Fetching $mib", sub {
		DoneIfExists($localfile);
		FetchFileFatal($mibURL,$localfile);
	    };
	}
    };
}

Phase "cron", "Adding cron jobs", sub {
    Phase "crontab", "Editing $CRONTAB", sub {
	DoneIfEdited($CRONTAB);
	AppendToFileFatal($CRONTAB,
	    "0  \t6\t*\t*\t*\troot\t$PREFIX/sbin/audit",
	    "12 \t*\t*\t*\t*\troot\t$PREFIX/sbin/dumperrorlog",
	    "0  \t1\t*\t*\t*\troot\t$PREFIX/sbin/dbcheck",
	    "45 \t1\t*\t*\t*\troot\t$PREFIX/sbin/backup",
	    "*/5\t*\t*\t*\t*\troot\t$PREFIX/sbin/node_status",
	    "*/5\t*\t*\t*\t*\troot\t$PREFIX/sbin/idlemail");
    };
};

Phase "sudoers", "Editing $SUDOERS", sub {
    DoneIfEdited($SUDOERS);
    AppendToFileFatal($SUDOERS,
		      "%wheel    ALL=(ALL) NOPASSWD: ALL",
		      "Defaults  logfile=/var/log/sudo.log");
};

Phase "ssh", "Setting up root ssh from boss to ops", sub {
    Phase "keygen", "Creating root private key", sub {
	DoneIfExists($ROOT_PRIVKEY);
	ExecQuietFatal("$SSH_KEYGEN -t rsa -P '' -f $ROOT_PRIVKEY");
    };
    #
    # Stick it into the DB.
    # WARNING: This sitevar (node/ssh_pubkey) is referenced in tmcd.c
    #
    Phase "sitevar", "Inserting pubkey into DB", sub {
	my $pubkey = `cat $ROOT_PUBKEY`;
	chomp $pubkey;
	ExecQuietFatal("echo \"update sitevariables set value='$pubkey' ".
		       "       where name='node/ssh_pubkey'\" | ".
		       "$MYSQL $DBNAME");
    };
    Phase "ssh", "Editing ssh config file", sub {
	DoneIfEdited($SSH_CONFIG);
	AppendToFileFatal($SSH_CONFIG,
	    "Host *",
	    "   StrictHostKeyChecking no",
	    "   Protocol 2,1");
    };
    Phase "keycopy", "Copy root ssh keys to ops and fs", sub {
	if (! ExecQuiet("$SSH -o 'BatchMode=yes' root\@${USERNODE} pwd")) {
	    PhaseSkip("Key already copied");
	} else {
	    ExecQuietFatal("chmod 400 $INIT_PRIVKEY");
	    ExecQuietFatal("$SCP_INIT -i $INIT_PRIVKEY ".
			   "$ROOT_PUBKEY ${USERNODE}:$ROOT_AUTHKEY");

	    # Copy hosts keys to ops.
	    ExecQuietFatal("cat ${ETCSSH}/*.pub | $SSH ${USERNODE} ".
			   "  '(cat > ${ETCSSH}/ssh_known_hosts)'");

	    if (ExecQuiet("$SSH -o 'BatchMode=yes' root\@${USERNODE} pwd")) {
		PhaseFail("You need to manually copy boss's public SSH key\n".
			  "over to $USERNODE so boss can get into it without\n".
			  "a password. Run the following as root:\n" .
			  "scp $ROOT_PUBKEY ${USERNODE}:$ROOT_AUTHKEY");
	    }
	}
    };
    Phase "keycopy2", "Copy root ssh keys to fs", sub {
	if ($USERNODE eq $FSNODE) {
	    PhaseSkip("FS node is ops node");
	}
	if ($BOSSNODE eq $FSNODE) {
	    PhaseSkip("FS node is boss node");
	}
	if (! ExecQuiet("$SSH -o 'BatchMode=yes' root\@${FSNODE} pwd")) {
	    PhaseSkip("Key already copied");
	} else {
	    ExecQuietFatal("$SCP_INIT -i $INIT_PRIVKEY ".
			   "$ROOT_PUBKEY ${FSNODE}:$ROOT_AUTHKEY");

	    # Copy hosts keys to fs.
	    ExecQuietFatal("cat ${ETCSSH}/*.pub | $SSH ${FSNODE} ".
			   "  '(cat > ${ETCSSH}/ssh_known_hosts)'");

	    if (ExecQuiet("$SSH -o 'BatchMode=yes' root\@${FSNODE} pwd")) {
		PhaseFail("You need to manually copy boss's public SSH key\n".
			  "over to $FSNODE so boss can get into it without\n".
			  "a password. Run the following as root:\n" .
			  "scp $ROOT_PUBKEY ${FSNODE}:$ROOT_AUTHKEY");
	    }
	}
    };
};

Phase "rndc", "Setting up rndc for control of nameserver", sub {
    my $RNDC_KEY     = "/etc/namedb/rndc.key";
    my $RNDC_CONFGEN = "/usr/sbin/rndc-confgen";

    # Bind9 port prior to FreeBSD6
    if ($FBSD_MAJOR < 6) {
	$RNDC_KEY     = "/usr/local/etc/rndc.key";
	$RNDC_CONFGEN = "/usr/local/sbin/rndc-confgen";
    }
    DoneIfExists($RNDC_KEY);
    ExecQuietFatal("$RNDC_CONFGEN -a -r /dev/urandom");
};

Phase "loader.conf", "Setting up $LOADER_CONF", sub {
    DoneIfEdited($LOADER_CONF);
    AppendToFileFatal($LOADER_CONF,
	"kern.hz=1000"
    );
};

Phase "sysctl.conf", "Setting up $SYSCTL_CONF", sub {
    DoneIfEdited($SYSCTL_CONF);
    AppendToFileFatal($SYSCTL_CONF,
	"net.local.dgram.maxdgram=65536",
	"net.local.dgram.recvspace=65536"
    );
};

Phase "sslcerts", "Setting up SSL certificates", sub {
    Phase "sslgen", "Generating SSL certificates", sub {
	DoneIfExists("$TOP_OBJDIR/ssl/$EMULAB_PEM");
	ExecQuietFatal("$GMAKE -C $TOP_OBJDIR/ssl remote-site");
    };
    Phase "sslinstall", "Installing SSL certificates", sub {
	DoneIfExists("$PREFIX/etc/$EMULAB_PEM");
	ExecQuietFatal("$GMAKE -C $TOP_OBJDIR/ssl remote-site-boss-install");
    };
    Phase "sslopscopy", "Copying SSL certificates to ops", sub {
 	ExecQuietFatal("$SSH -o 'BatchMode=yes' root\@${USERNODE} ".
		       "     mkdir -p ${ETC_EMULAB_DIR} ");
 	ExecQuietFatal("$SCP $PREFIX/etc/$EMULAB_PEM ".
 		       "     ${USERNODE}:${ETC_EMULAB_DIR}");
 	ExecQuietFatal("$SCP $TOP_OBJDIR/ssl/$CTRLNODE_PEM".
		       "     ${USERNODE}:${ETC_EMULAB_DIR}/${CLIENT_PEM}");
 	ExecQuietFatal("$SSH -o 'BatchMode=yes' root\@${USERNODE} ".
		       "     'chmod 640 ${ETC_EMULAB_DIR}/${CLIENT_PEM}; ".
		       "      chmod 640 ${ETC_EMULAB_DIR}/${EMULAB_PEM}'  ");
    };
    Phase "apache", "Setting up Apache on boss", sub {
	Phase "dirs", "Creating SSL directories ", sub {
	    PhaseSucceed()
		if (-d "$APACHE_ETCDIR/ssl.crt" &&
		    -d "$APACHE_ETCDIR/ssl.key");

	    if (! -d "$APACHE_ETCDIR/ssl.crt") {
		mkdir "$APACHE_ETCDIR/ssl.crt", 0700 or
		    PhaseFail("Unable to create $APACHE_ETCDIR/ssl.crt : $!");
	    }
	    if (! -d "$APACHE_ETCDIR/ssl.key") {
		mkdir "$APACHE_ETCDIR/ssl.key", 0700 or
		    PhaseFail("Unable to create $APACHE_ETCDIR/ssl.key : $!");
	    }
	};
	Phase "cert", "Installing Apache SSL certificate", sub {
	    DoneIfExists("$APACHE_CERTFILE");
	    ExecQuietFatal("$CP $TOP_OBJDIR/ssl/$APACHE_CERTPEM ".
			   "    $APACHE_CERTFILE");
	};
	Phase "key", "Installing Apache SSL key", sub {
	    DoneIfExists("$APACHE_KEYFILE");
	    ExecQuietFatal("$CP $TOP_OBJDIR/ssl/$APACHE_KEYPEM ".
			   "    $APACHE_KEYFILE");
	};
	if ($APACHE_VERSION eq "1.3") {
	    Phase "rc.d", "Installing Apache startup file", sub {
		DoneIfExists($APACHE_START);
		my $sfile;
		if ($FBSD_MAJOR > 6) {
		    $sfile = "$RCDIR/apache";		
		} else {
		    $sfile = "$RCDIR/apache.sh.sample";
		}
		ExecQuietFatal("mv $sfile $APACHE_START");
		if ($FBSD_MAJOR == 6) {
		    ExecQuietFatal("sed -i .orig ".
				   "-e 's/^apache_enable/#apache_enable/' ".
				   "$APACHE_START");
		    ExecQuietFatal("/bin/rm -f ${APACHE_START}.orig");
		}
	    };
	}
	Phase "starting", "Starting Apache server", sub {
	    DoneIfExists("$VARRUN/httpd.pid");
	    ExecQuietFatal("$APACHE_START start");
	};
    };
    if ($FBSD_MAJOR > 4) {
	Phase "apache", "Setting up Apache on ops", sub {
	    Phase "cert", "Installing Apache SSL certificate", sub {
		ExecQuietFatal("$SCP $TOP_OBJDIR/ssl/$APACHE_CERTPEM_OPS ".
			       "     ${USERNODE}:$APACHE_CERTFILE_OPS");
	    };
	    Phase "key", "Installing Apache SSL key", sub {
		ExecQuietFatal("$SCP $TOP_OBJDIR/ssl/$APACHE_KEYPEM_OPS ".
			       "     ${USERNODE}:$APACHE_KEYFILE_OPS");
	    };
	    if ($APACHE_VERSION eq "1.3") {
		Phase "rc.d", "Installing Apache startup file", sub {
		    ExecQuietFatal("$SCP $APACHE_START".
				   "     ${USERNODE}:${APACHE_START}");
		};
	    }
	};
    }
};

if ($MAILMANSUPPORT) {
    my $secret = substr(GenSecretKey(), 0, 10);
    
    Phase "Mailman", "Setting up Mailman admin Password", sub {
	ExecQuietFatal("echo \"update sitevariables set value='$secret' ".
		       "       where name='general/mailman/password'\" | ".
		       "$MYSQL $DBNAME");
    };
}

Phase "pubsub", "Setting up pubsub system", sub {
    # Ug, kill off the sync server in elabinelab.
    if ($ELABINELAB) {	
	Phase "syncd", "Stopping syncd", sub {
	    if (ExecQuiet("killall -s emulab-syncd")) {
		PhaseSkip("syncd not running");
	    }
	    ExecQuietFatal("killall emulab-syncd");
	};
    }
    # For elabinelab, be sure to kill off running event system. Harmless.
    Phase "stopping", "Stopping pubsub system", sub {
	if (ExecQuiet("killall -s pubsubd")) {
	    PhaseSkip("pubsubd not running");
	}
	ExecQuietFatal("$RCDIR/2.pubsubd.sh stop");
    };
    Phase "starting", "Starting pubsub system", sub {
	ExecQuietFatal("$RCDIR/2.pubsubd.sh start");
    };
};

#
# Build and install software. Note that I am not looking to see if its
# been done; I suppose we could touch a file to indicate that build has
# been completed, but maybe that is not such a good idea.
#
Phase "Software", "Building and Installing Software", sub {
    Phase "building", "Building (please be patient)", sub {
	ExecQuietFatal("cd $TOP_OBJDIR; $GMAKE");
    };
    Phase "installing", "Installing (please be patient)", sub {
	ExecQuietFatal("cd $TOP_OBJDIR; $GMAKE boss-install");
    };
    Phase "postinstall", "Post Installing Testbed Software", sub {
	ExecQuietFatal("cd $TOP_OBJDIR; $GMAKE post-install");
    };
};

#
# The next few items must be after the software install since they use
# testbed libraries and such.
#
Phase "dhcpd", "Setting up initial dhcpd configuration", sub {
    Phase "template", "Installing $DHCPD_TEMPLATE", sub {
	ExecQuietFatal("cd $TOP_OBJDIR/dhcpd; $GMAKE install");
    };
    Phase "config", "Creating $DHCPD_CONF from template", sub {
	ExecQuietFatal("$DHCPD_MAKECONF -i");
    };
    # How silly is this?
    Phase "leases", "Creating stub leases file", sub {
	DoneIfExists("$DHCPD_LEASES");
	ExecQuietFatal("touch $DHCPD_LEASES");
    };
};

Phase "named", "Setting up initial named configuration", sub {
    Phase "building", "Building named files and templates", sub {
	ExecQuietFatal("cd $TOP_OBJDIR/named; $GMAKE");
    };
    Phase "installing", "Installing named files and templates", sub {
	ExecQuietFatal("cd $TOP_OBJDIR/named; $GMAKE install-real");
    };
    Phase "generating", "Generating named zone files", sub {
	ExecQuietFatal("$NAMED_SETUP -norestart");
    };
    
    # Starting at 6.0 we use the default version of bind, not the port.
    my $named_control = ($FBSD_MAJOR < 6 ?
			 "$RCDIR/1.named.sh" : "/etc/rc.d/named");
    
    Phase "stopping", "Stopping named", sub {
	if (ExecQuiet("killall -s named")) {
	    PhaseSkip("named not running");
	}
	if (ExecQuiet("$named_control stop")) {
	    # XXX we have seen cases where the pid file is gone
	    if (ExecQuiet("killall named")) {
		PhaseSkip("named not running!?");
	    }
	}
    };
    Phase "starting", "Starting named", sub {
	#
	# XXX starting sometime in FBSD6, the named start/stop script
	# returns non-zero status whether it works or not.  So we just
	# check for the existance of the pidfile after running the start
	# script.
	#
	if ($FBSD_MAJOR >= 6) {
	    unlink($NAMED_PIDFILE)
		if ( -e "$NAMED_PIDFILE");
	    if (ExecQuiet("$named_control start") &&
		! -e "$NAMED_PIDFILE") {
		PhaseFail("Unable to start named: ");
	    }
	} else {
	    ExecQuietFatal("$named_control start");
	}
    };

    # Lets make sure that old file is gone!
    if ($FBSD_MAJOR >= 6) {
	Phase "cleanup", "Cleaning up old files", sub {
	    DoneIfDoesntExist("$RCDIR/1.named.sh");
	
	    if (!unlink "$RCDIR/1.named.sh") {
		PhaseFail("Unable to remove $RCDIR/1.named.sh: $!");
	    }
	};
    }
    
    Phase "copying", "Copying resolv.conf over to ops", sub {
 	ExecQuietFatal("$SCP $TOP_OBJDIR/named/resolv.conf.ops ".
		       "     ${USERNODE}:/etc/resolv.conf");
    };
    Phase "copying2", "Copying resolv.conf over to fs", sub {
	if ($USERNODE eq $FSNODE) {
	    PhaseSkip("FS node is ops node");
	}
	if ($BOSSNODE eq $FSNODE) {
	    PhaseSkip("FS node is boss node");
	}
 	ExecQuietFatal("$SCP $TOP_OBJDIR/named/resolv.conf.ops ".
		       "     ${FSNODE}:/etc/resolv.conf");
    };
};

if ($BUGDBSUPPORT) {
    my $BUGDBPROXY  = "$PREFIX/sbin/bugdbproxy";

    Phase "flyspray", "Finalizing flyspray installation", sub {
	PhaseSkip("flyspray not supported")
	    if ($FBSD_MAJOR < 6);

 	ExecQuietFatal("$SSH -o 'BatchMode=yes' root\@${USERNODE} ".
		       "     '$BUGDBPROXY setup' ");
    };
}

Phase "firstuser", "Setting up initial user ($PROTOUSER)", sub {
    Phase "firstuser", "Calling 'firstuser' to create account", sub {
	PhaseSkip("$PROTOUSER already created")
	    if (-d "$USERROOT/$PROTOUSER");
	my $safe_password = EscapeShellArg($password);
	ExecQuietFatal("perl $TOP_OBJDIR/utils/firstuser -b ".
		       (defined($password) ? " -p $safe_password" : ""));
    };
    Phase "Fixing", "Fixing up DB state for $PROTOUSER", sub {
	my ($exitval, @rows) =
	    ExecQuiet("echo 'select uid from users ".
		      "  where uid=\"$PROTOUSER\" and webonly=0' ".
		      "| $MYSQL -s $DBNAME");
	if ($exitval) {
	    PhaseFail("Error running query");
	}
	if (scalar @rows) {
	    PhaseSkip("Already done");
	}
	ExecQuietFatal("echo 'update users set webonly=0 ".
		       "  where uid=\"$PROTOUSER\"' | $MYSQL -s $DBNAME");
    };
    Phase "Thawing", "Thawing $PROTOUSER", sub {
	my ($exitval, @rows) =
	    ExecQuiet("echo 'select uid from users ".
		      "  where uid=\"$PROTOUSER\" and status=\"active\"' ".
		      "| $MYSQL -s $DBNAME");
	if ($exitval) {
	    PhaseFail("Error running query");
	}
	if (scalar @rows) {
	    PhaseSkip("Already done");
	}
	ExecQuietFatal("echo 'update users set status=\"active\" ".
		       "  where uid=\"$PROTOUSER\"' | $MYSQL -s $DBNAME");
	ExecQuietFatal("$SUDO -u $PROTOUSER $WAP $TBACCT -b thaw $PROTOUSER");
    };
    Phase "DSAKey", "Adding DSA key to $PROTOUSER account", sub {
	my ($exitval, @rows) =
	    ExecQuiet("echo 'select * from user_pubkeys ".
		      " where uid=\"$PROTOUSER\"' | $MYSQL -s $DBNAME");
	if ($exitval) {
	    PhaseFail("Error running query");
	}
	if (scalar @rows) {
	    PhaseSkip("Already done");
	}
	ExecQuietFatal("$SUDO -u $PROTOUSER $WAP ".
		       "  $ADDPUBKEY -f -u $PROTOUSER $PROTOUSER_KEY");
    };
    Phase "authkeys", "Generating authorized_keys for $PROTOUSER", sub {
	ExecQuietFatal("$SUDO -u $PROTOUSER $WAP $ADDPUBKEY -w $PROTOUSER");
    };
};

Phase "chkupuser", "Setting up checkup user ($CHECKUPUSER)", sub {
    PhaseSkip("$CHECKUPUSER already created")
	if (-d "$USERROOT/$CHECKUPUSER");
    my $safe_password = EscapeShellArg($password);
    ExecQuietFatal("perl $TOP_OBJDIR/utils/firstuser -b ".
		   (defined($password) ? " -p $safe_password" : "").
		   " -u $CHECKUPUSER -n 'Emulab Checkup User' ".
		   "-e '@TBTESTSUITEEMAIL@'");
};
Phase "wikidocs", "Installing wikidocs redirect", sub {
    DoneIfExists("$WWWDIR/wikidocs/.htaccess");

    if (! -e "$WWWDIR/wikidocs") {
	mkdir("$WWWDIR/wikidocs", 0755) or
	    PhaseFail("Unable to make $WWWDIR/wikidocs: $!");
    }
    CreateFileFatal("$WWWDIR/wikidocs/.htaccess",
		    "RedirectMatch (.*)/wikidocs ".
		    " http://users.emulab.net/trac/emulab");
};

Phase "experiments", "Setting up system experiments", sub {
    foreach my $eid (keys(%EXPERIMENTS)) {
	my $pid  = $EXPERIMENTS{$eid}->{"pid"};
	my $desc = $EXPERIMENTS{$eid}->{"description"};
	
	Phase "$pid/$eid", "$pid/$eid", sub {
	    PhaseSkip("Experiment Created")
		if (-d "$PROJROOT/$pid/exp/$eid");
	    ExecQuietFatal("$SUDO -u $PROTOUSER $WAP $BATCHEXP ".
			   "  -q -i -k -j -w -f -n -S 'System Experiment' ".
			   "  -L 'System Experiment' ".
			   "  -E '$desc - DO NOT DELETE' ".
			   "  -p $pid -e $eid");
	    #
	    # XXX create an empty topomap so that nodes booting up in
	    # one of these experiments won't fail in rc.topomap.
	    #
	    ExecQuiet("$SUDO -u $PROTOUSER $GENTOPOFILE $pid $eid");
	};
    }
};

print "----------------------------------------------------------------------\n";
print "Installation completed succesfully!\n";
print "Please reboot this machine before proceeding with boss setup\n";

exit 0;
