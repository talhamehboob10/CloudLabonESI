#
# CODE PAST THIS POINT WAS NOT AUTOMATICALLY GENERATED BY SWIG
#
#
# Copyright (c) 2000-2018 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
# For now, this has to get cat'ed onto the end of event.pm, since it
# doesn't seem possible to get SWIG to just pass it through into the
# output file
#

#
# Stash away the given callback and data, and call the C event_subscribe
# function that uses a stub callback
#
sub event_subscribe($$$;$) {
	my ($handle,$function,$tuple,$data) = @_;
	$event::callback = $function;
	$event::callback_data = $data;
	return stub_event_subscribe($handle,$tuple);
}

#
# Clear $callback_ready, call the C event_poll function, and see if the
# C callback got called (as evidenced by $callback_ready getting set) If it
# did, call the perl callback function. Handle both blocking and non-blocking
# versions of the call
#
sub internal_event_poll($$$) {
	my ($handle, $block, $timeout) = @_;

	my $rv;
	if ($block) {
		$rv = c_event_poll_blocking($handle,$timeout);
	} else {
		$rv = c_event_poll($handle);
	}

	if ($rv) {
		die "Trouble in event_poll - returned $rv\n";
	}

	while (my $data = dequeue_callback_data() ) {
		&$event::callback($handle,$data->{callback_notification},
				$event::callback_data);
		event_notification_free($handle,$data->{callback_notification});
		free_callback_data($data);
	}

	return 0;
}

#
# Wrapper for the internal polling function, non-blocking version
#
sub event_poll($) {
	my $handle = shift;
	return &internal_event_poll($handle,0,0);
}

#
# Same as above, but for the blocking version
#
sub event_poll_blocking($$) {
	my ($handle, $timeout) = @_;
	return &internal_event_poll($handle,1,$timeout);
}

#
# NOTE: The following line will only work if this module is included by
# a file that has already done a 'use lib' to get the path to testbed
# libraries in the INC path. But, since they had to do that to get this
# library anyway, shouldn't be a problem. (Didn't want to have to make
# this a .in file.)
#
use English;
use Carp qw(cluck);
use libtestbed;

#
# Conveniece functions - Intended to work like DBQuery* from libdb .
# Much of this code shamlessly ripped off from libdb.pm
#

#
# Warn after a failed event send. First argument is the error
# message to display. The contents of $EventErrorString is also printed.
# 
# usage: EventWarn(char *message)
#
sub EventWarn($) {
	my($message) = $_[0];
	my($text, $progname);

	#
	# Must taint check $PROGRAM_NAME cause it comes from outside. Silly!
	#
	if ($PROGRAM_NAME =~ /^([-\w.\/]+)$/) {
		$progname = $1;
	} else {
		$progname = "Tainted";
	}

	$text = "$message - In $progname - $EventErrorString";

	cluck($text);
}

#
# Same as above, but die after the warning.
# 
# usage: EventFatal(char *message);
#
sub EventFatal($) {
	my($message) = $_[0];

	EventWarn($message);

	die("\n");
}


#
# Conveniece function - Intended to work like DBQueryFatal from libdb
#
sub EventSendFatal(@) {
	my @tuple = @_;
    
	my $result = EventSend(@tuple);

	if (!$result) {
		EventFatal("Event Send failed");
	}

	return $result;
}

#
# Conveniece function - Intended to work like DBQueryWarn from libdb
#
sub EventSendWarn(@) {
	my @tuple = @_;
    
	my $result = EventSend(@tuple);

	if (!$result) {
		EventWarn("Event Send failed");
	}

	return $result;
}

#
# Register with the event system. You would use this if you are not
# running on boss. The inline registration below is a convenience for
# testbed software, but is technically bad practice. See the END block
# below where we disconnect at exit.
#
sub EventRegister(;$$) {
        my ($host, $port) = @_;

	if ($event::EventSendHandle) {
	        if (event_unregister($event::EventSendHandle) == 0) {
			warn "Could not unregister with event system";
		}
		$event::EventSendHandle = undef;
	}

	$host = TB_EVENTSERVER()
	    if (!defined($host));

	my $URL = "elvin://$host";
	$URL   .= ":$port"
	    if (defined($port));
	
	$event::EventSendHandle = event_register($URL,0);
	
	if (!$event::EventSendHandle) {
		$EventErrorString = "Unable to register with the event system";
		return undef;
	}

	return 1;
}

#
# SSL variant.
#
sub EventRegisterWithSSL($$;$$) {
        my ($certfile,$keyfile,$host, $port) = @_;

	if ($event::EventSendHandle) {
	        if (event_unregister($event::EventSendHandle) == 0) {
			warn "Could not unregister with event system";
		}
		$event::EventSendHandle = undef;
	}

	$host = TB_EVENTSERVER()
	    if (!defined($host));

	my $URL = "elvin://$host";
	$URL   .= ":$port"
	    if (defined($port));
	
	$event::EventSendHandle = event_register_withssl($URL, 0,
							 $certfile, $keyfile);
	
	if (!$event::EventSendHandle) {
		$EventErrorString = "Unable to register with the event system";
		return undef;
	}

	return 1;
}

sub EventSend(@) {
	my %tuple_values = @_;

	#
	# Only connect on the first call - thereafter, just use the existing
	# handle. The handle gets disconnected in the END block below
	#
	if (!$event::EventSendHandle) {
		EventRegister("localhost", TB_BOSSEVENTPORT());

		if (!$event::EventSendHandle) {
			$EventErrorString =
				"Unable to register with the event system";
			return undef;
		}
	}

	my $tuple = address_tuple_alloc();
	if (!$tuple) {
		$EventErrorString = "Unable to allocate an address tuple";
		return undef;
	}

	#
	# Set the values the user requested
	#
	%$tuple = %tuple_values;

	my $notification = event_notification_alloc($event::EventSendHandle,
		$tuple);
	if (!$notification) {
		$EventErrorString = "Could not allocate notification";
		return undef;
	}

	if (!event_notify($event::EventSendHandle, $notification)) {
		$EventErrorString = "Could not send event notification";
		return undef;
	}

	event_notification_free($event::EventSendHandle, $notification);
	address_tuple_free($tuple);

	return 1;
}

#
# After a fork, undef the handle to the event system so that we form a
# a new connection in the child. Do not disconnect from the child; I have
# no idea what that will do to the parent connection.
#
sub EventFork() {
    $event::EventSendHandle = undef;
}

#
# When we exit, unregister with the event system if we're connected
#
END {
    	if ($event::EventSendHandle) {
		if (event_unregister($event::EventSendHandle) == 0) {
			warn "Could not unregister with event system";
		}
	}
}

push @EXPORT, qw(event_subscribe event_poll event_poll_blocking EventSend
	EventSendFatal EventSendWarn EventFork EventRegister
        EventRegisterWithSSL);
1;

