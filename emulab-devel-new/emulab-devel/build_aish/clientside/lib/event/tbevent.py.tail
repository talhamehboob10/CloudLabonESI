# -*- python -*-
#
# CODE PAST THIS POINT WAS NOT AUTOMATICALLY GENERATED BY SWIG
#
#
# Copyright (c) 2000-2006 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
# For now, this has to get cat'ed onto the end of tbevent.py, since it
# doesn't seem possible to get SWIG to just pass it through into the
# output file
#

import sys
import time

class NotificationWrapper:
    """
    Wrapper class for event_notification structures.  Mostly just adds setter
    and getter methods.
    """

    def __init__(self, handle, notification):
        """
        Construct a NotificationWrapper that wraps the given objects.
        
        @param handle The event_handle used to create notification.
        @param notification The event_notification structure to wrap.
        """
        self.handle = handle
        self.notification = notification
        return

    def __del__(self):
        """
        Deconstruct the object by free'ing the wrapped notification.
        """
        event_notification_free(self.handle, self.notification)
        return

    # For the rest of these, consult the C header file, event.h.

    def getSite(self):
        return event_notification_get_site(self.handle, self.notification)

    def getExpt(self):
        return event_notification_get_expt(self.handle, self.notification)

    def getGroup(self):
        return event_notification_get_group(self.handle, self.notification)

    def getHost(self):
        return event_notification_get_host(self.handle, self.notification)

    def getObjType(self):
        return event_notification_get_objtype(self.handle, self.notification)

    def getObjName(self):
        return event_notification_get_objname(self.handle, self.notification)

    def getEventType(self):
        return event_notification_get_eventtype(self.handle, self.notification)

    def getArguments(self):
        return event_notification_get_arguments(self.handle, self.notification)

    def setArguments(self, args):
        return event_notification_set_arguments(self.handle,
                                                self.notification,
                                                args)

    def getTimeline(self, args):
        return event_notification_get_timeline(self.handle, self.notification)

    def getSender(self):
        return event_notification_get_sender(self.handle, self.notification)

    def setSender(self, sender):
        return event_notification_set_sender(self.handle,
                                             self.notification,
                                             sender)

    pass


class CallbackIterator:
    """
    Python iterator for the callback list created by the SWIG stubs.
    """

    def __init__(self, handle):
        """
        Construct an iterator with the given arguments.

        @param handle The event_handle being polled.
        """
        self.last = None
        self.handle = handle
        return

    def __del__(self):
        """
        Deconstruct the iterator.
        """
        if self.last:
            free_callback_data(self.last)
            self.last = None
            pass
        return

    def __iter__(self):
        return self

    def next(self):
        """
        Return the next object in the sequence or raise StopIteration if there
        are no more.  The returned object is a wrapped notification.
        """
        if self.last:
            free_callback_data(self.last)
            self.last = None
            pass
        self.last = dequeue_callback_data()
        if not self.last:
            raise StopIteration
        
        return NotificationWrapper(self.handle,
                                   self.last.callback_notification)

    pass


class EventError:
    """
    Base class for event related exceptions.
    """
    def __init__(self, code):
        self.args = code,
        return
    
    pass


class EventTimedOutError(EventError):
    """
    Exception raised when the run() method of EventClient timed out.
    """
    def __init__(self, timeout):
        self.args = timeout,
        return
    
    pass


# Ugh, elvin likes to crash if we unregister all of the handles, so we keep
# a dummy one around just to keep things happy.
_hack_handle = None

class EventClient:
    """
    Event client class, mostly just wraps the SWIG'd versions of the functions.
    """
    
    def __init__(self, server=None, port=None, url=None, keyfile=None):
        """
        Construct an EventClient object.

        @param url The server name in url'ish form (e.g. elvin://boss)
        @param server The name of the server.
        @param port The server port number.
        """
        global _hack_handle
        
        if url:
            if not url.startswith("elvin:"):
                raise ValueError, "malformed url: " + url
            pass
        else:
            if not server:
                raise ValueError, "url or server must be given"
            url = "elvin://" + server
            if port and len(port) > 0:
                url = url + ":" + port
                pass
            pass

        if keyfile:
            self.handle = event_register_withkeyfile(url, 0, keyfile)
            pass
        else:
            self.handle = event_register(url, 0)
            pass
        
        self.timeout = 0
        
        if not _hack_handle:
            # Open a handle for the sole purpose of keeping the event library
            # from calling the elvin cleanup function, because elvin likes to
            # segfault when it has been init'd/clean'd multiple times.
            _hack_handle = event_register(url, 0)
            pass
        
        return

    def __del__(self):
        """
        Deconstruct this object by disconnecting from the server.
        """
        event_unregister(self.handle)
        self.handle = None
        return

    def _callbacks(self):
        """
        Return an iterator that traverses the list of callbacks generated by
        the SWIG wrapper.
        """
        return CallbackIterator(self.handle)

    def handle_event(self, ev):
        """
        Default implementation of the event handling method.  Should be
        overridden by subclasses.

        @return None to continue processing events, any other value to stop.
        """
        return None

    def subscribe(self, tuple):
        """
        Subscribe to some events.

        @param tuple The address tuple describing the subscription.
        """
        return stub_event_subscribe(self.handle, tuple.this)

    def create_notification(self, tuple):
        """
        @return A notification that is bound to this client.
        """
        return NotificationWrapper(self.handle,
                                   event_notification_alloc(self.handle,
                                                            tuple.this))

    def notify(self, en):
        """
        Send a notification.
        """
        return event_notify(self.handle, en.notification)

    def schedule(self, en, tv):
        """
        Schedule a notification.
        """
        return event_schedule(self.handle, en.notification, tv)

    def set_timeout(self, timeout):
        """
        @param timeout The timeout, in seconds, for the run() loop.
        """
        self.timeout = timeout * 1000
        return

    def run(self):
        """
        Main loop used to wait for and process events.

        @return The not None value returned by handle_event.
        """
        retval = None
        while not retval:
            rc = c_event_poll_blocking(self.handle, self.timeout)
            if rc != 0:
                sys.stderr.write("c_event_poll_blocking: " + str(rc) + "\n")
                raise EventError, rc
            else:
                for ev in self._callbacks():
                    retval = self.handle_event(ev)
                    if retval:
                        # Not None return value, stop the bus.
                        break
                    pass
                else:
                    if self.timeout != 0:
                        # We're making a bit of an assumption here that no
                        # callbacks means a timeout occurred, oh well.
                        raise EventTimedOutError, self.timeout
                    pass
                
                if not retval:
                    time.sleep(0.1) # Forcefully slow down the poll.
                    pass
                pass
            pass
        return retval

    def poll(self):
        """
        Polling interface; returns events to caller, one at a time.
        """

        while True:
            try:
                #
                # First see if anything not yet delivered.
                #
                ev = CallbackIterator(self.handle).next()
                return ev;
            except StopIteration, e:
                pass
            
            rc = c_event_poll_blocking(self.handle, 0)        
            if rc != 0:
                sys.stderr.write("c_event_poll_blocking: " + str(rc) + "\n")
                raise IOError, "Reading events"
            pass
    pass

