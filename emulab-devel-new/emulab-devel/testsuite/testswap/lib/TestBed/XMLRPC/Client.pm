#!/usr/bin/perl
#
# Copyright (c) 2009 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
package TestBed::XMLRPC::Client;
use SemiModern::Perl;
use Moose;
use RPC::XML::Client;
use Net::SSL;
use LWP::Protocol::https;
use IO::Socket::SSL qw( SSL_VERIFY_NONE );
use TBConfig;
use Data::Dumper;
use Carp;
use Tools;

my $loglevel = "INFO";
$loglevel = "DEBUG" if $TBConfig::DEBUG_XML_CLIENT;
my $logger = Tools::init_tbts_logger("XMLRPCClient", undef, "INFO", "SCREEN");


#ensures loading of client side SSL certificates
BEGIN {
  use TBConfig;
  $ENV{HTTPS_CERT_FILE} = glob($TBConfig::SSL_CLIENT_CERT);
  $ENV{HTTPS_KEY_FILE}  = glob($TBConfig::SSL_CLIENT_KEY);
  $ENV{HTTPS_DEBUG} = 0;
}

#constructs RPC::XML::Client with 10 minute socket timeout
has 'client' => ( isa => 'RPC::XML::Client', is => 'rw', default => sub { 
  my $HTTP_TIMEOUT = $TBConfig::XMLRPC_SERVER_TIMEOUT;
  my $c = RPC::XML::Client->new($TBConfig::XMLRPC_SERVER, 
				useragent => [
				    ssl_opts => {
					verify_hostname => 0,
					SSL_verify_mode => SSL_VERIFY_NONE,
				    },
				],
				error_handler => sub { die "Transport error: $_[0]" },
				'timeout' => ($HTTP_TIMEOUT),
      );
  $c->{'__useragent'}->timeout($HTTP_TIMEOUT);
  $c; } );

#autoloaded/autogenerated/method_missings/etc
#automatically constructs XMLRPC resquests for any sub name not defined in the package
our $AUTOLOAD;
sub AUTOLOAD {
  my $self = shift;
  my $type = ref($self) or croak "$self is not an object";
  $self->xmlrpc_req_value(($self->xmlrpcfunc($AUTOLOAD))[0], $self->args(@_));
}

sub args { 
  my $self = shift;

  die "Odd number of args" . sayd(@_) if ((scalar @_) % 2 !=0);
  +{ @_ };
}

sub xmlrpcfunc {
  $_[1] =~ m/.*:([^:]*)::([^:]*)/;
  my ($package, $funcname) = (lc($1), $2);
  $funcname =~ s/\_.*//;
  ("$package.$funcname", $package, $funcname);
}

sub pkgfunclist { 
  my $caller = ((caller(3))[3]);
  (shift->xmlrpcfunc($caller));
}

sub pkgfunc { (shift->pkgfunclist())[0]; }
sub pkg     { (shift->pkgfunclist())[1]; }
sub func    { (shift->pkgfunclist())[2]; }

sub single_request {
  my ($self, $command, @args) = @_;
  $logger->debug(Tools::toperl($command, @args));
  $logger->debug("Sent");
  if ($TBConfig::DEBUG_XML_CLIENT) {
    say("Sent");
    Tools::sayperl($command, @args)
  }
  my $resp = $self->client->send_request($command, $TBConfig::XMLRPC_VERSION, @args); 
  $logger->debug("Received");
  $logger->debug( sub { Dumper($resp); } );
  if ($TBConfig::DEBUG_XML_CLIENT) {
    say("Received");
    say Dumper($resp);
  }
  if ((!ref($resp)) && ($resp =~ /SSL \w+ timeout/)) { die "SSL_SOCKET_TIMEOUT"; }
  if ($resp->isa('RPC::XML::fault')) { die $resp->{faultString}; }
  if ($resp->isa('RPC::XML::struct') && $resp->value->{'code'} != 0 ) { die $resp; }
  $resp;
}

sub xmlrpc_req        { single_request(@_)->value; }
sub xmlrpc_req_value  { single_request(@_)->value-> {'value'}; }
sub xmlrpc_req_output { single_request(@_)->value-> {'output'}; }
sub xmlrpc_req_code   { single_request(@_)->value-> {'code'}; }
sub augment { 
  my $self = shift;
  $self->xmlrpc_req_value($self->pkgfunc(), $self->args(@_));
}
sub augment_output { 
  my $self = shift;
  $self->xmlrpc_req_output($self->pkgfunc(), $self->args(@_));
}
sub augment_code { 
  my $self = shift;
  $self->xmlrpc_req_code($self->pkgfunc(), $self->args(@_));
}
sub augment_code0 { 
  my $self = shift;
  my $result = $self->xmlrpc_req($self->pkgfunc(), $self->args(@_));
  if ( $result->{'code'} ) {
    print $result->{'output'};
  }
  $result->{'code'};
}
sub augment_func { 
  my $self = shift;
  $self->xmlrpc_req_value($self->pkg() . "." . shift, $self->args(@_));
}
sub augment_func_output { 
  my $self = shift;
  $self->xmlrpc_req_output($self->pkg() . "." . shift, $self->args(@_));
}
sub augment_func_code { 
  my $self = shift;
  $self->xmlrpc_req_code($self->pkg() . "." . shift, $self->args(@_));
}

sub augment_func_code0 { 
  my $self = shift;
  my $result = $self->xmlrpc_req($self->pkg() . "." . shift, $self->args(@_));
  if ( $result->{'code'} ) {
    print $result->{'output'};
  }
  $result->{'code'};
}

=head1 NAME

TestBed::XMLRPC::Client

=over 4

=item C<< $client->args(@args) >>

default implementation of arg stuffing.
overridable by subclasses

=item C<< xmlrpcfunc($fq_package_name) >>

B<INTERNAL:>
takes a fully qualified package name and generates xml package and function names
strips _.* off the end of the function name
returns ("$package.$funcname", $package, $funcname)

=item C<< pkgfunclist >>

B<INTERNAL:> reaches up the caller chain three levels and returns the fully qualified package name

=item C<< pkgfunc >>

B<INTERNAL:> reaches up the caller chain three levels and returns the XMLRPC package.function

=item C<< pkg >>

B<INTERNAL:> reaches up the caller chain three levels and returns the XMLRPC package.function

=item C<< func >>

B<INTERNAL:> reaches up the caller chain three levels and returns the XMLRPC package.function

=item C<< $client->single_request($command, @args) >>

B<INTERNAL:> executes a single XMLRPC $command with @args and returns a XMLRPC response

=item C<< $client->xmlrpc_req(@args) >>

B<INTERNAL:> returns the response of a XMLRPC call with @args 

=item C<< $client->xmlrpc_req_value(@args) >>

B<INTERNAL:> returns the value member of a XMLRPC call with @args 

=item C<< $client->xmlrpc_req_output(@args) >>

B<INTERNAL:> returns the output member of a XMLRPC call with @args 

=item C<< $client->xmlrpc_req_code(@args) >>

B<INTERNAL:> returns the code member of a XMLRPC call with @args 

=item C<< $client->augment(@other_args) >>

executes xmlrpc request divining the XMLRPC package and function from the current perl package and function
returns XMLRPC reponse value

=item C<< $client->augment_output(@other_args) >>

executes xmlrpc request divining the XMLRPC package and function from the current perl package and function
returns XMLRPC reponse ouput

=item C<< $client->augment_code(@other_args) >>

executes xmlrpc request divining the XMLRPC package and function from the current perl package and function
returns XMLRPC reponse code

=item C<< $client->augment_func($funcname, @other_args) >>

executes xmlrpc request divining the XMLRPC package from the current perl package
returns XMLRPC reponse value

=item C<< $client->augment_func_output($funcname, @other_args) >>

executes xmlrpc request divining the XMLRPC package from the current perl package
returns XMLRPC reponse output

=item C<< $client->augment_code($funcname, @other_args) >>

executes xmlrpc request divining the XMLRPC package from the current perl package
returns XMLRPC reponse code

=item C<< $client->augment_code0($funcname, @other_args) >>

executes xmlrpc request divining the XMLRPC package from the current perl package
prints the output if response code is nonzero
returns XMLRPC reponse code

=item C<< $client->augment_func_code($funcname, @other_args) >>

executes xmlrpc request divining the XMLRPC package from the current perl package
returns XMLRPC reponse code

=item C<< $client->augment_func_code0($funcname, @other_args) >>

executes xmlrpc request divining the XMLRPC package from the current perl package
prints the output if response code is nonzero
returns XMLRPC reponse code

=back

=cut

1;
