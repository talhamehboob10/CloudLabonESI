#!/usr/bin/perl
#
# Copyright (c) 2009 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
package TestBed::XMLRPC::Client::Experiment;
use SemiModern::Perl;
use Moose;
use Data::Dumper;
use TestBed::XMLRPC::Client::NodeInfo;
use TBConfig;

extends 'TestBed::XMLRPC::Client';

has 'pid' => ( isa => 'Str', is => 'rw', default => sub { $TBConfig::DEFAULT_PID; } );
has 'gid' => ( isa => 'Str', is => 'rw', default => sub { $TBConfig::DEFAULT_GID || $TBConfig::DEFAULT_PID; } );
has 'eid' => ( isa => 'Str', is => 'rw', default => \&gen_random_eid );


sub BUILD {
  my $s = shift;
  if ($TBConfig::prefix) { $s->eid($TBConfig::prefix . $s->eid); }
}

#autoloaded/autogenerated/method_missings/etc batchexp swapexp endexp waitforactive getlist expinfo metadata modify state

my $EID_INCR = 0;
sub gen_random_eid {
  my $self = shift;
  $EID_INCR++;
  my $eid = "RANDEID$EID_INCR";
  $self->eid($eid);
}

sub args {
  my $self = shift;
  my $pid = $self->pid;
  my $gid = $self->gid;
  my $eid = $self->eid;
 
  confess ("Odd number of args" . sayd(@_)) if ((scalar @_) % 2 !=0);

  return { 'pid' => $pid, 'gid' => $gid, 'eid' => $eid, @_ };
}

sub retry_on_TIMEOUT(&$) {
  my ($sub, $message) = @_;
  my $retry_count = 0;
RETRY: 
  { 
    my $result = eval { $sub->(); };
    if ($@) {
      if ($@ =~ /SSL_SOCKET_TIMEOUT/) {
        warn "Retrying: SSL_SOCKET_TIMEOUT after $TBConfig::XMLRPC_SERVER_TIMEOUT seconds in $message";
        $retry_count++;
        redo RETRY;
      }
      elsif ($retry_count > 0 and $@->isa('RPC::XML::struct') and $@->value->{'output'} =~ /\*\*\* swapexp: Experiment .* is not swapped out!/) {
        return 1;         
      }
      else { die $@; }
    }
    $result;
  }
}

sub succeed_on_TIMEOUT(&$) {
  my ($sub, $message) = @_;
RETRY: 
  { 
    my $result = eval { $sub->(); };
    if ($@) {
      if ($@ =~ /SSL_SOCKET_TIMEOUT/) {
        warn "Retrying Indefinitely: SSL_SOCKET_TIMEOUT after $TBConfig::XMLRPC_SERVER_TIMEOUT seconds in $message";
        return 1;
      }
      else { die $@; }
    }
    $result;
  }
}

sub mkerrmsg       { my $e = shift; return $e->eid .  " " . shift;}
sub noemail        { @TBConfig::EXPERIMENT_OPS_PARAMS; }
sub echo           { shift->augment_output( 'str' => shift ); }
sub getlist_brief  { shift->augment( 'format' => 'brief'); }
sub getlist_full   { shift->augment( 'format' => 'full' ); }
sub batchexp_ns    { shift->augment_code( 'nsfilestr' => shift, 'noswapin' =>1, noemail, 'extrainfo' => 1, @_ ); }
sub modify_ns      { my ($e, $ns) = (shift, shift); my @args = @_; succeed_on_TIMEOUT { $e->augment_func_code( 'modify', 'nsfilestr' => $ns, 'noswapin' =>1, noemail, 'extrainfo' => 1, @args ); } $e->mkerrmsg('modify_ns'); }
sub swapin         { my $e = shift; my @args = @_; retry_on_TIMEOUT { $e->augment_func_code( 'swapexp', noemail, 'direction' => 'in', 'extrainfo' => 1, @args ) } $e->mkerrmsg('swapin'); }
sub swapout        { shift->augment_func_code( 'swapexp', noemail, 'direction' => 'out','extrainfo' => 1, @_ ); }
sub end            { shift->augment_func_code( 'endexp', noemail); }
sub end_wait       { shift->augment_func_code( 'endexp', noemail, 'wait' => 1); }
sub fqnodenames    { parseNodeInfo(shift->nodeinfo); }
sub waitforactive  { my $e = shift; my @args = @_; retry_on_TIMEOUT { $e->augment_func_code('waitforactive', @args) } $e->mkerrmsg('waitforactive'); }
sub waitforswapped { my $e = shift; retry_on_TIMEOUT { $e->augment_func_code( 'statewait', 'state' => 'swapped' ) } $e->mkerrmsg('waitforswapped'); }
sub waitforended   { my $e = shift; retry_on_TIMEOUT { $e->augment_func_code( 'statewait', 'state' => 'ended' ) } $e->mkerrmsg('waitforended'); }
sub startexp_ns    { batchexp_ns(@_, 'batch' => 0); }
sub startexp_ns_wait { batchexp_ns_wait(@_, 'batch' => 0); }

sub create_and_get_metadata {
  my $self = shift;
  $self->startexp_ns_wait(shift);
  $self->metadata;
}

sub modify_ns_wait { shift->modify_ns(@_, 'wait' => 1); }
sub modify_ns_swapin_wait { 
  my $s = shift;
  $s->modify_ns(@_, 'wait' => 1);
  $s->swapin_wait;
}

sub batchexp_ns_wait { shift->batchexp_ns(@_,'wait' => 1); }

use constant EXPERIMENT_NAME_ALREADY_TAKEN => 2;
use constant EXPERIMENT_ALREADY_SWAPPED_IN => 2;
sub ensure_active_ns {
  my $self = shift;
  eval { $self->startexp_ns_wait(@_); };
  my $exception = $@;
  if ($exception) {
    unless ($exception->isa('RPC::XML::struct') and $exception->value->{ 'code' } == EXPERIMENT_NAME_ALREADY_TAKEN) {
      die $exception;
    }
  }
  my $rc = eval { $self->swapin_wait; };
  $exception = $@;
  if ($exception) {
    unless ($exception->isa('RPC::XML::struct') and $exception->value->{ 'code' } == EXPERIMENT_ALREADY_SWAPPED_IN) {
      die $exception;
    }
  }
  $rc;
}

sub ensure_end {
  my $s = shift;
  eval { $s->end_wait(@_); };
  my $exception = $@;
  if ($exception) {
    if( $exception->isa('RPC::XML::struct')) {
      if ($exception->value->{ 'output' } =~ /No such experiment/ ) { return; }
      elsif ($exception->value->{ 'output' } =~ /Experiment .* went into transition/ ) { return; }
    }
    say "Error in ensure_end";
    sayd($exception);
    die $exception;

  }
}

sub swapin_wait { 
  my $self = shift;
  $self->swapin('wait' => 1);
  $self->waitforactive;
}

sub swapout_wait { 
  my $self = shift;
  $self->swapout('wait' => 1);
  $self->waitforswapped
}

sub inject_sub {
  my ($fqname, $sub) = @_;
  no strict 'refs';
  *{ $fqname } = $sub;
}

sub gen_expinfo_funcs {
  my ($package) = caller();
  for my $funcname (qw(mapping linkinfo shaping nodeinfo) ) {
    my $sub = sub {
      shift->augment_func_output('expinfo', 'show' => $funcname );
    };
    inject_sub($package . '::' . $funcname, $sub);
  }
}

gen_expinfo_funcs();

=head1 NAME

TestBed::XMLRPC::Client::Experiment

=over 4

=item C<< $e->pid >>

experiment pid

=item C<< $e->gid >>

experiment gid

=item C<< $e->eid >>

experiment eid

=item C<< $e->batchexp >>

calls batchexp xmlrpc function

=item C<< $e->swapexp >>

calls swapexp xmlrpc function

=item C<< $e->endexp >>

calls endexp xmlrpc function

=item C<< $e->waitforactive >>

calls waitforactive xmlrpc function

=item C<< $e->getlist >>

calls getlist xmlrpc function to get a list of experiments

=item C<< $e->expinfo >>

calls expinfo xmlrpc cfunction

=item C<args>

B<INTERNAL>: internal method for inserting pid, gid, and eid arguments into a xmlrpc call

=item C<< $e->echo($msg) >>

echos $msg through the emulab xmlrpc server

=item C<< $e->getlist_brief() >>

returns the 'format' => 'brief' experiement list

=item C<< $e->getlist_full() >>

returns the 'format' => 'full' experiement list

=item C<< $e->batchexp_ns($nsfile_contents, @args) >>

batches experiment defined in $nsfile_contents

=item C<< $e->swapin >>

swaps the experiment in

=item C<< $e->swapout >>

swaps the experiment out

=item C<< $e->end >>

ends the experiment

=item C<< $e->end_wait >>

ends the experiment, waits for it to reach the ended state

=item C<< $e->ensure_end >>

ends the experiment, allowing for experiment doesn't exist and in transition exceptions 

=item C<< $e->state >>

returns the experiment state as a string

=item C<< $e->nodeinfo >>

returns a list of node names in the experiment

=item C<< $e->waitsforactive >>

waits for the experiment to enter the active state

=item C<< $e->waitforswapped >>

waits for the experiment to enter the swapped state

=item C<< $e->waitforended >>

waits for the experiment to enter the ended state


=item C<< $e->startexp_ns($nsfile_contents, @args) >>

start experiment defined in $nsfile_contents

=item C<< $e->startexp_ns_wait($nsfile_contents, @args) >>

start experiment defined in $nsfile_contents
waits for it to become active

=item C<< $e->batchexp_ns_wait($nsfile_contents, @args) >>

batches experiment defined in $nsfile_contents
waits for it to become active

=item C<< $e->swapin_wait >>

swaps the experiment in, waits for the experiment to enter the active state

=item C<< $e->swapout_wait >>

swaps the experiment out, waits for the experiment to enter the swapped state

=item C<< inject_sub($fqname, $sub) >>

B<INTERNAL>: injects anonymous sub $sub into $fqname package

=item C<< $e->mapping >>

returns experiment node mapping

=item C<< $e->linkinfo >>

returns experiment linkinfo

=item C<< $e->shaping >>

returns experiment link shaping

=item C<< $e->create_and_get_metadata($ns) >>

creates the experiment and returns the create metadata
i.e. min and max nodes, as well as a bunch of other stuff

=item C<< $e->ensure_active_ns($ns) >>

creates the experiment if it doesn't already exist and ensures that the experiement is swapped in

=item C<< $e->gen_random_eid >>

hook for generating a random $eid if desired

=item C<< $e->modify_ns($ns) >>

modifies the current experiment with the give $ns file

=item C<< $e->modify_ns_wait($ns) >>

modifies the current experiment with the give $ns file and waits for the modifications to complete

=item C<< $e->fqnodenames >>

returns a list of fully qualified node names in the experiement

=item C<< $e->noemail >>

B<INTERNAL>: generates the noemail attribute for xmlrpc calls if so configured in TBConfig

=item C<< gen_expinfo_funcs >>

B<INTERNAL>: generates expinfo subs 

=item C<< retry_on_TIMEOUT(&sub, $messag) >>

B<INTERNAL>: catches socket timeout exceptions and rexecutes &sub after printing $message

=item C<< succeed_on_TIMEOUT(&sub, $messag) >>

B<INTERNAL>: catches socket timeout exceptions and returns success

=item C<< $e->mkerrmsg($messag) >>

B<INTERNAL>: prepends error message with eid

=item C<< $e->BUILD >>

B<INTERNAL>: a Mouse method to allow modification during construction time


=back 

=cut

1;
