#
# Copyright (c) 2008 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
# A little auth module I wrote to allow cross-domain login from emulab
# to the protogeni wiki, but I use it for all of the wikis. The basic
# idea is that the emulab backend inserts a hash value into the cookie
# table in the trac DB on ops (via ssh). Then Emulab issues a redirect
# over to the trac wiki, with the uid/hash values as arguments to the
# xlogin URL. This hash is use-once; if it exists in the cookies table,
# it is deleted and a new one generated by the underlying auth module,
# and a cookie returned to the browser. The user is thus logged in for
# all subsequent access.
#
# Why? Cause emulab.net cannot insert auth cookies for protogeni.net, so
# must let the auth module inside trac insert the cookie. 
#

import string
import re
import os

from trac import perm, util
from trac.core import *
from trac.config import Option
from trac.web import auth
from trac.web.api import IAuthenticator
from trac.web.main import IRequestHandler
from trac.util.html import escape, html

def if_enabled(func):
    def wrap(self, *args, **kwds):
        if not self.enabled:
            return None
        return func(self, *args, **kwds)
    return wrap

class EmulabAuthModule(auth.LoginModule):
    def authenticate(self, req):
        if req.method == 'GET' and req.path_info.startswith('/xlogin'):
            req.environ['REMOTE_USER'] = self._remote_user(req)
            pass
        return auth.LoginModule.authenticate(self, req)

    def match_request(self, req):
        return re.match('/(xlogin|logout)', req.path_info)

    authenticate  = if_enabled(authenticate)
    match_request = if_enabled(match_request)

    def process_request(self, req):
        if req.path_info.startswith('/xlogin') and req.authname == 'anonymous':
            raise TracError(html("Authentication information not available."))
        if req.path_info.startswith('/xlogin'):
            if not req.remote_user:
                req.redirect(self.env.abs_href())
                return
            if req.args.get('goto'):
                req.redirect(self.env.abs_href() + "/" + req.args.get('goto'))
            else:
                req.redirect(self.env.abs_href())
                pass
            pass
        elif req.path_info.startswith('/logout'):
            auth.LoginModule._do_logout(self, req)
        self._redirect_back(req)
        pass
    
    def _remote_user(self, req):
        user = req.args.get('user')
        hash = req.args.get('hash')
        if not user or not hash:
            return None
        #
        # Here is where we check the hash against the auth_cookie table
        # in the DB. There is no cookie yet since we have just come from
        # another domain. 
        #
        db = self.env.get_db_cnx()
        cursor = db.cursor()
        if self.check_ip:
            cursor.execute("SELECT name FROM auth_cookie "
                           "WHERE cookie=%s AND name=%s AND ipnr=%s",
                           (hash, user, req.remote_addr))
        else:
            cursor.execute("SELECT name FROM auth_cookie "
                           "WHERE cookie=%s and name=%s",
                           (hash, user))
        row = cursor.fetchone()
        if not row:
            # The hash is invalid (or has been purged from the database).
            # tell the user agent to drop it as it is invalid.
            return None

        db.commit()
        
        shortname = os.path.basename(self.env.path)        
        #
        # This is awful!
        #
        if shortname == "protogeni":
            cookie_key = "trac_auth_" + str(self.cookie_suffix)

            req.outcookie[cookie_key] = hash
            req.outcookie[cookie_key]['path'] = req.href()
            req.outcookie[cookie_key]['domain'] = ".protogeni.net";
            pass
        
        req.authname = user
        return user

    def _redirect_back(self, req):
        """Redirect the user back to the URL she came from."""
        referer = self._referer(req)
        if referer and not referer.startswith(req.base_url):
            # don't redirect to external sites
            referer = None
        req.redirect(referer or self.env.abs_href())

    def _referer(self, req):
        return req.args.get('referer') or req.get_header('Referer')

    def enabled(self):
        # Users should disable the built-in authentication to use this one
        return not self.env.is_component_enabled(auth.LoginModule)
    enabled = property(enabled)

    # INavigationContributor methods

    def get_active_navigation_item(self, req):
        return ''

    def get_navigation_items(self, req):
        if req.authname and req.authname != 'anonymous':
            yield ('metanav', 'login', 'logged in as %s' % req.authname)
            yield ('metanav', 'logout',
                   html.A('Logout', href=req.href.logout()))
        else:
            shortname = os.path.basename(self.env.path)
            page = req.path_info[1:] or 'wiki/WikiStart'

            url = 'https://www.emulab.net/gototrac.php3?login=1&wiki=%s&do=%s' % (shortname, page)
            yield ('metanav', 'login', html.A('Login', href=url))
            pass
        pass

    pass


