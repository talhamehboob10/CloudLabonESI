#!/usr/bin/perl -w
#
# Copyright (c) 2005, 2006 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
use English;
use Errno;
use Fcntl ':flock';
use Getopt::Std;

#
# Install new cvsd.conf file ...
#
sub usage()
{
    print(STDOUT "Usage: cvsrepo_ctrl.proxy [-m]\n");
    exit(-1);
}
my $optlist   = "m";
my $domounts  = 0;

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";

my $CVSDCONF	= "/usr/local/etc/cvsd/cvsd.conf";
my $CVSDCONFNEW	= "/usr/local/etc/cvsd/cvsd.conf.new";
my $CVSDCONFOLD	= "/usr/local/etc/cvsd/cvsd.conf.backup";
my $HEADFILE    = "$TB/lib/cvsd.conf.head";
my $STARTPROG   = "/usr/local/etc/rc.d/cvsd.sh";
my $REPODIR     = "cvsrepos";
my $MOUNT	= "/sbin/mount -o ro";
my $UNMOUNT     = "/sbin/umount";
my %pubrepos    = ();

#
# We don't want to run this script unless its the real version.
#
if ($UID != 0) {
    die("*** $0:\n".
	"    Must be root to run this script!");
}

# un-taint path
$ENV{'PATH'} = '/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

# Turn off line buffering on output
$| = 1;

# Protos
sub fatal($);

#
# Testbed Support libraries
# 
use lib "@prefix@/lib";
use libtestbed;

my $PROJREPODIR = PROJROOT() . "/$REPODIR";
my $JAILREPODIR = "/var/cvsjail/$REPODIR";

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{m})) {
    $domounts = 1;
}
usage()
    if (@ARGV);

#
# Take our input and get the list of repos we need to make public.
#
while (<STDIN>) {
    if ($_ =~ /^([^\s]*)$/) {
	$pubrepos{$1} = $1;
    }
}

#
# Generate a warning so that no one tries to edit the file by hand
#
open(CONF, ">$CVSDCONFNEW") ||
    fatal("Could not open $CVSDCONFNEW!");

print CONF
    "#\n".
    "# ******************************************************************\n".
    "# DO NOT EDIT THIS FILE. IT IS A CREATION, A FIGMENT, A CONTRIVANCE!\n".
    "# ******************************************************************\n".
    "#\n";
close(CONF);
chmod(0644, $CVSDCONFNEW);

#
# Now tack on the head part of the file.
#
system("cat $HEADFILE >> $CVSDCONFNEW") == 0 or
    fatal("Failed to concat $HEADFILE to $CVSDCONFNEW\n");

#
# Now the tail of the file.
#
open(CONF, ">>$CVSDCONFNEW") ||
    fatal("Could not open $CVSDCONFNEW for appending!");

print CONF "\n";
print CONF "#\n";
print CONF "# DO NOT EDIT below this point. Auto generated entries!\n";
print CONF "#\n";

foreach my $repo (keys(%pubrepos)) {
    print CONF "Repos /$REPODIR/$repo\n";
}
close(CONF);

#
# Back up the existing config, and then mv in the new one.
#
system("cp $CVSDCONF $CVSDCONFOLD") == 0 or
    fatal("Could not back up $CVSDCONF to $CVSDCONFOLD");

system("mv $CVSDCONFNEW $CVSDCONF") == 0 or
    fatal("Could not mv $CVSDCONFNEW to $CVSDCONF");

# Avoid accidental editing.
chmod(0444, $CVSDCONF);

#
# In mounts mode, just do the NFS mounts and exit. This is intended to
# be called at bootup, from boss.
#
if ($domounts) {
    foreach my $repo (keys(%pubrepos)) {
	my $dir = $repo;

	if (! -d "$JAILREPODIR/$dir") {
	    system("/bin/mkdir $JAILREPODIR/$dir") == 0 or
		fatal("Could not mkdir $JAILREPODIR/$dir");
	}

	#
	# Now mount it, if not already done so.
	#
	if (! -d "$JAILREPODIR/$dir/CVSROOT") {
	    print "Mount: localhost:${PROJREPODIR}/$dir $JAILREPODIR/$dir\n";
	    
	    system("$MOUNT localhost:${PROJREPODIR}/$dir $JAILREPODIR/$dir");
	    if ($?) {
		fatal("Could not NFS mount localhost:${PROJREPODIR}/$dir");
	    }
	}
    }
    exit(0);
}

#
# Must stop cvsd before doing the next step.
# 
system("$STARTPROG stop") == 0 or
    fatal("Could not stop cvsd!");

#
# Okay, now do the mounts and unmounts into the jail tree. Each pub
# repo gets a mount and each repo that is no longer pub, gets an unmount.
#
# First see whats already there. The only record I keep is the list of
# subdirs that exist already.
#
opendir(DIR, $JAILREPODIR) or
    fatal("Could not opdendir $JAILREPODIR: $!");
my @dirfiles = readdir(DIR);
closedir(DIR);

#
# Get rid of ones that are no longer supposed to be public.
# 
foreach my $dir (@dirfiles) {
    next
	if ($dir eq "." || $dir eq "..");

    #
    # Any directory that is not in the list we got from boss, needs
    # an unmount and rmdir; it is no longer public.
    # 
    if (! exists($pubrepos{$dir})) {
	system("$UNMOUNT $JAILREPODIR/$dir") == 0 or
	    fatal("Could not unmount $JAILREPODIR/$dir");
	system("/bin/rmdir $JAILREPODIR/$dir") == 0 or
	    fatal("Could not rmdir $JAILREPODIR/$dir");
    }
    else {
	#
	# Already there, so delete from the list of ones we need to add.
	#
	delete($pubrepos{$dir});
    }
}

#
# Now add any new ones.
#
foreach my $repo (keys(%pubrepos)) {
    my $dir = $repo;
	
    system("/bin/mkdir $JAILREPODIR/$dir") == 0 or
	fatal("Could not mkdir $JAILREPODIR/$dir");

    #
    # Now mount it; if it fails then remove the directory too so as
    # not to mess up the next time it runs. 
    #
    system("$MOUNT localhost:${PROJREPODIR}/$dir $JAILREPODIR/$dir");
    if ($?) {
	system("/bin/rm -r $JAILREPODIR/$dir");
	fatal("Could not NFS mount localhost:${PROJREPODIR}/$dir");
    }

    #
    # Setup an anoncvs password entry for the directory.
    #
    system("/bin/echo 'anoncvs::nobody' > ".
	   "$PROJREPODIR/$dir/CVSROOT/passwd") == 0 or
	fatal("Could not create $PROJREPODIR/$dir/CVSROOT/passwd!");

    system("/bin/echo 'anonymous::nobody' >> ".
	   "$PROJREPODIR/$dir/CVSROOT/passwd") == 0 or
	fatal("Could not create $PROJREPODIR/$dir/CVSROOT/passwd!");

    #
    # And now generate a config file that makes pserver happy. Just
    # blow away the existing one; it should not matter.
    # 
    system("/bin/rm -f $PROJREPODIR/$dir/CVSROOT/config ".
	   "           $PROJREPODIR/$dir/CVSROOT/config,v") == 0 or
	fatal("Could not rm $PROJREPODIR/$dir/CVSROOT/config!");

    open(CONF, "> $PROJREPODIR/$dir/CVSROOT/config") or
	fatal("Could not open $PROJREPODIR/$dir/CVSROOT/config!");
    print CONF "SystemAuth=no\n";
    print CONF "LockDir=/var/cvslock\n";
    close(CONF);
}

#
# Okay, restart the cvsd process. Too bad there is no HUP handler to reload
# the config file, as this is going to kill anyone currently connected. 
#
system("$STARTPROG start") == 0 or
    fatal("Could not restart cvsd!");

exit(0);

sub fatal($) {
    my ($msg) = @_;

    die("*** $0:\n".
	"    $msg\n");
}
