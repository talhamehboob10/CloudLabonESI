<?php
#
# Copyright (c) 2000-2021 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
chdir("..");
include_once("webtask.php");
include_once("geni_defs.php");
chdir("apt");
include_once("profile_defs.php");
include_once("instance_defs.php");
include_once("checkscript.ajax");

#
# Create for a new profile.
#
function Do_Create()
{
    global $this_user;
    global $ajax_args;
    $action = "";
    $errors = array();
    $this_idx = $this_user->uid_idx();
    
    if (!isset($ajax_args["formfields"])) {
	SPITAJAX_ERROR(1, "Missing formfields");
	return;
    }
    $formfields = $ajax_args["formfields"];
    # Allow for form precheck only. So JS code knows it will be fast. 
    $checkonly  = (isset($ajax_args["checkonly"]) &&
                   $ajax_args["checkonly"] == 1 ? 1 : 0);
    if (isset($formfields["snapuuid"]) && $formfields["snapuuid"] != "") {
        $snapuuid = $formfields["snapuuid"];
    }
    if (isset($formfields["snapnode_id"]) && $formfields["snapnode_id"] != "") {
        $snapnode_id = $formfields["snapnode_id"];
    }
    if (isset($formfields["copyuuid"]) && $formfields["copyuuid"] != "") {
        $copyuuid = $formfields["copyuuid"];
    }
    if (!isset($formfields["action"]) && $formfields["action"] == "") {
        $errors["errors"] = "Missing action";
        goto bad;
    }
    $action = $formfields["action"];    
    
    if ($action == "edit") {
        #
        # We better have a profile uuid.
        #
        if (!isset($formfields["uuid"])) {
            $errors["errors"] = "Missing profile uuid";
            goto bad;
        }
	$profile = Profile::Lookup($formfields["uuid"]);
	if (!$profile) {
            $errors["errors"] = "Cannot find profile";
            goto bad;
	}
	else if ($profile->locked()) {
            $errors["errors"] = "Profile is currently locked!";
            goto bad;
	}
	else if ($profile->deleted()) {
            $errors["errors"] = "Profile has been deleted!";
            goto bad;
	}
        if (! $profile->CanEdit($this_user)) {
            $errors["errors"] = "Not enough permission!";
            goto bad;
	}
    }

    #
    # Quick check for required fields.
    #
    $required = array("pid", "name");

    foreach ($required as $key) {
        if (!isset($formfields["profile_${key}"]) ||
            strcmp($formfields["profile_${key}"], "") == 0) {
            $errors["profile_${key}"] = "Missing Field";
        }
        elseif (! TBcheck_dbslot($formfields["profile_${key}"],
                                 "apt_profiles", $key,
                                TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
            $errors["profile_${key}"] = TBFieldErrorString();
        }
    }
    if (isset($formfields["copy-profile"]) &&
        $formfields["copy-profile"] != "") {
        // We get here via image creation on the status page.
	$profile = Profile::Lookup($formfields["copy-profile"]);
	if (!$profile) {
            $errors["errors"] = "Cannot find source profile";
            goto bad;
	}
        $rspec = $profile->rspec();
        if ($profile->script() && $profile->script() != "") {
            $script = $profile->script();
        }
        if ($profile->portal_converted()) {
            $portal_converted = 1;
        }
    }
    else {
        if (isset($formfields["profile_rspec"]) &&
            $formfields["profile_rspec"] != "") {
            if (! TBvalid_rspec($formfields["profile_rspec"])) {
                $errors["profile_rspec"] = TBFieldErrorString();	
            }
            elseif (trim($formfields["profile_rspec"]) == "") {
                $errors["profile_rspec"] = "no rspec provided";
            }
            else {
                $rspec = $formfields["profile_rspec"];
            }
        }
        if (isset($formfields["profile_script"]) &&
            $formfields["profile_script"] != "" &&
            trim($formfields["profile_script"]) != "") {
            $script = $formfields["profile_script"];
        }
        if (isset($formfields["portal_converted"]) &&
            $formfields["portal_converted"] != "") {
            $portal_converted = ($formfields["portal_converted"] == "yes"
                                 ? 1 : 0);
        }
    }

    # Present these errors before we call out to do anything else.
    if (count($errors)) {
        goto bad;
    }
    #
    # Project has to exist. We need to know it for the SUEXEC call
    # below. 
    #
    $project = Project::LookupByPid($formfields["profile_pid"]);
    if (!$project) {
        $errors["profile_pid"] = "No such project";
    }
    elseif (!ISADMIN() &&
            (!$project->IsMember($this_user, $isapproved) || !$isapproved)) {
        $errors["profile_pid"] = "Illegal project";
    }
    elseif (($action == "create" || $action == "clone") && 
            Profile::LookupByName($project, $formfields{"profile_name"})) {
        $errors["profile_name"] = "Already in use";
    }
    
    #
    # Convert profile_who to arguments.
    #
    if (!isset($formfields["profile_who"]) ||
        $formfields["profile_who"] == "") {
        $errors["profile_who"] = "Missing value";
    }
    else {
        $who = $formfields["profile_who"];
        if (! ($who == "private" || $who == "shared" || $who == "public")) {
            $errors["profile_who"] = "Illegal value";
        }
    }
    # Sanity check repourl.
    if ($action == "create" &&
        isset($formfields["profile_repourl"]) &&
        $formfields["profile_repourl"] != "") {
        if (!TBvalid_URL($formfields["profile_repourl"])) {
            $errors["error"] = "Invalid repository URL!";
        }
    }
    # Sanity check the snapuuid argument when doing a clone.
    if ($action == "clone") {
        if (!isset($snapuuid) || $snapuuid == "" || !IsValidUUID($snapuuid)) {
            $errors["error"] = "Invalid experiment specified for clone!";
        }
        $instance = Instance::Lookup($snapuuid);
        if (!$instance) {
            $errors["error"] = "No such experiment to clone!";
        }
        else if ($this_idx != $instance->creator_idx() && !ISADMIN()) {
            $errors["error"] = "Not enough permission!";
        }
        else if (! Profile::Lookup($instance->profile_id(),
                                   $instance->profile_version())) {
            $errors["error"] = "Cannot load profile for instance!";
        }
        else if (isset($snapnode_id) && !TBvalid_vnode_id($snapnode_id)) {
            $errors["error"] = "Invalid node_id for snapshot!";
        }
    }
    # Sanity check examples portals and public setting.
    if ($formfields["examples_portals"] != "" &&
        $formfields["profile_who"] != "public") {
        $errors["examples_portals"] =
            "Profile must be public to list on the Examples page";
    }
  bad:    
    if (count($errors)) {
	SPITAJAX_ERROR(2, $errors);
	return;
    }
    if ($checkonly) {
	SPITAJAX_RESPONSE(0);
	return;
    }
    #
    # Pass to the backend as an XML data file.
    #
    # Generate a temporary file and write in the XML goo.
    #
    $xmlname = tempnam("/tmp", "newprofile");
    if (! $xmlname) {
        TBERROR("Could not create temporary filename", 0);
        $errors["error"] = "Internal error; Could not create temp file";
        goto bad;
    }
    elseif (! ($fp = fopen($xmlname, "w"))) {
        TBERROR("Could not open temp file $xmlname", 0);
        $errors["error"] = "Internal error; Could not open temp file";
        unlink($xmlname);
        goto bad;
    }
    else {
        fwrite($fp, "<profile>\n");
        fwrite($fp, "<attribute name='profile_pid'>");
        fwrite($fp, "  <value>" . $formfields["profile_pid"] . "</value>");
        fwrite($fp, "</attribute>\n");
        fwrite($fp, "<attribute name='profile_name'>");
        fwrite($fp, "  <value>" .
               htmlspecialchars($formfields["profile_name"]) . "</value>");
        fwrite($fp, "</attribute>\n");
        if (isset($rspec)) {
            fwrite($fp, "<attribute name='rspec'>");
            fwrite($fp, "  <value>" . htmlspecialchars($rspec) . "</value>");
            fwrite($fp, "</attribute>\n");
        }
        if (isset($script)) {
            fwrite($fp, "<attribute name='script'>");
            fwrite($fp, "  <value>" .
                   htmlspecialchars($script) . "</value>");
            fwrite($fp, "</attribute>\n");
            if (isset($portal_converted)) {
                $pcon = ($portal_converted ? 1 : 0);
                fwrite($fp, "<attribute name='portal_converted'>");
                fwrite($fp, "  <value>$pcon</value>");
                fwrite($fp, "</attribute>\n");
            }
        }
        if (isset($formfields["profile_repourl"]) &&
            $formfields["profile_repourl"] != "") {
            fwrite($fp, "<attribute name='repourl'>");
            fwrite($fp, "  <value>" .
                   htmlspecialchars($formfields["profile_repourl"]) .
                   "</value>");
            fwrite($fp, "</attribute>\n");
        }
        #
        # When the profile is created we mark it listed=public if a mere
        # user. Mere users cannot change the value later. Admin users can
        # always set/change the value.
        #
        if ($action != "edit" || ISADMIN()) {
            fwrite($fp, "<attribute name='profile_listed'><value>");
            if (ISADMIN()) {
                if (isset($formfields["profile_listed"]) &&
                    $formfields["profile_listed"] == "checked") {
                    fwrite($fp, "1");
                }
                else {
                    fwrite($fp, "0");
                }
            }
            elseif ($action != "edit") {
                fwrite($fp, "0");
            }
            fwrite($fp, "</value></attribute>\n");
        }
        
        fwrite($fp, "<attribute name='profile_shared'><value>" .
               ($who == "shared" ? 1 : 0) . "</value></attribute>\n");
        fwrite($fp, "<attribute name='profile_public'><value>" .
               ($who == "public" ? 1 : 0) . "</value></attribute>\n");

        if (isset($formfields["profile_project_write"])) {
            fwrite($fp, "<attribute name='profile_project_write'><value>");
            if ($formfields["profile_project_write"] == "checked") {
                fwrite($fp, "1");
            }
            else {
                fwrite($fp, "0");
            }
            fwrite($fp, "</value></attribute>\n");
        }
        
        if (ISADMIN()) {
            fwrite($fp, "<attribute name='profile_topdog'><value>");

            if (isset($formfields["profile_topdog"]) &&
                $formfields["profile_topdog"] == "checked") {
                fwrite($fp, "1");
            }
            else {
                fwrite($fp, "0");
            }
            fwrite($fp, "</value></attribute>\n");
            fwrite($fp, "<attribute name='profile_disabled'><value>");
            if (isset($formfields["profile_disabled"]) &&
                $formfields["profile_disabled"] == "checked") {
                fwrite($fp, "1");
            }
            else {
                fwrite($fp, "0");
            }
            fwrite($fp, "</value></attribute>\n");
            fwrite($fp, "<attribute name='profile_disable_all'><value>");
            if (isset($formfields["profile_disable_all"]) &&
                $formfields["profile_disable_all"] == "checked") {
                fwrite($fp, "1");
            }
            else {
                fwrite($fp, "0");
            }
            fwrite($fp, "</value></attribute>\n");
            fwrite($fp, "<attribute name='profile_nodelete'><value>");
            if (isset($formfields["profile_nodelete"]) &&
                $formfields["profile_nodelete"] == "checked") {
                fwrite($fp, "1");
            }
            else {
                fwrite($fp, "0");
            }
            fwrite($fp, "</value></attribute>\n");
            fwrite($fp, "<attribute name='profile_nodelete_all'><value>");
            if (isset($formfields["profile_nodelete_all"]) &&
                $formfields["profile_nodelete_all"] == "checked") {
                fwrite($fp, "1");
            }
            else {
                fwrite($fp, "0");
            }
            fwrite($fp, "</value></attribute>\n");
            if (isset($formfields["examples_portals"])) {
                fwrite($fp, "<attribute name='examples_portals'><value>");
                fwrite($fp, $formfields["examples_portals"]);
                fwrite($fp, "</value></attribute>\n");
            }
        }
        fwrite($fp, "</profile>\n");
        fclose($fp);
        chmod($xmlname, 0666);
    }
    #
    # Call out to the backend.
    #
    $webtask    = WebTask::CreateAnonymous();
    $webtask_id = $webtask->task_id();
    $command    = "webmanage_profile -t $webtask_id ";

    if ($action == "edit") {
        $command .= " update " . $profile->uuid();
    }
    else {
        $command .= " create ";
        if (isset($copyuuid)) {
            $command .= "-c " . escapeshellarg($copyuuid);
        }
        elseif (isset($snapuuid)) {
            $command .= "-s " . escapeshellarg($snapuuid);
            if (isset($formfields["update_prepare"]) &&
                $formfields["update_prepare"]) {
                $command .= " -U ";
            }
            if (isset($snapnode_id)) {
                $command .= " -n " . escapeshellarg($snapnode_id);
            }
        }
    }
    $command .= " $xmlname";

    $retval = SUEXEC($this_user->uid(), $project->unix_gid(), $command,
                     SUEXEC_ACTION_IGNORE);
    unlink($xmlname);

    if ($retval) {
        if ($retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, "Internal Error; please try again later.");
        }
        else {
            $webtask->Refresh();
            if ($webtask->TaskValue("output")) {
                $parsed = simplexml_load_string($webtask->TaskValue("output"));
            }
            if (!$parsed) {
                SUEXECERROR(SUEXEC_ACTION_CONTINUE);
                SPITAJAX_ERROR(-1, "Internal Error; please try again later.");
            }
            else {
                foreach ($parsed->error as $error) {
                    $errors[(string)$error['name']] = (string)$error;
                }
                SPITAJAX_ERROR(2, $errors);
            }
        }
        $webtask->Delete();
        return;
    }
    #
    # Need the index to pass back through. But when its an edit operation,
    # we have to let the backend tell us it created a new version, since
    # we want to return to that.
    #
    if ($action == "edit") {
        $webtask->Refresh();
        if ($webtask->TaskValue("newProfile")) {
            $profile = Profile::Lookup($webtask->TaskValue("newProfile"));
        }
    }
    else {
        $profile = Profile::LookupByName($project, $formfields["profile_name"]);
    }
    if ($profile) {
        $uuid = $profile->uuid();
        $url  = "manage_profile.php?action=edit&uuid=$uuid";
        if ($action == "edit") {
            $url .= "&updated=" . time();
        }
        SPITAJAX_RESPONSE($url);
    }
    else {
        SPITAJAX_RESPONSE("user-dashboard.php#profiles");
    }
    $webtask->Delete();
}

#
# Duplicate Profile,
#
function Do_Duplicate()
{
    global $this_user;
    global $ajax_args;
    global $TB_PROJECT_CREATEEXPT;
    $errors = array();

    if (!isset($ajax_args["profile"])) {
	SPITAJAX_ERROR(1, "Missing profile");
	return;
    }
    $target = $ajax_args["profile"];

    if (! (IsValidUUID($target) || IsValidHash($target))) {
	SPITAJAX_ERROR(1, "Not a valid profile target");
	return;
    }
    $profile = Profile::Lookup($target);
    if (!$profile) {
	SPITAJAX_ERROR(1, "No such profile $target");
	return;
    }
    if (!isset($ajax_args["name"])) {
        $errors["name"] = "Missing profile name";
    }
    elseif (! TBcheck_dbslot($ajax_args["name"], "apt_profiles", "name",
                         TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
        $errors["name"] = TBFieldErrorString();
    }
    if (!isset($ajax_args["pid"])) {
	$errors["pid"] = "Missing profile pid";
    }
    elseif (! TBcheck_dbslot($ajax_args["pid"], "apt_profiles", "pid",
                         TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
        $errors["pid"] = TBFieldErrorString();
    }
    elseif (! ($project = Project::Lookup($ajax_args["pid"]))) {
        $errors["pid"] = "No such project";
    }
    elseif (! $project->AccessCheck($this_user, $TB_PROJECT_CREATEEXPT)) {
        $errors["pid"] = "Not enough permission";
    }
    if (count($errors)) {
	SPITAJAX_ERROR(2, $errors);
	return;
    }
    $name = escapeshellarg($ajax_args["name"]);
    $pid  = $ajax_args["pid"];

    #
    # Call out to the backend.
    #
    $webtask    = WebTask::CreateAnonymous();
    $webtask_id = $webtask->task_id();
    $command    = "webmanage_profile -t $webtask_id duplicate ";
    $command   .= $profile->uuid() . " $pid $name";

    $retval = SUEXEC($this_user->uid(), $project->unix_gid(), $command,
                     SUEXEC_ACTION_IGNORE);

    $webtask->Refresh();
    if ($retval) {
        if ($retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, "Internal Error; please try again later.");
        }
        else {
            if ($webtask->TaskValue("errors")) {
                SPITAJAX_ERROR(2, $webtask->TaskValue("errors"));
            }
            else {
                SUEXECERROR(SUEXEC_ACTION_CONTINUE);
                SPITAJAX_ERROR(-1, "Internal Error; please try again later.");
            }
        }
        $webtask->Delete();
        return;
    }
    $newuuid = $webtask->TaskValue("uuid");
    $webtask->Delete();
    SPITAJAX_RESPONSE($newuuid);
}

#
# Return clone status.
#
function Do_CloneStatus()
{
    global $this_user;
    global $ajax_args;

    $this_idx = $this_user->uid_idx();

    if (!isset($ajax_args["uuid"])) {
	SPITAJAX_ERROR(1, "Missing profile uuid");
	return;
    }
    $profile = Profile::Lookup($ajax_args["uuid"]);
    if (!$profile) {
	SPITAJAX_ERROR(1, "Clone operation failed, ".
                       "could not create disk image");
	return;
    }
    if ($this_idx != $profile->creator_idx() && !ISADMIN()) {
	SPITAJAX_ERROR(1, "Not enough permission");
	return;
    }
    $webtask = $profile->WebTask();
    if (!$webtask) {
	SPITAJAX_ERROR(1, "No status descriptor found");
	return;
    }
    if (!$webtask->TaskValue("cloning_instance")) {
	SPITAJAX_ERROR(1, "The cloned experiment is gone");
	return;
    }
    $instance = Instance::Lookup($webtask->TaskValue("cloning_instance"));
    if (!$instance) {
	SPITAJAX_ERROR(1, "The cloned experiment is not here anymore");
	return 1;
    }
    $instance_webtask = $instance->WebTask();
    if (!$instance_webtask) {
	SPITAJAX_ERROR(1, "No status descriptor found for instance");
	return;
    }
    $taskdata = $instance_webtask->TaskData();
    $blob = array();

    #
    # Size is in KB to avoid bigint problems. But kill the KB.
    # 
    if (isset($taskdata["image_size"])) {
	if (preg_match("/^(\d+)KB$/", $taskdata["image_size"], $matches)) {
	    $taskdata["image_size"] = $matches[1]; 
	}
	$blob["image_size"] = $taskdata["image_size"];
    }
    else {
	$blob["image_size"] = 0;
    }
    $blob["image_status"] = $taskdata["image_status"];
    
    #
    # Lets put the node status in too. The backend has helpfully told us
    # the aggregate and node to track down the status.
    #
    if (isset($taskdata["aggregate_urn"]) && isset($taskdata["client_id"])) {
        $sliver = InstanceSliver::Lookup($instance, $taskdata["aggregate_urn"]);
        if ($sliver) {
            foreach ($sliver->StatusArray() as $status) {
                if (isset($status["sliver_data"]) &&
                    $status["client_id"] == $taskdata["client_id"]) {
                    $blob["node_status"] = $status["sliver_details"]["rawstate"];
                    break;
                }
            }
        }
    }
    if ($instance_webtask->exited()) {
	# Success, but not sure what to report. Come back to this later.
	$blob["exited"]   = $instance_webtask->exited();
	$blob["exitcode"] = $instance_webtask->exitcode();
        if (isset($taskdata["image_name"])) {
            $blob["image_name"] = $taskdata["image_name"];
        }
    }
    SPITAJAX_RESPONSE($blob);
}

#
# Delete a profile. The backend tells us if its allowed, and we
# report back to user. If successful. tell the client where to
# redirect to (previous profile).
#
function Do_DeleteProfile()
{
    global $this_user;
    global $ajax_args;
    global $suexec_output, $suexec_output_array;
    
    $this_idx = $this_user->uid_idx();
    $this_uid = $this_user->uid();

    if (!isset($ajax_args["uuid"])) {
	SPITAJAX_ERROR(1, "Missing profile uuid");
	return;
    }
    $profile = Profile::Lookup($ajax_args["uuid"]);
    if (!$profile) {
	SPITAJAX_ERROR(1, "Unknown profile uuid");
	return;
    }
    if (!$profile->CanDelete($this_user)) {
	SPITAJAX_ERROR(1, "Not enough permission");
	return;
    }
    $opt = "";
    # Delete all profiles.
    if (isset($ajax_args["all"]) && $ajax_args["all"]) {
        $opt = "-a ";
    }
    # Force mode; user has seen the warnings
    if (isset($ajax_args["force"]) && $ajax_args["force"]) {
        $opt .= "-f ";
        # But user says to leave the images behind.
        if (isset($ajax_args["keepimages"]) && $ajax_args["keepimages"]) {
            $opt .= "-k ";
        }
    }
    # Impotent mode for testing
    if (isset($ajax_args["impotent"]) && $ajax_args["impotent"]) {
        $opt .= "-n ";
    }
    $webtask = WebTask::CreateAnonymous();
    if (!$webtask) {
	SPITAJAX_ERROR(-1, "Internal webtask Error");
	return;
    }
    $retval = SUEXEC($this_uid, $profile->pid(),
		     "webmanage_profile -t " . $webtask->task_id() . " " .
                     "delete $opt " . $profile->uuid(),
		     SUEXEC_ACTION_IGNORE);

    if ($retval != 0) {
        $webtask->Refresh();
        $code = 1;
        if ($retval < 0) {
            $error  = "Internal Error; please try again later\n\n";
            $error .= $webtask->TaskValue("output");
            $code   = -1;
	    SUEXECERROR(SUEXEC_ACTION_CONTINUE);
        }
        elseif ($webtask->exitcode() == 2) {
            $blob = array();
            
            foreach ($webtask->TaskValue("images") as $urn => $plist) {
                $profilelist = array();
                
                foreach ($plist as $uuid) {
                    $tmp = Profile::Lookup($uuid);
                    if ($tmp) {
                        $plob = array();
                        $plob["uuid"]    = $uuid;
                        $plob["name"]    = $tmp->name();
                        $plob["version"] = $tmp->version();
                        $plob["creator"] = $tmp->creator();
                        $plob["created"] = $tmp->created();
                        $plob["project"] = $tmp->pid();
                        $profilelist[$uuid] = $plob;
                    }
                }
                $blob[$urn] = $profilelist;
            }
            $error = $blob;
            $code  = 2;
        }
        else {
            $error = $webtask->TaskValue("output");
            $code  = 1;
        }
        $webtask->Delete();
	SPITAJAX_ERROR($code, $error);
	return;
    }
    $webtask->Delete();
    # Lookup next most recent version
    $profile = Profile::Lookup($profile->profileid());
    if (!$profile) {
	#
	# Go back to profiles page instead. Happens when last version
	# is deleted. 
	#
	SPITAJAX_RESPONSE("user-dashboard.php#profiles");
	return;
    }
    $uuid = $profile->uuid();
    SPITAJAX_RESPONSE("manage_profile.php?uuid=$uuid&action=edit");
}

#
# Publish a profile. The backend tells us if its allowed, and we
# report back to user. If successful. tell the client where to
# redirect to (previous profile).
#
function Do_PublishProfile()
{
    global $this_user;
    global $ajax_args;
    global $suexec_output, $suexec_output_array;
    
    $this_idx = $this_user->uid_idx();
    $this_uid = $this_user->uid();

    if (!isset($ajax_args["uuid"])) {
	SPITAJAX_ERROR(1, "Missing profile uuid");
	return;
    }
    $profile = Profile::Lookup($ajax_args["uuid"]);
    if (!$profile) {
	SPITAJAX_ERROR(1, "Unknown profile uuid");
	return;
    }
    if ($this_idx != $profile->creator_idx() && !ISADMIN()) {
	SPITAJAX_ERROR(1, "Not enough permission");
	return;
    }
    if ($profile->published()) {
	SPITAJAX_ERROR(1, "Not allowed to publish a published version");
	return;
    }
    if (!$profile->IsHead()) {
	SPITAJAX_ERROR(1, "Not allowed to publish non-head version");
	return;
    }
    $webtask = WebTask::CreateAnonymous();
    if (!$webtask) {
	SPITAJAX_ERROR(-1, "Internal webtask Error");
	return;
    }
    $retval = SUEXEC($this_uid, $profile->pid(),
		     "webmanage_profile -t " . $webtask->task_id() . " " .
                     "publish " . $profile->uuid(),
		     SUEXEC_ACTION_IGNORE);
    if ($retval != 0) {
        $webtask->Refresh();
        if ($retval < 0) {
            $error  = "Internal Error; please try again later\n\n";
            $error .= $webtask->TaskValue("output");
	    SUEXECERROR(SUEXEC_ACTION_CONTINUE);
        }
        else {
            $error = $webtask->TaskValue("output");
        }
        $webtask->Delete();
	SPITAJAX_ERROR(1, $error);
	return;
    }
    $webtask->Delete();
    $profile->Refresh();
    SPITAJAX_RESPONSE(array("published" => $profile->published()));
}

#
# Run a geni-lib script, returning the XML.
#
function Do_CheckScript()
{
    global $this_user;
    global $ajax_args;

    $this_idx      = $this_user->uid_idx();
    $this_uid      = $this_user->uid();
    $pid           = null;
    $profile       = null;
    $warningsfatal = false;
    $usenewgenilib = false;
    $refspec       = null;
    $getparams     = false;
    $blob          = null;
    $project       = null;
    $updaterepo    = false;

    if (isset($ajax_args["profile_uuid"])) {
        $profile = Profile::Lookup($ajax_args["profile_uuid"]);
        if (!$profile) {
            SPITAJAX_ERROR(1, "Unknown profile uuid");
            return;
        }
    }
    if (!isset($ajax_args["script"])) {
	SPITAJAX_ERROR(1, "Missing script");
	return;
    }
    $script = $ajax_args["script"];

    // XXX We might get this when creating a new profile. 
    if (isset($ajax_args["pid"]) && $ajax_args["pid"] != "") {
        $project = Project::LookupByPid($ajax_args["pid"]);
        if (!$project) {
            SPITAJAX_ERROR(1, "No such project");
            return;
        }
    }
    
    if (preg_match("/^import/m", $script)) {
        if (isset($ajax_args["warningsfatal"]) && $ajax_args["warningsfatal"]){
            $warningsfatal = true;
        }
        if (isset($ajax_args["getparams"]) && $ajax_args["getparams"]) {
            $getparams = true;
        }
        if ($profile) {
            // This is temporary
            $usenewgenilib = $profile->UseNewGeniLib($this_user);

            if ($profile->repourl()) {
                if (isset($ajax_args["refspec"])) {
                    if (!preg_match('/^[-\w\/]+$/', $ajax_args["refspec"])) {
                        SPITAJAX_ERROR(1, "Invalid refspec");
                        return;
                    }
                    $refspec = $ajax_args["refspec"];
                }
                // Check if user allowed to update the repo.
                if (isset($ajax_args["updaterepo"])) {
                    if ($this_idx != $profile->creator_idx() && !ISADMIN()) {
                        SPITAJAX_ERROR(1, "Not enough permission to ".
                                       "update repo");
                        return;
                    }
                    $updaterepo = true;
                }
            }
        }
        elseif ($project) {
            if (0) {
                if (FeatureEnabled("NewPParams", null,
                                   $project->DefaultGroup(), null)) {
                    $usenewgenilib = true;
                }
            }
        }
    }
    elseif (! preg_match("/^source tb_compat/m", $script)) {
	SPITAJAX_ERROR(1, "Unknown script type");
	return;
    }
    #
    # And run the script.
    #
    if (CheckScript($profile, $script, $pid, 
                    $warningsfatal, $usenewgenilib,
                    $refspec, $getparams, null, $blob) != 0) {
        # Error already spit.
        return;
    }
    if (!$updaterepo) {
        SPITAJAX_RESPONSE($blob);
        return;
    }
    #
    # We use this routine from the manage/instantiate/show pages,
    # but we do not want to update the master unless it the profile
    # creator and it is the manage profile page.
    #
    if (UpdateMaster($profile, $script, $blob["rspec"]) == 0) {
        SPITAJAX_RESPONSE($blob);
        return;
    }
    # Error already spit by UpdateMaster().
}

#
# Run geni-lib script, with given parameters, to generate an rspec.
# This is called from instantiate.ajax. Looks there to see $profile magic.
#
function Do_BindParameters()
{
    global $this_user;
    global $ajax_args;
    global $DEFAULT_AGGREGATE;
    global $suexec_output, $suexec_output_array;
    $runopts = "";

    # Allow for form precheck only. So JS code knows it will be fast. 
    $checkonly = isset($ajax_args["checkonly"]) && $ajax_args["checkonly"];

    if (!isset($ajax_args["profile"])) {
	SPITAJAX_ERROR(1, "Missing profile");
	return;
    }
    $target = $ajax_args["profile"];

    if (! (IsValidUUID($target) || IsValidHash($target))) {
	SPITAJAX_ERROR(1, "Not a valid profile target");
	return;
    }
    $profile = Profile::Lookup($target);
    if (!$profile) {
	SPITAJAX_ERROR(1, "No such profile $target");
	return;
    }
    # Allow for new code path.
    $usenewgenilib = false;
    
    if (!isset($ajax_args["formfields"])) {
	SPITAJAX_ERROR(1, "Missing formfields");
	return;
    }
    $formfields = $ajax_args["formfields"];

    $this_idx = $this_user->uid_idx();
    $this_uid = $this_user->uid();
    
    if (! ($profile->CanInstantiate($this_user) || IsValidHash($target))) {
	SPITAJAX_ERROR(1, "Not enough permission to instantiate profile");
	return;
    }

    #
    # If this is a repo-based profile, look in the form for the script
    # and the paramdefs.
    #
    if ($profile->repourl() &&
        isset($formfields["script"]) && $formfields["script"] != "" &&
        isset($formfields["paramdefs"]) && $formfields["paramdefs"] != "") {
        $script    = $formfields["script"];
        $paramdefs = $formfields["paramdefs"];

        # Repo argument to rungenilib;
        $runopts .= " -r " . $profile->reponame();
        if (isset($ajax_args["refspec"])) {
            if (!preg_match('/^[-\w\/]+$/', $ajax_args["refspec"])) {
                SPITAJAX_ERROR(1, "Invalid refspec");
                return;
            }
            $runopts .= " -h " . escapeshellarg($ajax_args["refspec"]);
        }
    }
    else {
        $script    = $profile->script();
        $paramdefs = $profile->paramdefs();
        # Repo argument to rungenilib;
        if ($profile->repourl()) {
            $runopts  .= " -r " . $profile->reponame();
            if (isset($ajax_args["refspec"])) {
                if (!preg_match('/^[-\w\/]+$/', $ajax_args["refspec"])) {
                    SPITAJAX_ERROR(1, "Invalid refspec");
                    return;
                }
                $runopts .= " -h " . escapeshellarg($ajax_args["refspec"]);
            }
        }
    }
    unset($formfields["script"]);
    unset($formfields["paramdefs"]);

    if (Do_CheckForm($formfields, $paramdefs, $rval)) {
        # Special return value for JS code.
        SPITAJAX_ERROR(2, $rval);
        return;
    }
    if ($checkonly) {
	SPITAJAX_RESPONSE(0);
	return;
    }

    $warningsfatal = "";
    if (isset($ajax_args["warningsfatal"]) && $ajax_args["warningsfatal"]) {
	$warningsfatal = "-W";
    }

    $infname   = tempnam("/tmp", "genilibin");
    $parmfname = tempnam("/tmp", "genilibparm");
    $outfname  = tempnam("/tmp", "genilibout");

    $fp = fopen($infname, "w");
    fwrite($fp, $script);
    fclose($fp);
    $fp = fopen($parmfname, "w");
    fwrite($fp, json_encode($formfields));
    fwrite($fp, "\n");
    fclose($fp);
    chmod($infname, 0666);
    chmod($parmfname, 0666);
    chmod($outfname, 0666);

    #
    # Invoke the backend.
    #
    $retval = SUEXEC($this_uid, "nobody",
		     "webrungenilib $warningsfatal -b $parmfname $runopts ".
                     ($usenewgenilib ? " -N " : "") .
                     "  -o $outfname $infname",
		     SUEXEC_ACTION_IGNORE);
    
    if ($retval != 0) {
	if ($retval < 0) {
	    SUEXECERROR(SUEXEC_ACTION_CONTINUE);
	    SPITAJAX_ERROR(-1, "Internal error, we have been notified");
	}
	else {
            # This might be a json structure, the JS code looks for it. 
	    $errors = file_get_contents($outfname);
	    SPITAJAX_ERROR(1, $errors);
	}
	unlink($infname);
	unlink($parmfname);
	unlink($outfname);
	return;
    }
    $rspec = file_get_contents($outfname);
    $blob = array();
    $blob["rspec"] = $rspec;

    # Guest users not allowed to choose aggregate.
    if (isset($this_user) && ($ISCLOUD || ISADMIN() || STUDLY())) {
        # Temporary until constraint system in place.
	$best = $profile->BestAggregate($rspec);
	if (!$best) {
	    $best = $DEFAULT_AGGREGATE;
	}
	$blob["amdefault"] = $best;
    }
    unlink($infname);
    unlink($parmfname);
    unlink($outfname);
    SPITAJAX_RESPONSE($blob);
}

#
# Check the form arguments.
#
function CheckBindingType($value, $type, &$error)
{
    $rval = 0;

    if ($type == "boolean") {
        if ($value != true && $value != false) {
            $error = "Invalid value; must be a boolean";
            $rval  = 1;
        }
    }
    elseif ($type == "integer" || $type == "size") {
        if (!is_numeric($value)) {
            $error = "Invalid value; must be an integer";
            $rval  = 1;
        }
    }
    elseif ($type == "bandwidth" || $type == "latency" || $type == "lossrate") {
        if (!is_numeric($value)) {
            $error = "Invalid value; must be an integer/float";
            $rval  = 1;
        }
    }
    elseif ($type == "string" || $type == "image" || $type == "aggregate" ||
            $type == "nodetype" ||
            $type == "fixedendpoint" || $type == "basestation") {
        if (!TBcheck_dbslot($value, "default", "html_fulltext",
                            TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
            $error = "Invalid value: " . TBFieldErrorString();
            $rval  = 1;
        }
    }
    else {
        $error = "Invalid value; do not know how to handle $type";
        $rval  = 1;
    }
    return $rval;
}

function CheckBinding($definition, &$binding, &$errors)
{
    $type    = $definition["type"];
    $mvalue  = $definition["multiValue"];
    $error   = null;
    $count   = count($errors);

    #
    # Most of these make no sense to be multivalue.
    #
    if ($mvalue) {
        foreach ($binding["value"] as &$B) {
            if (CheckBindingType($B["value"], $type, $error)) {
                $errors["$count"]  = array("message" => $error);
                $B["errors"] = array($count);
                $count++;
            }
        }
    }
    else {
        if (CheckBindingType($binding["value"], $type, $error)) {
            $errors["$count"]  = array("message" => $error);
            $binding["errors"] = array($count);
            $count++;
        }
    }
}

function Do_CheckForm($formfields, $paramdefs, &$rval)
{
    global $this_user;
    global $ajax_args;

    $count  = 0;
    $errors = array();
    $fields = json_decode($paramdefs, true);

    foreach ($formfields["bindings"] as $name => &$binding) {
        # Let unknown stuff pass through. Maybe not a good idea?
        if (!array_key_exists($name, $fields)) {
            continue;
        }
        $def     = $fields[$name];
        $type    = $def["type"];
        $mvalue  = $def["multiValue"];
        $error   = null;

        if ($type == "pubkey") {
            $errors["$count"]  = array("message" => "PUBKEY deprecated");
            $binding["errors"] = array($count);
            $count++;
        }
        elseif ($type == "struct") {
            if ($mvalue) {
                // Array of dicts.
                foreach ($binding["value"] as &$B) {
                    foreach ($B["value"] as $paramname => &$BB) {
                        $definition = $def["parameters"][$paramname];
                    
                        CheckBinding($definition, $BB, $errors);
                    }
                }
            }
            else {
                // A single dict.
                foreach ($binding["value"] as $paramname => &$B) {
                    $definition = $def["parameters"][$paramname];
                    
                    CheckBinding($definition, $B, $errors);
                }
            }
        }
        else {
            CheckBinding($def, $binding, $errors);
        }
    }
    if (count($errors)) {
        $formfields["errors"] = $errors;
        $rval = $formfields;
	return -1;
    }
    return 0;
}

#
# We no longer use this, if we have to bring it back, it has to be
# done without session variables.
#
function GenGenilibKey()
{
    $keyname  = tempnam("/tmp", "genilibkey");
    $pubname  = tempnam("/tmp", "genilibpub");

    chmod($keyname, 0666);
    chmod($pubname, 0666);

    #
    # First generate the private key.
    #
    $retval = myexec("/usr/bin/openssl genrsa -rand /dev/urandom ".
                     "   -out $keyname 1024");
    if ($retval) {
        unlink($keyname);
        unlink($pubname);
	return -1;
    }
    #
    # Now extract the public portion.
    #
    $retval = myexec("/usr/bin/openssl rsa -in $keyname -pubout -out $pubname");
    if ($retval) {
        unlink($keyname);
        unlink($pubname);
	return -1;
    }
    $_SESSION["privkey"] = file_get_contents($keyname);
    $_SESSION["pubkey"]  = file_get_contents($pubname);
    session_commit();
    unlink($keyname);
    unlink($pubname);
    return 0;
}
 
#
# Convert classic experiment to geni-lib script.
#
function Do_ConvertClassic()
{
    global $this_user;
    global $ajax_args, $TB_EXPT_MODIFY;
    
    $this_idx = $this_user->uid_idx();
    $this_uid = $this_user->uid();

    if (!isset($ajax_args["uuid"])) {
	SPITAJAX_ERROR(1, "Missing experiment uuid");
	return;
    }
    $experiment = Experiment::LookupByUUID($ajax_args["uuid"]);
    if (!$experiment) {
	SPITAJAX_ERROR(1, "No such experiment.");
	return;
    }
    if (!$experiment->AccessCheck($this_user, $TB_EXPT_MODIFY)) {
	SPITAJAX_ERROR(1, "Not enough permission to create a profile from ".
                       "this classic emulab experiment");
        return;
    }
    $command = "webns2genilib";
    #
    # We want to parse in the context of the project, so we can do
    # project based checks. 
    #
    if (isset($ajax_args["pid"]) && $ajax_args["pid"] != "") {
        if (! TBvalid_pid($ajax_args["pid"])) {
            SPITAJAX_ERROR(1, "Bad project name");
            return;
        }
        $command .= " -p " . $ajax_args["pid"];
    }
    $outfname = tempnam("/tmp", "genilibout");
    chmod($outfname, 0666);

    #
    # Invoke the backend.
    #
    $retval = SUEXEC($this_uid, "nobody", "$command -o $outfname ".
                     "-e " . $experiment->pid() . "," . $experiment->eid(),
		     SUEXEC_ACTION_IGNORE);
    
    if ($retval != 0) {
	if ($retval < 0) {
	    SUEXECERROR(SUEXEC_ACTION_CONTINUE);
	    SPITAJAX_ERROR(-1, "Internal error, we have been notified");
	}
	else {
	    $errors = file_get_contents($outfname);
	    SPITAJAX_ERROR(1, $errors);
	}
    }
    else {
	$script = file_get_contents($outfname);
	SPITAJAX_RESPONSE(array("script"  => $script));
    }
    unlink($outfname);
}

#
# Convert rspec to geni-lib script.
#
function Do_ConvertRspec()
{
    global $this_user, $suexec_output;
    global $ajax_args;
    
    $this_idx = $this_user->uid_idx();
    $this_uid = $this_user->uid();

    if (!isset($ajax_args["rspec"])) {
	SPITAJAX_ERROR(1, "Missing rspec");
	return;
    }
    $infname  = tempnam("/tmp", "convertin");
    $outfname = tempnam("/tmp", "convertout");
    $rspecfname = tempnam("/tmp", "convertoutrspec");
    
    $fp = fopen($infname, "w");
    fwrite($fp, $ajax_args["rspec"]);
    fclose($fp);
    chmod($infname, 0666);
    chmod($outfname, 0666);
    chmod($rspecfname, 0666);

    #
    # Invoke the backend.
    #
    $retval = SUEXEC($this_uid, "nobody",
                     "webrspec2genilib -r -s $rspecfname -o $outfname $infname",
		     SUEXEC_ACTION_IGNORE);
    
    if ($retval != 0) {
        #
        # All errors go to the user for now.
        #
        SPITAJAX_ERROR($retval, $suexec_output);
    }
    else {
	$script = file_get_contents($outfname);
	SPITAJAX_RESPONSE(array("script"  => $script,
                                "rspec"   => file_get_contents($rspecfname)));
    }
    unlink($infname);
    unlink($outfname);
    unlink($rspecfname);
}

#
# Do an RTE check to see if the user changed a portal converted profile
# in such a way that we cannot convert back from the rspec exactly.
#
function Do_RTECheck()
{
    global $this_user, $suexec_output;
    global $ajax_args;
    
    $this_idx = $this_user->uid_idx();
    $this_uid = $this_user->uid();

    if (!isset($ajax_args["script"])) {
	SPITAJAX_ERROR(1, "Missing script");
	return;
    }
    $infname  = tempnam("/tmp", "rtecheckin");
    
    $fp = fopen($infname, "w");
    fwrite($fp, $ajax_args["script"]);
    fclose($fp);
    chmod($infname, 0666);

    #
    # Invoke the backend.
    #
    $retval = SUEXEC($this_uid, "nobody", "webrtecheck $infname",
		     SUEXEC_ACTION_IGNORE);
    
    if ($retval != 0) {
        if ($retval < 0) {
	    SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, $suexec_output);
        }
        else {
	    #SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(1, $suexec_output);
        }
        unlink($infname);
        return;
    }
    unlink($infname);
    SPITAJAX_RESPONSE(0);
}

#
# Clone a repository and send back the script or rspec.
#
function Do_GetRepository()
{
    global $this_user;
    global $ajax_args;
    $project  = null;
    $nameopt  = "";
    $checkout = (ISADMIN() ? "-c" : "");

    $this_idx = $this_user->uid_idx();
    $this_uid = $this_user->uid();

    if (!isset($ajax_args["repourl"])) {
	SPITAJAX_ERROR(1, "Missing repository URL");
	return;
    }
    $repourl = $ajax_args["repourl"];
    if (!TBvalid_URL($repourl)) {
	SPITAJAX_ERROR(2, "Invalid repository URL");
	return;
    }
    $repourl = escapeshellarg($repourl);

    // XXX We might get this when creating a new profile. 
    if (isset($ajax_args["pid"]) && $ajax_args["pid"] != "") {
        $project = Project::LookupByPid($ajax_args["pid"]);
        if (!$project) {
            SPITAJAX_ERROR(1, "No such project");
            return;
        }
    }

    # Pass though profile name to use instead of profile.py.
    if (isset($ajax_args["profile_name"])) {
        if (!TBcheck_dbslot($ajax_args["profile_name"],
                            "apt_profiles", "name",
                            TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
            SPITAJAX_ERROR(2, "Invalid profile name: " . TBFieldErrorString());
            return;
        }
        $nameopt = "-S " . escapeshellarg($ajax_args["profile_name"]);
    }

    $webtask = WebTask::CreateAnonymous();
    if (!$webtask) {
	SPITAJAX_ERROR(-1, "Internal webtask Error");
	return;
    }

    #
    # First an existence/access check.
    #
    $retval = SUEXEC($this_uid, "tbadmin",
		     "webmanage_gitrepo -t " . $webtask->task_id() . " " .
                     "  check  $repourl",
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();
    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, "Internal error checking repository");
        }
        else {
            $error = $webtask->TaskValue("output");
            SPITAJAX_ERROR(1, $error);
        }
        $webtask->Delete();
	return;
    }
    $webtask->Reset();
    $outfname = tempnam("/tmp", "repofile");
    chmod($outfname, 0666);
    
    $retval = SUEXEC($this_uid, "tbadmin",
		     "webmanage_gitrepo -t " . $webtask->task_id() . " " .
                     "  clone $nameopt $checkout -o $outfname $repourl",
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();
    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, "Internal error checking repository");
        }
        else {
            $error = $webtask->TaskValue("output");
            SPITAJAX_ERROR(1, $error);
        }
        $webtask->Delete();
        unlink($outfname);
	return;
    }
    $reponame      = $webtask->TaskValue("name");
    $log           = $webtask->TaskValue("log");
    $hash          = $webtask->TaskValue("hash");
    $webtask->delete();
    $script        = file_get_contents($outfname);
    unlink($outfname);
    $warningsfatal = true;
    $usenewgenilib = null;
    $refspec       = null;
    $getparams     = false;
    $blob          = null;
    if ($project) {
        if (0) {
            if (FeatureEnabled("NewPParams", null,
                               $project->DefaultGroup(), null)) {
                $usenewgenilib = true;
            }
        }
    }
    if (CheckScript(null, $script, $project, 
                    $warningsfatal, $usenewgenilib,
                    $refspec, $getparams, $reponame, $blob)) {
        # Try not to leave repos behind, user might abort. 
        SUEXEC($this_uid, "tbadmin",
               "webmanage_gitrepo remove -n $reponame",
               SUEXEC_ACTION_CONTINUE);
        # Error already spit.
        return;
    }
    # Try not to leave repos behind, user might abort. 
    SUEXEC($this_uid, "tbadmin",
           "webmanage_gitrepo remove -n $reponame",
           SUEXEC_ACTION_CONTINUE);
    $result = array("script"  => $script,
                    "rspec"   => $blob["rspec"],
                    "log"     => $log,
                    "hash"    => $hash);
    SPITAJAX_RESPONSE($result);
}

#
# Update a repository and send back the script or rspec.
#
function Do_UpdateRepository()
{
    global $this_user;
    global $ajax_args;
    
    $this_idx = $this_user->uid_idx();
    $this_uid = $this_user->uid();

    if (!isset($ajax_args["uuid"])) {
	SPITAJAX_ERROR(1, "Missing profile uuid");
	return;
    }
    $profile = Profile::Lookup($ajax_args["uuid"]);
    if (!$profile) {
	SPITAJAX_ERROR(1, "Unknown profile uuid");
	return;
    }
    if ($this_idx != $profile->creator_idx() && !ISADMIN()) {
	SPITAJAX_ERROR(1, "Not enough permission");
	return;
    }
    $webtask = WebTask::CreateAnonymous();
    if (!$webtask) {
	SPITAJAX_ERROR(-1, "Internal webtask Error");
	return;
    }
    $outfname = tempnam("/tmp", "repofile");
    chmod($outfname, 0666);
    
    $retval = SUEXEC($this_uid, "tbadmin",
		     "webmanage_gitrepo -t " . $webtask->task_id() . " " .
                     "  update -o $outfname -p " . $profile->uuid(),
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();
    
    if ($retval != 0) {
        if ($retval < 0) {
            $error = $webtask->TaskValue("output");
	    SUEXECERROR(SUEXEC_ACTION_CONTINUE);
        }
        else {
            $error = $webtask->TaskValue("output");
        }
        $webtask->Delete();
        unlink($outfname);
	SPITAJAX_ERROR(1, $error);
	return;
    }
    $blob = array("source"  => file_get_contents($outfname),
                  "log"     => $webtask->TaskValue("log"),
                  "hash"    => $webtask->TaskValue("hash"));
    $webtask->Delete();
    unlink($outfname);

    #
    # If the source is an rspec, update the profile now.
    #
    if (! preg_match("/^import/m", $blob["source"])) {
        if (UpdateMaster($profile, null, $blob["source"])) {
            return;
        }
    }
    elseif ($profile->script() == $blob["source"]) {
        # The repo changed for some other reason, we want to record
        # the repo hash/branch in the profile metadata.
        if (UpdateMaster($profile, null, null)) {
            return;
        }
    }
    SPITAJAX_RESPONSE($blob);
}

#
# Save new master into the profile (no profile versioning on repos).
#
function UpdateMaster($profile, $script, $rspec)
{
    global $this_user;
    global $ajax_args;
    
    $this_idx = $this_user->uid_idx();
    $this_uid = $this_user->uid();

    $webtask = WebTask::CreateAnonymous();
    if (!$webtask) {
	SPITAJAX_ERROR(-1, "Internal webtask Error");
	return -1;
    }
    $fname = tempnam("/tmp", "updateprofile");
    $fp = fopen($fname, "w");
    fwrite($fp, "<profile>\n");
    fwrite($fp, "<attribute name='profile_pid'>");
    fwrite($fp, "  <value>" . $profile->pid() . "</value>");
    fwrite($fp, "</attribute>\n");
    fwrite($fp, "<attribute name='profile_name'>");
    fwrite($fp, "  <value>" .
	   htmlspecialchars($profile->name()) . "</value>");
    fwrite($fp, "</attribute>\n");
    if ($rspec) {
        fwrite($fp, "<attribute name='rspec'>");
        fwrite($fp, "  <value>" . htmlspecialchars($rspec) . "</value>");
        fwrite($fp, "</attribute>\n");
    }
    if ($script) {
	fwrite($fp, "<attribute name='script'>");
	fwrite($fp, "  <value>" . htmlspecialchars($script) . "</value>");
	fwrite($fp, "</attribute>\n");
    }
    fwrite($fp, "</profile>\n");
    fclose($fp);
    chmod($fname, 0666);
    
    $retval = SUEXEC($this_uid, $profile->pid(),
		     "webmanage_profile -t " . $webtask->task_id() . " " .
                     "update " . $profile->uuid() . " $fname",
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();

    if ($retval != 0) {
        if ($retval < 0) {
            $error = $webtask->TaskValue("output");
	    SUEXECERROR(SUEXEC_ACTION_CONTINUE);
        }
        else {
            $error = $webtask->TaskValue("output");
        }
        $webtask->Delete();
        unlink($fname);
	SPITAJAX_ERROR(1, $error);
	return -1;
    }
    $webtask->Delete();
    unlink($fname);
    return 0;
}

#
# Get the repo hash
#
function Do_GetRepoHash()
{
    global $this_user;
    global $ajax_args;

    $this_idx = $this_user->uid_idx();
    $this_uid = $this_user->uid();

    if (!isset($ajax_args["uuid"])) {
	SPITAJAX_ERROR(1, "Missing profile uuid");
	return;
    }
    $profile = Profile::Lookup($ajax_args["uuid"]);
    if (!$profile) {
	SPITAJAX_ERROR(1, "Unknown profile uuid");
	return;
    }
    if (!$profile->repourl()) {
	SPITAJAX_ERROR(1, "Not a repo-based profile");
	return;
    }
    if ($this_idx != $profile->creator_idx() && !ISADMIN()) {
	SPITAJAX_ERROR(1, "Not enough permission");
	return;
    }
    SPITAJAX_RESPONSE($profile->repohash());
}

#
# Return info about a profile.
#
function Do_GetProfile()
{
    global $this_user;
    global $ajax_args;
    
    $this_idx = $this_user->uid_idx();

    if (!isset($ajax_args["uuid"])) {
	SPITAJAX_ERROR(1, "Missing profile uuid");
	return;
    }
    $profile = Profile::Lookup($ajax_args["uuid"]);
    if (!$profile) {
	SPITAJAX_ERROR(1, "Unknown profile uuid");
	return;
    }
    if (!ISADMIN() &&
        !ISFOREIGN_ADMIN() &&
	!$profile->CanView($this_user)) {
	SPITAJAX_ERROR(1, "Not enough permission");
	return;
    }
    SPITAJAX_RESPONSE(array('rspec' => $profile->rspec(),
			    'name'  => $profile->name()));
}

#
# Admin search function.
#
function Do_SearchProfiles()
{
    global $this_user;
    global $ajax_args;

    if (!ISADMIN()) {
	SPITAJAX_ERROR(-1, "Not enough permission");
	return;
    }
    $results = array();

    if (!isset($ajax_args["text"])) {
	SPITAJAX_ERROR(-1, "Missing text to search for");
	return -1;
    }
    $text = $ajax_args["text"];
    if (!preg_match("/^[\w\s]*$/", $text)) {
	SPITAJAX_ERROR(-1, "Illegal text to search for");
	return -1;
    }
    $safe_text = addslashes("%${text}%");
    
    $query_result
        = DBQueryFatal("select p.*,v.*,DATE(v.created) as created ".
                       "   from apt_profiles as p ".
                       "left join apt_profile_versions as v on ".
                       "     v.profileid=p.profileid and ".
                       "     v.version=p.version ".
                       "where (v.creator like '$safe_text' or ".
                       "       p.pid like '$safe_text' or ".
                       "       v.rspec like ".
                       "        '%<description%>$safe_text</description>%' or ".
                       "       p.name like '$safe_text') ".
                       "order by v.creator");

    while ($row = mysql_fetch_array($query_result)) {
        $blob = array();

        $blob["profileid"] = $row["profileid"];
        $blob["uuid"]      = $row["uuid"];
        $blob["version"]   = $row["version"];
        $blob["name"]      = $row["name"];
        $blob["pid"]       = $row["pid"];
        $blob["desc"]      = CleanString($row["description"]);
        $blob["created"]   = DateStringGMT($row["created"]);
        $blob["public"]    = $row["public"];
        $blob["listed"]    = $row["listed"] ? "Yes" : "No";
        $blob["shared"]    = $row["shared"];
        $blob["creator"]   = $row["creator"];

        if ($public)
            $privacy = "Public";
        elseif ($shared)
            $privacy = "Site";
        else
            $privacy = "Project";
        $blob["privacy"] = $privacy;

        $parsed_xml = simplexml_load_string($row["rspec"]);
        if ($parsed_xml &&
            $parsed_xml->rspec_tour && $parsed_xml->rspec_tour->description) {
            $desc = $parsed_xml->rspec_tour->description;
            $blob["desc"] = CleanString($desc);
        }
        #
        # Convenience.
        #
        $uuid     = $row["uuid"];
        $name     = $row["name"];
        $pid      = $row["pid"];
        $pid_idx  = $row["pid_idx"];
        $creator  = $row["creator"];

        $blob["profile_link"]
            = "<a href='manage_profile.php?action=edit&uuid=$uuid' ".
            "target='_blank'>$name</a>";
        $blob["creator_link"]
            = "<a href='user-dashboard.php?user=$creator' ".
            "target='_blank'>$creator</a>";
        $blob["project_link"]
            = "<a href='show-project.php?pid=$pid_idx' ".
            "target='_blank'>$pid</a>";
                              
        $results[] = $blob;
    }
    SPITAJAX_RESPONSE($results);
    
}

# Local Variables:
# mode:php
# End:
?>
