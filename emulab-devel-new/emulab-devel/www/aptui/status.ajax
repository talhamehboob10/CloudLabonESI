<?php
#
# Copyright (c) 2000-2021 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
chdir("..");
include_once("webtask.php");
include_once("geni_defs.php");
chdir("apt");
include_once("profile_defs.php");
include_once("instance_defs.php");

# Set these globals below.
$instance = null;
$creator  = null;

#
# Locate the objects and check permission.
#
function StatusSetupAjax($needmodify)
{
    global $this_user, $ajax_args;
    global $instance, $creator;

    if (!isset($ajax_args["uuid"])) {
	SPITAJAX_ERROR(1, "Missing instance uuid");
	return 1;
    }
    $uuid = $ajax_args["uuid"];
    $instance = Instance::Lookup($uuid);
    if (!$instance) {
	SPITAJAX_ERROR(GENIRESPONSE_SEARCHFAILED,
                       "no such instance uuid: $uuid");
	return 1;
    }
    $creator = GeniUser::Lookup("sa", $instance->creator_uuid());
    if (! $creator) {
	$creator = User::LookupByUUID($instance->creator_uuid());
    }
    if (!$creator) {
	SPITAJAX_ERROR(1, "no such instance creator");
	return 1;
    }
    # Admin users do whatever they like.
    if (isset($this_user) && ISADMIN()) {
	return 0;
    }
    # Foreign admins can look.
    if (isset($this_user) && ISFOREIGN_ADMIN() && !$needmodify) {
	return 0;
    }
    # For a guest user; must be the same guest that created experiment.
    if (get_class($creator) == "GeniUser") {
        if (isset($_COOKIE['quickvm_user']) &&
            $_COOKIE['quickvm_user'] == $creator->uuid()) {
            return 0;
        }
	SPITAJAX_ERROR(1, "You do not have permission!");
	return 1;
    }
    # An experiment created by a real user, can be accessed by other
    # members of the project, subject to modify restrictions.
    if (! (isset($this_user) && get_class($creator) == "User" &&
           $instance->CanView($this_user) &&
           (!$needmodify || $instance->CanModify($this_user)))) {
	SPITAJAX_ERROR(1, "You do not have permission!");
	return 1;
    }
    return 0;
}

#
# Status/
#
function Do_GetInstanceStatus()
{
    global $instance, $creator, $APTBASE;

    if (StatusSetupAjax(0)) {
	return;
    }
    $blob = array();
    $blob["status"] = $instance->status();
    $blob["canceled"] = $instance->canceled() ? 1 : 0;
    $blob["paniced"] = $instance->paniced() ? 1 : 0;
    $blob["started"] = DateStringGMT($instance->started());
    $blob["sliverstatus"] = array();
    $prestageStatus = array();

    if ($instance->logfileid()) {
        $blob["logfile_url"] =
            "$APTBASE/spewlogfile.php?logfile=" . $instance->logfileid();
    }
    
    # Openstack experiment?
    $haveopenstack = $instance->isopenstack() ? 1 : 0;

    foreach ($instance->slivers() as $sliver) {
        $sliverblob =
            array("aggregate_urn"   => $sliver->aggregate_urn(),
                  "status"          => $sliver->status(),
                  "deferred"        => $sliver->deferred(),
                  "havemanifest"    => 0,
                  "offline"         => false);

        #
        # See if the aggregate is offline.
        #
        $aggregate = Aggregate::Lookup($sliver->aggregate_urn());
        if ($aggregate && ($aggregate->status() == "down" ||
                           $aggregate->status() == "offline")) {
            $sliverblob["offline"] = true;
        }
        if ($sliver->deferred()) {
            $sliverblob["retry_count"] = $sliver->retry_count();
            $sliverblob["last_retry"]  = DateStringGMT($sliver->last_retry());
            $sliverblob["deferred_reason"] = $sliver->deferred_reason();
            $sliverblob["deferred_cause"]  = null;

            #
            # If we have a retry count, there is going to be an error
            # associated with it in the webtask. Lets pull out that text
            # and show it to the user so they have some idea of what is
            # going on.
            #
            if ($sliver->retry_count()) {
                $wtask = $sliver->WebTask();
                if ($wtask && $wtask->TaskValue("output")) {
                    $sliverblob["deferred_cause"] =
                        htmlentities($wtask->TaskValue("output"));
                }
            }
        }
        else {
            if ($sliver->manifest()) {
                $sliverblob["havemanifest"] = 1;
                $statusblob = array();

                foreach ($sliver->StatusArray() as $status) {
                    if (isset($status["sliver_data"])) {
                        $statusblob[$status["client_id"]]
                            = $status["sliver_details"];
                    }
                }
                $sliverblob["details"] = $statusblob;
            }
        }
        if ($sliver->public_url()) {
            $sliverblob["url"] = $sliver->public_url();
        }
        # Prestage info
        if (($sliver->status() == "prestage" ||
             $sliver->status() == "staging" ||
             $sliver->status() == "staged") && $sliver->prestage_data()) {
            $prestageStatus[$sliver->aggregate_urn()] =
                json_decode($sliver->prestage_data(), true);            
        }
        $blob["sliverstatus"][$sliver->aggregate_urn()] = $sliverblob;
    }
    $blob["haveopenstackstats"] = $haveopenstack;
    if (count($prestageStatus)) {
        $blob["prestageStatus"] = $prestageStatus;
    }

    $webtask = $instance->WebTask();
    
    # Reflect errors back to the user.
    if ($webtask && $webtask->exited()) {
        $blob["code"] = $webtask->exitcode();
        
        if ($webtask->exitcode() == GENIRESPONSE_INSUFFICIENT_NODES) {
            # All the info in the results from the cluster.
            $blob["reason"]  = "";
        }
        elseif ($webtask->exitcode() == GENIRESPONSE_INSUFFICIENT_BANDWIDTH) {
            $blob["reason"]  = "Not enough available bandwidth for a link.\n\n";
        }
        elseif ($webtask->exitcode() == GENIRESPONSE_NO_CONNECT) {
            $blob["reason"]  = "Could not map all requested links to physical ".
	    "resources. Not enough free resources currently. ".
	    "Please try again later.\n\n";
	}
        elseif ($webtask->exitcode() == GENIRESPONSE_MAPPING_IMPOSSIBLE) {
            $blob["reason"]  = "Your topology cannot be instantiated. ".
	    "You have most likely asked for hardware that does not exist, ".
            "such as nodes of a type that are not at the target cluster, ".
            "or more network interfaces that exist on any of the nodes ".
            "at the target cluster. You will need to modify your profile ".
            "or try a different cluster.\n\n";
        }
        elseif ($webtask->exitcode() == GENIRESPONSE_NO_MAPPING) {
            $blob["reason"]  = "Your topology could not be mapped to physical ".
                "resources. In addition to any information below, you can ".
                "click on the 'Logs' button above, which will provide ".
                "lots of info, some of which might be useful in figuring out ".
                "why it failed.\n\n";
        }
        elseif ($webtask->exitcode() == GENIRESPONSE_TIMEDOUT) {
            $blob["reason"]  = "Your experiment timed out while setting up, ".
                "most likely because one or more nodes failed to boot. The ".
                "node consoles may provide more information.\n\n";
        }
        elseif ($webtask->exitcode() == GENIRESPONSE_TIMEDOUT) {
            $blob["reason"]  = "Your experiment timed out while setting up, ".
                "most likely because one or more nodes failed to boot. The ".
                "node consoles may provide more information.\n\n";
        }
        elseif ($webtask->exitcode() == GENIRESPONSE_NETWORK_ERROR) {
            $blob["reason"]  = "One or more clusters could no longer be ".
                "reached after your experiment was provisioned.";
        }
        elseif ($webtask->exitcode() == GENIRESPONSE_BADARGS) {
            #
            # This is GENIRESPONSE_BADARGS which typically means an error
            # in the input rspec, something the user must have put in it.
            #
            $blob["reason"]  = "Your topology source contains invalid ".
                "values.\n\n";
        }
        elseif ($webtask->exitcode() == GENIRESPONSE_NOSPACE) {
            #
            # Over Quota.
            #
            $blob["reason"]  = "You are over your disk quota at the target ".
                "cluster, probably because of too many saved disk images. ".
                "Please click on the 'Storage->My Disk Images' above and ".
                "delete images you no longer need.";
        }
        elseif ($webtask->exitcode() == GENIRESPONSE_STITCHER_ERROR) {
            #
            # This is GENIRESPONSE_STITCHER_ERROR which is a catch all.
            #
            $blob["reason"]  = "Your multi-site topology could not be ".
                "stitched together. Please look closely at the ".
                "error message below to see what went wrong.\n\n";
        }
        else {
            $blob["reason"] = "";
        }
        $blob["reason"] .= htmlentities($webtask->TaskValue("output"));
        $blob["canclearerror"]
            = ($webtask->TaskValue("canignore") != 0 ||
               $webtask->exitcode() ==
                 GENIRESPONSE_SETUPFAILURE_BOOTFAILED ? 1 : 0);
    }
    SPITAJAX_RESPONSE($blob);
}

#
# Terminate.
#
function Do_TerminateInstance()
{
    global $instance, $creator, $this_user, $ajax_args;

    # Check for read permission, and then check for Terminate permission.
    if (StatusSetupAjax(0)) {
	return;
    }
    if ($instance->paniced() && !ISADMIN()) {
        SPITAJAX_ERROR(1, "This experiment has been quarantined and ".
                       "must be terminated my an administrator.");
        return;
    }
    if (!(ISADMIN() || $instance->CanTerminate($this_user))) {
        SPITAJAX_ERROR(1, "Not enough permission to terminate");
        return;
    }
    $uuid = $instance->uuid();

    if ($instance->admin_lockdown()) {
        SPITAJAX_ERROR(1, "This experiment has been locked down by an ".
                       "administrator. The lock must be cleared before ".
                       "it can terminated.");
        return;

    }
    $webtask = WebTask::CreateAnonymous();
    $webtask_id = $webtask->task_id();

    if ($instance->user_lockdown()) {
        if (! (isset($this_user) &&
               ($instance->creator() == $this_user->uid() || ISADMIN()))) {
            SPITAJAX_ERROR(1, "Not enough permission to terminate; ".
                           "experiment is locked down.");
            $webtask->Delete();
            return;
        }
        $override = substr($uuid, 2, 5);

        if (! (isset($ajax_args["lockdown_override"]) &&
               $ajax_args["lockdown_override"] == $override)) {
            SPITAJAX_ERROR(1, "Lockdown override is incorrect");
            $webtask->Delete();
            return;
        }
        $retval = SUEXEC($this_user->uid(), "nobody",
                         "webmanage_instance -t $webtask_id -- ".
                         "  lockdown $uuid clear user",
                         SUEXEC_ACTION_CONTINUE);
        if ($retval) {
            $webtask->Refresh();

            if ($webtask && $webtask->exited()) {
                SPITAJAX_ERROR(1, $webtask->output());
            }
            else {
                SPITAJAX_ERROR(-1, "Internal Error. Please try again later");
            }
            $webtask->Delete();
            return;
        }
    }
    $webtask->Reset();
    
    # We do not want to see the busy errors, and that is the only error
    # that gets returned, that is not also emailed by the script. So just
    # use the ignore option.
    $retval = SUEXEC("nobody", "nobody",
                     "webmanage_instance -t $webtask_id -- terminate $uuid",
                     SUEXEC_ACTION_IGNORE);
    if ($retval) {
        $webtask->Refresh();
        if (!$webtask->exited() || $retval < 0) {
            # Email sent by manage_instance in this case.
            SPITAJAX_ERROR(-1, "Internal error terminating experiment");
        }
        else {
            SPITAJAX_ERROR(1, "Unable to terminate experiment at this time: " .
                           $webtask->output());
        }
    }
    else {
	SPITAJAX_RESPONSE("");
    }
    $webtask->Delete();
}

#
# Manifest.
#
function Do_GetInstanceManifest()
{
    global $instance, $creator, $ajax_args;

    if (StatusSetupAjax(0)) {
	return;
    }
    if (isset($ajax_args["aggregate_urn"])) {
        $urn = $ajax_args["aggregate_urn"];
        if (!Instance::ValidURN($urn)) {
            SPITAJAX_ERROR(-1, "Illegal characters in aggregate urn");
            return;
        }
        $sliver = InstanceSliver::Lookup($instance, $urn);
        if (!$sliver) {
            SPITAJAX_ERROR(-1, "No sliver for aggregate urn");
            return;
        }
        SPITAJAX_RESPONSE($sliver->manifest());
    }
    else {
        $blob = array();

        foreach ($instance->slivers() as $sliver) {
            if ($sliver->manifest()) {
                $blob[$sliver->aggregate_urn()] = $sliver->manifest();
            }
        }
        SPITAJAX_RESPONSE($blob);
    }
}

#
# SSH Auth Object
#
function Do_GetSSHAuthObject()
{
    global $instance, $creator, $this_user;
    global $ajax_args;

    if (!isset($ajax_args["hostport"])) {
	SPITAJAX_ERROR(1, "Missing hostport");
	return 1;
    }
    $hostport = $ajax_args["hostport"];
    
    if (StatusSetupAjax(0)) {
	return;
    }
    if (! ((isset($this_user) && $instance->CanDoSSH($this_user)) ||
	   (isset($_COOKIE['quickvm_user']) &&
	    $_COOKIE['quickvm_user'] == $creator->uuid()))) {
	SPITAJAX_ERROR(1, "Not allowed to ssh; ".
                       "only the creator or a project member");
	return;
    }
    
    $nodeid = $ajax_args["nodeid"];
    $auth   = SSHAuthObject(isset($this_user) ?
                            $this_user->uid() : $creator->uid(), $hostport);
    if (!$auth) {
	SPITAJAX_ERROR(1, "Could not create authentication object");
	return;
    }
    SPITAJAX_RESPONSE($auth);
}

function Do_RequestExtension()
{
    global $instance, $creator, $this_user, $suexec_output;
    global $ajax_args;
    $force   = 0;
    $autoextend_maximum = TBGetSiteVar("aptui/autoextend_maximum");

    if (StatusSetupAjax(1)) {
	goto bad;
    }
    if (isset($this_user)) {
        $project = Project::Lookup($instance->pid_idx());
        if ($project) {
            $group = $project->DefaultGroup();
            if (!(ISADMINISTRATOR() ||
                  FeatureEnabled("NewPortalExtend", $this_user, $group))) {
                return Do_RequestExtensionOld();
            }
        }
    }
    $uuid = $instance->uuid();
    $slice = GeniSlice::Lookup("sa", $instance->slice_uuid());
    if (!$slice) {
	SPITAJAX_ERROR(1, "no slice for instance");
	goto bad;
    }

    if ($autoextend_maximum == 0 && !ISADMIN()) {
	SPITAJAX_ERROR(1, "Extensions are currenly disabled; please ".
                       "contact us if you need to make special arrangements.");
	goto bad;
    }

    if (!isset($ajax_args["howlong"]) || $ajax_args["howlong"] == "") {
	SPITAJAX_ERROR(1, "Missing number of hours");
	goto bad;
    }
    $wanted = $ajax_args["howlong"];
    if (is_numeric($wanted)) {
        if ($wanted < 1) {
            SPITAJAX_ERROR(1, "Hours must be an integer greater then 1");
            goto bad;
        }
    }
    elseif (!strtotime($wanted)) {
        SPITAJAX_ERROR(1, "Invalid characters in hours");
        goto bad;
    }
    if (isset($ajax_args["maxextension"]) && $ajax_args["maxextension"] != "") {
        $maxextension = $ajax_args["maxextension"];
        if (!strtotime($maxextension)) {
            SPITAJAX_ERROR(1, "Invalid max extension date");
            goto bad;
        }
    }
    if (ISADMIN()) {
	if (isset($ajax_args["reason"]) && $ajax_args["reason"] != "") {
            $reason = $ajax_args["reason"];
        }
	if (isset($ajax_args["force"]) && $ajax_args["force"]) {
            $force = 1;
        }
    }
    else {
	if (!isset($ajax_args["reason"]) || $ajax_args["reason"] == "") {
	    SPITAJAX_ERROR(1, "Missing reason");
	    goto bad;
	}
	$reason = $ajax_args["reason"];
    }
    if (isset($reason)) {
        if (!TBvalid_fulltext($reason)) {
	    SPITAJAX_ERROR(1, "Illegal characters in reason");
	    goto bad;
        }
        $filename = tempnam("/tmp", "extension");
        $fp = fopen($filename, "w");
        fwrite($fp, $reason);
        fclose($fp);
    }        
    $webtask = WebTask::CreateAnonymous();
    $retval = SUEXEC("nobody", "nobody",
		     "webmanage_instance -t " . $webtask->task_id() . " -- ".
                     "  extend $uuid " .
                     (isset($filename) ? "-f $filename " : "").
                     (isset($maxextension) ? "-e '$maxextension' " : "").
                     ($force ? "-F " : "") . "'$wanted'",
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();
    if (isset($filename)) {
        unlink($filename);
    }
    if ($retval != 0) {
        # Debugging for a while.
        #SUEXECERROR(SUEXEC_ACTION_CONTINUE);
    
        if (!$webtask->exited() || $retval < 0) {
            SPITAJAX_ERROR(-1, "Internal error extending experiment");
        }
        else {
            # Need to pass exitcode through on this one.
            SPITAJAX_ERROR($webtask->exitcode(), $webtask->output());
        }
        $webtask->Delete();
        goto bad;
    }
    # Refresh. 
    $slice = GeniSlice::Lookup("sa", $instance->slice_uuid());
    $blob = array("expiration" => DateStringGMT($slice->expires()),
                  "granted"    => $webtask->TaskValue("granted"),
                  "message"    => $webtask->TaskValue("message"));
    $webtask->Delete();
    SPITAJAX_RESPONSE($blob);
bad:
delay:
    sleep(1);
}

function Do_DenyOrMoreinfo($action)
{
    global $instance, $creator, $this_user, $suexec_output;
    global $ajax_args;
    $lockout  = 0;
    $extrargs = "";

    # Really, only admins can do this.
    if (StatusSetupAjax(0)) {
	goto bad;
    }
    $uuid = $instance->uuid();
    $slice = GeniSlice::Lookup("sa", $instance->slice_uuid());
    if (!$slice) {
	SPITAJAX_ERROR(1, "no slice for instance");
	goto bad;
    }
    if (!ISADMIN()) {
	SPITAJAX_ERROR(1, "You do not have permission to do this.");
	goto bad;
    }
    if ($action == "terminate" && $instance->admin_lockdown()) {
        SPITAJAX_ERROR(1, "This experiment has been locked down by an ".
                       "administrator. The lock must be cleared before ".
                       "it can terminated.");
        return;

    }
    if (($action == "terminate" || $action == "deny") &&
        isset($ajax_args["lockout"]) && $ajax_args["lockout"] != "0") {
        $lockout = 1;
    }
    if (isset($ajax_args["reason"]) && $ajax_args["reason"] != "") {
        $reason = $ajax_args["reason"];
        
        if (!TBvalid_fulltext($reason)) {
	    SPITAJAX_ERROR(1, "Illegal characters in message");
	    goto bad;
        }
        $filename = tempnam("/tmp", "extension");
        $fp = fopen($filename, "w");
        fwrite($fp, $reason);
        fclose($fp);
    }
    if ($action == "terminate") {
        if (!isset($ajax_args["howlong"]) || $ajax_args["howlong"] == "") {
            SPITAJAX_ERROR(1, "Missing number of days");
            goto bad;
        }
        $days = $ajax_args["howlong"];
        if (! preg_match("/^\d+$/", $days)) {
            SPITAJAX_ERROR(1, "Invalid characters in days");
            goto bad;
        }
        $extrargs = $days;
    }
    $action = ($action == "deny" ? "denyextension" :
               ($action == "terminate" ? "schedterminate": "moreinfo"));
    $webtask = WebTask::CreateAnonymous();
    $retval = SUEXEC("nobody", "nobody",
		     "webmanage_instance -t " . $webtask->task_id() . " -- ".
                     "  $action $uuid $extrargs " .
                        (isset($filename) ? $filename : ""),
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();
    if (isset($filename)) {
        unlink($filename);
    }
    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, "Internal error");
        }
        else {
            # This is an important error, tell tbops.
            if ($webtask->exitcode() == GENIRESPONSE_REFUSED) {
                SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            }
            # Need to pass exitcode through on this one.
            SPITAJAX_ERROR($webtask->exitcode(), $webtask->output());
        }
        $webtask->Delete();
        return;
    }
    $webtask->Delete();
    if ($lockout) {
        if (Do_Lockout()) {
            SPITAJAX_ERROR(-1, "Could not disable extensions");
            return;
        }
        # Do_Lockout() issued a success.
        return;
    }
    SPITAJAX_RESPONSE("Success");
    return;
bad:
    $webtask->Delete();
    sleep(1);
}

function Do_DenyExtension()
{
    Do_DenyOrMoreinfo("deny");
}
function Do_MoreInfo()
{
    Do_DenyOrMoreinfo("info");
}
function Do_SchedTerminate()
{
    Do_DenyOrMoreinfo("terminate");
}

#
# Request a console URL and pass back to the status page.
#
function Do_ConsoleURL()
{
    global $instance, $creator, $this_user, $suexec_output;
    global $ajax_args, $TBDB_TRUST_LOCALROOT;

    if (StatusSetupAjax(0)) {
	return;
    }
    if (!isset($this_user)) {
	SPITAJAX_ERROR(1, "Only registered users can view node consoles");
	return;
    }
    if (!isset($ajax_args["node"])) {
	SPITAJAX_ERROR(1, "Missing node argument");
	return 1;
    }
    $node = $ajax_args["node"];
    $uuid = $instance->uuid();
    $slice = GeniSlice::Lookup("sa", $instance->slice_uuid());
    if (!$slice) {
	SPITAJAX_ERROR(1, "no slice for instance");
	return 1;
    }
    $webtask = WebTask::CreateAnonymous();
    $retval = SUEXEC("nobody", "nobody",
		     "webmanage_instance -t " . $webtask->task_id() . " ".
                     "  consoleurl $uuid " .
		     escapeshellarg($node),
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();

    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, "Internal error getting console info");
        }
        else {
            # JS needs this exitcode.
            SPITAJAX_ERROR($webtask->exitcode(),
                           "Could not get console info: ". $webtask->output());
        }
        $webtask->Delete();
	return;
    }
    #
    # If the user has 'user' privs in the current project/group
    # then we do not return the root password. They can still look
    # at the console though.
    #
    $group = $instance->Group();
    $trust = $group->UserTrust($this_user);
        
    $taskdata = $webtask->TaskData();
    $blob = array();
    $blob["url"] = $taskdata["url"];
    if (isset($taskdata["password"]) &&
        (ISADMIN() || TBMinTrust($trust, $TBDB_TRUST_LOCALROOT))) {
        $blob["password"] = $taskdata["password"];
    }
    if (isset($taskdata["logurl"])) {
        $blob["logurl"] = $taskdata["logurl"];
    }
    if (isset($taskdata["authobject"])) {
        $blob["authobject"] = $taskdata["authobject"];
    }
    SPITAJAX_RESPONSE($blob);
    $webtask->Delete();
    return;
}

#
# Fire off a snapshot.
#
function Do_Snapshot()
{
    global $this_user, $instance, $suexec_output;
    global $ajax_args;
    $errors = array();

    if (StatusSetupAjax(0)) {
	return;
    }
    if (!isset($this_user)) {
	SPITAJAX_ERROR(1, "Only registered users can snapshot nodes");
	return;
    }
    if ($instance->paniced()) {
        SPITAJAX_ERROR(1, "This experiment has been quarantined.");
        return;
    }
    
    $this_idx = $this_user->uid_idx();
    $uuid = $ajax_args["uuid"];
    $checkonly = (isset($ajax_args["checkonly"]) &&
                  $ajax_args["checkonly"] == 1 ? 1 : 0);
    $pid = $instance->pid();    
    
    #
    # As per Rob, if an experiment is locked down, then only the creator,
    # project leader, or an admininstrator.
    #
    if ($instance->admin_lockdown() || $instance->user_lockdown()) {
        if ($this_idx != $instance->creator_idx() && !ISADMIN() &&
            !$instance->Project()->IsLeader($this_user)) {
            SPITAJAX_ERROR(1, "Not enough permission, ".
                           "experiment is locked down.");
            return;
        }
    }
    if ($instance->status() != "ready") {
	SPITAJAX_ERROR(1, "Experiment is currently busy");
	return;
    }
    if (!isset($ajax_args["operation"]) || $ajax_args["operation"] == "") {
        SPITAJAX_ERROR(-1, "Must supply operation!");
        return;
    }
    $operation = $ajax_args["operation"];
    if (! ($operation == "update-profile" ||
           $operation == "copy-profile" ||
           $operation == "new-profile" ||
           $operation == "image-only")) {
        SPITAJAX_ERROR(-1, "Invalid operation!");
        return;
    }
           
    #
    # The profile also has to belong to the user, since it is
    # going to be modified to use the new image.
    #
    $profile = Profile::Lookup($instance->profile_id(),
			       $instance->profile_version());
    if (!$profile) {
	SPITAJAX_ERROR(1, "Cannot lookup profile for instance");
	return;
    }
    if ($operation == "update-profile" &&
        ($this_idx != $profile->creator_idx() && !ISADMIN())) {
	SPITAJAX_ERROR(1, "Not your profile to change. Make a copy first!");
	return;
    }
    $optargs = "";
    if (isset($ajax_args["node_id"]) && $ajax_args["node_id"] != "") {
        $node_id = $ajax_args["node_id"];
        if (!TBvalid_vnode_id($node_id)) {
            $errors["node_id"] = "Invalid node id";
        }
        else {
            $optargs .= " -n $node_id ";
        }
    } 
    if (isset($ajax_args["update_prepare"]) &&
        $ajax_args["update_prepare"]) {
        $optargs .= " -U ";
    }
    if (isset($ajax_args["wholedisk"]) && $ajax_args["wholedisk"]) {
        $optargs .= " -e ";
    }
    if (isset($ajax_args["nosnapshot"]) && $ajax_args["nosnapshot"]) {
        $optargs .= " -S ";
    }
    if (isset($ajax_args["imagename"]) && $ajax_args["imagename"] != "") {
        if (!TBvalid_imagename($ajax_args["imagename"])) {
            $errors["imagename"] = "Invalid imagename, alphanumeric only";
        }
        else {
            $optargs .= " -i " . escapeshellarg($ajax_args["imagename"]);
        }
    }
    if (isset($ajax_args["description"]) && $ajax_args["description"] != "") {
        $desc = $ajax_args["description"];
        
        if (!TBvalid_fulltext($desc)) {
            $errors["description"] = "Illegal characters";
        } 
        elseif (strlen($desc) > 225) { 
            $errors["description"] = "Too long, must be < 225 chars";
        }
        elseif (strlen($desc) < 10) {
            $errors["description"] = "Too short, must be >= 10 chars";
        }
        elseif (!$checkonly) {
            $filename = tempnam("/tmp", "description");
            $fp = fopen($filename, "w");
            fwrite($fp, $desc);
            fclose($fp);
            chmod($filename, 0666);        
            $optargs .= " -D $filename";
        }
    }
    if (count($errors)) {
        SPITAJAX_ERROR(2, $errors);
        return;
    }
    if ($checkonly) {
        SPITAJAX_RESPONSE("Success");
        return;
    }
    $optargs .= " -O $operation ";

    #
    # Call out to the backend.
    #
    $webtask = WebTask::CreateAnonymous();
    $retval = SUEXEC($this_user->uid(), $pid,
		     "webmanage_instance -t " . $webtask->task_id() . " " .
                     "  snapshot $uuid $optargs",
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();
    if (isset($filename)) {
        unlink($filename);
    }
    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-11, "Internal error creating snapshot");
        }
        else {
            SPITAJAX_ERROR(1, "Could not create snapshot: ".
                           $webtask->output());
        }
        $webtask->Delete();
	return;
    }
    $webtask->Delete();
    SPITAJAX_RESPONSE("Success");
}

#
# Return snapshot status.
#
function Do_SnapshotStatus()
{
    global $this_user, $instance;
    global $ajax_args;

    if (StatusSetupAjax(0)) {
	return;
    }
    if (!isset($this_user)) {
	SPITAJAX_ERROR(1, "Only registered users can snapshot nodes");
	return;
    }
    $this_idx = $this_user->uid_idx();
    $webtask  = $instance->WebTask();
    if (!$webtask) {
	SPITAJAX_ERROR(1, "No status descriptor found");
	return;
    }
    $taskdata = $webtask->TaskData();
    $blob = array();

    #
    # Size is in KB to avoid bigint problems. But kill the KB.
    # 
    if (isset($taskdata["image_size"])) {
	if (preg_match("/^(\d+)KB$/", $taskdata["image_size"], $matches)) {
	    $taskdata["image_size"] = $matches[1]; 
	}
	$blob["image_size"] = $taskdata["image_size"];
    }
    else {
	$blob["image_size"] = 0;
    }
    if (isset($taskdata["copyback_urn"])) {
        $blob["copyback_urn"] = $taskdata["copyback_urn"];
    }
    $blob["image_status"] = $taskdata["image_status"];
    
    #
    # Lets put the node status in too. The backend has helpfully told us
    # the aggregate and node to track down the status.
    #
    if (isset($taskdata["aggregate_urn"]) && isset($taskdata["client_id"])) {
        $sliver = InstanceSliver::Lookup($instance, $taskdata["aggregate_urn"]);
        if ($sliver) {
            foreach ($sliver->StatusArray() as $status) {
                if (isset($status["sliver_data"]) &&
                    $status["client_id"] == $taskdata["client_id"]) {
                    $blob["node_status"] = $status["sliver_details"]["rawstate"];
                    break;
                }
            }
        }
    }
    if ($webtask->exited()) {
	$blob["exited"]   = $webtask->exited();
	$blob["exitcode"] = $webtask->exitcode();
        # We want to say something in the web UI if imaging throws an error.
        if ($webtask->exitcode()) {
            $blob["errmsg"] = $webtask->output();
        }
        if (isset($taskdata["image_name"])) {
            $blob["image_name"] = $taskdata["image_name"];
        }
    }
    SPITAJAX_RESPONSE($blob);
}

#
# Ask the backend to refresh sliverstatus
#
function Do_Refresh()
{
    global $this_user, $instance, $suexec_output;
    global $ajax_args;

    #
    # Guest users can do this.
    #
    if (StatusSetupAjax(0)) {
	return;
    }
    $this_idx = $this_user->uid_idx();
    $uuid = $ajax_args["uuid"];
    #
    # Call out to the backend.
    #
    $webtask = WebTask::CreateAnonymous();
    $retval = SUEXEC("nobody", "nobody",
		     "webmanage_instance -t " . $webtask->task_id() .
                     " refresh $uuid",
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();

    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-11, "Internal error refreshing status");
        }
        else {
            SPITAJAX_ERROR(1, "Could not refresh status: ". $webtask->output());
        }
        $webtask->Delete();
	return;
    }
    $webtask->Delete();
    SPITAJAX_RESPONSE("Success");
}

#
# Reload rhe manifests.
#
function Do_ReloadTopology()
{
    global $this_user, $instance, $suexec_output;
    global $ajax_args;

    if (StatusSetupAjax(0)) {
	return;
    }
    $this_idx = $this_user->uid_idx();
    $uuid = $ajax_args["uuid"];
    #
    # Call out to the backend.
    #
    $webtask = WebTask::CreateAnonymous();
    $retval = SUEXEC("nobody", "nobody",
		     "webmanage_instance -t " . $webtask->task_id() .
                     "  getmanifests $uuid",
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();

    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-11, "Internal error getting manifests");
        }
        else {
            SPITAJAX_ERROR(1, $webtask->output());
        }
        $webtask->Delete();
	return;
    }
    $webtask->Delete();
    SPITAJAX_RESPONSE("Success");
}

#
# Ask the backend to reboot or reload a node.
#
function Do_RebootOrReload($which)
{
    global $this_user, $instance, $suexec_output;
    global $ajax_args, $TBDB_TRUST_GROUPROOT;

    if (StatusSetupAjax(0)) {
	return;
    }
    if (!isset($this_user)) {
	SPITAJAX_ERROR(1, "Only registered users can reboot/reload nodes");
	return;
    }
    if ($instance->paniced() && !ISADMIN()) {
        SPITAJAX_ERROR(1, "This experiment has been quarantined, only ".
                       "an admininstrator can reboot/reload.");
        return;
    }
    
    $this_idx = $this_user->uid_idx();
    $uuid = $ajax_args["uuid"];

    #
    # As per Rob, if an experiment is locked down, then only the creator,
    # project leader, or an admininstrator.
    #
    if ($instance->admin_lockdown() || $instance->user_lockdown()) {
        if ($this_idx != $instance->creator_idx() && !ISADMIN() &&
            $instance->Project()->UserTrust($this_user) <
            $TBDB_TRUST_GROUPROOT) {
            SPITAJAX_ERROR(1, "Not enough permission, ".
                           "experiment is locked down");
            return;
        }
    }

    if (!isset($ajax_args["node_ids"])) {
	SPITAJAX_ERROR(1, "Missing node_id list");
	return;
    }
    $nodelist = "";
    foreach ($ajax_args["node_ids"] as $node_id) {
        if (!preg_match("/^[-\w]+$/", $node_id)) {
            SPITAJAX_ERROR(1, "Illegal characters in node_id");
            return;
        }
        $nodelist .= " " . escapeshellarg($node_id);
    }
    if ($instance->status() != "ready" && $instance->status() != "failed") {
	SPITAJAX_ERROR(1, "Experiment is currently busy");
	return;
    }

    #
    # Call out to the backend.
    #
    $webtask = WebTask::CreateAnonymous();
    $retval = SUEXEC("nobody", "nobody",
		     "webmanage_instance -t " . $webtask->task_id() .
                     "  $which $uuid $nodelist",
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();

    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, "Internal error");
        }
        else {
            SPITAJAX_ERROR(1, $webtask->output());
        }
        $webtask->Delete();
	return;
    }
    $webtask->Delete();
    SPITAJAX_RESPONSE("Success");
}
function Do_Reboot()
{
    Do_RebootOrReload("reboot");
}
function Do_Reload()
{
    Do_RebootOrReload("reload");
}
function Do_PowerCycle()
{
    Do_RebootOrReload("powercycle");
}

#
# Delete nodes from an experiment
#
function Do_DeleteNodes()
{
    global $this_user, $instance, $suexec_output;
    global $ajax_args;

    if (StatusSetupAjax(1)) {
	return;
    }
    if (!isset($this_user)) {
	SPITAJAX_ERROR(1, "Only registered users can delete nodes");
	return;
    }
    if ($instance->paniced()) {
        SPITAJAX_ERROR(1, "This experiment has been quarantined.");
        return;
    }
    $this_idx = $this_user->uid_idx();
    $uuid = $ajax_args["uuid"];

    if (!isset($ajax_args["node_ids"])) {
	SPITAJAX_ERROR(1, "Missing node_id list");
	return;
    }
    $nodelist = "";
    foreach ($ajax_args["node_ids"] as $node_id) {
        if (!preg_match("/^[-\w]+$/", $node_id)) {
            SPITAJAX_ERROR(1, "Illegal characters in node_id");
            return;
        }
        $nodelist .= " " . escapeshellarg($node_id);
    }
    if ($this_idx != $instance->creator_idx() && !ISADMIN()) {
	SPITAJAX_ERROR(1, "Not enough permission.");
	return;
    }
    if ($instance->status() != "ready") {
	SPITAJAX_ERROR(1, "Experiment is currently busy");
	return;
    }

    #
    # Call out to the backend.
    #
    $webtask = WebTask::CreateAnonymous();
    $retval = SUEXEC("nobody", "nobody",
		     "webmanage_instance -t " . $webtask->task_id() .
                     "  deletenodes $uuid $nodelist",
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();

    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, "Internal error deleting nodes");
        }
        else {
            SPITAJAX_ERROR(1, $webtask->output());
        }
        $webtask->Delete();
	return;
    }
    $webtask->Delete();
    SPITAJAX_RESPONSE("Success");
}

#
# Decrypt the blocks using the per-instance private key.
#
function Do_DecryptBlocks()
{
    global $this_user, $instance, $suexec_output;
    global $ajax_args;

    if (StatusSetupAjax(0)) {
	return;
    }
    if (!isset($ajax_args["blocks"])) {
	SPITAJAX_ERROR(1, "Missing blocks argument");
	return;
    }
    $this_idx = $this_user->uid_idx();
    $uuid = $ajax_args["uuid"];
    $result = array();

    #
    # Grab the instance private key and write to a file for smime.
    #
    $infname  = tempnam("/tmp", "decryptin");
    $outfname = tempnam("/tmp", "decryptout");
    $pkeyname = tempnam("/tmp", "decryptkey");

    $fp = fopen($pkeyname, "w");
    fwrite($fp, $instance->private_key());
    fclose($fp);

    #
    # Use smime for each block and store.
    #
    foreach ($ajax_args["blocks"] as $key => $block) {
        $fp = fopen($infname, "w");
        fwrite($fp, $block);
        fclose($fp);
        # Truncate the output file.
        $fp = fopen($outfname, "w");
        fclose($fp);

        $retval =
            myexec("/usr/bin/openssl smime -decrypt -inform PEM -inkey ".
                   "$pkeyname -in $infname -out $outfname");

        if ($retval) {
            SPITAJAX_ERROR(-1, "Internal decryption error");
            return;
        }
        $decrypted = file_get_contents($outfname);
        $result[$key] = $decrypted;
    }
    unlink($infname);
    unlink($outfname);
    unlink($pkeyname);
    SPITAJAX_RESPONSE($result);
}

#
# Set or clear the lockout flag
#
function Do_Lockout()
{
    global $this_user;
    global $ajax_args;
    global $TBMAIL_OPS, $TBMAIL_AUDIT;

    if (!isset($this_user) || !ISADMIN()) {
	SPITAJAX_ERROR(1, "Not enough permission.");
	return -1;
    }
    $this_idx = $this_user->uid_idx();

    if (!isset($ajax_args["uuid"])) {
	SPITAJAX_ERROR(1, "Missing profile uuid");
	return -1;
    }
    if (!isset($ajax_args["lockout"])) {
	SPITAJAX_ERROR(1, "Missing lockout value");
	return -1;
    }
    if (isset($ajax_args["reason"]) && $ajax_args["reason"] != "") {
        $reason = $ajax_args["reason"];
        
        if (!TBvalid_fulltext($reason)) {
	    SPITAJAX_ERROR(1, "Illegal characters in message");
            return -1;
        }
        $safe_reason = DBQuoteSpecial($reason);
    }
    $uuid = $ajax_args["uuid"];
    $instance = Instance::Lookup($uuid);
    if (!$instance) {
	SPITAJAX_ERROR(1, "Unknown instance uuid");
	return -1;
    }
    $lockout = ($ajax_args["lockout"] == 0 ? 0 : 1);
    if ($lockout) {
        $reason_clause  = (isset($safe_reason) ?
                           ",extension_disabled_reason='$safe_reason'" : "");
    }
    else {
        $reason_clause  = ",extension_disabled_reason=null";
    }
    if (!DBQueryWarn("update apt_instances set ".
                     "  extension_disabled='$lockout' $reason_clause ".
                     "where uuid='$uuid'")) {
	SPITAJAX_ERROR(1, "Database failure.");
	return -1;
    }
    $this_uid = $this_user->uid();
    $pid      = $instance->pid();
    $name     = $instance->name();
    $which    = ($lockout ? "disabled" : "enabled");
    TBMAIL($TBMAIL_AUDIT,
           "Portal experiment $uuid extensions $which",
           "$this_uid has $which extensions for $pid/$name\n\n".
           ($lockout && isset($reason) ? "Reason:\n$reason\n\n" : "").
           $instance->AdminURL() . "\n",
           "From: $TBMAIL_OPS");
    
    SPITAJAX_RESPONSE("Success");
    return 0;
}

#
# Ignore a failure.
#
function Do_IgnoreFailure()
{
    global $this_user;
    global $ajax_args, $instance;

    if (StatusSetupAjax(1)) {
	return;
    }
    $uuid = $instance->uuid();
    if (!DBQueryWarn("update apt_instances set ".
                     "  status='ready',status_timestamp=now() ".
                     "where uuid='$uuid'")) {
	SPITAJAX_ERROR(1, "Internal Error");
	return -1;
    }
    SPITAJAX_RESPONSE("Success");
    return 0;
}

#
# Set or clear the lockdown flag
#
function Do_Lockdown()
{
    global $this_user;
    global $ajax_args;
    $force = "";

    if (!isset($this_user) || !ISADMIN()) {
	SPITAJAX_ERROR(1, "Not enough permission.");
	return;
    }
    $this_idx = $this_user->uid_idx();

    if (!isset($ajax_args["uuid"])) {
	SPITAJAX_ERROR(1, "Missing profile uuid");
	return;
    }
    if (!isset($ajax_args["action"])) {
	SPITAJAX_ERROR(1, "Missing action");
	return;
    }
    $action = $ajax_args["action"];
    if ($action != "set" && $action != "clear") {
	SPITAJAX_ERROR(1, "Bad action");
	return;
    }
    if (!isset($ajax_args["which"])) {
	SPITAJAX_ERROR(1, "Missing which");
	return;
    }
    $which = $ajax_args["which"];
    if ($which != "user" && $which != "admin") {
	SPITAJAX_ERROR(1, "Bad which");
	return;
    }
    if ($which == "admin" && !ISADMIN()) {
	SPITAJAX_ERROR(1, "Not enough permission.");
        return;
    }
    if (isset($ajax_args["force"]) && $ajax_args["force"] == 1) {
        $force = "-f";
    }
    $uuid = $ajax_args["uuid"];
    $instance = Instance::Lookup($uuid);
    if (!$instance) {
	SPITAJAX_ERROR(1, "Unknown instance uuid");
	return;
    }
    if ($which == "user" &&
        !($this_idx == $instance->creator_idx() || ISADMIN())) {
	SPITAJAX_ERROR(1, "Not enough permission.");
        return;
    }

    #
    # Call out to the backend.
    #
    $webtask = WebTask::CreateAnonymous();
    $retval = SUEXEC("nobody", "nobody",
		     "webmanage_instance -t " . $webtask->task_id() .
                     "  lockdown $uuid $force $action $which ",
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();

    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, "Internal error changing lockdown");
        }
        else {
            # Need to pass exitcode through.
            SPITAJAX_ERROR($webtask->exitcode(), $webtask->output());
        }
        $webtask->Delete();
	return;
    }
    $webtask->Delete();
    SPITAJAX_RESPONSE("Success");
}

#
# Save new admin notes.
#
function Do_SaveAdminNotes()
{
    global $this_user, $instance;
    global $ajax_args;

    if (StatusSetupAjax(0)) {
	return;
    }
    if (!isset($this_user) || !ISADMIN()) {
	SPITAJAX_ERROR(1, "Not enough permission.");
	return;
    }
    if (!isset($ajax_args["notes"])) {
	SPITAJAX_ERROR(1, "Missing notes");
	return;
    }
    $notes = $ajax_args["notes"];
    if ($notes != "") {
        if (!TBvalid_fulltext($reason)) {
	    SPITAJAX_ERROR(1, "Illegal characters in nodes");
            return;
        }
    }
    $instance->SetAdminNotes($notes);
    SPITAJAX_RESPONSE("Success");
}

#
# Handle Quarantine request/clear.
#
function Do_Quarantine()
{
    global $this_user;
    global $ajax_args;

    if (!isset($this_user) || !ISADMIN()) {
	SPITAJAX_ERROR(1, "Not enough permission.");
	return;
    }
    $this_idx = $this_user->uid_idx();

    if (!isset($ajax_args["uuid"])) {
	SPITAJAX_ERROR(1, "Missing profile uuid");
	return;
    }
    if (!isset($ajax_args["quarantine"])) {
	SPITAJAX_ERROR(1, "Missing quarantine value");
	return;
    }
    $which = $ajax_args["quarantine"];
    if ($which != "set" && $which != "clear") {
	SPITAJAX_ERROR(1, "Invalid quarantine value");
	return;
    }
    $uuid = $ajax_args["uuid"];
    $opt = "";
    if (isset($ajax_args["poweroff"]) && $ajax_args["poweroff"]) {
        $opt = "-p";
    }
    $instance = Instance::Lookup($uuid);
    if (!$instance) {
	SPITAJAX_ERROR(1, "Unknown instance uuid");
	return;
    }
    $webtask = WebTask::CreateAnonymous();
    $retval = SUEXEC($this_user->uid(), "nobody",
		     "webmanage_instance -t " . $webtask->task_id() . 
                     "  panic $uuid $opt $which",
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();

    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, "Internal error changing quarantine");
        }
        else {
            SPITAJAX_ERROR(-1, $webtask->output());
        }
        $webtask->Delete();
	return;
    }
    $webtask->Delete();
    SPITAJAX_RESPONSE("Success");
}

function Do_Linktest()
{
    global $instance, $this_user, $ajax_args, $urn_mapping;

    if (StatusSetupAjax(0)) {
	return;
    }
    if ($instance->paniced()) {
        SPITAJAX_ERROR(1, "This experiment has been quarantined.");
        return;
    }
    if (!isset($ajax_args["action"])) {
	SPITAJAX_ERROR(1, "Missing action");
	return;
    }
    $action = $ajax_args["action"];
    $uuid = $ajax_args["uuid"];
    $blob = array();
    $level = 1;

    if (isset($ajax_args["level"])) {
        $level = $ajax_args["level"];
        if (!preg_match("/^\d+$/", $level) || $level < 1 || $level > 4) {
            SPITAJAX_ERROR(1, "Bad level request");
            return;
        }
    }

    if ($action == "start") {
        if ($instance->status() == "linktest") {
            SPITAJAX_ERROR(1, "Linktest already running");
            return;
        }
        $webtask = WebTask::CreateAnonymous();
        $retval = SUEXEC("nobody", "nobody",
                         "webmanage_instance -t " . $webtask->task_id() .
                         " linktest $uuid $level",
                         SUEXEC_ACTION_IGNORE);
        $webtask->Refresh();

        if ($retval != 0) {
            if (!$webtask->exited() || $retval < 0) {
                SUEXECERROR(SUEXEC_ACTION_CONTINUE);
                SPITAJAX_ERROR(-1, "Internal error starting linktest");
            }
            else {
                SPITAJAX_ERROR(1, "Could not start linktest: ".
                               $webtask->output());
            }
            $webtask->Delete();
            return;
        }
        # This one does not tell us anything.
        $webtask->Delete();
        # Look at per sliver.
        foreach ($instance->slivers() as $sliver) {
            if ($sliver->webtask_id() &&
                $webtask = WebTask::Lookup($sliver->webtask_id())) {

                if (!($sliver->physnode_count() || $sliver->virtnode_count())) {
                    continue;
                }
                $tmp = array();
                $tmp["status"] = $webtask->TaskValue("status");
                if ($webtask->TaskValue("status") == "running") {
                    $tmp["url"] = $webtask->TaskValue("url");
                }
                else {
                    $tmp["results"] = $webtask->TaskValue("results");
                }
                $blob[$urn_mapping[$sliver->aggregate_urn()]] = $tmp;
            }
        }
        SPITAJAX_RESPONSE($blob);
    }
    elseif ($action == "stop") {
        if ($instance->status() != "linktest") {
            SPITAJAX_RESPONSE(0);
            return;
        }
        $webtask = WebTask::CreateAnonymous();
        $retval = SUEXEC("nobody", "nobody",
                         "webmanage_instance -t " . $webtask->task_id() .
                         "  linktest $uuid -k",
                         SUEXEC_ACTION_IGNORE);
        $webtask->Refresh();

        if ($retval != 0) {
            if (!$webtask->exited() || $retval < 0) {
                SUEXECERROR(SUEXEC_ACTION_CONTINUE);
                SPITAJAX_ERROR(-1, "Internal error stopping  linktest");
            }
            else {
                SPITAJAX_ERROR(1, "Could not stop linktest: ".
                               $webtask->output());
            }
            $webtask->Delete();
            return;
        }
        SPITAJAX_RESPONSE(0);
        $webtask->Delete();
    }
    else {
       SPITAJAX_ERROR(-1, "Improper lintest action"); 
    }
}

#
# Clear the extension denied flag; user has seen it and dismissed it.
#
function Do_DismissExtensionDenied()
{
    global $this_user;
    global $ajax_args;

    if (!isset($this_user)) {
	SPITAJAX_ERROR(1, "Not enough permission.");
	return;
    }
    $this_idx = $this_user->uid_idx();

    if (!isset($ajax_args["uuid"])) {
	SPITAJAX_ERROR(1, "Missing instance uuid");
	return;
    }
    $uuid = $ajax_args["uuid"];
    $instance = Instance::Lookup($uuid);
    if (!$instance) {
	SPITAJAX_ERROR(1, "Unknown instance uuid");
	return;
    }
    if (!DBQueryWarn("update apt_instances set extension_denied='0' ".
                     "where uuid='$uuid'")) {
	SPITAJAX_ERROR(1, "Database failure.");
	return;
    }
    SPITAJAX_RESPONSE("Success");
}

#
# Blob of experiment info
#
function Do_ExpInfo()
{
    global $instance, $creator;

    if (StatusSetupAjax(0)) {
	return;
    }
    $slice = GeniSlice::Lookup("sa", $instance->slice_uuid());
    if (!$slice) {
	SPITAJAX_ERROR(1, "no slice for instance");
	return 1;
    }
    $profile = Profile::Lookup($instance->profile_id(),
			       $instance->profile_version());
    
    $blob = array();
    $blob["expires"]      = DateStringGMT($slice->expires());
    $blob["created"]      = DateStringGMT($instance->created());
    $blob["start_at"]     = DateStringGMT($instance->start_at());
    $blob["stop_at"]      = DateStringGMT($instance->stop_at());
    $blob["started"]      = DateStringGMT($instance->started());
    $blob["creator"]      = $creator->uid();
    $blob["creator_email"]= $creator->email();
    $blob["project"]      = $instance->pid();
    $blob["group"]        = $instance->gid();
    $blob["name"]         = $instance->name();
    $blob["uuid"]         = $instance->uuid();
    $blob["status"]       = $instance->status();
    $blob["params"]       = ($instance->params() ?
                             json_decode($instance->params()) : null);
    $blob["repourl"]      = $instance->repourl();
    $blob["reporef"]      = $instance->reporef();
    $blob["repohash"]     = $instance->repohash();
    # If we have params (bindings), then we want to provide the paramdefs too.
    if ($instance->paramdefs()) {
        $blob["paramdefs"] = json_decode($instance->paramdefs());
    }
    elseif (isset($profile) && $profile->paramdefs()) {
        $blob["paramdefs"] = json_decode($profile->paramdefs());
    }
    else {
        $blob["paramdefs"] = null;
    }
    if (isset($profile)) {
        $blob["profile_name"] = $profile->name();
        $blob["profile_uuid"] = $profile->uuid();
    }
    else {
        $blob["profile_name"] = "unknown";
        $blob["profile_uuid"] = null;
    }
    $blob["physnode_count"]  = intval($instance->physnode_count());
    $blob["virtnode_count"]  = intval($instance->virtnode_count());
    $blob["physnode_hours"]  = 
            ($instance->physnode_count() *
             ((time() - strtotime($instance->started())) / 3600));
    $blob["user_lockdown"]   = $instance->user_lockdown() ? true : false;
    $blob["admin_lockdown"]  = $instance->admin_lockdown() ? true : false;
    $blob["paniced"]         = $instance->paniced() ? true : false;
    $blob["lockout"]         = $instance->extension_disabled() ? true : false;
    if (ISADMIN() && $instance->admin_notes()) {
        $blob["admin_notes"] = $instance->admin_notes();
    }
    else {
        $blob["admin_notes"] = "";
    }
    #
    # Extension stuff
    #
    $eblob = array();

    $eblob["extension_denied"] =
        ($instance->extension_denied() ? true : false);
    $eblob["extension_reason"] =
        ($instance->extension_reason() ?
         $instance->extension_reason() : "");
    $eblob["extension_denied_reason"] =
        ($instance->extension_denied_reason() ?
         $instance->extension_denied_reason() : "");
    $eblob["extension_disabled_reason"] =
        ($instance->extension_disabled_reason() ?
         $instance->extension_disabled_reason() : "");

    $extensions      = ExtensionInfo::LookupForInstance($instance);
    if (count($extensions)) {
        $foo = array();
        foreach ($extensions as $extension) {
            $foo[$extension->idx()] = $extension->info;
        }
        $eblob["extensions"] = $foo;
    }
    $blob["extension_info"] = $eblob;
    
    SPITAJAX_RESPONSE($blob);
}

#
# utilization
#
function Do_Utilization()
{
    global $instance, $creator;
    global $urn_mapping, $TBADMINGROUP;

    if (StatusSetupAjax(0)) {
	return;
    }
    $uuid = $instance->uuid();
    $slice = GeniSlice::Lookup("sa", $instance->slice_uuid());
    if (!$slice) {
	SPITAJAX_ERROR(1, "no slice for instance");
	return 1;
    }
    $webtask = WebTask::CreateAnonymous();
    # XXX Need to do this as elabman cause of emulab.key. Pondering.
    $retval = SUEXEC("elabman", $TBADMINGROUP,
		     "webmanage_instance -t " . $webtask->task_id() . " -- ".
                     "  utilization $uuid",
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();

    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, "Internal error getting utilization");
        }
        else {
            SPITAJAX_ERROR($webtask->exitcode(), $webtask->output());
        }
        $webtask->Delete();
        return;
    }
    $results = $webtask->TaskValue("results");
    $blob = array();
    # Look at per sliver.
    foreach ($instance->slivers() as $sliver) {
        if (!($sliver->physnode_count() || $sliver->virtnode_count())) {
            continue;
        }
        $blob[$urn_mapping[$sliver->aggregate_urn()]] = 
            $results[$sliver->aggregate_urn()];
    }
    $webtask->Delete();
    SPITAJAX_RESPONSE($blob);
}

#
# idledata
#
function Do_IdleData()
{
    global $instance, $creator;
    global $urn_mapping, $TBADMINGROUP;

    if (StatusSetupAjax(0)) {
	return;
    }
    $uuid = $instance->uuid();
    $slice = GeniSlice::Lookup("sa", $instance->slice_uuid());
    if (!$slice) {
	SPITAJAX_ERROR(1, "no slice for instance");
	return 1;
    }

    #
    # This can be a lot of data, so lets not go through the DB
    # (via the webtask). Pass a temp file name to the backend.
    #
    $filename = tempnam("/tmp", "idledata");
    $fp = fopen($filename, "w+");
    chmod($filename, 0666);        
    
    $webtask = WebTask::CreateAnonymous();
    # XXX Need to do this as elabman cause of emulab.key. Pondering.
    $retval = SUEXEC("elabman", $TBADMINGROUP,
		     "webmanage_instance -t " . $webtask->task_id() . " -- ".
                     "  idledata $uuid -o $filename",
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();

    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, "Internal error getting utilization");
        }
        else {
            SPITAJAX_ERROR($webtask->exitcode(), $webtask->output());
        }
        unlink($filename);
        $webtask->Delete();
        return;
    }
    $webtask->Delete();
    $blob = array();

    while (($urn = fgets($fp, 0x1000)) !== false) {
        $json = "";
        
        #
        # First line is an aggregate urn. Now suck up the next very
        # big line until the newline.
        #
        while (($buffer = fgets($fp, 0x4000)) !== false) {
            $json = $json . $buffer;

            if ($buffer[strlen($buffer)-1] == "\n") {
                break;
            }
        }
        $urn  = rtrim($urn);
        $json = rtrim($json);

        # This happens occasionally. 
        if ($json == "") {
            continue;
        }
        # Send back the raw json. 
        $blob[$urn_mapping[$urn]] = $json;
    }
    fclose($fp);
    unlink($filename);
    SPITAJAX_RESPONSE($blob);
}

#
# openstack stats
#
function Do_OpenstackStats()
{
    global $instance, $creator, $TBADMINGROUP;

    if (StatusSetupAjax(0)) {
	return;
    }
    $uuid = $instance->uuid();
    $webtask = WebTask::CreateAnonymous();
    # XXX Need to do this as elabman cause of emulab.key. Pondering.
    $retval = SUEXEC("elabman", $TBADMINGROUP,
		     "webmanage_instance -t " . $webtask->task_id() . " -- ".
                     "  openstackstats $uuid",
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();

    if ($retval != 0) {
        if ($webtask->exited()) {
            SPITAJAX_ERROR($webtask->exitcode(), $webtask->TaskValue("output"));
        }
        elseif ($retval < 0) {
            SPITAJAX_ERROR($retval, "Internal error, cannot proceed.");
            # Notify tbops.
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
        }
        else {
            SPITAJAX_ERROR($retval, $suexec_output);
        }
        $webtask->Delete();
        return;
    }
    $blob = $webtask->TaskValue("openstackstats");
    $webtask->Delete();
    SPITAJAX_RESPONSE($blob);
}

#
# Max extension allowed.
#
function Do_MaxExtension()
{
    global $instance, $creator, $TBADMINGROUP, $suexec_output;

    if (0) {
        $blob = "2017-11-06T18:09:59Z";
        SPITAJAX_RESPONSE($blob);
        return;
    }

    if (StatusSetupAjax(0)) {
	return;
    }
    $uuid = $instance->uuid();
    $webtask = WebTask::CreateAnonymous();
    # XXX Need to do this as elabman cause of emulab.key. Pondering.
    $retval = SUEXEC("elabman", $TBADMINGROUP,
		     "webmanage_instance -t " . $webtask->task_id() . " -- ".
                     "  maxextension $uuid",
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();

    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, "Unable to extend your experiment at this ".
                           "time, please try again later");
        }
        elseif ($webtask->exitcode() == GENIRESPONSE_REFUSED) {
            SPITAJAX_ERROR($webtask->exitcode(),
                           "No extension is possible at this time because of ".
                           "prior commitments to other projects or users.");
        }
        else {
            SPITAJAX_ERROR(1, "Unable to extend your experiment at this ".
                           "time: ". $webtask->output());
        }
        $webtask->Delete();
        return;
    }
    $blob = array("maxextension" => $webtask->TaskValue("MaxExtension"),
                  "reservations" => $webtask->TaskValue("Reservations"));
    $webtask->Delete();
    SPITAJAX_RESPONSE($blob);
}

function Do_GetRspec()
{
    global $instance;

    if (StatusSetupAjax(0)) {
	return;
    }
    SPITAJAX_RESPONSE($instance->rspec());
}

# Fetch overall cluster aggregate health status.
# Can be done without logging in (for front page status).
function Do_GetHealthStatus()
{
    global $ajax_args, $PORTAL_HEALTH;
    $amlist     = array();
    $fedlist    = array();
    $status     = array();
    $PORTAL_HEALTH = 1;
    CalculateAggregateStatus($amlist, $fedlist, $status);
    SPITAJAX_RESPONSE($status);
}

function Do_WarnExperiment()
{
    global $instance, $creator, $this_user;
    global $ajax_args;
    $this_uid = $this_user->uid();
    $options  = "";

    # Really, only admins can do this.
    if (StatusSetupAjax(0)) {
	goto bad;
    }
    $uuid = $instance->uuid();
    $slice = GeniSlice::Lookup("sa", $instance->slice_uuid());
    if (!$slice) {
	SPITAJAX_ERROR(1, "no slice for instance");
	goto bad;
    }
    if (!ISADMIN()) {
	SPITAJAX_ERROR(1, "You do not have permission to do this.");
	goto bad;
    }
    if (isset($ajax_args["reason"]) && $ajax_args["reason"] != "") {
        $reason = $ajax_args["reason"];
        
        if (!TBvalid_html_fulltext($reason)) {
	    SPITAJAX_ERROR(1, "Illegal characters in message");
	    goto bad;
        }
        $filename = tempnam("/tmp", "reason");
        $fp = fopen($filename, "w");
        fwrite($fp, $reason);
        fclose($fp);
        chmod($filename, 0666);        
        $options = "-f $filename ";
    }
    # Terminate or Quarantine experiment
    if (isset($ajax_args["terminate"]) && $ajax_args["terminate"]) {
        $options .= "-T ";
    }
    elseif (isset($ajax_args["quarantine"]) && $ajax_args["quarantine"]) {
        $options .= "-Q ";
        if (isset($ajax_args["poweroff"]) && $ajax_args["poweroff"]) {
            $options .= "-P ";
        }
    }
    # Freeze user
    if (isset($ajax_args["freeze"]) && $ajax_args["freeze"]) {
        $options .= "-F ";
    }
    $webtask = WebTask::CreateAnonymous();
    $retval = SUEXEC($this_uid, "nobody",
		     "webmanage_instance -t " . $webtask->task_id() . " -- ".
                     "  warn $uuid $options ",
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();
    if (isset($filename)) {
        unlink($filename);
    }
    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, "Internal error");
        }
        else {
            # Need to pass exitcode through on this one.
            SPITAJAX_ERROR($webtask->exitcode(), $webtask->output());
        }
        $webtask->Delete();
        return;
    }
    $webtask->Delete();
    SPITAJAX_RESPONSE("Success");
    return;
bad:
    sleep(1);
}

#
# Put a node into recovery mode
#
function Do_Recovery()
{
    global $instance, $creator, $this_user;
    global $ajax_args;
    $opt = "";

    if (StatusSetupAjax(1)) {
	return;
    }
    if ($instance->paniced()) {
        SPITAJAX_ERROR(1, "This experiment has been quarantined.");
        return;
    }
    if (!isset($ajax_args["node"])) {
	SPITAJAX_ERROR(1, "Missing node argument");
	return 1;
    }
    $node = $ajax_args["node"];
    $uuid = $instance->uuid();
    $slice = GeniSlice::Lookup("sa", $instance->slice_uuid());
    if (!$slice) {
	SPITAJAX_ERROR(1, "no slice for instance");
	return 1;
    }
    if (isset($ajax_args["clear"]) && $ajax_args["clear"]) {
        $opt = "-c";
    }
    $webtask = WebTask::CreateAnonymous();
    $retval = SUEXEC("nobody", "nobody",
		     "webmanage_instance -t " . $webtask->task_id() . " ".
                     "  recovery $uuid $opt " . escapeshellarg($node),
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();

    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, "Internal error setting recovery mode");
        }
        else {
            # JS needs this exitcode.
            SPITAJAX_ERROR($webtask->exitcode(),
                           "Could not set recovery mode: ". $webtask->output());
        }
        $webtask->Delete();
	return;
    }
    $webtask->Delete();
    SPITAJAX_RESPONSE(1);
    return;
}

#
# Flash a new FPGA image onto a radio
#
function Do_Flash()
{
    global $instance, $creator, $this_user;
    global $ajax_args;
    $opt = "";

    if (StatusSetupAjax(1)) {
	return;
    }
    if (!isset($ajax_args["node"])) {
	SPITAJAX_ERROR(1, "Missing node argument");
	return 1;
    }
    $node = $ajax_args["node"];
    $uuid = $instance->uuid();
    $slice = GeniSlice::Lookup("sa", $instance->slice_uuid());
    if (!$slice) {
	SPITAJAX_ERROR(1, "no slice for instance");
	return 1;
    }
    $webtask = WebTask::CreateAnonymous();
    $retval = SUEXEC("nobody", "nobody",
		     "webmanage_instance -t " . $webtask->task_id() . " ".
                     "  flash $uuid $opt " . escapeshellarg($node),
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();

    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, "Internal error flashing radio");
        }
        else {
            # JS needs this exitcode.
            SPITAJAX_ERROR($webtask->exitcode(),
                           "Could not flash radio: ". $webtask->output());
        }
        $webtask->Delete();
	return;
    }
    $webtask->Delete();
    SPITAJAX_RESPONSE(1);
    return;
}

#
# Request top processes
#
function Do_Top()
{
    global $instance, $creator, $this_user;
    global $ajax_args, $TBDB_TRUST_LOCALROOT;

    if (StatusSetupAjax(0)) {
	return;
    }
    if (!isset($ajax_args["node"])) {
	SPITAJAX_ERROR(1, "Missing node argument");
	return 1;
    }
    $node = $ajax_args["node"];
    $uuid = $instance->uuid();
    $webtask = WebTask::CreateAnonymous();
    $retval = SUEXEC("nobody", "nobody",
		     "webmanage_instance -t " . $webtask->task_id() . " ".
                     "  top $uuid " . escapeshellarg($node),
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();

    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, "Internal error getting top info");
        }
        else {
            SPITAJAX_ERROR(1, "Could not get top info: ". $webtask->output());
        }
        $webtask->Delete();
	return;
    }
    SPITAJAX_RESPONSE($webtask->TaskValue("results"));
    $webtask->Delete();
    return;
}

#
# Delete nodes from an experiment
#
function Do_DeleteSite()
{
    global $this_user, $instance, $suexec_output;
    global $ajax_args;

    if (StatusSetupAjax(1)) {
	return;
    }
    if ($instance->paniced()) {
        SPITAJAX_ERROR(1, "This experiment has been quarantined.");
        return;
    }
    $this_idx = $this_user->uid_idx();
    $uuid = $ajax_args["uuid"];

    if (!isset($ajax_args["cluster"])) {
	SPITAJAX_ERROR(1, "Missing cluster list");
	return;
    }
    $cluster = $ajax_args["cluster"];
    if (!preg_match("/^[-\w]+$/", $cluster)) {

        SPITAJAX_ERROR(1, "Illegal characters in cluster");
        return;
    }
    if ($this_idx != $instance->creator_idx() && !ISADMIN()) {
	SPITAJAX_ERROR(1, "Not enough permission.");
	return;
    }
    if ($instance->status() != "ready") {
	SPITAJAX_ERROR(1, "Experiment is currently busy");
	return;
    }
    $aggregate = Aggregate::LookupByNickname($cluster);
    if (!$aggregate) {
	SPITAJAX_ERROR(1, "No such cluster");
	return;
    }
    $sliver = InstanceSliver::Lookup($instance, $aggregate->urn());
    if (!$sliver) {
	SPITAJAX_ERROR(1, "Not a cluster in this instance");
	return;
    }
    $urn = $aggregate->urn();
    #
    # Call out to the backend.
    #
    $webtask = WebTask::CreateAnonymous();
    $retval = SUEXEC("nobody", "nobody",
		     "webmanage_instance -t " . $webtask->task_id() .
                     "  deleteaggregates $uuid '$urn'",
		     SUEXEC_ACTION_IGNORE);
    $webtask->Refresh();

    if ($retval != 0) {
        if (!$webtask->exited() || $retval < 0) {
            SUEXECERROR(SUEXEC_ACTION_CONTINUE);
            SPITAJAX_ERROR(-1, "Internal error deleting site");
        }
        else {
            SPITAJAX_ERROR(1, $webtask->output());
        }
        $webtask->Delete();
	return;
    }
    $webtask->Delete();
    SPITAJAX_RESPONSE("Success");
}

# Local Variables:
# mode:php
# End:
?>
