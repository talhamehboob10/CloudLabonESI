#
# Given two full images I1 and I2:
#
# I. Basic:
#
# 1. create a shiny new delta image (imagedelta) I2.ddz.v2
# 2. create a shiny new full image (imageundelta) I2.ndz.v2 from I1 and delta
# 3. compare sigs of I2.ndz and I2.ndz.v2
#
# What we learn: imagedelta/undelta don't crash on the image in question,
# delta/undelta are correct at the level of the signature file.
#
# II. More advanced:
#
# 4. lay down I1.ndz on a ramdisk and optionally verify against sig [4]
# 5. lay down I2.ndz on a ramdisk and optionally verify against sig [4]
# 6. create an old school delta image (imagezip -D) I2.ddz from I2 disk, I1 sig
# 7. compare sigs of I2.ddz I2.ddz.v2
# 7a. if sigs don't compare [1], we compare I2.ddz.v2 against the I2 disk
#
# What we learn: imagezip and imagedelta delta creation are consistent.
#
# III. Over the top:
#
# 8.  apply delta I2.ddz.v2 to I1 disk (if I1 disk is large enough)
# 9.  compare contents of I1 and I2 disks [2]
# 10. load full I2.ndz.v2 image on I3 disk
# 11. compare contents of I2 and I3 disks [3]
#
# What we learn: new format files can be loaded (imagezip), actual on-disk
# contents are correct.
#
# What is left behind:
#
# I[12].ndz and I[12].ndz.sig:
#    the original files we were working on.
# I2.ddz.new and I2.ddz.new.sig (all phases):
#    I2 delta image created with imagedelta.
# I2.ddz and I2.ddz.sig (phase 2 and 3 only):
#    I2 delta image created with imagezip from I2 disk and I1 signature.
# I2.ndz.new and I2.ndz.new.sig (phase 3 only):
#    full I2 image created with imageundelta
# I2.ndz.clean and I2.ndz.clean.sig (phase 3 only):
#    "clean" (-F 0) full I2 image recreated with imagezip from I2 disk.
#
# Footnotes:
#
# [1] Since delta signatures generated by imagezip are imperfect,
#     the sigs may not match. To ensure their equivalence, we assume
#     the imagezip sig is correct and verify the other by checking it
#     against the on-disk image.
#
# [2] We cannot just "cmp" the two disks due to inexactness of the
#     delta created by imagedelta. It may include unused blocks that
#     will get propogate back to disk. Hence, we create new image files
#     from both disks using imagezip--with "-F 0" to ensure no free sects
#     are included--and byte compare those image files.
#
# [3] As with imagedelta, imageundelta is inexact and may have included
#     garbage sectors from the original image. We perform the same
#     comparison as in [2] instead.
#
# [4] A freshly unzipped image can has imagehash errors if the image has
#     relocations.
#
my $TMPDIR = "/local/tmp";
my $LOGDIR = "/local/logs";
my @NEEDBINS = ("imagezip", "imageunzip", "imagehash", "imagedump",
    "imagedelta", "imageundelta");

my $MINPHASE = 2;
my $MAXPHASE = 3;

my $MAXRDSECTORS = (20 * 1024 * 1024 * 2);
my $MAXSECTORS = (200 * 1024 * 1024 * 2);
my $LVMSTRIPE = 6;
my $MYID = $0;

# more aggressive checking of signatures
my $checksig = 1;

# do everything we can to fix signatures, (re)create them as necessary
my $fixsigs = 1;

# do not consider imagedump differences fatal
my $ignoreimagedump = 1;

# remove temporary disks on a test failure
my $cleanonfail = 1;

my $os = `uname`;
chomp($os);
if ($os !~ /^(Linux|FreeBSD)$/) {
    die "Unknown OS '$os'\n";
}
my $arch = `uname -m`;
chomp($arch);
if ($arch !~ /^(x86_32|x86_64|aarch64|i386|amd64)$/) {
    die "Unknown arch '$arch'\n";
}
my $bindir = "/images/bin/${os}_${arch}";

foreach my $bin (@NEEDBINS) {
    if (! -x "$bindir/$bin") {
	die "Cannot find $bindir/$bin\n";
    }
}

if (@ARGV != 2) {
    print STDERR "Usage: testdelta.pl imageV1.ndz imageV2.ndz\n";
    exit(1);
}

my $uid = $>;
if ($uid == 0) {
    print STDERR "Do not run as root, script will sudo when necessary\n";
    exit(1);
}

my $tstamp = time();
my $logfile = "$LOGDIR/$MYID.$tstamp.log";
logit("Comparing '$ARGV[0]' and '$ARGV[1]'");
logit("Log is $logfile");

my %image1 = ( "name" => $ARGV[0] );
my %image2 = ( "name" => $ARGV[1] );

my $rv = 0;
if ($MINPHASE <= 1 && $MAXPHASE > 0) {
    $rv = phase1(\%image1, \%image2);
}
if ($rv == 0 && $MINPHASE <= 2 && $MAXPHASE > 1) {
    $rv = phase2(\%image1, \%image2);
}
if ($rv == 0 && $MINPHASE <= 3 && $MAXPHASE > 2) {
    $rv = phase3(\%image1, \%image2);
} elsif ($rv == 0 && $MINPHASE <= 2 && $MAXPHASE > 1) {
    unmakedisk($image2{'name'}, $image2{'disk'}, $image2{'suffix'});
    unmakedisk($image1{'name'}, $image1{'disk'}, $image1{'suffix'});
}

# XXX hack post-check of imagedump info of created images
if ($rv == 0 && $MINPHASE == 4 && $MAXPHASE == 4) {
    $ignoreimagedump = 1;
    $rv = phase4($image2{'name'});
}
exit($rv);

#
# I. Basic:
#
# 1. create a shiny new delta image (imagedelta) I2.ddz.v2
# 2. create a shiny new full image (imageundelta) I2.ndz.v2 from I1 and delta
# 3. compare sigs of I2.ndz and I2.ndz.v2
#
sub phase1($$)
{
    my ($image1,$image2) = @_;
    my $fixedsig = 0;

    my $imagev1 = $image1->{'name'};
    my $imagev2 = $image2->{'name'};

    logit("START signature check of both images");
    if (sigcheck($imagev1) || sigcheck($imagev2)) {
	logit("FAILED signature check of both images");
	return 1;
    }
    logit("END signature check of both images");

    my $delta = $imagev2;
    $delta =~ s/ndz/ddz/;
    if ($imagev2 eq $delta) {
	logit("  $imagev2: malformed name, no .ndz");
	return 1;
    }

    logit("START image2 delta creation");
again:
    if (mysystem("$bindir/imagedelta -SVF $imagev1 $imagev2 $delta.new", 0)) {
	#
	# The verification pass of imagedelta requires that any hash range
	# falls completely in a single chunk or it has the magic high-bit
	# set in the chunk number. We apparently have some images where
	# the high bit is not properly set, triggering a verification failure.
	# To get around this, we regenerate the faulty signature file.
	#
	logit("  WARNING: could not generate delta image");
	if ($fixsigs && $fixedsig < 2) {
	    my $nimage = ($fixedsig ? $imagev2 : $imagev1);

	    logit("  recreating signature for $nimage...");
	    mysystem("mv $nimage.sig $nimage.bak.sig");
	    if (!mysystem("$bindir/imagehash -qcX $nimage")) {
		logit("  validating new signature for $nimage...");
		if (!comparesigfiles("$nimage.bak", $nimage, 0)) {
		    unlink("$nimage.bak.sig");
		    logit("RESTART image2 delta creation");
		    $fixedsig++;
		    goto again;
		}
		unlink("$nimage.sig");
	    }
	    mysystem("mv $nimage.bak.sig $nimage.sig");
	}
	logit("FAILED image2 delta creation");
	return 1;
    }

    #
    # If there was no error and no delta, they must have been identical.
    # We really should remove this as a test case, so just bail early.
    if (! -e "$delta.new") {
	if (mysystem("cmp $imagev1 $imagev2") == 0) {
	    logit("  *** $imagev1 and $imagev2 are identical, quitting early");
	    logit("END image2 delta creation");
	    exit(0);
	}
	logit("  *** no delta produced for $imagev1 and $imagev2,".
	      " but not identical!?");
	logit("FAILED image2 delta creation");
	return 1;
    }
    logit("END image2 delta creation");

    #
    # Certain structural attributes of the original and the delta should
    # be the same.
    #
    logit("START imagedump compare of image2 and delta.new");
    if (compareimageshape($imagev2, "$delta.new")) {
	logit("FAILED imagedump compare of image2 and delta.new");
	return 1;
    }
    logit("END imagedump compare of image2 and delta.new");

    logit("START undelta to image2.new");
    if (mysystem("$bindir/imageundelta -SV $imagev1 $delta.new $imagev2.new")) {
	logit("FAILED undelta to image2.new");
	return 1;
    }
    logit("END undelta to image2.new");

    logit("START signature compare of image2 and image2.new");
    if (comparesigfiles($imagev2, "$imagev2.new", 1)) {
	logit("  $imagev2.new: signature mismatch with $imagev2");
	logit("FAILED signature compare of image2 and image2.new");
	return 1;
    }
    logit("END signature compare of image2 and image2.new");

    logit("START imagedump compare of image2 and image2.new");
    if (compareimageshape($imagev2, "$imagev2.new")) {
	logit("FAILED imagedump compare of image2 and image2.new");
	return 1;
    }
    logit("END imagedump compare of image2 and image2.new");

    return 0;
}

#
# II. More advanced:
#
# 4. lay down I1.ndz on a ramdisk and optionally verify against sig
# 5. lay down I2.ndz on a ramdisk and optionally verify against sig
# 6. create an old school delta image (imagezip -D) I2.ddz from I2 disk, I1 sig
# 7. compare sigs of I2.ddz I2.ddz.v2
#
sub phase2($$)
{
    my ($image1,$image2) = @_;

    my $imagev1 = $image1->{'name'};
    my $imagev2 = $image2->{'name'};
    my $sufv1 = "v1";
    my $sufv2 = "v2";

    #
    # XXX relocs are wrong in LILO Linux images. Just skip them...
    #
    if ($imagev1 =~ /RHL\d+/ || $imagev2 =~ /RHL\d+/) {
	logit("  WARNING: cannot zip/unzip RHL images, calling it a day...");
	return 0;
    }

    my $delta = $imagev2;
    $delta =~ s/ndz/ddz/;
    if ($imagev2 eq $delta) {
	logit("  $imagev2: malformed name, no .ndz");
	return 1;
    }

    logit("START unzip of image1");
    my ($devv1,$ssizev1) = unzipimage($imagev1, $sufv1);
    if (!$devv1) {
	logit("FAILED unzip of image1");
	return 1;
    }
    logit("END unzip of image1");

    if ($checksig) {
	logit("START signature check of image1 on disk");
	if (comparesigtodisk($imagev1, $devv1)) {
	    logit("FAILED signature check of image1 on disk");
	    unmakedisk($imagev1, $devv1, $sufv1) if ($cleanonfail);
	    return 1;
	}
	logit("END signature check of image1 on disk");
    }

    logit("START unzip of image2");
    my ($devv2,$ssizev2) = unzipimage($imagev2, $sufv2);
    if (!$devv2) {
	logit("FAILED unzip of image2");
	unmakedisk($imagev1, $devv1, $sufv1) if ($cleanonfail);
	return 1;
    }
    logit("END unzip of image2");

    if ($checksig) {
	logit("START signature check of image2 on disk");
	if (comparesigtodisk($imagev2, $devv2)) {
	    logit("FAILED signature check of image2 on disk");
	    unmakedisk($imagev2, $devv2, $sufv2) if ($cleanonfail);
	    unmakedisk($imagev1, $devv1, $sufv1) if ($cleanonfail);
	    return 1;
	}
	logit("END signature check of image2 on disk");
    }

    logit("START create imagezip delta of image2 from disk");
    if (zipimage($delta, "$imagev1.sig", $devv2, $ssizev2)) {
	if ($delta =~ /FBSD/) {
	    logit("  WARNING: probably failed due to lack of relocations");
	}
	logit("FAILED create imagezip delta of image2 from disk");
	unmakedisk($imagev2, $devv2, $sufv2) if ($cleanonfail);
	unmakedisk($imagev1, $devv1, $sufv1) if ($cleanonfail);
	return 1;
    }
    logit("END create imagezip delta of image2 from disk");

    #
    # Hashmaps for delta images produced by imagezip are less than
    # perfect as they can split a contiguous range in the new image if
    # the corresponding range in the old image was not fully populated
    # (and probably under other conditions too!)
    #
    if (-e "$delta.new") {
	logit("START image sigfile compare for deltas");
	# returns -1 if files are missing
	my $rv = comparesigfiles($delta, "$delta.new", 0);
	if ($rv > 0) {
	    logit("  WARNING: delta signature mismatch, ".
		  "comparing new sig with image");
	    $rv = comparesigtodisk("$delta.new", $devv2);
	    if ($rv) {
		logit("  *** $delta.new.sig is bad!");
	    }
	}
	if ($rv) {
	    logit("ERROR image sigfile compare for deltas");
	    unmakedisk($imagev2, $devv2, $sufv2) if ($cleanonfail);
	    unmakedisk($imagev1, $devv1, $sufv1) if ($cleanonfail);
	    return 1;
	}
	logit("END image sigfile compare for deltas");
    }

    $image1->{'disk'} = $devv1;
    $image2->{'disk'} = $devv2;
    $image1->{'disksize'} = $ssizev1;
    $image2->{'disksize'} = $ssizev2;
    $image1->{'suffix'} = $sufv1;
    $image2->{'suffix'} = $sufv2;
    return 0;
}

#
# III. Over the top:
#
# 8.  apply delta I2.ddz.v2 to I1 disk (if possible)
# 9.  compare contents of I1 and I2 disks (if #8 done)
# 10. load full I2.ndz.v2 image on I3 disk
# 11. compare contents of I2 and I3 disks
#
sub phase3($$)
{
    my ($image1,$image2) = @_;

    my $imagev1 = $image1->{'name'};
    my $devv1 = $image1->{'disk'};
    my $ssizev1 = $image1->{'disksize'};
    my $sufv1 = $image1->{'suffix'};
    my $imagev2 = $image2->{'name'};
    my $devv2 = $image2->{'disk'};
    my $ssizev2 = $image2->{'disksize'};
    my $sufv2 = $image2->{'suffix'};

    my $delta = $imagev2;
    $delta =~ s/ndz/ddz/;
    if ($imagev2 eq $delta) {
	logit("  $imagev2: malformed name, no .ndz");
	unmakedisk($imagev2, $devv2, $sufv2) if ($cleanonfail);
	unmakedisk($imagev1, $devv1, $sufv1) if ($cleanonfail);
	return 1;
    }

    logit("START unzip of delta.new onto image1 disk");

    #
    # I1 disk has to be large enough for I2 image, or deltaing-up
    # won't work.
    #
    my $skipi1 = 0;
    if ($ssizev1 < $ssizev2) {
	logit("  WARNING: image1 disk not large enough for delta");
	logit("SKIPPED unzip of delta.new onto image1 disk");
	$skipi1 = 1;
	goto skipped;
    }
    
    if (applydelta("$delta.new", $devv1)) {
	logit("FAILED unzip of delta.new onto image1 disk");
	unmakedisk($imagev2, $devv2, $sufv2) if ($cleanonfail);
	unmakedisk($imagev1, $devv1, $sufv1) if ($cleanonfail);
	return 1;
    }
    logit("END unzip of delta.new onto image1 disk");

    logit("START clean zip of image1+delta disk");
    if (zipimage("$imagev2.fromdelta", undef, $devv1, $ssizev1, "-F 0 -x")) {
	logit("FAILED clean zip of image1+delta disk");
	unmakedisk($imagev2, $devv2, $sufv2) if ($cleanonfail);
	unmakedisk($imagev1, $devv1, $sufv1) if ($cleanonfail);
	return 1;
    }
    logit("END clean zip of image1+delta disk");

    logit("START clean zip of image2 disk");
    if (zipimage("$imagev2.fromold", undef, $devv2, $ssizev2, "-F 0 -x")) {
	logit("FAILED clean zip of image2 disk");
	unmakedisk($imagev2, $devv2, $sufv2) if ($cleanonfail);
	unmakedisk($imagev1, $devv1, $sufv1) if ($cleanonfail);
	return 1;
    }
    logit("END clean zip of image2 disk");

    logit("START compare image1+delta to image2 contents");
    if (compareimages("$imagev2.fromdelta", "$imagev2.fromold", 0)) {
	logit("FAILED compare image1+delta to image2 contents");
	unmakedisk($imagev2, $devv2, $sufv2) if ($cleanonfail);
	unmakedisk($imagev1, $devv1, $sufv1) if ($cleanonfail);
	return 1;
    }
    logit("END compare image1+delta to image2 contents");

skipped:
    # done with image1 disk
    unlink("$imagev2.fromdelta", "$imagev2.fromdelta.sig");
    unmakedisk($imagev1, $devv1, $sufv1);

    logit("START unzip of image2.new");
    my $imagev3 = "$imagev2.new";
    my ($devv3,$ssizev3) = unzipimage($imagev3, "new");
    if (!$devv3) {
	logit("FAILED unzip of image2.new");
	unmakedisk($imagev2, $devv2, $sufv2) if ($cleanonfail);
	return 1;
    }
    logit("END unzip of image2.new");

    if ($checksig) {
	logit("START signature check of image2.new on disk");
	if (comparesigtodisk($imagev3, $devv3)) {
	    logit("FAILED signature check of image2.new on disk");
	    unmakedisk($imagev3, $devv3, "new") if ($cleanonfail);
	    unmakedisk($imagev2, $devv2, $sufv2) if ($cleanonfail);
	    return 1;
	}
	logit("END signature check of image2.new on disk");
    }

    if ($skipi1) {
	logit("START clean zip of image2 disk");
	if (zipimage("$imagev2.fromold", undef, $devv2, $ssizev2, "-F 0 -x")) {
	    logit("FAILED clean zip of image2 disk");
	    unmakedisk($imagev3, $devv3, "new") if ($cleanonfail);
	    unmakedisk($imagev2, $devv2, $sufv2) if ($cleanonfail);
	    return 1;
	}
	logit("END clean zip of image2 disk");
    }
    
    logit("START clean zip of image2.new disk");
    if (zipimage("$imagev2.clean", undef, $devv3, $ssizev3, "-F 0 -x")) {
	logit("FAILED clean zip of image2.new disk");
	unmakedisk($imagev3, $devv3, "new") if ($cleanonfail);
	unmakedisk($imagev2, $devv2, $sufv2) if ($cleanonfail);
	return 1;
    }
    logit("END clean zip of image2.new disk");

    logit("START compare image2 to image2.new contents");
    if (compareimages("$imagev2.fromold", "$imagev2.clean", 0)) {
	logit("FAILED compare image2 to image2.new contents");
	unmakedisk($imagev3, $devv3, "new") if ($cleanonfail);
	unmakedisk($imagev2, $devv2, $sufv2) if ($cleanonfail);
	return 1;
    }
    logit("END compare image2 to image2.new contents");

    # done with all disks
    unmakedisk($imagev2, $devv2, $sufv2);
    unlink("$imagev2.fromold", "$imagev2.fromold.sig");
    unmakedisk($imagev3, $devv3, "new");

    return 0;
}

sub phase4($)
{
    my $image = shift;

    my $delta = $image;
    $delta =~ s/ndz/ddz/;
    if ($image eq $delta) {
	logit("  $image: malformed name, no .ndz");
	return 1;
    }

    #
    # We may not have "new" versions of the image and delta if the
    # two images being compared were found to be the same.
    #
    if (! -e "$image.new" || ! -e "$delta.new") {
	logit("  WARNING: image2 image/delta do not exist");
	logit("SKIPPED imagedump compares");
	return 0;
    }

    #
    # Compare original image vs. imagedelta generated delta
    #
    logit("START imagedump compare of image2 and delta.new");
    if (compareimageshape($image, "$delta.new")) {
	logit("FAILED imagedump compare of image2 and delta.new");
	return 1;
    }
    logit("END imagedump compare of image2 and delta.new");

    #
    # Compare original image vs. imageundelta generated image
    #
    logit("START imagedump compare of image2 and image2.new");
    if (compareimageshape($image, "$image.new")) {
	logit("FAILED imagedump compare of image2 and image2.new");
	return 1;
    }
    logit("END imagedump compare of image2 and image2.new");

    #
    # Compare imagezip generated delta vs. imagedelta generated one.
    # Note: may not have generated one or both deltas.
    #
    logit("START imagedump compare of delta and delta.new");
    if (-e "$delta") {
	if (compareimageshape($delta, "$delta.new")) {
	    logit("FAILED imagedump compare of delta and delta.new");
	    return 1;
	}
	logit("END imagedump compare of delta and delta.new");
    } else {
	logit("SKIPPED imagedump compare of delta and delta.new");
    }
}

#
# Compare two images files.
#
# $how == 1: cmp the image files themselves (strongest)
# $how == 2: imageunzip -I the files, compare the streams
# $how == 4: dump and compare the signatures (weakest)
#
# $how == 0: try all three in order, return 0 if any succeed.
#
sub compareimages($$;$)
{
    my ($image1,$image2,$how) = @_;

    if (!$how || $how == 1) {
	if (!mysystem("cmp $image1 $image2")) {
	    return 0;
	}
	print "  WARNING: image file comparison fails, trying image stream\n"
	    if (!$how);
    }
    if (!$how || $how == 2) {
	if (!mysystem("$bindir/imageunzip -I $image1 - > $image1.raw") &&
	    !mysystem("$bindir/imageunzip -I $image2 - > $image2.raw") &&
	    !mysystem("cmp $image1.raw $image2.raw")) {
	    unlink("image1.raw", "image2.raw");
	    return 0;
	}
	unlink("image1.raw", "image2.raw");
	print "  WARNING: image stream comparison fails, trying image signature\n"
	    if (!$how);
    }
    if (!$how || $how == 3) {
	if (!comparesigfiles($image1, $image2, 0)) {
	    return 0;
	}
	print "  *** image signature comparison fails, images are not the same!\n"
	    if (!$how);
    }

    return 1;
}

sub sigcheck($)
{
    my $image = shift;

    if (! -e "$image") {
	print "  *** $image does not exist\n";
	return 1;
    }
    if (! -e "$image.sig") {
	if ($fixsigs) {
	    print "  WARNING: $image signature does not exist, creating one...\n";
	    if (mysystem("$bindir/imagehash -qcX $image")) {
		print "  *** could not generate signature for $image\n";
		return 1;
	    }
	    # no point in further checks
	    return 0;
	}
	print "  *** $image signature does not exist\n";
	return 1;
    }

    if ($checksig) {
	if (mysystem("$bindir/imagehash -qSX $image")) {
	    if ($fixsigs) {
		print "  WARNING: $image signature did not check, recreating\n";
		mysystem("mv $image.sig $image.bak.sig");
		if (!mysystem("$bindir/imagehash -qcX $image")) {
		    if (!mysystem("$bindir/imagehash -qSX $image")) {
			unlink("$image.bak.sig");
			return 0;
		    }
		}
		mysystem("mv $image.bak.sig $image.sig");
	    }
	    print "  *** $image signature did not check\n";
	    return 1;
	}

	# gen a new format sig file and compare
	if (mysystem("$bindir/imagehash -qcX -o ${image}.newsig.sig $image")) {
	    print "  *** could not generate signature for $image\n";
	    return 1;
	}
	if (comparesigfiles($image, "${image}.newsig", 1)) {
	    print "  *** new signature for $image does not match old\n";
	    unlink("${image}.newsig.sig");
	    return 1;
	}
	unlink("${image}.newsig.sig");
    }

    return 0;
}

sub comparesigfiles($$$)
{
    my ($image1,$image2,$bitchnmoan) = @_;

    if (mysystem("$bindir/imagehash -RTq -o $image1.sig > $image1.sig.txt")) {
	print "  *** could not dump signature for $image1\n";
	return -1;
    }
    if (mysystem("$bindir/imagehash -RTq -o $image2.sig > $image2.sig.txt")) {
	print "  *** could not dump signature for $image2\n";
	return -1;
    }
    if (mysystem("diff -q $image1.sig.txt $image2.sig.txt", 1)) {
	if ($bitchnmoan) {
	    print "  *** signatures for $image1 and $image2 differ ".
		"(diff $image1.sig.txt $image2.sig.txt)\n";
	} else {
	    unlink("$image1.sig.txt", "$image2.sig.txt");
	}
	return 1;
    }

    unlink("$image1.sig.txt", "$image2.sig.txt");
    return 0;
}

sub comparesigtodisk($$)
{
    my ($image,$dev) = @_;

    if (mysystem("sudo $bindir/imagehash -q $image $dev", 1)) {
	#
	# XXX imagehash can fail if the image has relocations.
	#
	if (imagerelocs($image) == 0) {
	    print "  *** signature check of $image on $dev failed\n";
	    return 1;
	}
	print "  WARNING: signature check of $image on $dev failed,".
	    " probably due to relocations; continuing\n";
    }

    return 0;
}

sub imageinfo($)
{
    my $image = shift;
    my ($losect,$hisect,$relocs,$warns) = (0,0,0,0);

    my @output = `$bindir/imagedump $image`;
    if ($?) {
	print "  *** imagedump failed on $image\n";
	return (-1,-1,-1,-1);
    }
    foreach my $line (@output) {
	chomp($line);
	if ($line =~ /covered sector range: \[(\d+)-(\d+)\]/) {
	    $losect = $1;
	    $hisect = $2;
	    last;
	}
	if ($line =~ /(\d+) relocations covering/) {
	    $relocs++;
	    next;
	}
	if ($checkwarns && $line =~ /WARNING: /) {
	    $warns++;
	    next;
	}
    }

    return ($losect,$hisect,$relocs,$warns);
}

sub compareimageshape($$)
{
    my ($imagev1,$imagev2) = @_;
    my $fails = 0;

    my @i1info = imageinfo($imagev1);
    my @i2info = imageinfo($imagev2);
    if ($i1info[0] < 0 || $i2info[0] < 0) {
	return -1;
    }

    if ($i1info[0] != $i2info[0]) {
	print "  WARNING: image low sectors disagree ".
	    "($i1info[0] != $i2info[0])\n";
	$fails++;
    } elsif ($i1info[0] != 0) {
	print "  WARNING: images do not start at 0\n";
	$fails++;
    }
    if ($i1info[1] != $i2info[1]) {
	print "  WARNING: image high sectors disagree ".
	    "($i1info[1] != $i2info[1])\n";
	$fails++;
    }
    if ($i1info[2] != $i2info[2]) {
	print "  WARNING: image relocation counts disagree ".
	    "($i1info[2] != $i2info[2])\n";
	$fails++;
    }
    if ($i1info[3] > 0) {
	print "  WARNING: $imagev1: imagedump reported $i1info[3] warnings\n";
	$fails++;
    }
    if ($i2info[3] > 0) {
	print "  WARNING: $imagev2: imagedump reported $i2info[3] warnings\n";
	$fails++;
    }	

    return $ignoreimagedump ? 0 : $fails;
}

sub zipimage($$$$;$)
{
    my ($image,$oldsig,$dev,$ssize,$moreargs) = @_;
    my $iargs = "";

    $iargs .= " -U $image.sig";
    if ($oldsig) {
	$iargs .= " -H $oldsig";
    }

    #
    # XXX always specify size to avoid issues with LVM virtual disks.
    #
    # LVM might round up the LV size which will cause imagezip
    # to record a larger last sector value for the final chunk.
    # This in turn will cause imagedump to report a different
    # "sectors covered" range than the original image.
    #
    $iargs .= " -c $ssize";

    #
    # XXX gak! Without an MBR/GPT, imagezip cannot (yet) figure out
    # what the filesystem is. We make a wild guess here based on image name.
    #
    my $ifile;
    if ($image =~ /([^\/]+)$/) {
	$ifile = $1;
    } else {
	$ifile = $image;
    }
    if ($ifile =~ /\+/) {
	# full image, don't need anything
	;
    } elsif ($image =~ /FBSD/) {
	# FreeBSD
	$iargs .= " -S 165";
	# XXX force relocs (-L) just for testing
	$iargs .= " -L";
    } elsif ($ifile =~ /WIN/) {
	# WIN XP or 7 are full disk images
	;
    } elsif ($ifile =~ /SYSTEM-UBUNTU12-BIGFS/) {
	;
    } else {
	# otherwise assume Linux
	$iargs .= " -S 131";
    }

    if ($moreargs) {
	$iargs .= " $moreargs";
    }

    if (mysystem("sudo $bindir/imagezip $iargs $dev $image")) {
	print "  *** imagezip of $image to $dev failed\n";
	return 1;
    }

    # XXX
    mysystem("sudo chown $uid $image $image.sig");

    return 0;
}

sub unzipimage($$)
{
    my ($image,$suf) = @_;
    my $dev = undef;

    # create a memdisk/LV for the image
    my $ssize = imagesize($image, 0);
    my $dev = makedisk($image, $ssize, $suf);
    if (!$dev) {
	print "  *** could not create disk with $ssize sectors\n";
	return $dev;
    }
    # and load it
    if (mysystem("sudo $bindir/imageunzip -f $image $dev")) {
	print "  *** could not unzip $image to $dev\n";
	unmakedisk($image, $dev, $suf) if ($cleanonfail);
	return $dev;
    }

    # optionally compare vs signature

    return ($dev,$ssize);
}

sub applydelta($$)
{
    my ($delta,$dev) = @_;

    # load it
    if (mysystem("sudo $bindir/imageunzip -f $delta $dev")) {
	print "  *** could not unzip delta image $delta to $dev\n";
	return 1;
    }

    return 0;
}

sub imagesize($)
{
    my $image = shift;
    my $warns = 0;

    my @output = `$bindir/imagedump $image`;
    if ($?) {
	print "  *** could not get size of $image\n";
	return 0;
    }
    foreach my $line (@output) {
	chomp($line);
	if ($line =~ /covered sector range: \[(\d+)-(\d+)\]/) {
	    $ssize = $2 + 1;
	    last;
	}
    }

    return $ssize;
}

sub imagerelocs($)
{
    my $image = shift;

    my @output = `$bindir/imagedump $image`;
    if ($?) {
	print "  *** could not get size of $image\n";
	return 0;
    }
    foreach my $line (@output) {
	chomp($line);
	if ($line =~ /(\d+) relocations covering/) {
	    return $1;
	}
    }

    return 0;
}

sub makedisk($$$)
{
    my ($image,$ssize,$suf) = @_;
    my ($istr,$dev);

    $suf = "" if (!defined($suf));
    if ($image =~ /([^\/]+)\/([^\/]+)$/) {
	$istr = "$MYID-$1-$2.$suf";
    } elsif ($image =~ /([^\/]+)$/) {
	$istr = "$MYID-$1.$suf";
    } else {
	print "  *** could not parse name '$image'\n";
	return undef;
    }
    $istr =~ s/:/./g;

    my $mb = int(($ssize + 2047) / 2048);
    $mb += 100;

    if ($os eq "Linux") {
	if ($ssize > $MAXSECTORS) {
	    print "  WARNING: image $image too large ($ssize) for unpacking,".
		" skipping\n";
	    return undef;
	}
	if ($ssize > $MAXRDSECTORS) {
	    print "  WARNING: image $image too large ($ssize) for ramdisk,".
		" using LV instead\n";
	    goto uselv;
	}

	# XXX there has to be a better way!
	#
	# mount -t tmpfs -o size=20580m tmpfs /mnt/FOO.ndz
	# dd if=/dev/zero of=/mnt/FOO.ndz/disk bs=1024k seek=20479 count=1
	# losetup -f
	# losetup /dev/loop0 /mnt/FOO.ndz/disk
	#
	my $mountpoint = "/mnt/$istr";
	if (!mkdir($mountpoint)) {
	    print "  *** could not make ramdisk mountpoint $mountpoint\n";
	    goto ramdiskfail;
	}
	if (mysystem("sudo mount -t tmpfs -o size=${mb}m tmpfs $mountpoint")) {
	    rmdir($mountpoint);
	    goto ramdiskfail;
	}
	my $mbm1 = $mb - 1;
	if (mysystem("sudo dd if=/dev/zero of=$mountpoint/disk bs=1024k seek=$mbm1 count=1")) {
	    mysystem("sudo umount $mountpoint");
	    rmdir($mountpoint);
	    goto ramdiskfail;
	}
	$dev = `sudo losetup -f`;
	chomp($dev);
	if (!$dev || mysystem("sudo losetup $dev $mountpoint/disk")) {
	    mysystem("sudo umount $mountpoint");
	    rmdir($mountpoint);
	    goto ramdiskfail;
	}
	return $dev;

ramdiskfail:
	print "  *** could not setup ramdisk, falling back to LV ...\n";
uselv:
	if (mysystem("sudo lvcreate -i $LVMSTRIPE -L ${mb}m -n $istr emulab")) {
	    print "  *** could not create LV for $image\n";
	    return undef;
	}
	return "/dev/emulab/$istr";
    }

    print "  *** cannot do this under $os yet\n";
    return $dev;
}

sub unmakedisk($$$)
{
    my ($image,$dev,$suf) = @_;
    my $istr;

    if (!$image || !$dev) {
	return 0;
    }

    $suf = "" if (!defined($suf));
    if ($image =~ /([^\/]+)\/([^\/]+)$/) {
	$istr = "$MYID-$1-$2.$suf";
    } elsif ($image =~ /([^\/]+)$/) {
	$istr = "$MYID-$1.$suf";
    } else {
	print "  *** could not parse name '$image'\n";
	return undef;
    }
    $istr =~ s/:/./g;

    if ($dev eq "/dev/emulab/$istr") {
	if (mysystem("sudo lvremove -f emulab/$istr")) {
	    print "  *** could not destroy LV emulab/$istr\n";
	    return -1;
	}
    } elsif (mysystem("sudo losetup -d $dev") ||
	     mysystem("sudo umount /mnt/$istr") ||
	     !rmdir("/mnt/$istr")) {
	print "  *** could not tear down ramdisk ($dev on /mnt/$istr)\n";
	return -1;
    }
    return 0;
}

sub mysystem($;$)
{
    my ($cmd,$quiet) = @_;
    my $now = localtime();
    my $redir;

    if (open(FD, ">>$logfile")) {
	print FD "==== $now: $cmd\n";
	close(FD);
    }

    if ($cmd =~ />/) {
	$redir = "2>>$logfile";
    } else {
	$redir = ">>$logfile 2>&1";
    }
    if (system("$cmd $redir")) {
	my $stat = $?;
	print "*** '$cmd' failed, see '$logfile'\n"
	    if (!$quiet);
	return $stat;
    }

    return 0;
}

sub logit($)
{
    my $msg = shift;
    my $pid = $$;

    my $elapsed = int(time() - $tstamp);
    printf "%05d: +%03d: %s\n", $pid, $elapsed, $msg;
}
