--- dist-ns-allinone-2.26/ns-2.26/trace/cmu-trace.cc	Wed Feb 26 15:11:29 2003
+++ ns-allinone-2.26/ns-2.26/trace/cmu-trace.cc	Fri Nov 28 16:55:25 2003
@@ -941,6 +941,8 @@
 		case PT_GAF:
 		case PT_PING:
 			break;
+		case PT_LIVE:
+			break;
 		default:
 			fprintf(stderr, "%s - invalid packet type (%s).\n",
 				__PRETTY_FUNCTION__, packet_info.name(ch->ptype()));
--- dist-ns-allinone-2.26/ns-2.26/tools/random.cc	Wed Feb 26 15:11:28 2003
+++ ns-allinone-2.26/ns-2.26/tools/random.cc	Fri Nov 28 16:55:25 2003
@@ -47,11 +47,13 @@
 #define GCC_THROW
 #endif
 
+#if 0
 RANDOM_RETURN_TYPE
 random() GCC_THROW
 {
 	printf("random() called in ns.\nRandom is not portable, please use Random::uniform() instead.\n");
 	abort();
 }
+#endif
 
 #endif /* !WIN32 */
--- dist-ns-allinone-2.26/ns-2.26/tcp/tcp-full.cc	Wed Feb 26 15:11:24 2003
+++ ns-allinone-2.26/ns-2.26/tcp/tcp-full.cc	Fri Nov 28 16:55:25 2003
@@ -76,7 +76,7 @@
  *
  * Some warnings and comments:
  *	this version of TCP will not work correctly if the sequence number
- *	goes above 2147483648 due to sequence number wrap
+ *	goes above 1073741824 due to sequence number wrap
  *
  *	this version of TCP by default sends data at the beginning of a
  *	connection in the "typical" way... That is,
@@ -360,16 +360,16 @@
 	case TCPS_CLOSED:
 	case TCPS_LISTEN:
                 reset();
-                curseq_ = iss_ + nb;
+                INCR_SEQ( curseq_, SEQ_ADD(iss_, nb));
                 connect();              // initiate new connection
 		break;
 
 	case TCPS_ESTABLISHED:
 	case TCPS_SYN_SENT:
 	case TCPS_SYN_RECEIVED:
-                if (curseq_ < iss_) 
+	        if (SEQ_LT(curseq_, iss_) ) 
                         curseq_ = iss_; 
-                curseq_ += nb;
+                INCR_SEQ(curseq_, nb);
 		break;
 
 	default:
@@ -454,7 +454,7 @@
 void
 FullTcpAgent::usrclosed()
 {
-	curseq_ = maxseq_ - 1;	// now, no more data
+	curseq_ = SEQ_SUB(maxseq_, 1);	// now, no more data
 	infinite_send_ = FALSE;	// stop infinite send
 
 	switch (state_) {
@@ -736,7 +736,7 @@
 int
 FullTcpAgent::rcvseqinit(int seq, int dlen)
 {
-	return (seq + dlen + 1);
+	return (SEQ_ADD(seq, dlen + 1));
 }
 
 /*
@@ -764,8 +764,8 @@
 FullTcpAgent::pack(Packet *pkt)
 {
 	hdr_tcp *tcph = hdr_tcp::access(pkt);
-	return (tcph->ackno() >= highest_ack_ &&
-		tcph->ackno() < recover_);
+	return (SEQ_GE(tcph->ackno(), highest_ack_) &&
+		SEQ_LT(tcph->ackno(), recover_));
 }
 
 /*
@@ -822,6 +822,9 @@
         tcph->hlen() = tcpip_base_hdr_size_;
 	tcph->hlen() += build_options(tcph);
 
+	/* Fill in maxseg_ for MSS negotiation in TCPTap (NSE) */
+	tcph->maxseg() = maxseg_;
+	
 	/*
 	 * Explicit Congestion Notification (ECN) related:
 	 * Bits in header:
@@ -930,24 +933,24 @@
 	else
 		size_ =  maxseg_ + headersize();
 
-	int is_retransmit = (seqno < maxseq_);
+	int is_retransmit = SEQ_LT(seqno, maxseq_);
 	int quiet = (highest_ack_ == maxseq_);
 	int pflags = outflags();
 	int syn = (seqno == iss_);
 	int emptying_buffer = FALSE;
 	int buffered_bytes = (infinite_send_) ? TCP_MAXSEQ :
-				curseq_ - highest_ack_ + 1;
+				SEQ_ADD( SEQ_SUB(curseq_, highest_ack_), 1);
 
 	int win = window() * maxseg_;	// window (in bytes)
-	int off = seqno - highest_ack_;	// offset of seg in window
+	int off = SEQ_SUB(seqno, highest_ack_);	// offset of seg in window
 	int datalen;
 	//int amtsent = 0;
 
 	// be careful if we have not received any ACK yet
 	if (highest_ack_ < 0) {
 		if (!infinite_send_)
-			buffered_bytes = curseq_ - iss_;;
-		off = seqno - iss_;
+			buffered_bytes = SEQ_SUB(curseq_, iss_);
+		off = SEQ_SUB(seqno, iss_);
 	}
 
 	if (syn && !data_on_syn_)
@@ -989,7 +992,7 @@
 	// a dataless SYN packet counts also
 	//
 
-	if (!infinite_send_ && ((seqno + datalen) > curseq_ || 
+	if (!infinite_send_ && (SEQ_GT( SEQ_ADD(seqno, datalen), curseq_) || 
 	    (syn && datalen == 0))) {
 		emptying_buffer = TRUE;
 		//
@@ -1106,15 +1109,15 @@
 	 * around until we actually send a segment
 	 */
 
-	int reliable = datalen + syn + fin; // seq #'s reliably sent
+	int reliable = SEQ_ADD(datalen, syn + fin); // seq #'s reliably sent
 	if (cong_action_ && reliable > 0)
 		cong_action_ = FALSE;
 
 	// highest: greatest sequence number sent + 1
 	//	and adjusted for SYNs and FINs which use up one number
 
-	int highest = seqno + reliable;
-	if (highest > maxseq_) {
+	int highest = SEQ_ADD(seqno, reliable);
+	if (SEQ_GT(highest, maxseq_)) {
 		maxseq_ = highest;
 		//
 		// if we are using conventional RTT estimation,
@@ -1207,10 +1210,11 @@
         int win = window() * maxseg_;
         int topwin = curseq_; // 1 seq number past the last byte we can send
 
-        if ((topwin > highest_ack_ + win) || infinite_send_)
-                topwin = highest_ack_ + win; 
+	int hiack_plus_win = SEQ_ADD(highest_ack_, win);
+        if (SEQ_GT(topwin, hiack_plus_win) || infinite_send_)
+                INCR_SEQ( topwin, hiack_plus_win); 
 
-	return (seq < topwin);
+	return (SEQ_LT(seq, topwin));
 }
 /*
  * Process an ACK
@@ -1231,7 +1235,7 @@
 	hdr_tcp *tcph = hdr_tcp::access(pkt);
 
 	register int ackno = tcph->ackno();
-	int progress = (ackno > highest_ack_);
+	int progress = SEQ_GT(ackno, highest_ack_);
 
 	if (ackno == maxseq_) {
 		cancel_rtx_timer();	// all data ACKd
@@ -1250,7 +1254,7 @@
 	// update t_seqno_ here, otherwise we would be doing
 	// go-back-n.
 
-	if (t_seqno_ < highest_ack_)
+	if (SEQ_LT(t_seqno_, highest_ack_))
 		t_seqno_ = highest_ack_; // seq# to send next
 
         /*
@@ -1266,7 +1270,7 @@
 			recent_age_ = now();
 			recent_ = tcph->ts();
 			rtt_update(now() - tcph->ts_echo());
-		} else if (rtt_active_ && ackno > rtt_seq_) {
+		} else if (rtt_active_ && SEQ_GT(ackno,rtt_seq_)) {
 			// got an RTT sample, record it
 			// "t_backoff_ = 1;" deleted by T. Kelly.
 			rtt_active_ = FALSE;
@@ -1368,10 +1372,10 @@
 	if (flags_ & TF_ACKNOW)
 		return TRUE;
 
-	int spa = (spa_thresh_ > 0 && ((rcv_nxt_ - irs_)  < spa_thresh_)) ?
+	int spa = (spa_thresh_ > 0 && (SEQ_SUB(rcv_nxt_,irs_)  < spa_thresh_)) ?
 		1 : segs_per_ack_;
 		
-	return ((rcv_nxt_ - last_ack_sent_) >= (spa * maxseg_));
+	return (SEQ_SUB(rcv_nxt_, last_ack_sent_) >= (spa * maxseg_));
 }
 
 /*
@@ -1510,7 +1514,7 @@
 		 * See RFC1323 (now RFC1323 bis)
                  */
                 if (ts_option_ && !fh->no_ts_ &&
-		    tcph->seqno() <= last_ack_sent_) {
+		    SEQ_LE(tcph->seqno(), last_ack_sent_)) {
 			/*
 			 * this is the case where the ts value is newer than
 			 * the last one we've seen, and the seq # is the one
@@ -1548,7 +1552,7 @@
 			// If we are in fast
 			// recovery, go below so we can remember to deflate
 			// the window if we need to
-			if (ackno > highest_ack_ && ackno < maxseq_ &&
+			if (SEQ_GT(ackno, highest_ack_) && SEQ_LT(ackno, maxseq_) &&
 			    cwnd_ >= wnd_ && !fastrecov_) {
 				newack(pkt);	// update timers,  highest_ack_
 				send_much(0, REASON_NORMAL, maxburst_);
@@ -1566,7 +1570,7 @@
 			//	this routine scans all tcpcb's looking for
 			//	DELACK segments and when it finds them
 			//	changes DELACK to ACKNOW and calls tcp_output()
-			rcv_nxt_ += datalen;
+			INCR_SEQ(rcv_nxt_, datalen);
 			flags_ |= TF_DELACK;
 			recvBytes(datalen); // notify application of "delivery"
 			//
@@ -1667,7 +1671,7 @@
 
 		/* drop if it's a SYN+ACK and the ack field is bad */
 		if ((tiflags & TH_ACK) &&
-			((ackno <= iss_) || (ackno > maxseq_))) {
+			(SEQ_LE(ackno, iss_) || SEQ_GT(ackno, maxseq_))) {
 			// not an ACK for our SYN, discard
 			fprintf(stderr,
 			    "%f: FullTcpAgent::recv(%s): bad ACK for our SYN: ",
@@ -1761,14 +1765,14 @@
 			 * SYN+ACK, so t_seqno_ will have been
 			 * advanced to 2... reduce this
 			 */
-			t_seqno_--;	// CHECKME
+			DECR_SEQ(t_seqno_, 1);	// CHECKME
 		}
 
 trimthenstep6:
 		/*
 		 * advance the seq# to correspond to first data byte
 		 */
-		tcph->seqno()++;
+		INCR_SEQ(tcph->seqno(), 1);
 
 		if (tiflags & TH_ACK)
 			goto process_ACK;
@@ -1838,13 +1842,13 @@
 	// do anything with it.  In particular, would like to
 	// avoid ACKing an incoming FIN+ACK while in CLOSING
 	//
-	todrop = rcv_nxt_ - tcph->seqno();  // how much overlap?
+	todrop = SEQ_SUB(rcv_nxt_, tcph->seqno());  // how much overlap?
 
 	if (todrop > 0 && ((tiflags & (TH_SYN)) || datalen > 0)) {
 //printf("%f(%s): trim 1..todrop:%d, dlen:%d\n",now(), name(), todrop, datalen);
 		if (tiflags & TH_SYN) {
 			tiflags &= ~TH_SYN;
-			tcph->seqno()++;
+			INCR_SEQ(tcph->seqno(), 1);
 			th->size()--;	// XXX Must decrease packet size too!!
 					// Q: Why?.. this is only a SYN
 			todrop--;
@@ -1881,7 +1885,7 @@
 		 * Trim duplicate data from the front of the packet
 		 */
 
-		tcph->seqno() += todrop;
+		INCR_SEQ(tcph->seqno(), todrop);
 		th->size() -= todrop;	// XXX Must decrease size too!!
 					// why? [kf]..prob when put in RQ
 		datalen -= todrop;
@@ -1894,7 +1898,7 @@
 	 * record the timestamp.
 	 * See RFC1323 (now RFC1323 bis)
 	 */
-	if (ts_option_ && !fh->no_ts_ && tcph->seqno() <= last_ack_sent_) {
+	if (ts_option_ && !fh->no_ts_ && SEQ_LE(tcph->seqno(), last_ack_sent_)) {
 		/*
 		 * this is the case where the ts value is newer than
 		 * the last one we've seen, and the seq # is the one we expect
@@ -1925,7 +1929,7 @@
 
 	switch (state_) {
 	case TCPS_SYN_RECEIVED:	/* want ACK for our SYN+ACK */
-		if (ackno < highest_ack_ || ackno > maxseq_) {
+		if (SEQ_LT(ackno, highest_ack_) || SEQ_GT(ackno, maxseq_)) {
 			// not in useful range
 		    	fprintf(stderr,
 		    		"%f: FullTcpAgent(%s): ack(%d) not in range while in SYN_RECEIVED: ",
@@ -1999,13 +2003,13 @@
 		//	try not to be fooled by data
 		//
 
-		if (fastrecov_ && (datalen == 0 || ackno > highest_ack_))
+		if (fastrecov_ && (datalen == 0 || SEQ_GT(ackno, highest_ack_)))
 			pipe_ -= maxseg_;
 
 		// look for dup ACKs (dup ack numbers, no data)
 		//
 		// do fast retransmit/recovery if at/past thresh
-		if (ackno <= highest_ack_) {
+		if (SEQ_LE(ackno, highest_ack_)) {
 			// a pure ACK which doesn't advance highest_ack_
 			if (datalen == 0 && (!dupseg_fix_ || !dupseg)) {
 
@@ -2029,7 +2033,7 @@
                                  */
 
 				if ((rtx_timer_.status() != TIMER_PENDING) ||
-				    ackno < highest_ack_) {
+				    SEQ_LT(ackno, highest_ack_)) {
 					// Q: significance of timer not pending?
 					// ACK below highest_ack_
 					oldack();
@@ -2069,7 +2073,7 @@
 
 process_ACK:
 
-		if (ackno > maxseq_) {
+		if (SEQ_GT(ackno, maxseq_)) {
 			// ack more than we sent(!?)
 			fprintf(stderr,
 			    "%f: FullTcpAgent::recv(%s) too-big ACK (maxseq:%d): ",
@@ -2130,7 +2134,7 @@
 		 * If no data (only SYN) was ACK'd,
 		 *    skip rest of ACK processing.
 		 */
-		if (ackno == (highest_ack_ + 1))
+		if (ackno == SEQ_ADD(highest_ack_, 1))
 			goto step6;
 
 		// if we are delaying initial cwnd growth (probably due to
@@ -2244,7 +2248,7 @@
 			// accept the data here as-is (i.e. don't
 			// require being in ESTABLISHED state)
 			flags_ |= TF_DELACK;
-			rcv_nxt_ += datalen;
+			INCR_SEQ(rcv_nxt_, datalen);
 			tiflags = tcph->flags() & TH_FIN;
 
 			// give to "application" here
@@ -2262,11 +2266,11 @@
 			// Note that we may have just a FIN here (datalen = 0)
 			int rcv_nxt_old_ = rcv_nxt_; // notify app. if changes
 			tiflags = reass(pkt);
-			if (rcv_nxt_ > rcv_nxt_old_) {
+			if (SEQ_GT(rcv_nxt_, rcv_nxt_old_)) {
 				// if rcv_nxt_ has advanced, must have
 				// been a hole fill.  In this case, there
 				// is something to give to application
-				recvBytes(rcv_nxt_ - rcv_nxt_old_);
+				recvBytes(SEQ_SUB(rcv_nxt_, rcv_nxt_old_));
 			}
 			flags_ |= TF_ACKNOW;
 
@@ -2295,7 +2299,7 @@
 	if (tiflags & TH_FIN) {
 		if (TCPS_HAVERCVDFIN(state_) == 0) {
 			flags_ |= TF_ACKNOW;
- 			rcv_nxt_++;
+ 			INCR_SEQ(rcv_nxt_, 1);
 		}
 		switch (state_) {
                 /*
@@ -2332,7 +2336,7 @@
 
 	if (needoutput || (flags_ & TF_ACKNOW))
 		send_much(1, REASON_NORMAL, maxburst_);
-	else if (curseq_ >= highest_ack_ || infinite_send_)
+	else if (SEQ_GE(curseq_, highest_ack_) || infinite_send_)
 		send_much(0, REASON_NORMAL, maxburst_);
 	// K: which state to return to when nothing left?
 
@@ -2363,9 +2367,9 @@
 	if (tiflags & TH_ACK) {
 		sendpacket(ackno, 0, 0x0, 0, REASON_NORMAL);
 	} else {
-		int ack = tcph->seqno() + datalen;
+		int ack = SEQ_ADD(tcph->seqno(), datalen);
 		if (tiflags & TH_SYN)
-			ack--;
+			DECR_SEQ(ack, 1);
 		sendpacket(0, ack, TH_ACK, 0, REASON_NORMAL);
 	}
 drop:
@@ -2393,7 +2397,7 @@
 FullTcpAgent::dupack_action()
 {   
 
-        int recovered = (highest_ack_ > recover_);
+        int recovered = SEQ_GT(highest_ack_, recover_);
 
 	fastrecov_ = TRUE;
 	rtxbytes_ = 0;
@@ -2579,7 +2583,7 @@
 void
 TahoeFullTcpAgent::dupack_action()
 {  
-        int recovered = (highest_ack_ > recover_);
+        int recovered = SEQ_GT(highest_ack_, recover_);
 
 	fastrecov_ = TRUE;
 	rtxbytes_ = 0;
@@ -2696,11 +2700,11 @@
 SackFullTcpAgent::dupack_action()
 {
 
-        int recovered = (highest_ack_ > recover_);
+        int recovered = SEQ_GT(highest_ack_, recover_);
 
 	fastrecov_ = TRUE;
 	rtxbytes_ = 0;
-	pipe_ = maxseq_ - highest_ack_ - sq_.total();
+	pipe_ = SEQ_SUB( SEQ_SUB(maxseq_, highest_ack_), sq_.total());
 
 //printf("%f: SACK DUPACK-ACTION:pipe_:%d, sq-total:%d, bugfix:%d, cwnd:%d, highest_ack:%d, recover_:%d\n",
 //now(), pipe_, sq_.total(), bug_fix_, int(cwnd_), int(highest_ack_), recover_);
@@ -2740,7 +2744,7 @@
 	recover_ = maxseq_;	// where I am when recovery starts
 
 	int amt = fast_retransmit(highest_ack_);
-	h_seqno_ = highest_ack_ + amt;
+	h_seqno_ = SEQ_ADD(highest_ack_, amt);
 
 //printf("%f: FAST-RTX seq:%d, h_seqno_ is now:%d, pipe:%d, cwnd:%d, recover:%d\n",
 //now(), int(highest_ack_), h_seqno_, pipe_, int(cwnd_), recover_);
@@ -2753,12 +2757,12 @@
 void
 SackFullTcpAgent::pack_action(Packet* p)
 {
-	if (!sq_.empty() && sack_min_ < highest_ack_) {
+	if (!sq_.empty() && SEQ_LT(sack_min_, highest_ack_)) {
 		sack_min_ = highest_ack_;
 		sq_.cleartonxt();
 	}
 	pipe_ -= maxseg_;	// see comment in tcp-sack1.cc
-	if (h_seqno_ < highest_ack_)
+	if (SEQ_LT(h_seqno_, highest_ack_))
 		h_seqno_ = highest_ack_;
 }
 
@@ -2768,7 +2772,7 @@
 //printf("%f: EXITING fast recovery, recover:%d\n",
 //now(), recover_);
 	fastrecov_ = pipectrl_ = FALSE;
-        if (!sq_.empty() && sack_min_ < highest_ack_) {
+        if (!sq_.empty() && SEQ_LT(sack_min_, highest_ack_)) {
                 sack_min_ = highest_ack_;
                 sq_.cleartonxt();
         }
@@ -2854,8 +2858,8 @@
 		return (FullTcpAgent::send_allowed(seq));
 
 	// don't overshoot receiver's advertised window
-	int topawin = highest_ack_ + int(wnd_) * maxseg_;
-	if (seq >= topawin) {
+	int topawin = SEQ_ADD(highest_ack_, int(wnd_) * maxseg_);
+	if (SEQ_GE(seq, topawin)) {
 //printf("%f: SEND(%d) NOT ALLOWED DUE TO AWIN:%d, pipe:%d, cwnd:%d\n",
 //now(), seq, topawin, pipe_, int(cwnd_));
 		return FALSE;
@@ -2877,7 +2881,7 @@
 SackFullTcpAgent::nxt_tseq()
 {
 
-	int in_recovery = (highest_ack_ < recover_);
+	int in_recovery = SEQ_LT(highest_ack_, recover_);
 	int seq = h_seqno_;
 
 	if (!in_recovery) {
@@ -2916,13 +2920,13 @@
 			// adjust h_seqno, as we may have
 			// been "jumped ahead" by learning
 			// about a filled hole
-			if (seq > h_seqno_)
+			if (SEQ_GT(seq, h_seqno_))
 				h_seqno_ = seq;
 			return (seq);
 		} else if (fcnt <= 0)
 			break;
 		else {
-			seq += maxseg_;
+			INCR_SEQ(seq, maxseg_);
 		}
 	}
 //if (int(t_seqno_) > 1)
--- dist-ns-allinone-2.26/ns-2.26/tcp/tcp-full.h	Wed Feb 26 15:11:24 2003
+++ ns-allinone-2.26/ns-2.26/tcp/tcp-full.h	Fri Nov 28 16:55:25 2003
@@ -104,6 +104,20 @@
 #define PF_TIMEOUT 0x04	    /* protocol defined */
 #define	TCP_PAWS_IDLE	(24 * 24 * 60 * 60)	/* 24 days in secs */
 
+#define SEQ_LT(a,b)  (((a)<(b) && (b)-(a) < TCP_MAXSEQ/2) || ((a)>(b) && (a)-(b) >= TCP_MAXSEQ/2))
+#define SEQ_LE(a,b)  (((a)<=(b) && (b)-(a) < TCP_MAXSEQ/2) || ((a)>(b) && (a)-(b) >= TCP_MAXSEQ/2))
+#define SEQ_GT(a,b)  (((a)>(b) && (a)-(b) < TCP_MAXSEQ/2) || ((a)<(b) && (b)-(a) >= TCP_MAXSEQ/2))
+#define SEQ_GE(a,b)  (((a)>=(b) && (a)-(b) < TCP_MAXSEQ/2) || ((a)<(b) && (b)-(a) >= TCP_MAXSEQ/2))
+#define INCR_SEQ(num, val) (num) = ((num) + (val)) % TCP_MAXSEQ
+#define SEQ_ADD(num, val) (((num) + (val)) % TCP_MAXSEQ)
+inline int SEQ_SUB(int num, int val) {
+  int ret = num - val;
+    return( abs(ret) < TCP_MAXSEQ/2 ? ret : ((int)(((long long)(num) - (val) + TCP_MAXSEQ) % TCP_MAXSEQ)) );
+}
+#define DECR_SEQ(num, val) (num) = SEQ_SUB((num), (val))
+#define SEQ_MIN(x,y) (SEQ_LT((x),(y))?(x):(y))
+#define SEQ_MAX(x,y) (SEQ_GT((x),(y))?(x):(y))
+
 class FullTcpAgent;
 class DelAckTimer : public TimerHandler {
 public:
@@ -190,9 +204,9 @@
 	}
 	virtual void sent(int seq, int amt) {
 		if (seq == t_seqno_)
-			t_seqno_ += amt;
+			INCR_SEQ(t_seqno_, amt);
 		pipe_ += amt;
-		if (seq < int(maxseq_))
+		if (SEQ_LT(seq, int(maxseq_)))
 			rtxbytes_ += amt;
 	}
 	virtual void oldack() {			// what to do on old ack
--- dist-ns-allinone-2.26/ns-2.26/tcp/tcp.h	Wed Feb 26 15:11:25 2003
+++ ns-allinone-2.26/ns-2.26/tcp/tcp.h	Fri Nov 28 16:55:25 2003
@@ -56,6 +56,8 @@
 	int tcp_flags_;         /* TCP flags for FullTcp */
 	int last_rtt_;		/* more recent RTT measurement in ms, */
 				/*   for statistics only */
+        int maxseg_;            /* MSS for TCPTap to negotiate in the SYN segment
+				   needed in NSE */
 
 	static int offset_;	// offset for this header
 	inline static int& offset() { return offset_; }
@@ -75,6 +77,7 @@
 	int& ackno() { return (ackno_); }  
 	int& flags() { return (tcp_flags_); }
 	int& last_rtt() { return (last_rtt_); }
+	int& maxseg() { return (maxseg_); }
 };
 
 /* these are used to mark packets as to why we xmitted them */
--- dist-ns-allinone-2.26/ns-2.26/tcl/lib/ns-address.tcl	Wed Feb 26 15:09:37 2003
+++ ns-allinone-2.26/ns-2.26/tcl/lib/ns-address.tcl	Fri Nov 28 16:55:25 2003
@@ -162,7 +162,7 @@
 	Simulator set AddressFormat_ HIER
 	Node enable-module "Hier"
 	if [$self multicast?] {
-		$a set-mcastbits 1
+		$a set-mcastbits 3
 	}
 	eval $a set-idbits $hlevel $args
 }
@@ -184,7 +184,7 @@
 	# One bit is set aside for mcast as default :: this waste of 1 bit 
 	# may be avoided, if mcast option is enabled before the initialization
 	# of Simulator.
-	$a set-mcastbits 1
+	$a set-mcastbits 3
 	set lastbit [expr $node - [$a set mcastsize_]]
 	$a set-idbits 1 $lastbit
 }
@@ -269,9 +269,9 @@
 
 AllocAddrBits instproc set-mcastbits {bit_num} {
 	$self instvar size_ mcastsize_
-	if {$bit_num != 1} {
-		error "setmcast : mcastbit > 1"
-	}
+	#if {$bit_num != 1} {
+		#error "setmcast : mcastbit > 1"
+	#}
 	set mcastsize_ $bit_num
 
 	#chk to ensure there;s no change in size
--- dist-ns-allinone-2.26/ns-2.26/tcl/lib/ns-default.tcl	Wed Feb 26 15:09:37 2003
+++ ns-allinone-2.26/ns-2.26/tcl/lib/ns-default.tcl	Fri Nov 28 16:55:25 2003
@@ -347,6 +347,8 @@
 Classifier set offset_ 0
 Classifier set shift_ 0
 Classifier set mask_ 0xffffffff
+# default IP mask is 255.255.255.0
+Classifier set ipmask_ 0xffffff00
 Classifier set debug_ false
 
 Classifier/Hash set default_ -1; # none
--- dist-ns-allinone-2.26/ns-2.26/tcl/lib/ns-lib.tcl	Wed Feb 26 15:09:37 2003
+++ ns-allinone-2.26/ns-2.26/tcl/lib/ns-lib.tcl	Mon Jan 12 00:36:16 2004
@@ -1,6 +1,6 @@
 # -*-	Mode:tcl; tcl-indent-level:8; tab-width:8; indent-tabs-mode:t -*-
 #
-# Copyright (c) 1996 Regents of the University of California.
+# Copyright (c) 1996, 2003 Regents of the University of California.
 # All rights reserved.
 # 
 # Redistribution and use in source and binary forms, with or without
@@ -882,6 +882,9 @@
 	# Do all nam-related initialization here
 	$self init-nam
 
+	# XXX netbed specific 
+	#$self add-routes-to-neighbour-ips
+
 	# NIXVECTOR xxx?
 	# global simstart
 	# set simstart [clock seconds]
@@ -1372,8 +1375,8 @@
 	$link_([$n1 id]:[$n2 id]) cost $c
 }
 
-Simulator instproc attach-agent { node agent } {
-	$node attach $agent
+Simulator instproc attach-agent { node agent {port ""} } {
+	$node attach $agent $port
 	# $agent set nodeid_ [$node id]
 }
 
@@ -2045,3 +2048,167 @@
 	}
 }
     
+# XXX netbed changes
+Simulator instproc inet-aton ipaddr {
+    set c [regsub -all \\. $ipaddr " " addrlist]
+    if { $c == 0} { 
+        return [expr $ipaddr]
+    }
+    if { [llength $addrlist] != 4} {
+        error "Ill-formatted ip address $ipaddr, addrlistlth = [llength $addrlist]"
+    }
+    if { $c == 3 } {
+        set r 0
+        foreach a $addrlist {
+            if { $a < 0 || $a > 255 } {
+                error "Ill-formatted ip address $ipaddr, a = $a"
+            }
+            set r [expr ($r << 8) + $a]     
+        }
+        return $r
+    } else {
+        error "Ill-formatted ip address $ipaddr, c = $c"
+    }
+}
+
+# XXX netbed changes
+Simulator instproc inet-ntoa ipaddr {
+    set p1 [expr ($ipaddr >> 24) & 0xff]
+    set p2 [expr ($ipaddr >> 16) & 0xff]
+    set p3 [expr ($ipaddr >>  8) & 0xff]
+    set p4 [expr ($ipaddr >>  0) & 0xff]
+    return [format "%d\.%d\.%d\.%d" $p1 $p2 $p3 $p4]
+}
+
+# XXX netbed changes
+Simulator instproc add-ip { node ip } {
+
+    $self instvar iptonode_
+    $self instvar ipsubnetlist_
+
+    set iptonode_($ip) $node
+    $self cmd add-ip $node $ip
+    
+    set ip_masked [expr [$self inet-aton $ip] & [$self inet-aton "255.255.255.0"]]
+    lappend ipsubnetlist_($ip_masked) $ip
+}
+
+Simulator instproc add-ip-mask-target { ip mask target } {
+    $self instvar iptotarget_
+
+    set ipaton [$self inet-aton $ip]
+    set maskaton [$self inet-aton $mask]
+    set ipmask [$self inet-ntoa [expr $ipaton & $maskaton]]
+    
+    set iptotarget_($ipmask) $target
+}
+
+# XXX netbed changes
+Simulator instproc ip-to-node {ip} {
+    $self instvar iptonode_
+
+    if { [info exists iptonode_($ip)] } {
+	return $iptonode_($ip)
+    } else {
+	    return {}
+    }
+}
+
+# XXX netbed changes
+Simulator instproc ip-to-target {ip} {
+    $self instvar iptotarget_
+
+    if { [info exists iptotarget_($ip)] } {
+	return $iptotarget_($ip)
+    } else {
+	    return {}
+    }
+}
+
+## Should be called only after routing is computed
+## A good place is the run method
+## XXX netbed specific
+Simulator instproc add-routes-to-neighbour-ips {} {
+    $self instvar ipsubnetlist_
+    $self instvar iptotarget_
+    $self instvar link_
+
+    set rtlogic [$self get-routelogic]
+
+    foreach subnet [array names ipsubnetlist_] {
+	set subnet_aton [$self inet-aton $subnet]
+	foreach ip1 $ipsubnetlist_($subnet) {
+	    foreach ip2 $ipsubnetlist_($subnet) {
+		if( $ip1 == $ip2 ) {
+		    continue
+		}
+		set node1 $iptotarget_($ip1)
+		set node2 $iptotarget_($ip2)
+		set rt1id [$rtlogic lookup [$node1 id] [$node2 id]]
+		set rt2id [$rtlogic lookup [$node2 id] [$node1 id]]
+		$node1 add-route $subnet-aton $link_([$node1 id]:$rt1id)
+		$node2 add-route $subnet-aton $link_([$node2 id]:$rt2id)
+	    }
+	}
+    }
+}
+
+# XXX netbed changes
+Simulator instproc rlink { n1 n2ip {bw ""} {delay ""} {qtype ""} args } {
+    $self instvar rlink_ queueMap_ 
+
+    set sid [$n1 id]
+    set did [$self inet-aton $n2ip]
+
+    # If any of the bw/delay/qtype are not passed, it means
+    # that we have a link from a sim node to a real node.
+    # Any shaping will happen via a dummynet node
+    if { $bw == {} || $delay == {} || $qtype == {} } {	    
+	set rlink_($sid:$did) [new Rlink $n1 $n2ip]
+	$self add-ip-mask-target $n2ip 255.255.255.255 [$rlink_($sid:$did) head]
+	return $rlink_($sid:$did)
+    }
+    
+	
+    if { [info exists queueMap_($qtype)] } {
+	set qtype $queueMap_($qtype)
+    }
+    # construct the queue
+    set qtypeOrig $qtype
+    switch -exact $qtype {
+	ErrorModule {
+	    if { [llength $args] > 0 } {
+		set q [eval new $qtype $args]
+	    } else {
+		set q [new $qtype Fid]
+	    }
+	}
+	intserv {
+	    set qtype [lindex $args 0]
+	    set q [new Queue/$qtype]
+	}
+	default {
+	    if { [llength $args] == 0} {
+		set q [new Queue/$qtype]
+	    } else {
+		set q [new Queue/$qtype $args]
+	    }
+	}
+    }	
+    set rlink_($sid:$did) [new Rlink $n1 $n2ip $bw $delay $q]
+    $self add-ip-mask-target $n2ip 255.255.255.255 [$rlink_($sid:$did) head]
+    return $rlink_($sid:$did)
+}
+
+Simulator instproc ip-connect { agent ip port } {
+    set ipaton [$self inet-aton $ip]
+    $agent set dst_addr_ $ipaton
+    $agent set dst_port_ $port
+
+    $agent instvar node_
+    $node_ instvar nodeiplist_
+    # We just use one of the IP addresses of src node
+    # as the agent's src address
+    set srcipaton [$self inet-aton [lindex $nodeiplist_ 0]]
+    $agent set agent_addr_ $srcipaton
+}
--- dist-ns-allinone-2.26/ns-2.26/tcl/lib/ns-link.tcl	Wed Feb 26 15:09:37 2003
+++ ns-allinone-2.26/ns-2.26/tcl/lib/ns-link.tcl	Tue Dec  2 00:57:03 2003
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1996 Regents of the University of California.
+# Copyright (c) 1996, 2003 Regents of the University of California.
 # All rights reserved.
 # 
 # Redistribution and use in source and binary forms, with or without
@@ -63,6 +63,14 @@
 	return $head_
 }
 
+# XXX netbed specific
+# Want to have the same method for both
+# node and link
+Link instproc entry {} {
+    $self instvar head_
+    return $head_
+}
+
 Link instproc add-to-head { connector } {
 	$self instvar head_
 	$connector target [$head_ target]
@@ -164,6 +172,123 @@
 	$self instvar link_
 	$em target [$link_ target]
 	$link_ target $em
+}
+
+# XXX netbed specific
+Link instproc set-ip {ip} {
+    $self instvar srcipaddr_ fromNode_
+
+    set srcipaddr_ $ip
+    $fromNode_ add-ip $ip
+
+    # Besides that, adding a route for
+    # the subnet with this link as the target
+    # will ensure that packets destined to the 
+    # neighbors will be routed to us
+    set ns_ [Simulator instance]
+    
+    set ipmasked [expr [$ns_ inet-aton $ip] & [$ns_ inet-aton 255.255.255.0]]
+    $fromNode_ add-route $ipmasked [$self head]
+
+    # Need to add mapping from subnet mask to link so that new routes being
+    # added can use this
+    $ns_ add-ip-mask-target $ip 255.255.255.0 [$self head]
+}
+
+# XXX netbed specific
+Class Rlink -superclass Link
+
+Rlink instproc init { src dstip {bw ""} {delay ""} {q ""} {lltype "DelayLink"} } {
+        $self next $src $dstip
+	$self instvar link_ queue_ head_ toNode_ ttl_
+	$self instvar drophead_ dstipaddr_ srcipaddr_ target_
+
+        set dstipaddr_ $dstip
+	set ns [Simulator instance]
+	set drophead_ [new Connector]
+	$drophead_ target [$ns set nullAgent_]
+
+	set head_ [new Connector]
+	$head_ set link_ $self
+
+        # If any of the bw/delay/qtype are not passed, it means
+	# that we have a link from a sim node to a real node.
+	# Any shaping will happen via a dummynet node
+        if { $bw == {} || $delay == {} || $q == {} } {
+	    set target_ [new Agent/IPTap]
+	    $ns attach-agent $src $target_
+	    $head_ target $target_
+	    return $self
+	}
+
+	#set head_ $queue_ -> replace by the following
+	# xxx this is hacky
+	if { [[$q info class] info heritage ErrModule] == "ErrorModule" } {
+		$head_ target [$q classifier]
+        } else {
+                $head_ target $q
+
+        }
+
+	set queue_ $q
+	set link_ [new $lltype]
+	$link_ set bandwidth_ $bw
+	$link_ set delay_ $delay
+
+	$queue_ target $link_
+	set target_ [new Agent/IPTap]
+
+	# put the ttl checker after the delay
+	# so we don't have to worry about accounting
+	# for ttl-drops within the trace and/or monitor
+	# fabric
+	#
+	set ttl_ [new TTLChecker]
+	$ttl_ target $target_
+	$self ttl-drop-trace
+	$link_ target $ttl_
+
+	$ns attach-agent $src $target_
+	$queue_ drop-target $drophead_
+
+	return $self
+	# Finally, if running a multicast simulation,
+	# put the iif for the neighbor node...
+#	if { [$ns multicast?] } {
+#		$self enable-mcast $src $dst
+#	}
+#        $ns instvar srcRt_
+#	if [info exists srcRt_] {
+#        	if { $srcRt_ == 1 } {
+#            	$self enable-src-rt $src $dst $head_
+#        	}
+#	}    
+}
+
+Rlink instproc ttl-drop-trace args {
+	$self instvar ttl_
+	if ![info exists ttl_] return
+	if {[llength $args] != 0} {
+		$ttl_ drop-target [lindex $args 0]
+	} else {
+		$self instvar drophead_
+		$ttl_ drop-target $drophead_
+	}
+}
+
+Rlink instproc srcipaddr {} {
+    $self instvar srcipaddr_
+    return $srcipaddr_
+}
+
+Rlink instproc dstipaddr {} {
+    $self instvar dstipaddr_
+    return $dstipaddr_
+}
+
+Rlink instproc target {} {
+    $self instvar target_
+    return $target_
 }
 
 Class SimpleLink -superclass Link
--- dist-ns-allinone-2.26/ns-2.26/tcl/lib/ns-node.tcl	Wed Feb 26 15:09:37 2003
+++ ns-allinone-2.26/ns-2.26/tcl/lib/ns-node.tcl	Sun Jan  4 18:27:34 2004
@@ -492,6 +492,15 @@
 		# at the port demuxer (if there is one)
 		$self add-route $address_ $dmux_
 	}
+	# XXX netbed specific
+	$self instvar nodeiplist_
+	set ns_ [Simulator instance]
+	if { [info exists nodeiplist_] } {
+	    foreach ip $nodeiplist_ { 
+	    	set ipaton [$ns_ inet-aton $ip]
+	    	$self add-route $ipaton $dmux_
+	    }
+	}
 	if { $port == "" } {
 		set port [$dmux_ alloc-port [[Simulator instance] nullagent]]
 	}
@@ -569,3 +578,49 @@
 	$self instvar neighbor_
 	return [expr [lsearch $neighbor_ $node] != -1]
 }
+
+# XXX netbed specific
+Node instproc add-ip { ip } {
+    set ns_ [Simulator instance]
+    $ns_ instvar iplist_
+    lappend iplist_ $ip
+
+    $self instvar nodeiplist_ dmux_
+    lappend nodeiplist_ $ip
+
+    set ip_aton [$ns_ inet-aton $ip]
+
+    if { $dmux_ != "" } {
+	# By adding the IP of this link to the node, we
+	# make sure that packets with the dstaddr == ip
+	# will be given to the port classifier
+	$self add-route $ip_aton $dmux_
+    }
+    $ns_ add-ip $self $ip
+}
+
+# XXX netbed specific
+Node instproc add-route-to-ip { ip nhopip {mask 255.255.255.255} } {
+    set ns_ [Simulator instance]
+
+    set ip_aton [$ns_ inet-aton $ip]
+    set mask_aton [$ns_ inet-aton $mask]
+    set ip_masked [expr $ip_aton & $mask_aton]
+    set node [$ns_ ip-to-node $nhopip]
+    if { $node != {} } {
+        $self add-route $ip_masked [[$ns_ link $self $node] head]
+	return
+    }
+
+    set target [$ns_ ip-to-target $nhopip]
+    if { $target == {} } {
+	set nhop_aton [$ns_ inet-aton $nhopip]
+	set target [$ns_ ip-to-target [$ns_ inet-ntoa \
+	    [expr $nhop_aton & [$ns_ inet-aton 255.255.255.0]]]]
+    }
+
+    if { $target != {} } {
+	$self add-route $ip_masked $target
+    }
+}
+
--- dist-ns-allinone-2.26/ns-2.26/tcl/lib/ns-rtmodule.tcl	Fri Feb 28 10:50:56 2003
+++ ns-allinone-2.26/ns-2.26/tcl/lib/ns-rtmodule.tcl	Fri Nov 28 16:55:25 2003
@@ -125,6 +125,7 @@
 	$classifier_ set mask_ [AddrParams NodeMask 1]
 	$classifier_ set shift_ [AddrParams NodeShift 1]
 	# XXX Base should ALWAYS be the first module to be installed.
+        $classifier_ set ipmask_ [[Simulator instance] inet-aton 255.255.255.0]
 
 	$node install-entry $self $classifier_
 }
--- dist-ns-allinone-2.26/ns-2.26/apps/telnet.cc	Wed Feb 26 15:07:16 2003
+++ ns-allinone-2.26/ns-2.26/apps/telnet.cc	Fri Nov 28 16:55:25 2003
@@ -77,7 +77,7 @@
 {
         if (running_) {
 	        /* call the TCP advance method */
-		agent_->sendmsg(agent_->size());
+		agent_->sendmsg(1); // send 1 byte packets instead of 1460
 		/* reschedule the timer */
 		double t = next();
 		timer_.resched(t);
--- dist-ns-allinone-2.26/ns-2.26/classifier/classifier-hash.h	Wed Feb 26 15:07:30 2003
+++ ns-allinone-2.26/ns-2.26/classifier/classifier-hash.h	Fri Nov 28 16:55:25 2003
@@ -177,5 +177,17 @@
 	const char* hashkey(nsaddr_t, nsaddr_t dst, int) {
 		return (const char*) mshift(dst);
 	}
+	/* Since our address classifier (in flat 32 bit addressing) is
+	   a dest hash classifier, we do a naive longer prefix matching
+	   of the full IP address and then use ipmask_ to do a shorter
+	   prefix matching */
+	virtual int lookup(Packet* p) {
+		hdr_ip* h = hdr_ip::access(p);
+		int sl = get_hash(h->saddr(), h->daddr(), h->flowid());
+		if (sl >= 0 && sl <=maxslot_)
+		  return (sl);
+		return get_hash(h->saddr(), h->daddr() & ipmask_,
+				h->flowid());
+	}
 };
 
--- dist-ns-allinone-2.26/ns-2.26/classifier/classifier.cc	Wed Feb 26 15:07:34 2003
+++ ns-allinone-2.26/ns-2.26/classifier/classifier.cc	Fri Nov 28 16:55:25 2003
@@ -52,13 +52,14 @@
 
 
 Classifier::Classifier() : 
-	slot_(0), nslot_(0), maxslot_(-1), shift_(0), mask_(0xffffffff), nsize_(0)
+	slot_(0), nslot_(0), maxslot_(-1), shift_(0), mask_(0xffffffff), nsize_(0), ipmask_(0xffffff00)
 {
 	default_target_ = 0;
 
 	bind("offset_", &offset_);
 	bind("shift_", &shift_);
 	bind("mask_", &mask_);
+	bind("ipmask_", &ipmask_);
 }
 
 int Classifier::classify(Packet *p)
--- dist-ns-allinone-2.26/ns-2.26/classifier/classifier.h	Wed Feb 26 15:07:34 2003
+++ ns-allinone-2.26/ns-2.26/classifier/classifier.h	Fri Nov 28 16:55:25 2003
@@ -82,10 +82,11 @@
 	int nslot_;
 	int maxslot_;
 	int offset_;		// offset for Packet::access()
-	int shift_;
-	int mask_;
+	u_int32_t shift_;
+	u_int32_t mask_;
 	NsObject *default_target_;
 	int nsize_;       //what size of nslot_ should be
+	u_int32_t ipmask_;
 };
 
 #endif
--- dist-ns-allinone-2.26/ns-2.26/classifier/classifier-port.h	Wed Feb 26 15:07:33 2003
+++ ns-allinone-2.26/ns-2.26/classifier/classifier-port.h	Fri Mar 19 17:27:13 2004
@@ -28,13 +28,29 @@
 #include "ip.h"
 #include "classifier.h"
 
+#ifdef STORE_PKTS
+#ifndef NUM_PKTS
+#define NUM_PKTS 100000
+#endif
+#endif
+
 class PortClassifier : public Classifier {
+#ifdef STORE_PKTS    
+public:
+    	PortClassifier();
+#endif
 protected:
 	int classify(Packet *p);
 // 	void clear(int slot);
 // 	int getnxt(NsObject *);
 //	int command(int argc, const char*const* argv);
 // 	int reserved_;
+#ifdef STORE_PKTS
+	Tcl_HashTable pktsonport;
+	int command(int argc, const char*const* argv);
+	void print_pkts();
+	void alloc_store_pkts(u_int32_t port, u_int32_t max_size=NUM_PKTS);
+#endif
 };
 
 class ReservePortClassifier : public PortClassifier {
--- dist-ns-allinone-2.26/ns-2.26/classifier/classifier-port.cc	Wed Feb 26 15:07:33 2003
+++ ns-allinone-2.26/ns-2.26/classifier/classifier-port.cc	Wed Apr 14 03:58:33 2004
@@ -26,6 +26,31 @@
 #endif
 
 #include "classifier-port.h"
+#include "packet.h"
+
+#ifdef STORE_PKTS
+
+struct pkt_data {
+    double ts;
+    unsigned int size;
+    double clock;
+};
+
+struct pkt_dump {
+    pkt_dump() : num_pkts(0) {}
+    ns_addr_t src;
+    ns_addr_t dst;
+    u_int32_t num_pkts;
+    u_int32_t max_pkts;
+    // variable sized array
+    pkt_data pkts[0];
+};
+
+PortClassifier::PortClassifier()
+{
+    	Tcl_InitHashTable( &pktsonport, TCL_ONE_WORD_KEYS );
+}
+#endif
 
 int PortClassifier::classify(Packet *p) 
 {
@@ -33,8 +58,99 @@
 	// or masking is required since in the 32-bit addressing,
 	// ports are stored in a seperate variable.
 	hdr_ip* iph = hdr_ip::access(p);
+#ifdef STORE_PKTS
+	Tcl_HashEntry *he = Tcl_FindHashEntry( &pktsonport,
+					       (char *)(iph->dport()) );
+
+	pkt_dump *dump = 0;
+	if( he != 0 ) {
+	    dump = (pkt_dump *)Tcl_GetHashValue(he);
+	    if ( dump->num_pkts < dump->max_pkts ) {
+		if( dump->num_pkts == 0 ) {
+		    dump->src = iph->src_;
+		    dump->dst = iph->dst_;
+		}
+		hdr_cmn *hc = HDR_CMN(p);
+		dump->pkts[dump->num_pkts].size = hc->size();
+		dump->pkts[dump->num_pkts].ts = p->time_; 
+		dump->pkts[dump->num_pkts].clock = Scheduler::instance().clock(); 
+		dump->num_pkts += 1;
+	    }
+	} 
+#endif
 	return iph->dport();
 };
+
+#ifdef STORE_PKTS
+
+int PortClassifier::command(int argc, const char*const* argv)
+{
+        if (argc == 2 && strcmp(argv[1],"print-pkts") == 0) {
+	    	print_pkts();
+                return(TCL_OK);
+        } 
+#ifdef STORE_PKTS
+	else if (argc >= 3 && strcmp(argv[1],"store-pkts") == 0) {
+	        u_int32_t port = atoi(argv[2]);
+		if ( argc == 4 )
+		    alloc_store_pkts(port, atoi(argv[3]));
+		else
+		    alloc_store_pkts(port);
+                return(TCL_OK);
+        }
+#endif
+        return (Classifier::command(argc, argv));
+}
+
+#ifdef STORE_PKTS
+void PortClassifier::alloc_store_pkts(u_int32_t port, u_int32_t max_size) {
+
+	int newentry = 0;
+	pkt_dump *dump = 0;
+	Tcl_HashEntry *he = Tcl_CreateHashEntry( &pktsonport,
+						 (char *)port,
+						 &newentry );
+	if( newentry == 0 ) {
+	    dump = (pkt_dump *)Tcl_GetHashValue(he);
+	    free(dump);
+	    dump = 0;
+	} 
+	dump = (pkt_dump *)calloc(1, sizeof(pkt_dump) + 
+		    		  max_size * sizeof(pkt_data) );
+	dump->max_pkts = max_size;
+	Tcl_SetHashValue( he, (char *)dump );
+}
+#endif
+
+void PortClassifier::print_pkts()
+{
+    	Tcl_HashSearch search;
+	Tcl_HashEntry *he = 0;
+	Tcl &tcl = Tcl::instance();
+	char srcip[20], dstip[20];
+
+	for( he = Tcl_FirstHashEntry(&pktsonport, &search) ; he != 0 ;
+	     he = Tcl_NextHashEntry(&search) ) {
+	    pkt_dump *dump = (pkt_dump *)Tcl_GetHashValue( he );
+	    if( dump->num_pkts == 0 ) 
+		continue;
+
+	    tcl.evalf("[Simulator instance] inet-ntoa %d", dump->src.addr_ );
+	    strncpy( srcip, tcl.result(), sizeof(srcip) );
+	    tcl.evalf("[Simulator instance] inet-ntoa %d", dump->dst.addr_ );
+	    strncpy( dstip, tcl.result(), sizeof(dstip) );
+	    printf("***************src-%s:%d dst-%s:%d***************\n", 
+		    srcip, dump->src.port_, dstip, dump->dst.port_ );
+	    for( unsigned int i=0 ; i<dump->num_pkts ; i++ ) {
+		printf("%f %d %f\n", dump->pkts[i].ts, dump->pkts[i].size,
+		       dump->pkts[i].clock );
+	    }
+	    printf("---------------------------------------\n");
+	    fflush(stdout);
+	}
+}
+
+#endif 
 
 static class PortClassifierClass : public TclClass {
 public:
--- dist-ns-allinone-2.26/ns-2.26/common/ip.h	Wed Feb 26 15:07:39 2003
+++ ns-allinone-2.26/ns-2.26/common/ip.h	Fri Nov 28 16:55:25 2003
@@ -76,11 +76,11 @@
 	/* per-field member acces functions */
 	ns_addr_t& src() { return (src_); }
 	nsaddr_t& saddr() { return (src_.addr_); }
-        int32_t& sport() { return src_.port_;}
+        u_int32_t& sport() { return src_.port_;}
 
 	ns_addr_t& dst() { return (dst_); }
 	nsaddr_t& daddr() { return (dst_.addr_); }
-        int32_t& dport() { return dst_.port_;}
+        u_int32_t& dport() { return dst_.port_;}
 	int& ttl() { return (ttl_); }
 	/* ipv6 fields */
 	int& flowid() { return (fid_); }
--- dist-ns-allinone-2.26/ns-2.26/common/packet.h	Wed Feb 26 15:07:40 2003
+++ ns-allinone-2.26/ns-2.26/common/packet.h	Fri Jan 16 16:09:19 2004
@@ -325,6 +325,10 @@
 	inline int& ref_count() { return (ref_count_); }
 	static inline Packet* alloc();
 	static inline Packet* alloc(int);
+        static inline int compress(unsigned long* pTarget, 
+				   unsigned long* pSource, int Count);
+	static inline int uncompress(unsigned long* pTarget, 
+				     unsigned long* pSource, int Count);
 	inline void allocdata(int);
 	// dirty hack for diffusion data
 	inline void initdata() { data_  = 0;}
@@ -519,8 +523,8 @@
 			abort();
 	}
 	init(p); // Initialize bits_[]
-	(HDR_CMN(p))->next_hop_ = -2; // -1 reserved for IP_BROADCAST
-	(HDR_CMN(p))->last_hop_ = -2; // -1 reserved for IP_BROADCAST
+	(HDR_CMN(p))->next_hop_ = (nsaddr_t)-2; // -1 reserved for IP_BROADCAST
+	(HDR_CMN(p))->last_hop_ = (nsaddr_t)-2; // -1 reserved for IP_BROADCAST
 	p->fflag_ = TRUE;
 	(HDR_CMN(p))->direction() = hdr_cmn::DOWN;
 	/* setting all direction of pkts to be downward as default; 
@@ -607,6 +611,88 @@
                         p->bits_[offset + i + 12], p->bits_[offset + i + 13],
                         p->bits_[offset + i + 14], p->bits_[offset + i + 15]);
         }
+}
+
+inline int Packet::compress(unsigned long* pTarget, unsigned long* pSource, int Count)
+{ // Returns total size of target buffer
+  // This code works only on buffers <= 0x10000 words long (about 250k bytes)
+  // Target buffer must be 1 word longer than source, to allow for the
+  // case where no zeros at all occur.
+ int offset = 0;
+ int skipping = 1;
+ int targoffset = 0;
+ int lth;
+
+ unsigned long* pCW = pTarget; // Control word pointer
+ // Format of control word is 16 bits of length, 16 bits of starting offset
+ *pCW = 0;  // All zero CW means done
+ while(offset < Count)
+   {
+     if (skipping)
+       {
+         if (pSource[offset] |= 0)
+           { // Time to stop skipping
+             skipping = 0;
+             pCW = &pTarget[targoffset];
+             *pCW = offset; // Set source offset, leave lth zero for now
+             targoffset++;  // Leave room for CW
+             lth = 0;       // Counts how many non-zero
+           }
+         else
+           { // Still zero, just skip it
+             offset++;
+           }
+       }
+     if (!skipping)
+       {
+         // First see if we found a zero
+         if (pSource[offset] == 0)
+           { // Found a zero, but just use it unless two in a row
+             if ((offset+1) < Count)
+               {
+                 if (pSource[offset+1] == 0)
+                   {
+                     skipping = 1; // Found two in a row, resume skipping
+                     *pCW |= (lth << 16);
+                     //*pCW |= (0x1L << 31); // just for debugging, mark cw
+                     offset++; // And skip this one
+                   }
+               }
+           }
+       }
+     if (!skipping)
+       {
+         pTarget[targoffset++] = pSource[offset++];
+         lth++;
+       }
+   }
+ if (!skipping)
+   { // Need to update last CW
+     *pCW |= (lth << 16);
+     //*pCW |= (0x1L << 31); // just for debugging, mark cw
+   }
+ return(targoffset);
+}
+
+inline int Packet::uncompress(unsigned long* pTarget, unsigned long* pSource, int Count)
+{ // Reverse above compression
+  // Target buffer MUST BE ZERO on entry!
+int offset = 0;
+int targoffset = 0;
+int lth;
+
+  while(offset < Count)
+    {
+      // Get next control word
+      targoffset = pSource[offset] & 0xffff;
+      lth = pSource[offset] >> 16;
+      offset++;
+      for (int i = 0; i < lth; i++)
+        { // Copy to target
+          pTarget[targoffset++] = pSource[offset++];
+        }
+    }
+  return(targoffset); // Last non-zero entry
 }
 
 #endif
--- dist-ns-allinone-2.26/ns-2.26/common/scheduler.cc	Wed Feb 26 15:07:41 2003
+++ ns-allinone-2.26/ns-2.26/common/scheduler.cc	Tue Mar 30 17:46:34 2004
@@ -46,12 +46,50 @@
 #include "config.h"
 #include "scheduler.h"
 #include "packet.h"
+#ifdef USEEVENTS
+#include "tbevent.h"
+#endif
+
+#ifdef HAVE_POLLER
+
+#include "Poller_kqueue.h"
+
+Poller_kqueue *poller;
+
+#endif
 
 
 #ifdef MEMDEBUG_SIMULATIONS
 #include "mem-trace.h"
 #endif
 
+#ifdef MEASURE_EVENT_RATE
+
+unsigned long long event_dispatch_counter;
+unsigned int events_per_sec_arr[70];
+
+#endif
+
+#ifdef GETTIME_TSC
+
+#define read_tsc()      \
+    ({ \
+        unsigned long low, high; \
+        asm volatile( \
+        ".byte 0x0f; .byte 0x31" \
+        : "=d" (high), "=a" (low)); \
+        ((unsigned long long)high << 32) | low; \
+    })
+
+#define TSC_FREQ     851.94
+#define TSC_COUNT_PERSEC (TSC_FREQ * 1000000)
+
+#endif
+
+#ifdef SCHED_DEBUG
+static Tcl_HashTable newevents;
+#endif
+
 Scheduler* Scheduler::instance_;
 scheduler_uid_t Scheduler::uid_ = 1;
 
@@ -62,6 +100,9 @@
 
 Scheduler::Scheduler() : clock_(SCHED_START), halted_(0)
 {
+#ifdef SCHED_DEBUG
+	  Tcl_InitHashTable( &newevents, TCL_ONE_WORD_KEYS );
+#endif
 }
 
 Scheduler::~Scheduler(){
@@ -112,6 +153,17 @@
 
 	e->time_ = t;
 	insert(e);
+#ifdef SCHED_DEBUG
+	int newentry = 0 ;
+	Tcl_HashEntry *he = Tcl_CreateHashEntry( &newevents,
+						 (char *)((unsigned int)e->uid_),
+						 &newentry );
+	if( newentry == 0 ) {
+	  fprintf(stderr, "e->uid_ = %d already present. error\n", (unsigned int)e->uid_);
+	} else {
+	  Tcl_SetHashValue( he, (char *)h );
+	}
+#endif
 }
 
 void
@@ -579,7 +631,7 @@
 	}
 } class_calendar_sched;
 
-CalendarScheduler::CalendarScheduler() : cal_clock_(clock_) {
+CalendarScheduler::CalendarScheduler() : cal_clock_(clock_), cached_head_(0) {
 	reinit(4, 1.0, cal_clock_);
 }
 
@@ -598,6 +650,7 @@
 		// may happen in RT scheduler
 		cal_clock_ = e->time_;
 		i = lastbucket_ = CALENDAR_HASH(cal_clock_);
+		cached_head_ = e;
 	} else
 		i = CALENDAR_HASH(e->time_);
 
@@ -703,6 +756,10 @@
 	if (qsize_ == 0)
 		return NULL;
 
+	if (cached_head_) {
+	  return cached_head_;	  
+	}
+
 	int l, i = lastbucket_;
 	int lastbucket_dec = (lastbucket_) ? lastbucket_ - 1 : nbuckets_ - 1;
 	double diff;
@@ -755,7 +812,7 @@
 	 */
 	lastbucket_ = l;
  	cal_clock_  = e->time_;
-	
+	cached_head_ = e;
 	return e;
 }
 
@@ -797,6 +854,8 @@
 		resize(nbuckets_ >> 1, cal_clock_);
 	}
 
+	cached_head_ = 0;
+
 	return e;
 }
 
@@ -926,6 +985,9 @@
 
 	--qsize_;
 
+	if ( e == cached_head_ )
+	  cached_head_ = 0;
+
 	return;
 }
 
@@ -946,23 +1008,6 @@
 	return NULL;
 }
 
-#ifndef WIN32
-#include <sys/time.h>
-#endif
-
-class RealTimeScheduler : public CalendarScheduler {
-public:
-	RealTimeScheduler();
-	virtual void run();
-	double start() const { return start_; }
-	virtual void reset();
-protected:
-	void sync() { clock_ = tod(); }
-	double tod();
-	double slop_;	// allowed drift between real-time and virt time
-	double start_;	// starting time
-};
-
 static class RealTimeSchedulerClass : public TclClass {
 public:
 	RealTimeSchedulerClass() : TclClass("Scheduler/RealTime") {}
@@ -971,72 +1016,245 @@
 	}
 } class_realtime_sched;
 
-RealTimeScheduler::RealTimeScheduler() : start_(0.0)
+RealTimeScheduler::RealTimeScheduler() : start_(0.0), num_violation_(0),
+                                         clock_first_violation_(0.0)
 {
 	bind("maxslop_", &slop_);
+#ifdef USEEVENTS
+        evsink_ = 0 ;
+#endif
+#ifdef GETTIME_TSC
+        basetsc_ = 0 ;
+	oneontscfreq_ = 1.0 / (double)TSC_COUNT_PERSEC;
+	tscfreq_ = TSC_COUNT_PERSEC;
+#endif
+#ifdef HAVE_POLLER
+	poller = new Poller_kqueue;
+	poller->init();
+#endif
+}
+
+#ifdef USEEVENTS
+  
+int RealTimeScheduler::command(int argc, const char*const* argv)
+{
+  if (instance_ == 0)
+    instance_ = this;
+  
+  
+  if( argc == 3 ) {
+    if(strcmp(argv[1], "tbevent-sink") == 0) {
+      evsink_ = (TbEventSink *)TclObject::lookup(argv[2]);
+      return(TCL_OK);
+    } else if (strcmp(argv[1], "cpuspeed") == 0) {
+      double ret;
+      if( (ret = atof(argv[2])) != 0 ) {
+	tscfreq_ = ret;
+	oneontscfreq_ = 1.0 / tscfreq_;
+      }
+      return(TCL_OK);
+    }
+  }
+
+  return(Scheduler::command(argc, argv));
+}  
+
+#endif
+
+/*
+ * dispatch a single simulator event by setting the system
+ * virtul clock to the event's timestamp and calling its handler.
+ * Note that the event may have side effects of placing other items
+ * in the scheduling queue
+ */
+
+void
+RealTimeScheduler::dispatch(Event* p, double t)
+{
+
+#ifdef SCHED_DEBUG
+	Tcl_HashEntry *he = Tcl_FindHashEntry(&newevents, (char *)((unsigned int)p->uid_));
+	if( he ) {
+	  Tcl_DeleteHashEntry(he);
+	} else {
+	  fprintf(stderr, "error. couldnt find event with uid = %d\n", (unsigned int)p->uid_);
+	}
+#endif
+	clock_ = t;
+	p->uid_ = -p->uid_;	// being dispatched
+	p->handler_->handle(p);	// dispatch
+#ifdef MEASURE_EVENT_RATE
+	event_dispatch_counter++;
+#endif
 }
 
 double
 RealTimeScheduler::tod()
 {
+#ifdef GETTIME_TSC
+                 
+        unsigned long long curtsc = read_tsc();
+        return (((double)(curtsc - basetsc_)) * oneontscfreq_);
+#else
 	timeval tv;
 	gettimeofday(&tv, 0);
 	double s = tv.tv_sec;
 	s += (1e-6 * tv.tv_usec);
 	return (s - start_);
+#endif
 }
 
 void
 RealTimeScheduler::reset()
 {
 	clock_ = SCHED_START;
+#ifdef GETTIME_TSC   
+	timeval tv;
+	gettimeofday(&tv, 0);
+        basetsc_ = read_tsc();
+	start_ = tv.tv_sec + (1e-6 * tv.tv_usec);
+#else
 	start_ = tod();
+#endif
 }
 
+#ifdef SCHED_DEBUG
+int done = 0;
+#endif
+
 void 
 RealTimeScheduler::run()
 { 
+#ifdef SELECT_TIMEOUT
 	static const double RTSCHEDULER_MINWAIT = 1.0e-3; // don't wait for less
+	static const double delta = 1.0e-4; // should be smaller than above
+#endif
+	static const int VIOLATION_THRESHOLD = 5;
+	static const double VIOLATION_TIME_THRESHOLD = 1.0;
 	const Event *p;
+	bool gethead = true;
+
+#ifdef USEEVENTS
+
+	if( evsink_ ) {
+	  evsink_->init();
+	  evsink_->subscribe();
+	}
+
+#endif
 
 	/*XXX*/
 	instance_ = this;
 
 	while (!halted_) {
+		if( gethead ) {
+		  p = head();
+		  gethead = false;
+		}
 		clock_ = tod();
-		p = head();
+
 		if (p && (clock_ - p->time_) > slop_) {
-			fprintf(stderr,
-				"RealTimeScheduler: warning: slop "
-				"%f exceeded limit %f [clock_:%f, p->time_:%f]\n",
-				clock_ - p->time_, slop_, clock_, p->time_);
+		    num_violation_++;
+		    if (num_violation_ == 1 ) {
+			clock_first_violation_ = clock_;
+		    } else if(num_violation_ == VIOLATION_THRESHOLD) {
+			double diff = clock_ - clock_first_violation_;
+			if (diff < VIOLATION_TIME_THRESHOLD) {
+#ifdef USEEVENTS
+			    if (evsink_) {
+#ifdef RESWAP
+				evsink_->send_nseswap();
+#endif
+			    }
+#endif
+			} else {
+			    clock_first_violation_ = clock_;
+			    num_violation_ = 1;
+			}
+		    }
+#ifdef PRINT_SLOP
+		    fprintf(stderr,
+			    "RealTimeScheduler: warning: slop "
+			    "%f exceeded limit %f [clock_:%f, p->time_:%f]\n",
+			    clock_ - p->time_, slop_, clock_, p->time_);
+#endif
+		    clock_ = tod();
 		}
 		// handle "old events"
 		while (p && p->time_ <= clock_) {
 
+#ifdef DISPATCH_IN_RT
 			dispatch(deque(), clock_);
+#else
+			dispatch(deque(), p->time_);
+#endif
 			if (halted_)
 				return;
 			p = head();
 			clock_ = tod();
 		}
-		
+
+#ifdef USEEVENTS
+		if( evsink_ && evsink_->poll() == 1 ) {
+		  gethead = true;
+		  continue;
+		}
+#endif
+
+#ifdef SCHED_DEBUG
+		if( clock_ >= 240.0 && done == 0 ) {
+		  fprintf( stderr, "After 60 secs. Hash Stats for newevents = %s\n",
+			   Tcl_HashStats(&newevents) );
+		  done = 1;
+		}
+#endif
+
+#if !defined(HAVE_POLLER) && defined(SELECT_TIMEOUT)
 		if (!p) {
 			// blocking wait for TCL events
-			Tcl_WaitForEvent(0); // no sim events, wait forever
+			// Tcl_WaitForEvent(0); // no sim events, wait forever
+			// XXX: But we can't afford to wait forever coz testbed
+			// events are not being polled here and we might miss them
 			clock_ = tod();
+			Tcl_WaitForEvent(0); // no sim events, wait forever
 		} else {
 			double diff = p->time_ - clock_;
 			// blocking wait only if there is enough time
 			if (diff > RTSCHEDULER_MINWAIT) {
 				Tcl_Time to;
 				to.sec = long(diff);
-				to.usec = long(1e6*(diff - to.sec));
+				to.usec = long(1e6*((diff - delta) - to.sec)); // wait for delta less
 				Tcl_WaitForEvent(&to);    // block
 				clock_ = tod();
 			}
 		}
-		Tcl_DoOneEvent(TCL_DONT_WAIT);
+#else
+		clock_ = tod();
+#endif
+#ifdef HAVE_POLLER
+		struct Poller::PollEvent pe;
+
+		if(poller->waitForEvents(0) == 0) {
+		    while(poller->getNextEvent(&pe) == 0) {
+			Poller::Client *client = pe.client;
+			if (client) {
+			    client->notifyPollEvent(&pe);
+			    gethead = true;
+			}
+		    }
+		}
+#else
+		if( Tcl_DoOneEvent(TCL_DONT_WAIT) == 1 ) {
+		  /* If we have more than 1 I/O channel (bpf device typically)
+		   * that we can get packets from, we better service all that
+		   * are ready in one go or some packets will be quite late. The 
+		   * while loop below runs as many times as there are I/O channels
+		   * ready
+		   */
+		  while( Tcl_ServiceEvent(0) == 1 );
+		  gethead = true;
+		}
+#endif
 	}
 	// we reach here only if halted
 }
--- dist-ns-allinone-2.26/ns-2.26/common/scheduler.h	Wed Feb 26 15:07:41 2003
+++ ns-allinone-2.26/ns-2.26/common/scheduler.h	Thu Mar 11 19:01:17 2004
@@ -98,7 +98,7 @@
 protected:
 	void dumpq();	// for debug: remove + print remaining events
 	void dispatch(Event*);	// execute an event
-	void dispatch(Event*, double);	// exec event, set clock_
+	virtual void dispatch(Event*, double);	// exec event, set clock_
 	Scheduler();
 	virtual ~Scheduler();
 	int command(int argc, const char*const* argv);
@@ -176,6 +176,7 @@
 private:
 	virtual void insert2(Event*);
 	double cal_clock_;  // same as clock in sims, may be different in RT-scheduling.
+	const Event *cached_head_;
 
 };
 
@@ -206,5 +207,43 @@
 	int validate(Event *);
 };
 
+#ifndef WIN32
+#include <sys/time.h>
+#endif
+
+#ifdef USEEVENTS
+class TbEventSink;
+#endif
+
+class RealTimeScheduler : public CalendarScheduler {
+public:
+	RealTimeScheduler();
+	virtual void run();
+	virtual double start() const { return start_; }
+	virtual void reset();
+#ifdef USEEVENTS
+	int command(int argc, const char*const* argv);
+#endif
+protected:
+	void sync() { clock_ = tod(); }
+	virtual void dispatch(Event*, double);	// exec event, set clock_
+	double tod();
+	double slop_;	// allowed drift between real-time and virt time
+	double start_;	// starting time
+	int    num_violation_; /* Number of times the clock has drifted by
+	                        * slop between real-time and virtual time
+			        */
+	double clock_first_violation_; /* Value of clock when the first
+				        * violation is detected
+				        */
+#ifdef USEEVENTS
+        TbEventSink *evsink_;
+#endif
+#ifdef GETTIME_TSC
+        unsigned long long basetsc_ ;
+        double  oneontscfreq_;
+        double  tscfreq_;
+#endif
+};
 
 #endif
--- dist-ns-allinone-2.26/ns-2.26/common/simulator.cc	Wed Feb 26 15:07:41 2003
+++ ns-allinone-2.26/ns-2.26/common/simulator.cc	Fri Nov 28 16:55:25 2003
@@ -23,6 +23,7 @@
 #include "object.h"
 
 //class ParentNode;
+Simulator* Simulator::instance_;
 
 static class SimulatorClass : public TclClass {
 public:
@@ -92,6 +93,25 @@
 			int id = atoi(argv[3]);
 			add_node(node, id);
 			return TCL_OK;
+		} else if (strcmp(argv[1], "add-ip") == 0) {
+			Node *node = (Node *)(TclObject::lookup(argv[2]));
+			if (node == NULL) {
+				tcl.add_errorf("Wrong object name %s",argv[2]);
+				return TCL_ERROR;
+			}
+			in_addr_t ip = inet_addr(argv[3]);
+			int newentry = 0;
+			Tcl_HashEntry *he = Tcl_CreateHashEntry( &iptonode,
+								 (char *)(ip),
+								 &newentry );
+			if ( newentry == 0 ) {
+				Node *n = (Node *)Tcl_GetHashValue( he );
+				tcl.add_errorf("IP address %s already belongs to node %s\n",
+					       argv[3], n->name() );
+				return TCL_ERROR;
+			}
+			Tcl_SetHashValue( he, (char *)node);	
+			return TCL_OK;
 		} 
 	}
 	return (TclObject::command(argc, argv));
@@ -250,3 +270,11 @@
 	return l_head;
 }
 
+Node * Simulator::ip_to_node(in_addr_t ip) {
+
+	Tcl_HashEntry *he = Tcl_FindHashEntry( &iptonode, (char *)ip );
+	if( he == 0 ) 
+		return 0;
+	else
+		return (Node *)Tcl_GetHashValue(he);
+}
--- dist-ns-allinone-2.26/ns-2.26/common/simulator.h	Wed Feb 26 15:07:42 2003
+++ ns-allinone-2.26/ns-2.26/common/simulator.h	Fri Nov 28 16:55:25 2003
@@ -25,17 +25,21 @@
 
 #include <tclcl.h>
 #include "object.h"
+#include <sys/types.h>
 
 class ParentNode;
 class RouteLogic;
+class Node;
 
 class Simulator : public TclObject {
 public:
       Simulator() : nodelist_(NULL), rtobject_(NULL), nn_(0), \
-	size_(0) {}
+	size_(0) { Tcl_InitHashTable( &iptonode, TCL_ONE_WORD_KEYS ); instance_ = this; }
       ~Simulator() {
-	    delete []nodelist_; 
+	    delete []nodelist_;
+	    instance_ = 0;
       }
+      static Simulator &instance() { return (*instance_); }
 	int command(int argc, const char*const* argv);
 	void populate_flat_classifiers();
 	void populate_hier_classifiers();
@@ -45,12 +49,15 @@
 	char *append_addr(int level, int *addr);
 	void alloc(int n);
 	void check(int n);
+	Node *ip_to_node(in_addr_t);
 	
 private:
         ParentNode **nodelist_;
 	RouteLogic *rtobject_;
 	int nn_;
 	int size_;
+	Tcl_HashTable iptonode;
+	static Simulator *instance_;
 };
 
 #endif /* ns_simulator_h */
--- dist-ns-allinone-2.26/ns-2.26/common/tclAppInit.cc	Wed Feb 26 15:07:42 2003
+++ ns-allinone-2.26/ns-2.26/common/tclAppInit.cc	Fri Nov 28 16:55:25 2003
@@ -186,6 +186,7 @@
 	return TCL_OK;
 }
 
+#if 0
 #ifndef WIN32
 void
 abort()
@@ -200,6 +201,7 @@
 #endif /*abort*/
 	/*NOTREACHED*/
 }
+#endif
 #endif
 
 }
--- dist-ns-allinone-2.26/ns-2.26/common/timer-handler.cc	Wed Feb 26 15:07:42 2003
+++ ns-allinone-2.26/ns-2.26/common/timer-handler.cc	Fri Nov 28 16:55:25 2003
@@ -76,3 +76,40 @@
 	if (status_ == TIMER_HANDLING)
 		status_ = TIMER_IDLE;
 }
+
+#ifdef MEASURE_EVENT_RATE
+
+extern unsigned long long event_dispatch_counter;
+
+unsigned int idx;
+
+#define MAX_EVENT_ARR 70
+
+// circular buffer for the data
+extern unsigned int events_per_sec_arr[MAX_EVENT_ARR];
+
+
+void EventRateTimer::expire(Event *e) {
+
+  if ( idx % MAX_EVENT_ARR == MAX_EVENT_ARR-1 ) {
+
+    events_per_sec_arr[idx % MAX_EVENT_ARR] = event_dispatch_counter;
+    event_dispatch_counter = 0;
+    idx++;
+    
+    int i = 0 ;
+    for( ; i < MAX_EVENT_ARR-1 ; i++ ) {
+      fprintf(stderr, "%u, ", events_per_sec_arr[i] );
+    }
+    fprintf(stderr, "%u\n", events_per_sec_arr[MAX_EVENT_ARR-1] );    
+  } else {
+  
+    events_per_sec_arr[idx % MAX_EVENT_ARR] = event_dispatch_counter;
+    event_dispatch_counter = 0;
+    idx++;
+  }
+  resched(1.0);    
+    
+}
+
+#endif
--- dist-ns-allinone-2.26/ns-2.26/common/timer-handler.h	Wed Feb 26 15:07:42 2003
+++ ns-allinone-2.26/ns-2.26/common/timer-handler.h	Fri Nov 28 16:55:25 2003
@@ -88,4 +88,15 @@
 // mode:c++
 // End:
 
+#ifdef MEASURE_EVENT_RATE
+
+class EventRateTimer : public TimerHandler {
+
+public:
+  virtual void expire(Event *e) ;
+
+};
+
+#endif
+
 #endif /* timer_handler_h */
--- dist-ns-allinone-2.26/ns-2.26/routing/address.cc	Wed Feb 26 15:09:15 2003
+++ ns-allinone-2.26/ns-2.26/routing/address.cc	Fri Nov 28 16:55:25 2003
@@ -120,7 +120,7 @@
 			}
 			else 
 				levels_ = temp;
-			NodeShift_ = new int[levels_ + 1];
+			NodeShift_ = new u_int32_t[levels_ + 1];
 			for (i = 3, c = 1; c <= levels_; c++, i+=2)
 				NodeShift_[c] = atoi(argv[i]);
 			return (TCL_OK); 
@@ -136,7 +136,7 @@
 			}
 			else 
 				levels_ = temp;
-			NodeMask_ = new int[levels_ + 1];
+			NodeMask_ = new u_int32_t[levels_ + 1];
 			for (i = 3, c = 1; c <= levels_; c++, i+=2) 
 				NodeMask_[c] = atoi(argv[i]);
 			return (TCL_OK);
--- dist-ns-allinone-2.26/ns-2.26/routing/address.h	Wed Feb 26 15:09:15 2003
+++ ns-allinone-2.26/ns-2.26/routing/address.h	Fri Nov 28 16:55:25 2003
@@ -61,10 +61,10 @@
 	// e.g 32 for level=1, 10/11/11 for level=3.
 	// used to check validity of address-str.
 	int *bpl_;
-	int *NodeShift_;
-	int *NodeMask_;
-	int McastShift_;
-	int McastMask_;
+	u_int32_t *NodeShift_;
+	u_int32_t *NodeMask_;
+	u_int32_t McastShift_;
+	u_int32_t McastMask_;
 	int levels_;
  protected:
 	int command(int argc, const char*const* argv);
--- dist-ns-allinone-2.26/ns-2.26/emulate/iptap.cc	Wed Feb 26 15:08:40 2003
+++ ns-allinone-2.26/ns-2.26/emulate/iptap.cc	Fri Apr 16 06:07:15 2004
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 1998 The Regents of the University of California.
+ * Copyright (c) 1997, 1998, 2003 The Regents of the University of California.
  * All rights reserved.
  * 
  * Redistribution and use in source and binary forms, with or without
@@ -37,28 +37,80 @@
 #endif
 
 #include "iptap.h"
+#include "node.h"
+#include "simulator.h"
+#include <sys/time.h>
+#include <netinet/in.h>
+
+#include "tbnexthop.h"
+
+#ifdef MEASURE_EVENT_RATE
+#include "timer-handler.h"
+
+EventRateTimer ert;
+unsigned int firstpacket;
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include        "tbdefs.h"
+#include        "log.h"
+
+#ifdef __cplusplus
+}
+#endif
 
 
 static class IPTapAgentClass : public TclClass {
  public:
-	IPTapAgentClass() : TclClass("Agent/IPTap") {}
+	IPTapAgentClass() : TclClass("Agent/IPTap") {
+	}
 	TclObject* create(int, const char*const*) {
+#ifdef MEASURE_EVENT_RATE
+	  // schedule the event rate 
+	  if ( firstpacket == 0 ) {
+	    ert.sched(1.0);
+	    firstpacket++;
+	  }
+#endif
 		return (new IPTapAgent());
 	}
 } class_iptap_agent;
 
 
 IPTapAgent::IPTapAgent() 
+#ifdef MEASURE_DELAYS  
+                        :  firstpkt_in_burst(false),
+			   max_delay(0.0), bpf_ts_to_iptap_max_delay(0.0),
+			   bpf_ts_to_iptap_min_delay(100.0), data_idx(0)
+#endif
 {
   int i = 0;
   index = 0;
+#ifdef MEASURE_DELAYS
+  memset( bpf_ts_to_iptap, 0, sizeof(bpf_ts_to_iptap));
+#endif
   for (; i < MAX_PACKETS ; i++) {
     ident[i] = -1;
     offset[i] = -1;
   }
 
+  sbuflen = rbuflen = ROUNDUP(sizeof(struct ip) + Packet::hdrlen_, sizeof(unsigned long) )
+                      + sizeof(unsigned long);
+  sendbuf = new unsigned char[sbuflen];
+  recvbuf = new unsigned char[rbuflen];
+  mtu = 1500; /* just assume default */
+  icmpagent = 0;
+  memset( &srcnodeipaddr, 0, sizeof(srcnodeipaddr) );
+  send_count = recv_count = 0;
 }
 
+IPTapAgent::~IPTapAgent()
+{
+  delete[] sendbuf;
+  delete[] recvbuf;
+}
 
 /*
  * Checking for duplicate packets.  Need to do this, if running
@@ -127,21 +179,77 @@
   inst->processpkt(p, ts);
 }
 
+bool PacketDecapsulateIfNeeded(Packet *p);
+
 void
 IPTapAgent::processpkt(Packet *p, const struct timeval &ts)
 {
   struct ip *ipheader;
-  struct tcphdr *tcpheader;
-  unsigned char *buf;
   
   /* Ip header information from the grabbed packet. */
-  int iphlen;  
   unsigned short datagramlen;
   unsigned char ttl;
+
+  recv_count++;
+
+#ifdef MEASURE_DELAYS
+
+  double delay ;
+  // This code keeps some delay data and drops the packet 
+  if( firstpkt_in_burst ) {
+    ts_firstpkt_in_burst = ts.tv_sec + ts.tv_usec * 1e-6 ;
+    firstpkt_in_burst = false;
+    delay = 0.0;
+  } else {
+    delay = double(ts.tv_sec + ts.tv_usec * 1e-6) - ts_firstpkt_in_burst;
+    timeval tv;
+    gettimeofday(&tv, 0);
+    double nowts = tv.tv_sec + (1e-6 * tv.tv_usec);
+    max_delay = MAX(nowts - ts_firstpkt_in_burst, max_delay);
+  }
+
+
+#endif
+
   
-  /* TCP header info from the grabbed packet. */
-  unsigned char tcphlen;
+#if 0
+  timeval tv;
+  gettimeofday(&tv, 0);
+  double nowts = tv.tv_sec + (1e-6 * tv.tv_usec);
+  max_delay = MAX(nowts - ts_firstpkt_in_burst, max_delay);
+  bpf_ts_to_iptap[data_idx] = nowts - (ts.tv_sec + ts.tv_usec * 1e-6);
+  bpf_ts_to_iptap_max_delay = MAX(bpf_ts_to_iptap[data_idx],
+			      bpf_ts_to_iptap_max_delay);
+  bpf_ts_to_iptap_min_delay = MIN(bpf_ts_to_iptap[data_idx],
+			      bpf_ts_to_iptap_min_delay);
+  data_idx = (data_idx+1) %
+    (sizeof(bpf_ts_to_iptap)/sizeof(bpf_ts_to_iptap[0]));
+
+  Packet::free(p);
+  return;
   
+#endif
+
+#if 0 //MEASURE_EVENT_RATE
+  // schedule the event rate 
+  if ( firstpacket == 0 ) {
+    ert.sched(1.0);
+    firstpacket++;
+  }
+#endif
+  
+  // Pcap would have filled in a timestamp based on the bpf timestamp
+  double ptime = p->time_;
+  // We always need to decapsulate right here coz further simulation
+  // of the packet
+  if( PacketDecapsulateIfNeeded(p) ) {
+      p->time_ = ptime;
+      goto sendit;
+  }
+  /* PcapNetwork created this packet and does not know how
+     to initialize it. So, we need to do that here by calling
+     the base Agent class's initpkt method */
+  initpkt(p);
   /* 
      At this point, all I have to do is to grab the ttl value 
      from the received packet and put it in p's ttl field after
@@ -150,8 +258,6 @@
   */
 
   ipheader = (struct ip *) p->accessdata();
-  buf = p->accessdata();
-  iphlen = ipheader->ip_hl * 4;
   ttl = ipheader->ip_ttl;
   if (!(--ttl)) {
     fprintf(stderr,
@@ -174,21 +280,43 @@
   datagramlen = ntohs(ipheader->ip_len);
 
   /* Put all the info in the ns headers. */
-  hdr_cmn *ch = HDR_CMN(p);
+  hdr_cmn *ch;
+  ch = HDR_CMN(p);
   ch->size() = datagramlen;
 
-  hdr_ip *ih = HDR_IP(p);
+  hdr_ip *ih;
+  ih = HDR_IP(p);
   ih->ttl() = ttl;
 
+  /* Route lookups need not be performed here in the new code.
+     The classifier has the correct rules. Just need to make sure
+     that destination IP address and port are stored in the header
+     of the ns packet. Need to decapsulate the payload into ns
+     bag of bits of a) it was encapsulated before and b) the dest
+     IP address is local in this simulator */
+
+  ih->daddr() = ntohl(ipheader->ip_dst.s_addr);
+  /* Dunno how to take care of ports yet */  
+
+sendit:
+  // syncing the clock to real-time for every packet
+  // so that further packet scheduling uses a reliable
+  // value of clock instead of some old value.
+  Scheduler::instance().sync();
+
+#ifdef MEASURE_DELAYS
+  Scheduler::instance().schedule( target_, p, max_delay );
+#else 
   // inject into simulator
   target_->recv(p);
+#endif
   return;
 }
 
 /*
  * ns scheduler calls TapAgent::dispatch which calls recvpkt.
  * 
- * recvpkt then calls the network (net_) to receive as many packets
+ * recvpkt then calls the network (net_incoming_) to receive as many packets
  * as there are from the packet capture facility.
  * For every packet received through the callback, it populates the ns packet
  * ttl value and inject it into the simulator by calling target_->recv
@@ -197,14 +325,17 @@
 void
 IPTapAgent::recvpkt()
 {
-  if (net_->mode() != O_RDWR && net_->mode() != O_RDONLY) {
+  if (net_incoming_->mode() != O_RDWR && net_incoming_->mode() != O_RDONLY) {
     fprintf(stderr,
 	    "IPTapAgent(%s): recvpkt called while in write-only mode!\n",
 	    name());
     return;
   }
   
-  int cc = net_->recv(pkt_handler, this);
+#ifdef MEASURE_DELAYS
+  firstpkt_in_burst = true;
+#endif
+  int cc = net_incoming_->recv(pkt_handler, this);
   if (cc <= 0) {
     if (cc < 0) {
       perror("recv");
@@ -219,13 +350,71 @@
 }
 
 
+int
+IPTapAgent::command(int argc, const char*const* argv)
+{
+	Tcl& tcl = Tcl::instance();
+
+	if (argc == 2) {
+#if MEASURE_DELAYS
+	  if( strcmp(argv[1], "print_delays") == 0 ) {
+	    printf("object %s : max_delay = %g "
+		   "bpf_ts_to_iptap_max_delay = %g "
+		   "bpf_ts_to_iptap_min_delay = %g\n",
+		   name(), max_delay, bpf_ts_to_iptap_max_delay,
+		   bpf_ts_to_iptap_min_delay);
+	    for( int i=0; i<sizeof(bpf_ts_to_iptap)/sizeof(bpf_ts_to_iptap[0]) ; i++ )
+	      printf("%.10f ", bpf_ts_to_iptap[i]);
+	    printf("\n");
+	    return (TCL_OK);
+	  } 
+#endif
+	  if(strcmp(argv[1], "sendcount") == 0 ) {
+	      fprintf( stderr, "sendcount:%d\n", send_count );
+	      return (TCL_OK);
+	  } else if(strcmp(argv[1], "recvcount") == 0 ) {
+	      fprintf( stderr, "recvcount:%d\n", recv_count );
+	      return (TCL_OK);
+	  }
+	} else if (argc == 3) {
+		if (strcmp(argv[1], "network-incoming") == 0) {
+			PcapNetwork *net_in_ = (PcapNetwork *)TclObject::lookup(argv[2]);
+			if (net_in_ != 0) {
+			  /*
+			   * Although, we should get the MTU of the outgoing interface,
+			   * we just do it for the incoming one coz the outgoing net
+			   * object is just a RAW IP socket.
+			   */
+			  mtu = net_in_->getmtu();
+			}
+		} else if( strcmp(argv[1], "ipmask") == 0) {
+		  struct in_addr tmpmask;
+		  if( inet_aton( argv[2], &tmpmask ) == 1 ) {
+		    ipmask = tmpmask;
+		    return(TCL_OK);
+		  } else {
+		    return(TCL_ERROR);
+		  }
+		} else if (strcmp(argv[1], "icmpagent") == 0) {
+		  icmpagent = (IcmpAgent *)TclObject::lookup(argv[2]);
+		  if (icmpagent)
+		    return(TCL_OK);
+		  else
+		    return(TCL_ERROR);
+		} else if (strcmp(argv[1], "ipaddr") == 0) {
+		  srcnodeipaddr.s_addr = inet_addr(argv[2]);
+		  return(TCL_OK);
+		}
+	}
+	return (TapAgent::command(argc, argv));
+}
 
 
 /*
  * simulator schedules TapAgent::recv which calls sendpkt
  *
  * Grabs a ns packet, converts it into real packet 
- * and injects onto the network using net_->send
+ * and injects onto the network using net_outgoing_->send
  */
 int
 IPTapAgent::sendpkt(Packet* p)
@@ -233,10 +422,11 @@
   int byteswritten;
   unsigned char *packet;
   unsigned char received_ttl;
-  unsigned short dglen;
+  unsigned short sendlen;
   struct ip *ipheader;
+  u_short ip_off;
 
-  if (net_->mode() != O_RDWR && net_->mode() != O_WRONLY) {
+  if (net_outgoing_->mode() != O_RDWR && net_outgoing_->mode() != O_WRONLY) {
     fprintf(stderr,
 	    "IPTapAgent(%s): sendpkt called while in read-only mode!\n",
 	    name());
@@ -245,7 +435,7 @@
   
   // send packet into the live network
   hdr_cmn* hc = HDR_CMN(p);
-  if (net_ == NULL) {
+  if (net_outgoing_ == NULL) {
     fprintf(stderr,
 	    "IPTapAgent(%s): sendpkt attempted with NULL net\n",
 	    name());
@@ -273,27 +463,107 @@
     return(-1);
   }
 
+  /* Check what type of packet it is and if it is a normal
+     simulator packet as opposed to PT_LIVE, we need to
+     perform encapsulation */
 
-  /* Modify the original packet with the new info. */
-  packet = p->accessdata();
-  ipheader = (struct ip *) packet;
-  ipheader->ip_ttl = received_ttl;
-  ipheader->ip_sum = 0;
-  ipheader->ip_sum = (unsigned short) in_cksum((unsigned short *) ipheader,
-						sizeof(struct ip));
-
-  if (net_->send(p->accessdata(), hc->size()) < 0) {
-    fprintf(stderr,
-	    "IPTapAgent(%s): sendpkt (%p, %d): %s\n",
-	    name(), p->accessdata(), hc->size(), strerror(errno));
+  if (hc->ptype_ == PT_LIVE) {
+    
+    /* Modify the original packet with the new info. */
+    packet = p->accessdata();
+    ipheader = (struct ip *) packet;
+    ipheader->ip_ttl = received_ttl;
+    ipheader->ip_sum = 0;
+    ipheader->ip_sum = (unsigned short) in_cksum((unsigned short *) ipheader,
+						 sizeof(struct ip));
+
+    ip_off = ntohs(ipheader->ip_off);
+    sendlen = ntohs(ipheader->ip_len);
+    if ( (sendlen > mtu) && (ip_off & IP_DF) ) {
+      if (icmpagent) {
+	icmpagent->sendfragneeded(srcnodeipaddr, ipheader->ip_src, mtu, packet );
+      }
+      TDEBUG4("IPTapAgent(%s): Packet size (sz: %d) exceeded MTU: %d\n",
+	      name(), sendlen, mtu);
+      drop(p);
+      return (-1);
+    } 
+
+    if (net_outgoing_->send(p->accessdata(), sendlen) < 0) {
+      fprintf(stderr,
+	      "IPTapAgent(%s): sendpkt (%p, %d): %s\n",
+	      name(), p->accessdata(), sendlen, strerror(errno));
+      drop(p);
+      return (-1);
+    
+    }
+#if 0
+    if( hc->size() < 50 ) {
+      fprintf( stderr, "sent pkt %d\n", hc->size());
+    }
+#endif
     Packet::free(p);
-    return (-1);
+    TDEBUG3("IPTapAgent(%s): sent packet (sz: %d)\n",
+	    name(), hc->size());
+  } else {
+    
+    unsigned long *hdrbits = 0;
+    memset( sendbuf, 0, sbuflen * sizeof(unsigned char) );
+    ipheader = (struct ip *)sendbuf;
+  
+    ipheader->ip_hl = (IP_HEADER_LEN / 4);
+    ipheader->ip_v = IPVERSION;
     
+    ipheader->ip_id = 0;
+    ipheader->ip_ttl = received_ttl;
+    ipheader->ip_p = IPPROTO_ENCAP;
+    
+    ipheader->ip_src.s_addr = htonl(ih->saddr());
+    ipheader->ip_dst.s_addr = htonl(ih->daddr());
+
+    hdrbits = (unsigned long *)(ipheader + 1);
+    int size = Packet::compress( hdrbits, (unsigned long *)p->bits(), (Packet::hdrlen_+3)/4);
+
+    /* ip_len field should be in host byte order which the kernel will later
+       change to network byte order */
+    ipheader->ip_len = sendlen = size * sizeof(unsigned long) + sizeof(struct ip);
+
+    /* Converting values to network order since the class Network/IP will
+       convert it back to host order coz the kernel expects it that way */
+    ipheader->ip_len = htons(ipheader->ip_len);
+    ipheader->ip_off = htons(ipheader->ip_off);
+
+    ipheader->ip_sum = (unsigned short) in_cksum((unsigned short *) ipheader,
+						 sizeof(struct ip));
+    
+
+    if (net_outgoing_->send(sendbuf, sendlen) < 0) {
+      fprintf(stderr,
+	      "IPTapAgent(%s): sendpkt compressed(%p, %d) error: %s\n",
+	      name(), sendbuf, size, strerror(errno));
+      drop(p);
+      return (-1);    
+    }
+    send_count++;
+    Packet::free(p);
+    TDEBUG3("IPTapAgent(%s): sent compressed packet (sz: %d)\n",
+	    name(), size);
   }
-  Packet::free(p);
-  TDEBUG3("IPTapAgent(%s): sent packet (sz: %d)\n",
-	  name(), hc->size());
-  return 0;
+    return 0;
 }
 
+bool PacketDecapsulateIfNeeded(Packet *p) {
+    struct ip *ipheader = (struct ip *)p->accessdata();
+    if (!ipheader || ipheader->ip_p != IPPROTO_ENCAP )
+	return false;
+
+    unsigned long *hdrbits = (unsigned long *)(ipheader + 1);
+    unsigned short datagramlen = ntohs(ipheader->ip_len);
+    int iphlen = ipheader->ip_hl * 4;
+
+    /* This should take care of copying all the header bits to this packet. */
+    int lastnonzerobyte = Packet::uncompress( (unsigned long *)p->bits(), hdrbits,
+				              (datagramlen - iphlen)/4 );
 
+    return true;
+}
--- dist-ns-allinone-2.26/ns-2.26/emulate/iptap.h	Wed Feb 26 15:08:40 2003
+++ ns-allinone-2.26/ns-2.26/emulate/iptap.h	Fri Mar  5 18:15:03 2004
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 1998 The Regents of the University of California.
+ * Copyright (c) 1997, 1998, 2003 The Regents of the University of California.
  * All rights reserved.
  * 
  * Redistribution and use in source and binary forms, with or without
@@ -45,19 +45,34 @@
 #include <sys/socket.h>
 #include "tcp.h"
 #include "ip.h"
+#include "icmp.h"
+
+#include <net/if.h>
+
+#define ROUNDUP(a, size) (((a) & ((size)-1)) ? (1 + ((a) | ((size)-1))) : (a))
 
 #define MAX_PACKETS 640
 
+#define IP_HEADER_LEN         (sizeof(struct ip))
 
 class IPTapAgent : public TapAgent {
 
  public:
   IPTapAgent();
+  ~IPTapAgent();
+  int command(int, const char*const*);
+  int compress(long unsigned int *, long unsigned int *, int);
+  int uncompress(long unsigned int *, long unsigned int *, int);
 
  private:
   int ident[MAX_PACKETS];      /* All three used for duplicate */
   int offset[MAX_PACKETS];     /* packet detection. */
   int index;
+  struct in_addr ipmask;
+#ifdef MEASURE_DELAYS
+  bool firstpkt_in_burst;
+  double ts_firstpkt_in_burst;
+#endif  
 
   unsigned short in_cksum(unsigned short *,int);
   void recvpkt();
@@ -66,6 +81,22 @@
   void processpkt(Packet *, const struct timeval &);
   static void pkt_handler(void *, Packet *, const struct timeval &);
 
+#ifdef MEASURE_DELAYS  
+  double max_delay;
+  double bpf_ts_to_iptap_max_delay;
+  double bpf_ts_to_iptap_min_delay;
+  int data_idx;
+  double bpf_ts_to_iptap[80000];
+#endif
+  unsigned char *sendbuf;
+  unsigned int sbuflen;
+  unsigned char *recvbuf;
+  unsigned int rbuflen;
+  u_int16_t  mtu;
+  IcmpAgent *icmpagent;
+  struct in_addr  srcnodeipaddr;
+  unsigned int send_count;
+  unsigned int recv_count;
 };
 
 #endif /* iptap_h */
--- dist-ns-allinone-2.26/ns-2.26/emulate/icmp.cc	Wed Feb 26 15:08:40 2003
+++ ns-allinone-2.26/ns-2.26/emulate/icmp.cc	Sun Dec 14 01:32:59 2003
@@ -1,5 +1,5 @@
 /*    
- * Copyright (c) 1998 Regents of the University of California.
+ * Copyright (c) 1998, 2003 Regents of the University of California.
  * All rights reserved.
  *    
  * Redistribution and use in source and binary forms, with or without 
@@ -50,6 +50,8 @@
 #include "packet.h"
 #include "emulate/net.h"
 #include "emulate/internet.h"
+#include "ip.h"
+#include "icmp.h"
 
 #ifndef IPPROTO_GGP
 #define IPPROTO_GGP 3
@@ -59,17 +61,6 @@
 // icmp.cc -- a very limited-functionality set of icmp routines
 // 
 
-class IcmpAgent : public Agent {
-public:
-	IcmpAgent();
-	void recv(Packet*, Handler*) { abort(); }
-protected:
-	void	sendredirect(in_addr& me, in_addr& target, in_addr& dest, in_addr& gw);
-	int	command(int argc, const char*const* argv);
-
-	int	ttl_;
-};
-
 static class IcmpAgentClass : public TclClass { 
 public:
         IcmpAgentClass() : TclClass("Agent/IcmpAgent") {}
@@ -122,6 +113,62 @@
 	icp->icmp_cksum = 0;
 	icp->icmp_type = ICMP_REDIRECT;
 	icp->icmp_code = ICMP_REDIRECT_HOST;
+	icp->icmp_cksum = Internet::in_cksum((u_short*)icp,
+		8 + sizeof(ip) + 8);
+
+	send(p, 0);
+	return;
+}
+
+/*
+ * sendfragneeded -- send a packet to "target" containing a redirect
+ * for the network specified by "dst", so that the gateway "gw" is used
+ * also, forge the source address so as to appear to come from "me"
+ */
+
+void
+IcmpAgent::sendfragneeded(struct in_addr & me, struct in_addr & target, u_int16_t mtu, void *data )
+{
+	// make a simulator packet to hold the IP packet, which in turn
+	// holds: ip header, icmp header, embedded ip header, plus 64 bits
+	// data
+	int iplen = sizeof(ip) + 8 + sizeof(ip) + 8;
+        Packet* p = allocpkt(iplen);
+	hdr_cmn* hc = HDR_CMN(p);
+	/* When this packet gets sent out to the host by an IPTap eventually,
+	   it should not try to encapsulate this in any way. Just send it as
+	   it is */
+	hc->ptype_ = PT_LIVE;
+	ip* iph = (ip*) p->accessdata();
+	hc->size() = iplen;
+
+	// make an IP packet ready to send to target
+	// size will be min icmp + a dummy'd-up IP header
+	Internet::makeip(iph, iplen, ttl_, IPPROTO_ICMP, me, target);
+	iph->ip_off |= htons(IP_DF);
+	iph->ip_sum = Internet::in_cksum((u_short*) iph, 20);
+
+	// Store the destination addr in the NS packet for
+	// the simulator to route it
+	hdr_ip *ih = HDR_IP(p);
+	ih->daddr() = ntohl(target.s_addr);
+	ih->saddr() = ntohl(me.s_addr);
+
+	// make an ICMP host redirect, set the gwaddr field
+	icmp* icp = (icmp*) (iph + 1);
+	icp->icmp_nextmtu = htons(mtu);
+
+	// make an inner IP packet to go in the ICMP data, which will
+	// be used to indicate to the end host which routing table
+	// entry to update
+
+	ip* innerhdr = (ip*)((u_char*)icp + 8);	// past icmp hdr
+		// deprecated protocol inside
+	memcpy( innerhdr, data, sizeof(ip) + 8 );
+
+	icp->icmp_cksum = 0;
+	icp->icmp_type = ICMP_UNREACH;
+	icp->icmp_code = ICMP_UNREACH_NEEDFRAG;
 	icp->icmp_cksum = Internet::in_cksum((u_short*)icp,
 		8 + sizeof(ip) + 8);
 
--- /dev/null	Fri Apr 16 06:10:10 2004
+++ ns-allinone-2.26/ns-2.26/emulate/icmp.h	Sun Dec 14 20:33:36 2003
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 1997, 1998, 2003 The Regents of the University of California.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ * 	This product includes software developed by the MASH Research
+ *	Group at the University of California, Berkeley.
+ * 4. Neither the name of the University nor of the Research Group may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#ifndef icmp_h
+#define icmp_h
+
+class IcmpAgent : public Agent {
+public:
+	IcmpAgent();
+	void recv(Packet*, Handler*) { abort(); }
+	void    sendfragneeded(struct in_addr & me, struct in_addr & target, u_int16_t mtu, void *data );
+protected:
+	void	sendredirect(in_addr& me, in_addr& target, in_addr& dest, in_addr& gw);
+	int	command(int argc, const char*const* argv);
+
+	int	ttl_;
+};
+
+#endif
--- dist-ns-allinone-2.26/ns-2.26/emulate/net-ip.cc	Wed Feb 26 15:08:40 2003
+++ ns-allinone-2.26/ns-2.26/emulate/net-ip.cc	Fri Nov 28 16:55:25 2003
@@ -668,6 +668,20 @@
 				tcl.result("1");
 			return (TCL_OK);
 		}
+/* This may not be defined since it is a custom socket option that
+   was added. Look in <sys/socket.h> */
+#ifndef SO_RTABID
+#define SO_RTABID 0x1010
+#endif
+		if (strcmp(argv[1], "setrtabid") == 0) {
+			unsigned int rtabid = atoi(argv[2]);
+			if( ::setsockopt(ssock_, SOL_SOCKET, SO_RTABID,
+					 &rtabid, sizeof(rtabid)) < 0 ) {
+			  tcl.result(strerror(errno));
+			  return (TCL_ERROR);
+			}
+			return (TCL_OK);
+		}
 	}
 	return (Network::command(argc, argv));
 }
--- dist-ns-allinone-2.26/ns-2.26/emulate/net-pcap.cc	Wed Feb 26 15:08:40 2003
+++ ns-allinone-2.26/ns-2.26/emulate/net-pcap.cc	Fri Apr 16 06:07:48 2004
@@ -1,5 +1,5 @@
 /*-
- * Copyright (c) 1998 The Regents of the University of California.
+ * Copyright (c) 1998, 2003 The Regents of the University of California.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -69,83 +69,6 @@
 #include "tclcl.h"
 #include "packet.h"
 
-/*
- * observations about pcap library
- *	device name is in the ifreq struct sense, should be doc'd
- *	pcap_lookupdev returns a ptr to static data
- *	q: does lookupdev only return devs in the AF_INET addr family?
- *	why does pcap_compile require a netmask? seems odd
- *	would like some way to tell it what buffer to use
- *	arriving packets have the link layer hdr at the beginning, doc
- *	not convenient/possible to open bpf read/write
- *	no real way to know what file (/dev/bpf?) it is using
- *		would be nice if pcap_lookdev helped out more by
- *		returning ifnet or ifreq or whatever structure
- *	pcap_lookupnet makes calls to get our addr, but
- *		then tosses it anyhow, should get us addr and netmask
- *	interface type codes could be via rfc1573
- *		see freebsd net/if_types.h
- *	want a way to set immed mode
- *	pcap_next masks errors by returning 0 if pcap_dispatch fails
- *	a pcap_t carries it's own internal buffer, and
- *		_dispatch gives pointers into it when invoked [eek]
- *	when you open pcap using a file, pcap_fileno always
- *		returns -1; not so convenient
- *	
- */
-
-#define	PNET_PSTATE_INACTIVE	0
-#define	PNET_PSTATE_ACTIVE	1
-
-//
-// PcapNetwork: a "network" (source or possibly sink of packets)
-//	this is a base class only-- the derived classes are:
-//	PcapLiveNetwork [a live net; currently bpf + ethernet]
-//	PcapFileNetwork [packets from a tcpdump-style trace file]
-//
-
-class PcapNetwork : public Network {
-
-public:
-	PcapNetwork() : t_firstpkt_(0.0),
-		pfd_(-1), pcnt_(0), local_netmask_(0) { }
-	int rchannel() { return(pfd_); }
-	int schannel() { return(pfd_); }
-	virtual int command(int argc, const char*const* argv);
-
-	virtual int open(int mode, const char *) = 0;
-	virtual int skiphdr() = 0;
-	virtual double gents(pcap_pkthdr*) = 0;		// generate timestamp
-	int recv(u_char *buf, int len, sockaddr&, double&); // get from net
-	int send(u_char *buf, int len);			// write to net
-	int recv(netpkt_handler callback, void *clientdata); // get from net
-	void close();
-	void reset();
-
-	int filter(const char*);	// compile + install a filter
-	int stat_pkts();
-	int stat_pdrops();
-
-	double offset_;			// time offset to 1st pkt in a trace
-	double t_firstpkt_;		// ts of 1st pkt recvd
-
-protected:
-	static void phandler(u_char* u, const pcap_pkthdr* h, const u_char* p);
-	static void phandler_callback(u_char* u, const pcap_pkthdr* h, const u_char* p);
-	virtual void bindvars() = 0;
-
-	char errbuf_[PCAP_ERRBUF_SIZE];		// place to put err msgs
-	char srcname_[PATH_MAX];		// device or file name
-	int pfd_;				// pcap fd
-	int pcnt_;				// # pkts counted
-	int state_;				// PNET_PSTATE_xxx (above)
-	int optimize_;				// bpf optimizer enable
-	pcap_t* pcap_;				// reference to pcap state
-	struct bpf_program bpfpgm_;		// generated program
-	struct pcap_stat pcs_;			// status
-
-	unsigned int local_netmask_;	// seems shouldn't be necessary :(
-};
 
 //
 // PcapLiveNetwork: a live network tap
@@ -285,6 +208,8 @@
 	if (pcap_stats(pcap_, &pcs_) < 0)
 		return (-1);
 
+	fprintf( stderr, "%s : pkts:%d drops:%d\n", name(), pcs_.ps_recv, 
+		 pcs_.ps_drop );
 	return (pcs_.ps_recv);
 }
 
@@ -340,6 +265,19 @@
 	// link layer header will be placed at the beginning from pcap
 	int s = inst->skiphdr();	// go to IP header
 	memcpy(p->accessdata(), pkt + s, ph->caplen - s);
+#ifdef BPF_BASED_PACKET_TIME
+	// Store the bpf timestamp in the packet's time_ variable.
+	// If the packet is scheduled in the scheduler again, that
+	// will update the packet's time_ variable accordingly. But
+	// untill that happens, it is useful to carry the bpf
+	// timestamp for debugging reasons
+	p->time_ = ph->ts.tv_sec;
+	p->time_ += (1e-6 * ph->ts.tv_usec);
+	// Not sure why the virtual start() method is not correctly invoked
+	// without casting the reference to the subclass type
+	static double start = ((RealTimeScheduler &)Scheduler::instance()).start();
+	p->time_ -= start;
+#endif
 
 	ps->callback(ps->clientdata, p, ph->ts);
 }
@@ -490,6 +428,10 @@
 			name(), devname, errbuf_);
 		return -1;
 	}
+	if ( pcap_setnonblock(pcap_, 1, errbuf_) == -1 ) {
+	    fprintf( stderr, "pcap/live object (%s) couldn't set non-blocking mode:%s\n",
+		     name(), errbuf_ );
+	}
 	mode_ = mode;
 	dlink_type_ = pcap_datalink(pcap_);
 	pfd_ = pcap_fileno(pcap_);
@@ -498,6 +440,7 @@
 		// use SIOCGIFADDR hook in bpf to get link addr
 		struct ifreq ifr;
 		struct sockaddr *sa = &ifr.ifr_addr;
+		int s;
 #ifdef HAVE_SIOCGIFHWADDR
 		memset(&ifr, 0, sizeof(struct ifreq));
 		strcpy(ifr.ifr_name, devname);
@@ -513,6 +456,19 @@
 			  name(), pfd_);
 		}
 #endif
+#ifdef SIOCGIFMTU
+		memset(&ifr, 0, sizeof(ifr));
+		strncpy(ifr.ifr_name, devname, sizeof (ifr.ifr_name));
+		s = socket(AF_INET, SOCK_DGRAM, 0);
+		if (ioctl(s, SIOCGIFMTU, (caddr_t)&ifr) < 0) {
+			fprintf(stderr,
+			  "pcap/live (%s) SIOCGIFMTU on bpf fd %d\n",
+			  name(), pfd_);
+		} else {
+		  mtu_ = ifr.ifr_mtu;
+		}
+		::close(s);
+#endif
 		if (dlink_type_ != DLT_EN10MB) {
 			fprintf(stderr,
 				"sorry, only ethernet supported\n");
@@ -539,6 +495,12 @@
 				"warning: pcap/live (%s) couldn't set immed\n",
 				name());
 			perror("ioctl(BIOCIMMEDIATE)");
+		}
+		if (ioctl(pfd_, BIOCFLUSH, 0) < 0) {
+			fprintf(stderr,
+				"warning: pcap/live (%s) couldn't flush bpf buffer\n",
+				name());
+			perror("ioctl(BIOCFLUSH)");
 		}
 	}
 #endif
--- dist-ns-allinone-2.26/ns-2.26/emulate/net.cc	Wed Feb 26 15:08:40 2003
+++ ns-allinone-2.26/ns-2.26/emulate/net.cc	Fri Dec 12 18:57:43 2003
@@ -1,5 +1,5 @@
 /*-
- * Copyright (c) 1993-1994, 1998 The Regents of the University of California.
+ * Copyright (c) 1993-1994, 1998, 2003 The Regents of the University of California.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
--- dist-ns-allinone-2.26/ns-2.26/emulate/net.h	Wed Feb 26 15:08:40 2003
+++ ns-allinone-2.26/ns-2.26/emulate/net.h	Sat Dec 13 21:20:28 2003
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1991-1994, 1998 Regents of the University of California.
+ * Copyright (c) 1991-1994, 1998, 2003 Regents of the University of California.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -55,7 +55,7 @@
 
 class Network : public TclObject {
 public:
-	Network() : mode_(-1) { }
+	Network() : mode_(-1),mtu_(1500) { }
 	virtual int command(int argc, const char*const* argv);
 	virtual int send(u_char* buf, int len) = 0;
 	virtual int recv(u_char* buf, int len, sockaddr& from, double& ts) = 0;
@@ -69,10 +69,102 @@
 	virtual int rchannel() = 0;
 	virtual int schannel() = 0;
 	int mode() { return mode_; }
+	u_int16_t getmtu() { return mtu_; }
 	static int nonblock(int fd);
 	static int parsemode(const char*);  // strings to mode bits
 	static char* modename(int);	    // and the reverse
 protected:
 	int mode_;	// read/write bits (from fcntl.h)
+	u_int16_t mtu_;
 };
+
+#ifdef __cplusplus
+extern "C" {
+#include <pcap.h>
+}
+#else
+#include <pcap.h>
+#endif
+
+#include <sys/param.h>
+
+/*
+ * observations about pcap library
+ *	device name is in the ifreq struct sense, should be doc'd
+ *	pcap_lookupdev returns a ptr to static data
+ *	q: does lookupdev only return devs in the AF_INET addr family?
+ *	why does pcap_compile require a netmask? seems odd
+ *	would like some way to tell it what buffer to use
+ *	arriving packets have the link layer hdr at the beginning, doc
+ *	not convenient/possible to open bpf read/write
+ *	no real way to know what file (/dev/bpf?) it is using
+ *		would be nice if pcap_lookdev helped out more by
+ *		returning ifnet or ifreq or whatever structure
+ *	pcap_lookupnet makes calls to get our addr, but
+ *		then tosses it anyhow, should get us addr and netmask
+ *	interface type codes could be via rfc1573
+ *		see freebsd net/if_types.h
+ *	want a way to set immed mode
+ *	pcap_next masks errors by returning 0 if pcap_dispatch fails
+ *	a pcap_t carries it's own internal buffer, and
+ *		_dispatch gives pointers into it when invoked [eek]
+ *	when you open pcap using a file, pcap_fileno always
+ *		returns -1; not so convenient
+ *	
+ */
+
+#define	PNET_PSTATE_INACTIVE	0
+#define	PNET_PSTATE_ACTIVE	1
+
+//
+// PcapNetwork: a "network" (source or possibly sink of packets)
+//	this is a base class only-- the derived classes are:
+//	PcapLiveNetwork [a live net; currently bpf + ethernet]
+//	PcapFileNetwork [packets from a tcpdump-style trace file]
+//
+
+class PcapNetwork : public Network {
+
+public:
+	PcapNetwork() : t_firstpkt_(0.0),
+		pfd_(-1), pcnt_(0), local_netmask_(0) { }
+	int rchannel() { return(pfd_); }
+	int schannel() { return(pfd_); }
+	virtual int command(int argc, const char*const* argv);
+
+	virtual int open(int mode, const char *) = 0;
+	virtual int skiphdr() = 0;
+	virtual double gents(pcap_pkthdr*) = 0;		// generate timestamp
+	int recv(u_char *buf, int len, sockaddr&, double&); // get from net
+	int send(u_char *buf, int len);			// write to net
+	int recv(netpkt_handler callback, void *clientdata); // get from net
+	void close();
+	void reset();
+
+	int filter(const char*);	// compile + install a filter
+	int stat_pkts();
+	int stat_pdrops();
+
+	double offset_;			// time offset to 1st pkt in a trace
+	double t_firstpkt_;		// ts of 1st pkt recvd
+        inline char *srcname() { return(srcname_); }
+
+protected:
+	static void phandler(u_char* u, const pcap_pkthdr* h, const u_char* p);
+	static void phandler_callback(u_char* u, const pcap_pkthdr* h, const u_char* p);
+	virtual void bindvars() = 0;
+
+	char errbuf_[PCAP_ERRBUF_SIZE];		// place to put err msgs
+	char srcname_[PATH_MAX];		// device or file name
+	int pfd_;				// pcap fd
+	int pcnt_;				// # pkts counted
+	int state_;				// PNET_PSTATE_xxx (above)
+	int optimize_;				// bpf optimizer enable
+	pcap_t* pcap_;				// reference to pcap state
+	struct bpf_program bpfpgm_;		// generated program
+	struct pcap_stat pcs_;			// status
+
+	unsigned int local_netmask_;	// seems shouldn't be necessary :(
+};
+
 #endif
--- dist-ns-allinone-2.26/ns-2.26/emulate/tap.cc	Wed Feb 26 15:08:42 2003
+++ ns-allinone-2.26/ns-2.26/emulate/tap.cc	Thu Apr  1 16:16:28 2004
@@ -38,6 +38,10 @@
 
 #include "tap.h"
 
+#ifdef HAVE_POLLER
+    extern Poller_kqueue *poller;
+#endif
+
 static class TapAgentClass : public TclClass {
  public:
 	TapAgentClass() : TclClass("Agent/Tap") {}
@@ -46,7 +50,7 @@
 	}
 } class_tap_agent;
 
-TapAgent::TapAgent() : Agent(PT_LIVE), net_(NULL)
+TapAgent::TapAgent() : Agent(PT_LIVE), net_outgoing_(NULL), net_incoming_(NULL)
 {
 	bind("maxpkt_", &maxpkt_);
 }
@@ -55,35 +59,41 @@
 // link in a network to the agent.  Assumes net_ is non-zero
 //
 int
-TapAgent::linknet()
+TapAgent::linknet(Network *net)
 {
-	int mode = net_->mode();
-	int rchan = net_->rchannel();
-	int wchan = net_->schannel();
+	int mode = net->mode();
+	int rchan = net->rchannel();
+	int wchan = net->schannel();
 
+#ifndef HAVE_POLLER
 	unlink();
+#endif
 	if (mode == O_RDONLY || mode == O_RDWR) {
 		// reading enabled?
 		if (rchan < 0) {
 			fprintf(stderr,
 		"TapAgent(%s): network %s not open for reading (mode:%d)\n",
-			    name(), net_->name(), mode);
+			    name(), net->name(), mode);
 			return (TCL_ERROR);
 		}
+#ifdef HAVE_POLLER
+		poller->add(rchan, this, POLLIN );
+#else
 		link(rchan, TCL_READABLE);
+#endif
 		TDEBUG3("TapAgent(%s): linked sock %d as READABLE\n",
 			name(), rchan);
 	} else if (mode != O_WRONLY) {
 		if (mode == -1) {
 			fprintf(stderr,
 			   "TapAgent(%s): Network(%s) not opened properly.\n",
-				name(), net_->name());
+				name(), net->name());
 			fprintf(stderr,
 			   "(choose: readonly, readwrite, or writeonly)\n");
 		} else {
 			fprintf(stderr,
 			    "TapAgent(%s): unknown mode %d in Network(%s)\n",
-				name(), mode, net_->name());
+				name(), mode, net->name());
 		}
 		return (TCL_ERROR);
 	}
@@ -93,7 +103,7 @@
 		if (wchan < 0) {
 			fprintf(stderr,
 			"TapAgent(%s): network %s not open for writing\n",
-			    name(), net_->name());
+			    name(), net->name());
 			return (TCL_ERROR);
 		}
 	}
@@ -112,10 +122,25 @@
 		} 
 	}
 	if (argc == 3) {
-		if (strcmp(argv[1], "network") == 0) {
-			net_ = (Network *)TclObject::lookup(argv[2]);
-			if (net_ != 0) {
-				return(linknet());
+		if (strcmp(argv[1], "network-outgoing") == 0) {
+			net_outgoing_ = (Network *)TclObject::lookup(argv[2]);
+			/* We don't need to monitor outgoing network (by calling linknet()) coz
+			   we just send packets to it. In case a particular
+			   network object does both, the user has to explicitly
+			   use the command network-incoming to monitor this fd */
+			if (net_outgoing_ == 0) {
+				fprintf(stderr,
+				"TapAgent(%s): unknown network %s\n",
+				    name(), argv[2]);
+				return (TCL_ERROR);
+			}
+			return(TCL_OK);
+		}	
+
+		if (strcmp(argv[1], "network-incoming") == 0) {
+			net_incoming_ = (Network *)TclObject::lookup(argv[2]);
+			if (net_incoming_ != 0) {
+				return(linknet(net_incoming_));
 			} else {
 				fprintf(stderr,
 				"TapAgent(%s): unknown network %s\n",
@@ -135,7 +160,7 @@
 TapAgent::recvpkt()
 {
 
-	if (net_->mode() != O_RDWR && net_->mode() != O_RDONLY) {
+	if (net_incoming_->mode() != O_RDWR && net_incoming_->mode() != O_RDONLY) {
 		fprintf(stderr,
 		  "TapAgent(%s): recvpkt called while in write-only mode!\n",
 		  name());
@@ -155,7 +180,7 @@
 	// fill up payload
 	sockaddr addr;	// not really used (yet)
 	double tstamp;
-	int cc = net_->recv(p->accessdata(), maxpkt_, addr, tstamp);
+	int cc = net_incoming_->recv(p->accessdata(), maxpkt_, addr, tstamp);
 	if (cc <= 0) {
 		if (cc < 0) {
 			perror("recv");
@@ -211,6 +236,16 @@
 	recvpkt();
 }
 
+#ifdef HAVE_POLLER
+int
+TapAgent::notifyPollEvent(Poller::PollEvent *e)
+{
+        recvpkt();
+	return 0;
+}
+
+#endif
+
 /*
  * SIM -> Live
  *
@@ -230,7 +265,7 @@
 int
 TapAgent::sendpkt(Packet* p)
 {
-	if (net_->mode() != O_RDWR && net_->mode() != O_WRONLY) {
+	if (net_outgoing_->mode() != O_RDWR && net_outgoing_->mode() != O_WRONLY) {
 		fprintf(stderr,
 		    "TapAgent(%s): sendpkt called while in read-only mode!\n",
 		    name());
@@ -239,14 +274,14 @@
 
 	// send packet into the live network
 	hdr_cmn* hc = HDR_CMN(p);
-	if (net_ == NULL) {
+	if (net_outgoing_ == NULL) {
 		fprintf(stderr,
 	         "TapAgent(%s): sendpkt attempted with NULL net\n",
 		 name());
 		drop(p);
 		return (-1);
 	}
-	if (net_->send(p->accessdata(), hc->size()) < 0) {
+	if (net_outgoing_->send(p->accessdata(), hc->size()) < 0) {
 		fprintf(stderr,
 		    "TapAgent(%s): sendpkt (%p, %d): %s\n",
 		    name(), p->accessdata(), hc->size(), strerror(errno));
--- dist-ns-allinone-2.26/ns-2.26/emulate/tap.h	Wed Feb 26 15:08:42 2003
+++ ns-allinone-2.26/ns-2.26/emulate/tap.h	Mon Mar 29 19:37:57 2004
@@ -43,7 +43,7 @@
 #include "agent.h"
 
 
-#define TAPDEBUG 1 
+#define TAPDEBUG 0
 #ifdef TAPDEBUG
 #define	TDEBUG(x) { if (TAPDEBUG) fprintf(stderr, (x)); }
 #define	TDEBUG2(x,y) { if (TAPDEBUG) fprintf(stderr, (x), (y)); }
@@ -60,7 +60,15 @@
 
 #include <errno.h>
 
-class TapAgent : public Agent, public IOHandler {
+#ifdef HAVE_POLLER
+#include "Poller_kqueue.h"
+#endif
+
+class TapAgent : public Agent, public IOHandler
+#ifdef HAVE_POLLER
+,  public Poller::Client
+#endif
+{
 public:
         TapAgent();
 	int command(int, const char*const*);
@@ -71,9 +79,13 @@
 protected:
 	int maxpkt_;		/* max size allocated to recv a pkt */
 	void dispatch(int);	/* invoked via scheduler on I/O event */
-	int linknet();		/* establish I/O handler */
-	Network* net_;		/* live network object */
+	int linknet(Network *);		/* establish I/O handler */
+	Network* net_outgoing_;	/* live network object for outgoing packets */
+	Network* net_incoming_;		/* live network object for incoming packets */
 	double now() { return Scheduler::instance().clock(); }
+#ifdef HAVE_POLLER
+	virtual int notifyPollEvent(Poller::PollEvent *e);
+#endif
 };
 
 
--- dist-ns-allinone-2.26/ns-2.26/emulate/tcptap.cc	Wed Feb 26 15:08:42 2003
+++ ns-allinone-2.26/ns-2.26/emulate/tcptap.cc	Fri Nov 28 16:55:25 2003
@@ -97,6 +97,11 @@
       return (TCL_OK);
     }
 
+    if (strcmp(argv[1], "nsport") == 0) {
+      nsnode.sin_port = atoi(argv[2]);
+      return (TCL_OK);
+    }
+
     if (strcmp(argv[1], "advertised-window") == 0) {
       adv_window = atoi(argv[2]);
       return (TCL_OK);
@@ -438,7 +443,7 @@
 /*
  * ns scheduler calls TapAgent::dispatch which calls recvpkt.
  * 
- * recvpkt then calls the network (net_) to receive as many packets
+ * recvpkt then calls the network (net_incoming_) to receive as many packets
  * as there are from the packet capture facility.
  * For every packet received through the callback, it converts to ns
  * FullTcp packet and injects it into the simulator by calling target_->recv
@@ -447,14 +452,14 @@
 void
 TCPTapAgent::recvpkt()
 {
-  if (net_->mode() != O_RDWR && net_->mode() != O_RDONLY) {
+  if (net_incoming_->mode() != O_RDWR && net_incoming_->mode() != O_RDONLY) {
     fprintf(stderr,
 	    "TCPTapAgent(%s): recvpkt called while in write-only mode!\n",
 	    name());
     return;
   }
   
-  int cc = net_->recv(pkt_handler, this);
+  int cc = net_incoming_->recv(pkt_handler, this);
   if (cc <= 0) {
     if (cc < 0) {
       perror("recv");
@@ -474,7 +479,7 @@
  * simulator schedules TapAgent::recv which calls sendpkt
  *
  * Grabs a ns Full TCP packet, converts it into real TCP packet 
- * and injects onto the network using net_->send
+ * and injects onto the network using net_outgoing_->send
  *
  */
 int
@@ -486,7 +491,7 @@
   int hlength = IP_HEADER_LEN + TCP_HEADER_LEN;
   struct tcphdr *tcpheader;
 
-  if (net_->mode() != O_RDWR && net_->mode() != O_WRONLY) {
+  if (net_outgoing_->mode() != O_RDWR && net_outgoing_->mode() != O_WRONLY) {
     fprintf(stderr,
 	    "TCPTapAgent(%s): sendpkt called while in read-only mode!\n",
 	    name());
@@ -495,7 +500,7 @@
   
   // send packet into the live network
   hdr_cmn* ns_cmnhdr = HDR_CMN(p);
-  if (net_ == NULL) {
+  if (net_outgoing_ == NULL) {
     fprintf(stderr,
 	    "TCPTapAgent(%s): sendpkt attempted with NULL net\n",
 	    name());
@@ -543,7 +548,7 @@
      Limits the packets going out to only IP + TCP header. 
      ns will act as an ACK machine.
    */
-  byteswritten = net_->send(packet, hlength + datalen);
+  byteswritten = net_outgoing_->send(packet, hlength + datalen);
   if (byteswritten < 0) {
     fprintf(stderr,"TCPTapAgent(%s): sendpkt (%p, %d): %s\n",
 	    name(), p->accessdata(), ns_cmnhdr->size(), strerror(errno));
--- dist-ns-allinone-2.26/ns-2.26/link/delay.h	Wed Feb 26 15:08:54 2003
+++ ns-allinone-2.26/ns-2.26/link/delay.h	Fri Nov 28 16:55:25 2003
@@ -44,6 +44,10 @@
 #include "ip.h"
 #include "connector.h"
 
+#ifdef ADD_ETHER_OVERHEAD
+#include <net/ethernet.h>
+#endif
+
 class LinkDelay : public Connector {
  public:
 	LinkDelay();
@@ -52,7 +56,11 @@
 	void handle(Event* e);
 	double delay() { return delay_; }
 	inline double txtime(Packet* p) {
+#ifndef ADD_ETHER_OVERHEAD
 		return (8. * hdr_cmn::access(p)->size() / bandwidth_);
+#else
+		return (8. * (hdr_cmn::access(p)->size() + ETHER_HDR_LEN) / bandwidth_);
+#endif
 	}
 	double bandwidth() const { return bandwidth_; }
 	void pktintran(int src, int group);
--- dist-ns-allinone-2.26/ns-2.26/mcast/lms.h	Wed Feb 26 15:08:58 2003
+++ ns-allinone-2.26/ns-2.26/mcast/lms.h	Fri Nov 28 16:55:25 2003
@@ -64,7 +64,7 @@
     nsaddr_t    src_;		// original source of mcast packet
     nsaddr_t    group_;		// mcast group
     nsaddr_t    tp_addr_;	// turning point address
-    int	       	tp_port_;	// turning point port id 
+    u_int      	tp_port_;	// turning point port id 
     int	       	tp_iface_;	// turning point interface
     int	       	lo_, hi_;	// range of lost packets
     double     	ts_;		// timestamp for RTT estimation
--- dist-ns-allinone-2.26/ns-2.26/Makefile.in	Thu Feb 27 17:51:25 2003
+++ ns-allinone-2.26/ns-2.26/Makefile.in	Wed Apr 14 03:59:40 2004
@@ -79,6 +79,25 @@
 
 CFLAGS	= $(CCOPT) $(DEFINE)
 
+#### with event system
+INCLUDES += -I../.. -I../../../lib -I../../../../lib/libtb `elvin-config --cflags vin4c`
+INCLUDES += -I../../dkftpbench-0.45
+# The following commented CFLAGS represent all flags that can be used when building even
+# though many of them are not turned on by default. Some of the options need to be used
+# together. e.g. STORE_PKTS and NUM_PKTS, USEEVENTS and RESWAP
+#CFLAGS += -DUSEEVENTS -DADD_ETHER_OVERHEAD -DGETTIME_TSC -DSTORE_PKTS
+#CFLAGS += -DNUM_PKTS=20000 -DBPF_BASED_PACKET_TIME -DRESWAP -DPRINT_SLOP -DDISPATCH_IN_RT
+#CFLAGS += -DSELECT_TIMEOUT -SCHED_DEBUG -DMEASURE_EVENT_RATE -DMEASURE_DELAYS
+#CFLAGS += -DHAVE_POLLER -DHAVE_KQUEUE
+CFLAGS += -DUSEEVENTS -DADD_ETHER_OVERHEAD -DGETTIME_TSC -DSTORE_PKTS 
+CFLAGS += -DRESWAP -DBPF_BASED_PACKET_TIME -DRESWAP -DPRINT_SLOP
+CFLAGS += -DHAVE_POLLER -DHAVE_KQUEUE
+LIB += -L../../../lib -L../../../../lib/libtb -levent -ltb -lcrypto
+LIB += `elvin-config --libs vin4c`
+LIB += -L../../dkftpbench-0.45 -lPoller
+STATIC += -static
+####
+
 # Explicitly define compilation rules since SunOS 4's make doesn't like gcc.
 # Also, gcc does not remove the .o before forking 'as', which can be a
 # problem if you don't own the file but can write to the directory.
@@ -276,6 +295,7 @@
 	mcast/lms-sender.o \
 	@V_STLOBJ@
 
+OBJ_CC += ../../tbevent.o
 
 # don't allow comments to follow continuation lines
 
@@ -303,6 +323,10 @@
 	emulate/nat.o  \
 	emulate/iptap.o \
 	emulate/tcptap.o
+
+##### nse with event system
+OBJ_EMULATE_CC += ../../tbnexthop.o
+####
 
 OBJ_EMULATE_C = \
 	emulate/inet.o
--- dist-ns-allinone-2.26/ns-2.26/config.h	Wed Feb 26 15:07:55 2003
+++ ns-allinone-2.26/ns-2.26/config.h	Fri Nov 28 16:55:25 2003
@@ -73,13 +73,13 @@
  typedef unsigned char u_char;
 typedef unsigned int u_int;
 */
-typedef int32_t nsaddr_t; 
-typedef int32_t nsmask_t; 
+typedef u_int32_t nsaddr_t; 
+typedef u_int32_t nsmask_t; 
 
 // 32-bit addressing support
 struct ns_addr_t {
-	int32_t addr_;
-	int32_t port_;
+	u_int32_t addr_;
+	u_int32_t port_;
 #ifdef __cplusplus
 	ns_addr_t& operator= (const ns_addr_t& n) {
 		addr_ = n.addr_;
--- dist-ns-allinone-2.26/install	Wed Feb 26 16:07:51 2003
+++ ns-allinone-2.26/install	Mon Dec 15 19:04:53 2003
@@ -41,301 +41,47 @@
 # Get current path
 CUR_PATH=`pwd`
 
-# Check if we are using Cygwin, and if so, if it is a bona fide install
-# Cygwin patches contributed by Nicolas Christin <nicolas@cs.virginia.edu>
+if [ -x /usr/local/tcl8.3.2/bin/tclsh8.3 ] ; then
+  V_TCLSH=/usr/local/tcl8.3.2/bin/tclsh8.3 
+  export V_TCLSH
+  WITHTCL_PATH=/usr/local/tcl8.3.2
+  export WITHTCL_PATH
 
-echo "============================================================"
-echo "* Testing for Cygwin environment"
-echo "============================================================"
-
-if [ -x /usr/bin/uname ]; then
-        # it may be a Cygwin install
-        test_cygwin=`uname | tr [a-z] [A-Z] | sed -e 's|.*CYGWIN.*|true|'`;
-        if  [ "${test_cygwin}" = "true" ]; then
-                echo "Cygwin detected";
-                echo "Note: Cygwin install is still considered EXPERIMENTAL";
-                echo "";
-                echo -n "Checking Cygwin version is >=1.3.12... "
-                cmaj=` uname -r | sed -e 's/^\([0-9]*\)\.\([0-9]*\).\([0-9]*\).*/\1/'`;
-                echo $cmaj | grep -v [0-9] >/dev/null 2>&1
-                if [ "$?" -eq "0" ]; then
-                        cmaj=0;
-                fi;
-                cmin=` uname -r | sed -e 's/^\([0-9]*\)\.\([0-9]*\).\([0-9]*\).*/\2/'`;
-                echo $cmin | grep -v [0-9] >/dev/null 2>&1
-                if [ "$?" -eq "0" ]; then
-                        cmin=0;
-                fi;
-                cpat=` uname -r | sed -e 's/^\([0-9]*\)\.\([0-9]*\).\([0-9]*\).*/\3/'`;
-                echo $cpat | grep -v [0-9] >/dev/null 2>&1
-                if [ "$?" -eq "0" ]; then
-                        cpat=0;
-                fi;
-                echo -n "$cmaj.$cmin.$cpat ";
-                if ([ "$cmaj" -gt "1" ]) || ([ "$cmaj" -eq "1" ] && [ $cmin -gt "3" ]) || ([ "$cmaj" -eq 1 ] && [ $cmin -eq "3" ] && [ "$cpat" -ge "12" ]); then
-                        echo "should be ok";
-                else
-                        echo "*** POSSIBLE PROBLEM ***";
-                        echo "";
-                        echo "ns-allinone-${NSVER} has not been tested under versions of Cygwin older than";
-                        echo "1.3.12. Your version ($cmaj.$cmin.$cpat) appears to be older than that. Success of";
-                        echo "the install process is therefore NOT GUARANTEED.";
-                        echo "";
-                        cygversion="failed";                
-		fi;
-                echo -n "Checking filesystems are mounted as UNIX filetype... ";
-                mount | grep "textmode" >/dev/null 2>&1;
-                if [ "$?" -eq "0" ]; then
-                        echo "*** NO! ***";
-                        mount_test="failed";
-                        echo "";
-                        echo "It appears that some of your Cygwin shares are mounted as DOS file";
-                        echo "type. This has not been tested, but is likely to result in failure of";
-                        echo "validation tests. Success of the install process is also NOT";
-                        echo "GUARANTEED.";
-                        echo "";
-                        echo "Refer to the Cygwin user guide for how to install Cygwin with the UNIX";
-                        echo "file text mode.";
-                        echo "";
-                else
-                        echo "yes";
-                        echo -n "Checking default mode is binmode... ";
-                        echo ${CYGWIN} | grep "nobinmode" >/dev/null 2>&1;
-                        if [ "$?" -eq "0" ]; then
-                                cyg_env_var="failed";
-                                echo "*** NO! ***";
-                                echo "";
-                                echo "Your \$CYGWIN environment variable specifies \"nobinmode\". This is";
-                                echo "likely to result in failure of validation tests, and (possibly) of";
-                                echo "the whole install process. You need to have the \$CYGWIN environment";
-                                echo "variable set to \"binmode\". Please refer to the Cygwin user guide for";
-                                echo "details on how to change this.";
-                                echo "";
-                        else 
-                                echo "yes";
-                        fi;
-                fi;                           
-                if [ "$cygversion" = "failed" ] || [ "$cyg_env_var" = "failed" ] || [ "$mount_test" = "failed" ]; then
-                        echo "";
-                        echo "Tests indicate that your installation of Cygwin may not be suitable for";
-                        echo "installing ns-2 allinone.";
-                        echo "";
-                        echo -n "Do you wish to proceed regardless? [y/n] "
-                        read answer;
-                        if [ "$answer" != "y" ] && [ "$answer" != "Y" ]; then
-                                die "Installation aborted...";
-                        fi;
-                fi;
-                echo "Patching Tcl for Cygwin.";
-                if [ ! -f ./tcl${TCLVER}/generic/tcl.h.orig ]; then
-                        cp ./tcl${TCLVER}/generic/tcl.h ./tcl${TCLVER}/generic/tcl.h.orig;
-                        echo "The original tcl${TCLVER}/generic/tcl.h is backed up as tcl${TCLVER}/generic/tcl.h.orig";
-                        sed -e 's/\#define _TCL/\#define _TCL\`\`\#ifdef __CYGWIN__\`\#define HAVE_TM_ZONE 1\`\#endif \/\* __CYGWIN__ \*\//g' ./tcl${TCLVER}/generic/tcl.h.orig | tr '\`' '\n' > ./tcl${TCLVER}/generic/tcl.h;
-                fi;
-                touch ./tcl${TCLVER}/generic/tclStubInit.c;
-                echo "Patching sgb for Cygwin.";
-                cp ./sgb/Makefile ./sgb/Makefile.orig;
-                echo "The original sgb/Makefile is backed up as sgb/Makefile.orig";
-                sed -e 's|rm \(.*\)test_io test_graph test_flip test_sample\(.*\)|rm -f \1test_io.exe test_graph.exe test_flip.exe test_sample.exe\2|' ./sgb/Makefile.orig > ./sgb/Makefile;
-                echo "Setting executable format to .exe...";
-                EXE=".exe";
-        else
-                echo "Cygwin not detected, proceeding with regular install.";
-                EXE=;
-        fi;
-else
-        echo "Cygwin not detected, proceeding with regular install.";
-fi;
-
-
-
-# Compile and install xgraph
-
-echo "============================================================"
-echo "* Build XGraph-$XGRAPHVER"
-echo "============================================================"
-
-cd ./xgraph-$XGRAPHVER
-./configure --prefix=../
-if  [ "${test_cygwin}" = "true" ]; then
-       touch stamp-h;
-fi;
-if make
-then
-	echo "xgraph has been installed successfully. "
-else 
-	echo "Can not create xgraph; But xgraph is an optional package, continuing..."
-fi
-
-cd ../
-
-# Compile and install cweb and sgblib
-
-echo "============================================================"
-echo "* Build CWeb"
-echo "============================================================"
-
-cd ./cweb
-
-if [ ! -f ./Makefile ]
-then
-	echo "ns-allinone unable to install cweb for you. Please install it manually. cweb is used by sgb to create sgblibrary needed by scenario-generator. But this will not affect the use of ns as such, so continue.."
-else
-	echo "Making cweb"
-	touch *.c
-	make all || warn "cweb failed to make, but it's optional"
-	# xxx: other stuff will fail...
-	chmod 755 cweave${EXE}
-	chmod 755 ctangle${EXE}
-	cd ..
-	#echo "cd .."
-	if [ ! -d bin ]
-	then
-		mkdir bin
-	fi
-	cd bin
-	ln -s $CUR_PATH/cweb/cweave${EXE} cweave${EXE}
-	ln -s $CUR_PATH/cweb/ctangle${EXE} ctangle${EXE}
-fi
-
-cd ..
-PATH=$CUR_PATH/bin:$PATH
-export PATH
-
-echo "============================================================"
-echo "* Build Stanford GraphBase"
-echo "============================================================"
-
-cd ./sgb
-if [ ! -f ./Makefile ]
-	then
-	echo "Unable to create sgb library. This library is used by gt-itm and so for scenario generators. If you already have sgblib (possible if you are on solaris,sunos or freebsd platforms) you may still be able to run gt-itm. so continuing.."
-else
-	echo "Making sgb"
-	if make tests
-	then
-                if [ -f libgb.a ] ; then
-                        rm -f ../gt-itm/lib/libgb.a
-			cp libgb.a ../gt-itm/lib/libgb.a
-                else 
-		        echo "* Weird: sgb said it has been built but we can't find libgb.a! "
-			exit -1
-                fi
-	else
-	        echo "Unable to create sgb library, but it's optional, so continuing..."
-	fi
-fi
-
-cd ..
-
-# Compile and install gt-itm & sgb2ns
-
-echo "============================================================"
-echo "* Build GT-ITM"
-echo "============================================================"
-
-if [ -f ./gt-itm/lib/libgb.a ]
-then
- if [ ! -f ./gt-itm/src/Makefile ] 
-    then
-    echo "ns-alline is unable to install gt-itm sgb2ns for you, please install"
-    echo "them manually. You can't run scenario generator without gt-itm"
-    echo "and sgb2ns. But it will not affect you use ns, so continue ..."
- else
-    cd ./gt-itm/src
-    if make
-    then
-      echo "gt-itm has been installed successfully."
-    fi
-    
-    cd ../sgb2ns
-    if make
-    then
-      echo "sgb2ns has been installed successfully."
-    fi
-   cd ../../
- fi
-else
-    echo "sgb lib not found. gt-itm & sgb2ns could not be installed. Continuing.."
-fi
-
-# Build zlib
-
-echo "============================================================"
-echo "* Build zlib"
-echo "============================================================"
-
-cd ./zlib-1.1.4
-
-if ./configure --exec-prefix=../ --prefix=../
-then
-	if make
-	then
-		echo "Zlib has been installed successfully."
-	else
-		warn "Zlib make failed, but it's optional Continue ..."
-	fi
-else
-	warn "Zlib-1.1.4 configuration failed, but it's optional, so continuing ..."
-fi
-
-cd ../
-
-# Build Tcl8.3.5
-
-echo "============================================================"
-echo "* Build tcl$TCLVER"
-echo "============================================================"
-
-cd ./tcl$TCLVER/unix
-if [ -f Makefile ] ; then 
-	make distclean
-fi
-
-blame='Tcl is not part of the ns project.  Please see www.Scriptics.com
-to see if they have a fix for your platform.'
-./configure --enable-gcc --disable-shared --prefix=$CUR_PATH || die "tcl8.3.2 configuration failed! Exiting ..."
-if make 
-then 
-	echo "tcl$TCLVER make succeeded."
-	make install || die "tcl$TCLVER installation failed."
-	echo "tcl$TCLVER installation succeeded."
-	cp ../generic/*.h ../../include
 else
-	echo "tcl$TCLVER make failed! Exiting ..."
-	echo "For problems with Tcl/Tk see http://www.scriptics.com"
-	exit
-fi
 
-cd ../../
+  # Build Tcl8.3.5
+
+  echo "============================================================"
+  echo "* Build tcl$TCLVER"
+  echo "============================================================"
+
+  cd ./tcl$TCLVER/unix
+  if [ -f Makefile ] ; then 
+	  make distclean
+  fi
+
+  blame='Tcl is not part of the ns project.  Please see www.Scriptics.com
+  to see if they have a fix for your platform.'
+  ./configure --enable-gcc --disable-shared --prefix=$CUR_PATH || die "tcl8.3.2 configuration failed! Exiting ..."
+  if make 
+  then 
+  	  echo "tcl$TCLVER make succeeded."
+	  make install || die "tcl$TCLVER installation failed."
+	  echo "tcl$TCLVER installation succeeded."
+	  cp ../generic/*.h ../../include
+  else
+	  echo "tcl$TCLVER make failed! Exiting ..."
+	  echo "For problems with Tcl/Tk see http://www.scriptics.com"
+	  exit
+  fi
 
-# compile and install tk
+  cd ../../
 
-echo "============================================================"
-echo "* Build Tk$TKVER"
-echo "============================================================"
+  WITHTCL_PATH=$CUR_PATH/tcl$TCLVER
+  export WITHTCL_PATH
 
-cd ./tk$TKVER/unix
-if [ -f Makefile ] ; then
-	make distclean
 fi
 
-blame='Tk is not part of the ns project.  Please see www.Scriptics.com
-to see if they have a fix for your platform.'
-./configure --enable-gcc --disable-shared --prefix=$CUR_PATH || die "tk8.3.2 configuration failed! Exiting ..."
-if make 
-then
-	echo "tk$TKVER build succeeded."
-	make install || die "tk$TKVER installation failed."
-	echo "tk$TKVER installation succeeded."
-else
-	echo "tk$TKVER make failed! Exiting ..."
-	echo "For problems with Tcl/Tk see http://www.scriptics.com"
-	exit
-fi
-
-cd ../../
-
 #
 # Since our configures search for tclsh in $PATH, the following 
 # is needed. This is necessary for otcl/tclcl/ns/nam
@@ -345,28 +91,40 @@
 LD_LIBRARY_PATH=$CUR_PATH/tcl$TCLVER/unix:$CUR_PATH/tk$TKVER/unix:$LD_LIBRARY_PATH
 export LD_LIBRARY_PATH
 
-# Build otcl
+if [ -d /usr/local/otcl-1.0a8 ] ; then
 
-echo "============================================================"
-echo "* Build OTcl-$OTCLVER"
-echo "============================================================"
+  WITHOTCL_PATH=/usr/local/otcl-1.0a8
+  export WITHOTCL_PATH
 
-cd ./otcl-$OTCLVER
+else
 
-blame='Please check http://www.isi.edu/nsnam/ns/ns-problems.html
-for common problems and bug fixes.'
-./configure || die "otcl-$OTCLVER configuration failed! Exiting ..."
+  # Build otcl
 
-if make 
-then
-	echo "otcl-$OTCLVER has been installed successfully."
-else
-	echo "otcl-$OTCLVER make failed! Exiting ..."
-	echo "See http://www.isi.edu/nsnam/ns/ns-problems.html for problems"
-	exit
-fi
+  echo "============================================================"
+  echo "* Build OTcl-$OTCLVER"
+  echo "============================================================"
+
+  cd ./otcl-$OTCLVER
+
+  blame='Please check http://www.isi.edu/nsnam/ns/ns-problems.html
+  for common problems and bug fixes.'
+  ./configure || die "otcl-$OTCLVER configuration failed! Exiting ..."
 
-cd ..
+  if make 
+  then
+  	  echo "otcl-$OTCLVER has been installed successfully."
+  else
+	  echo "otcl-$OTCLVER make failed! Exiting ..."
+	  echo "See http://www.isi.edu/nsnam/ns/ns-problems.html for problems"
+	  exit
+  fi
+
+  cd ..
+
+  WITHOTCL_PATH=`pwd`/otcl-$OTCLVER
+  export WITHOTCL_PATH
+
+fi
 
 # Build tclcl
 
@@ -376,7 +134,7 @@
 
 cd ./tclcl-$TCLCLVER
 
-./configure || die "tclcl-$TCLCLVER configuration failed! Exiting ..."
+./configure --enable-static --with-tcl=$WITHTCL_PATH --with-otcl=$WITHOTCL_PATH || die "tclcl-$TCLCLVER configuration failed! Exiting ..."
 
 if make
 then
@@ -397,40 +155,20 @@
 echo "============================================================"
 
 cd ./ns-$NSVER
-./configure || die "Ns configuration failed! Exiting ..."
+./configure --enable-static --enable-debug --with-tcl=$WITHTCL_PATH --with-otcl=$WITHOTCL_PATH || die "Ns configuration failed! Exiting ..."
 
-if make
+if make nse
 then
-	echo " Ns has been installed successfully." 
+	echo " Nse has been installed successfully." 
 else
-	echo "Ns make failed!"
+	echo "Nse make failed!"
 	echo "See http://www.isi.edu/nsnam/ns/ns-problems.html for problems"
 	exit
 fi
 
 cd ../
 
-# Build nam
-
-echo "============================================================"
-echo "* Build nam-$NAMVER"
-echo "============================================================"
-
-cd ./nam-$NAMVER
-
-./configure --with-tclcl=$CUR_PATH/tclcl-$TCLCLVER  || die "Nam configuration failed! Exiting ..."
-
-if make
-then 
-    echo "Nam has been installed successfully."
-else
-    echo "Nam make failed! Continue ..."
-    echo "See http://www.isi.edu/nsnam/ns-problems.html for problems"
-fi
-
-cd ../
-
-# Install nam, ns, xgraph into bin
+# Install nse into bin
 
 if [ ! -d bin ] ; then
     mkdir bin
@@ -438,55 +176,14 @@
 
 cd bin
 
-ln -s $CUR_PATH/ns-$NSVER/ns${EXE} ns${EXE}
-
-if test -x $CUR_PATH/nam-$NAMVER/nam${EXE}
-then
-    ln -s $CUR_PATH/nam-$NAMVER/nam${EXE} nam${EXE}
-else
-    echo "Please compile your nam separately."
-fi
-
-if test -x $CUR_PATH/xgraph-$XGRAPHVER/xgraph${EXE}
-then
-    ln -s $CUR_PATH/xgraph-$XGRAPHVER/xgraph${EXE} xgraph${EXE}
-else
-    echo "Please compile your xgraph separately."
-fi
-
-if test -x $CUR_PATH/gt-itm/bin/sgb2ns${EXE}
-then 
-    ln -s $CUR_PATH/gt-itm/bin/sgb2ns${EXE} sgb2ns${EXE}
-    ln -s $CUR_PATH/gt-itm/bin/sgb2hierns${EXE} sgb2hierns${EXE}
-    ln -s $CUR_PATH/gt-itm/bin/sgb2comns${EXE} sgb2comns${EXE}
-    ln -s $CUR_PATH/gt-itm/bin/itm${EXE} itm${EXE}
-    ln -s $CUR_PATH/gt-itm/bin/sgb2alt${EXE} sgb2alt${EXE}
-    ln -s $CUR_PATH/gt-itm/bin/edriver${EXE} edriver${EXE}
-else
-    echo "Please compile your gt-itm & sgb2ns separately."
-fi
+ln -s $CUR_PATH/ns-$NSVER/nse nse
 
 echo "Ns-allinone package has been installed successfully."
 echo "Here are the installation places:"
 echo "tcl$TCLVER:	$CUR_PATH/{bin,include,lib}"
-echo "tk$TKVER:		$CUR_PATH/{bin,include,lib}"
 echo "otcl:		$CUR_PATH/otcl-$OTCLVER"
 echo "tclcl:		$CUR_PATH/tclcl-$TCLCLVER"
-echo "ns:		$CUR_PATH/ns-$NSVER/ns"
-
-if [ -x $CUR_PATH/nam-$NAMVER/nam ]
-then
-echo "nam:	$CUR_PATH/nam-$NAMVER/nam"
-fi
-
-if [ -x $CUR_PATH/xgraph-$XGRAPHVER/xgraph ]
-then
-echo "xgraph:	$CUR_PATH/xgraph-$XGRAPHVER"
-fi
-if [ -x $CUR_PATH/gt-itm/bin/sgb2ns ] 
-then
-echo "gt-itm:   $CUR_PATH/itm, edriver, sgb2alt, sgb2ns, sgb2comns, sgb2hierns"
-fi
+echo "nse:		$CUR_PATH/ns-$NSVER/nse"
 
 echo ""
 echo "----------------------------------------------------------------------------------"
