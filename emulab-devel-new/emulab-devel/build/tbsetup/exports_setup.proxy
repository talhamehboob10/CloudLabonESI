#!/usr/bin/perl -wT

#
# Copyright (c) 2000-2021 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#

use English;
use Errno;
use Fcntl ':flock';
use Getopt::Std;

#
# Create and /etc/exports file based on current reserved table and project
# members.
#
# usage: exports_setup
#

my %opts = ();
getopts('Si', \%opts);

#
# Configure variables
#
my $TBOPS       = "testbed-ops\@ops.cloudlab.umass.edu";
my $LINUX_FSNODE= 0;
my $INC_MOUNTD  = 0;
my $DIFFDIR	= "/users/mshobana/emulab-devel/build/log/exports";
my $NFSROOT     = "";

my $etcdir;
my $exports;
my $exportsnew;
my $exportsback;
my $exportshead;
my $exportstail;
my $pidfile;
my $daemon;
my $incremental;
my $issamba = 0;

#
# We don't want to run this script unless its the real version.
#
if ($UID != 0) {
    die("Must be root!");
}

# un-taint path
$ENV{'PATH'} = '/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

$| = 1; #Turn off line buffering on output

#
# Testbed Support libraries
# 
use lib "/users/mshobana/emulab-devel/build/lib";
use libtestbed;

# Are we modifying the Samba config file or the NFS exports?
if (defined($opts{'S'})) {
    $issamba	 = 1;
    $etcdir      = ($LINUX_FSNODE ? "/etc/samba" : "/usr/local/etc");
    $exports	 = "$etcdir/smb.conf";
    $exportsnew  = "$etcdir/smb.conf.new";
    $exportsback = "$etcdir/smb.conf.backup";
    $exportshead = "$etcdir/smb.conf.head";
    $exportstail = "$etcdir/smb.conf.tail";
    if (-r "/var/run/samba/smbd.pid") {
	$pidfile = "/var/run/samba/smbd.pid";
    } elsif (-r "/var/run/smbd.pid") {
	$pidfile = "/var/run/smbd.pid";
    } else {
	fatal("Cannot locate pidfile for smbd\n");
    }
    $daemon      = "smbd";
}
else {
    $etcdir      = "/etc";
    $exports	 = "$etcdir/exports";
    $exportsnew  = "$etcdir/exports.new";
    $exportsback = "$etcdir/exports.backup";
    $exportshead = "$etcdir/exports.head";
    $exportstail = "$etcdir/exports.tail";
    $pidfile     = "/var/run/mountd.pid";
    $daemon      = "mountd";
    $exportfs    = ($LINUX_FSNODE ? "/usr/sbin/exportfs -ra" : undef);

    #
    # Incremental only applies to mountd.
    # And as of 12.2, incremental updates are the default.
    #
    if (defined($opts{'i'})) {
	my $rel = `uname -r`;
	if ($rel =~ /^(\d+\.\d+)-/) {
	    $rel = $1;
	} else {
	    $rel = 0;
	}
	if ($INC_MOUNTD) {
	    if ($rel < 12.2) {
		$incremental = 1;
	    } else {
		print "WARNING: running FreeBSD $rel, incremental mode is not needed.\n";
	    }
	} else {
	    print "WARNING: incremental updates not supported, ignoring option\n";
	}
    }
}

my $dbg		= 0;
my @row;

#
# Create a new exports file by concatonating a bunch of pieces
#
sub buildexports($$$) {
    my ($out, $head, $tail) = @_;

    #
    # Generate a warning so that no one tries to edit the file by hand
    #
    open(OUT, ">$out") or
	fatal("Couldn't create $out\n");

    print OUT <<EOF;
#
# ******************************************************************
# DO NOT EDIT THIS FILE. IT IS A CREATION, A FIGMENT, A CONTRIVANCE!
#
# Edit $exportshead, then run exports_setup on boss.
# ******************************************************************
#
EOF
    ;

    #
    # Now tack on the head and tail of the file.
    #
    foreach my $file ($head, $tail) {
	open(IN, "<$file") or
	    fatal("Failed to concat $file to $out\n");
	while (<IN>) {
	    print OUT "$_";
	}
	close(IN);
    }

    close(OUT);
    chmod(0644, $out);
}

#
# Take our input and write it to the tail file.
#
# We do this without any pre-checking of the contents to optimize the
# relatively common case of being called when nothing has changed.
#
# XXX one exception: if this is an NFS-based MFS filesystem, we have to
# check and see if the FS has been renamed. When we do a "node_admin off"
# we rename the "pcX" FS to "pcX-DEAD" because we don't want to yank the
# FS out from under the node while it is still running. But this is done
# on "fs" (nfsmfs_setup.proxy) and "boss" doesn't know about it, so it will
# continue to tell us "pcX" should be exported.
#
open(TAIL, ">$exportstail") || fatal("Couldn't open $exportstail\n");
while (<STDIN>) {
    if (/^($NFSROOT\/\S+)/ && ! -d "$1" && -d "$1-DEAD") {
	my $str = $1;
	s/$str/$str-DEAD/;
    }
    print TAIL $_;
}
close(TAIL);
chmod(0444, $exportstail);

buildexports($exportsnew, $exportshead, $exportstail);

#
# Do nothing if no change.
#
# Note that for now, we are actually saving the diffs so we can
# compare to the new differential behavior of mountd in case of
# an inconsisency. But only for mountd, not smbd.
#
my $outfile;
if ($issamba) {
    system("/usr/bin/diff -q $exports $exportsnew >/dev/null");
} else {
    if (-d "$DIFFDIR") {
	$outfile = "$DIFFDIR/diff." . time();
    } else {
	$outfile = "/dev/null";
    }
    system("/usr/bin/diff $exports $exportsnew >$outfile 2>&1");
}
if (! $?) {
#    print "No changes to $exports; skipping ...\n";
    unlink($outfile)
	if ($outfile && $outfile ne "/dev/null");
    exit(0);
}

#
# Go back and re-parse the file and stat each of the exported filesystems
# to make sure they exist. Otherwise mountd may prematurely fail. We used
# to do this on the boss-side, but that would stat the directories across
# NFS, and in some cases, before the filesystem was even exported!
#
# Note that we do not do this for samba as we assume that the samba
# invocation (-S) of this script will follow the normal invocation and
# have the same directories.
#
if (!$issamba) {
    my $changed = 0;
    
    open(TAIL, "<$exportstail") || fatal("Couldn't open $exportstail\n");
    open(NTAIL, ">$exportstail.new") || fatal("Couldn't open $exportstail.new\n");
    while(<TAIL>) {
	if ($_ !~ /^\//) {
	    print NTAIL $_;
	    next;
	}

	my @tokens = ();
	my $numdirs = 0;
	my $dirsdone = 0;
	foreach my $token (split) {
	    if (!$dirsdone) {
		# starts with a slash, assume it is an exported dir
		if ($token =~ /^\//) {
		    if (! -d "$token") {
			print STDERR "$token: does not exist, ignored\n";
			$changed++;
			next;
		    }
		    $numdirs++;
		} else {
		    $dirsdone = 1;
		}
	    }
	    push(@tokens, $token);
	}

	if ($numdirs > 0) {
	    print NTAIL join(' ', @tokens), "\n";
	}
    }
    close(TAIL);
    close(NTAIL);

    #
    # If there was a bogus directory in the tail file, we have to recreate
    # the new exports file again.
    #
    if ($changed) {
	buildexports($exportsnew, $exportshead, "$exportstail.new");
    }
    unlink("$exportstail.new");
}

#
# Back up the existing exports, and then mv in the new one.
#
system("cp $exports $exportsback") == 0 or
    fatal("Could not back up $exports to $exportsback\n");

system("mv $exportsnew $exports") == 0 or
    fatal("Could not mv $exportsnew to $exports\n");

# Avoid accidental editing.
chmod(0444, $exports);

my $checkstamp = 0;
if (!$LINUX_FSNODE) {
    my $daemonpid = `cat $pidfile`;
    $daemonpid =~ s/\n//;
    # untaint
    if ($daemonpid =~ /^([-\@\w.]+)$/) {
	$daemonpid = $1;
    }

    #
    # Utah feature: if mountd is maintaining a timestamp file, we use
    # that to determine when it has finished processing the exports.
    #
    # XXX since mountd always blindly updates the file, we just remove it
    # here so we don't have to bother checking the content, we just have to
    # wait for it to exist.
    #
    if (!$issamba && unlink("/var/run/mountd.ts") != 0) {
	$checkstamp = 1;
    }

    if ($incremental) {
	if (kill('USR1', $daemonpid) == 0) {
	    fatal("Could not kill(USR1) process $daemonpid ($daemon): $!");
	}
    } else {
	if (kill('HUP', $daemonpid) == 0) {
	    fatal("Could not kill(HUP) process $daemonpid ($daemon): $!");
	}
    }
}
else {
    # Not supporting Samba at this time. 
    if (!$issamba) {
	#
	# run exportfs. linux handles exports changes much more gracefully
	# then freebsd does.
	#
        system($exportfs) == 0 or
            fatal("Could not run $exportfs\n");
    }
}

#
# In FreeBSD, must allow time to react since HUP'ing mountd causes all
# mounts to briefly become invalid. Our caller (exports_setup) checks for
# this, but we need to make sure that processing has at least started!
#
# Note that Utah has hacked mountd to write a timestamp when it is done.
# Hence we can tell exactly when it has finished. In this case, our caller
# will not wait at all.
#
if ($checkstamp) {
    # On Utah Emulab with thousands of mount points, this can take 15 seconds!
    my $wtime = $incremental ? 8 : 15;

    for (my $i = 0; $i < $wtime; $i++) {
	print "exports_setup.proxy: waiting for mountd to finish ($i)...\n";
	if (-e "/var/run/mountd.ts") {
	    print "exports_setup.proxy: mountd done.\n";
	    last;
	}
	sleep(1);
    }
} else {
    sleep(1);
}

exit(0);

sub fatal {
    local($msg) = $_[0];

    SENDMAIL($TBOPS, "Exports Setup Failed", $msg);    
    die($msg);
}

