<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DataqSDK: di_serial_io.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>di_serial_io.cpp</h1><div class="fragment"><pre>00001 <span class="comment">/***************************************************************************</span>
00002 <span class="comment">              di_serial_io.cpp  -  Functions that deal with input/output</span>
00003 <span class="comment">                                   to many serial devices.</span>
00004 <span class="comment">                             -------------------</span>
00005 <span class="comment">    begin                : Wed Jun 23 2004</span>
00006 <span class="comment">    author               : Ioan S. Popescu</span>
00007 <span class="comment"></span>
00008 <span class="comment">Copyright (C) 2004 DATAQ Instruments, Inc. &lt;develop@dataq.com&gt;</span>
00009 <span class="comment"></span>
00010 <span class="comment">This program is free software; you can redistribute it and/or </span>
00011 <span class="comment">modify it under the terms of the GNU General Public License </span>
00012 <span class="comment">as published by the Free Software Foundation; either </span>
00013 <span class="comment">version 2 of the License, or (at your option) any later </span>
00014 <span class="comment">version.</span>
00015 <span class="comment"></span>
00016 <span class="comment">This program is distributed in the hope that it will be useful,</span>
00017 <span class="comment">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00018 <span class="comment">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00019 <span class="comment">GNU General Public License for more details.</span>
00020 <span class="comment"></span>
00021 <span class="comment">You should have received a copy of the GNU General Public License</span>
00022 <span class="comment">along with this program; if not, write to the Free Software</span>
00023 <span class="comment">Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
00024 <span class="comment"> ***************************************************************************/</span>
00025 
00026 <span class="preprocessor">#include "<a class="code" href="di__serial__io_8h.html">di_serial_io.h</a>"</span>
00027 
00028 <span class="preprocessor">#include &lt;unistd.h&gt;</span>   <span class="comment">// UNIX standard function definitions</span>
00029 <span class="preprocessor">#include &lt;sys/ioctl.h&gt;</span><span class="comment">// IO port control function definitions</span>
00030 <span class="preprocessor">#include &lt;time.h&gt;</span>     <span class="comment">// Time function definitions</span>
00031 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>    <span class="comment">// File control definitions</span>
00032 
<a name="l00033"></a><a class="code" href="classdi__serial__io.html#a0">00033</a> <a class="code" href="classdi__serial__io.html#a0">di_serial_io::di_serial_io</a>()
00034 {
00035   <a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a> = -1;
00036   <a class="code" href="classdi__serial__io.html#r0">m_baudrate</a> = B4800;
00037   <a class="code" href="classdi__serial__io.html#r3">m_old_tiocm</a> = 0;
00038   <a class="code" href="classdi__serial__io.html#r4">m_timeout</a> = 2;
00039 }
00040 
<a name="l00041"></a><a class="code" href="classdi__serial__io.html#a1">00041</a> <a class="code" href="classdi__serial__io.html#a1">di_serial_io::~di_serial_io</a>()
00042 {
00043   <span class="keywordflow">if</span>(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a> != -1)
00044     <a class="code" href="classdi__serial__io.html#a3">disconnect</a>();
00045 }
00046 
<a name="l00064"></a><a class="code" href="classdi__serial__io.html#a2">00064</a> <span class="keyword">const</span> u_int16_t <a class="code" href="classdi__serial__io.html#a2">di_serial_io::connect</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> dev_file, <span class="keyword">const</span> u_int8_t device)
00065 {
00066   my_errno = 0;
00067   <span class="comment">// open the serial port</span>
00068   <a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a> = open(dev_file, O_RDWR | O_NOCTTY | O_NDELAY);
00069   <span class="keywordflow">if</span> (<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a> == -1)
00070   {
00071     my_errno = errno;
00072     <span class="keywordflow">return</span> my_errno; <span class="comment">// same error codes as open()</span>
00073   }
00074   <span class="keywordflow">else</span>
00075     fcntl(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, F_SETFL, FNDELAY); <span class="comment">// set to non-blocking</span>
00076 
00077   <span class="keyword">struct </span>termios serial_opts; <span class="comment">// will hold new serial port settings</span>
00078 
00079   <span class="comment">// flush send/receive buffers so settings will be set properly</span>
00080   <a class="code" href="classdi__serial__io.html#a8">flush_receive</a>();
00081   tcflush(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, TCOFLUSH);
00082 
00083   <span class="comment">// get copy of current serial port settings to restore later</span>
00084   <span class="keywordflow">if</span>(tcgetattr(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, &amp;<a class="code" href="classdi__serial__io.html#r2">m_old_termios</a>) == -1)
00085   {
00086     my_errno = errno;
00087     <span class="keywordflow">return</span> my_errno; <span class="comment">// same error codes as tcgetattr()</span>
00088   }
00089   <span class="comment">// get copy of other current serial port settings to restore later</span>
00090   <span class="keywordflow">if</span>(ioctl(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, TIOCMGET, &amp;<a class="code" href="classdi__serial__io.html#r3">m_old_tiocm</a>) == -1)
00091   {
00092     my_errno = errno;
00093     <span class="keywordflow">return</span> my_errno;
00094   }
00095 
00096   <span class="comment">// get current serial port settings (must modify existing settings)</span>
00097   <span class="keywordflow">if</span>(tcgetattr(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, &amp;serial_opts) == -1)
00098   {
00099     my_errno = errno;
00100     <span class="keywordflow">return</span> my_errno; <span class="comment">// same error codes as tcgetattr()</span>
00101   }
00102 
00103   <span class="comment">// clear out settings</span>
00104   serial_opts.c_cflag = 0;
00105   serial_opts.c_iflag = 0;
00106   serial_opts.c_lflag = 0;
00107   serial_opts.c_oflag = 0;
00108 
00109   <span class="comment">// set baud rate</span>
00110   <span class="keywordflow">if</span>(cfsetispeed(&amp;serial_opts, <a class="code" href="classdi__serial__io.html#r0">m_baudrate</a>) == -1)
00111   {
00112     my_errno = errno;
00113     <span class="keywordflow">return</span> my_errno; <span class="comment">// same error codes as cfsetispeed()</span>
00114   }
00115   <span class="keywordflow">if</span>(cfsetospeed(&amp;serial_opts, <a class="code" href="classdi__serial__io.html#r0">m_baudrate</a>) == -1)
00116   {
00117     my_errno = errno;
00118     <span class="keywordflow">return</span> my_errno; <span class="comment">// same error codes as cfsetospeed()</span>
00119   }
00120 
00121   <span class="comment">// no parity</span>
00122   serial_opts.c_cflag &amp;= ~PARENB;
00123   serial_opts.c_iflag &amp;= ~INPCK;
00124 
00125   <span class="comment">// apply settings and check for error</span>
00126   <span class="comment">// this is done because tcsetattr() would return success if *any*</span>
00127   <span class="comment">// settings were set correctly; this way, more error checking is done</span>
00128   <span class="keywordflow">if</span>(tcsetattr(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, TCSANOW, &amp;serial_opts) == -1)
00129   {
00130     my_errno = errno;
00131     <span class="keywordflow">return</span> my_errno; <span class="comment">// same error codes as tcsetattr()</span>
00132   }
00133 
00134   serial_opts.c_cflag &amp;= ~CSTOPB; <span class="comment">// 1 stop bit</span>
00135   serial_opts.c_cflag &amp;= ~CSIZE;  <span class="comment">// reset byte size</span>
00136   serial_opts.c_cflag |= CS8;     <span class="comment">// 8 bits</span>
00137 
00138   <span class="comment">// apply settings and check for error</span>
00139   <span class="keywordflow">if</span>(tcsetattr(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, TCSANOW, &amp;serial_opts) == -1)
00140   {
00141     my_errno = errno;
00142     <span class="keywordflow">return</span> my_errno; <span class="comment">// same error codes as tcsetattr()</span>
00143   }
00144 
00145   <span class="comment">// disable hardware flow control</span>
00146   serial_opts.c_cflag &amp;= ~CRTSCTS;
00147 
00148   <span class="comment">// apply settings and check for error</span>
00149   <span class="keywordflow">if</span>(tcsetattr(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, TCSANOW, &amp;serial_opts) == -1)
00150   {
00151     my_errno = errno;
00152     <span class="keywordflow">return</span> my_errno; <span class="comment">// same error codes as tcsetattr()</span>
00153   }
00154 
00155   <span class="comment">// disable software flow control</span>
00156   serial_opts.c_iflag &amp;= ~(IXON | IXOFF | IXANY);
00157 
00158   <span class="comment">// apply settings and check for error</span>
00159   <span class="keywordflow">if</span>(tcsetattr(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, TCSANOW, &amp;serial_opts) == -1)
00160   {
00161     my_errno = errno;
00162     <span class="keywordflow">return</span> my_errno; <span class="comment">// same error codes as tcsetattr()</span>
00163   }
00164 
00165   <span class="comment">// raw I/O</span>
00166   serial_opts.c_lflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG);
00167   serial_opts.c_oflag &amp;= ~OPOST;
00168 
00169   <span class="comment">// apply settings and check for error</span>
00170   <span class="keywordflow">if</span>(tcsetattr(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, TCSANOW, &amp;serial_opts) == -1)
00171   {
00172     my_errno = errno;
00173     <span class="keywordflow">return</span> my_errno; <span class="comment">// same error codes as tcsetattr()</span>
00174   }
00175 
00176   <span class="comment">// timeouts</span>
00177   serial_opts.c_cc[VMIN] = 0;
00178   serial_opts.c_cc[VTIME] = 10;
00179 
00180   <span class="comment">// apply settings and check for error</span>
00181   <span class="keywordflow">if</span>(tcsetattr(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, TCSANOW, &amp;serial_opts) == -1)
00182   {
00183     my_errno = errno;
00184     <span class="keywordflow">return</span> my_errno; <span class="comment">// same error codes as tcsetattr()</span>
00185   }
00186 
00187   <span class="comment">// misc. settings</span>
00188   serial_opts.c_cflag |= HUPCL;
00189   serial_opts.c_cflag |= (CLOCAL | CREAD);
00190 
00191   <span class="comment">// apply settings and check for error</span>
00192   <span class="keywordflow">if</span>(tcsetattr(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, TCSANOW, &amp;serial_opts) == -1)
00193   {
00194     my_errno = errno;
00195     <span class="keywordflow">return</span> my_errno; <span class="comment">// same error codes as tcsetattr()</span>
00196   }
00197 
00198   <span class="keywordtype">int</span> status = <a class="code" href="classdi__serial__io.html#r3">m_old_tiocm</a>; <span class="comment">// get settings</span>
00199   <span class="keywordflow">switch</span>(device)
00200   {
00201     <span class="keywordflow">default</span>:
00202       status |= TIOCM_DTR;  <span class="comment">// turn on DTR and...</span>
00203       status |= TIOCM_RTS;  <span class="comment">// ...RTS lines to power up device</span>
00204       <span class="comment">// apply settings</span>
00205       <span class="keywordflow">if</span>(ioctl(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, TIOCMSET, &amp;status) == -1)
00206       {
00207         my_errno = errno;
00208         <span class="keywordflow">return</span> my_errno;
00209       }
00210 
00211       <span class="comment">// wait for device to power up</span>
00212       usleep(100000);
00213   }
00214 
00215   <span class="comment">// flush send/receive buffers so settings will be set properly</span>
00216   <a class="code" href="classdi__serial__io.html#a8">flush_receive</a>();
00217   tcflush(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, TCOFLUSH);
00218 
00219   <span class="keywordflow">return</span> 0;
00220 }
00221 
<a name="l00232"></a><a class="code" href="classdi__serial__io.html#a3">00232</a> <span class="keyword">const</span> u_int16_t <a class="code" href="classdi__serial__io.html#a3">di_serial_io::disconnect</a>()
00233 {
00234   my_errno = 0;
00235   <span class="comment">// flush send/receive buffers so settings will be set properly</span>
00236   <a class="code" href="classdi__serial__io.html#a8">flush_receive</a>();
00237   tcflush(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, TCOFLUSH);
00238 
00239   <span class="comment">// try to reset serial port settings back to original</span>
00240   tcsetattr(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, TCSANOW, &amp;<a class="code" href="classdi__serial__io.html#r2">m_old_termios</a>);
00241   <span class="comment">// try to reset other serial port settings back to original</span>
00242   ioctl(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, TIOCMSET, &amp;<a class="code" href="classdi__serial__io.html#r3">m_old_tiocm</a>);
00243 
00244   <span class="comment">// try to close serial port</span>
00245   <span class="keywordflow">if</span>(close(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>) == -1)
00246   {
00247     my_errno = errno;
00248     <span class="keywordflow">return</span> my_errno;
00249   }
00250   <a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a> = -1;
00251   <span class="keywordflow">return</span> 0;
00252 }
00253 
<a name="l00258"></a><a class="code" href="classdi__serial__io.html#a4">00258</a> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="classdi__serial__io.html#a4">di_serial_io::is_comm_open</a>()
00259 {
00260   <span class="keywordflow">if</span>(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a> == -1)
00261     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00262   <span class="keywordflow">else</span>
00263     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00264 }
00265 
<a name="l00285"></a><a class="code" href="classdi__serial__io.html#a5">00285</a> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="classdi__serial__io.html#a5">di_serial_io::di_read</a>(u_int8_t *data,
00286                                  u_int16_t &amp;amount,
00287                                  <span class="keyword">const</span> u_int8_t packet_len)
00288 {
00289   my_errno = 0;
00290   int16_t available = 0;
00291   u_int8_t retries = 4;
00292   time_t time_start = time(NULL);
00293 
00294   ioctl(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, FIONREAD, &amp;available);
00295   <span class="comment">// wait for data</span>
00296   <span class="keywordflow">while</span>((time(NULL) - time_start &lt; <a class="code" href="classdi__serial__io.html#r4">m_timeout</a>) &amp;&amp;  <span class="comment">// stop when timeout reached</span>
00297         (available &lt; amount))                      <span class="comment">// or when enough data</span>
00298   {
00299     usleep(50);
00300     ioctl(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, FIONREAD, &amp;available);       <span class="comment">// is available</span>
00301   }
00302 
00303   <span class="comment">// timed out without any data</span>
00304   <span class="keywordflow">if</span>(available == 0)
00305   {
00306     my_errno = ENODATA;
00307     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00308   }
00309   <span class="comment">// timed out and not enough data</span>
00310   <span class="keywordflow">if</span>(time(NULL) - time_start &gt;= <a class="code" href="classdi__serial__io.html#r4">m_timeout</a> &amp;&amp; available &lt; amount)
00311   {
00312     <span class="comment">// read as much as is available</span>
00313     <span class="keywordflow">if</span>(read(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, data, available) == -1)
00314     {
00315       my_errno = errno;
00316       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00317     }
00318 
00319     <span class="comment">// let caller know how much was read</span>
00320     amount = available;
00321     my_errno = ETIMEDOUT;
00322     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00323   }
00324 
00325   <span class="comment">// read the amount requested</span>
00326   <span class="keywordflow">if</span>(read(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, data, amount) == -1)
00327   {
00328     my_errno = errno;
00329     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00330   }
00331 
00332   <span class="comment">// validate if requested</span>
00333   <span class="keywordflow">if</span>(packet_len &gt; 0)
00334   {
00335     time_start = time(NULL);
00336     <span class="keywordflow">while</span>(retries-- &gt; 0 &amp;&amp; !<a class="code" href="classdi__serial__io.html#d0">di_valid</a>(data, packet_len))
00337     {
00338       <span class="comment">// inside this loop means previously read data was invalid</span>
00339       <span class="keywordflow">if</span>(!<a class="code" href="classdi__serial__io.html#d1">di_synchronize</a>(data, amount, packet_len))
00340       {
00341         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00342       }
00343     }
00344   }
00345 
00346   <span class="keywordflow">return</span> <span class="keyword">false</span>;  <span class="comment">// success</span>
00347 }
00348 
<a name="l00367"></a><a class="code" href="classdi__serial__io.html#a6">00367</a> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="classdi__serial__io.html#a6">di_serial_io::di_send</a>(<span class="keyword">const</span> u_int8_t *<span class="keyword">const</span> data,
00368                                  u_int16_t &amp;amount,
00369                                  <span class="keyword">const</span> u_int8_t echo,
00370                                  <span class="keyword">const</span> u_int8_t retry)
00371 {
00372   my_errno = 0;
00373   u_int8_t tries = retry;
00374   <span class="keywordtype">int</span> write_return = 0;
00375 
00376   <span class="keywordflow">while</span>(tries-- &gt; 0)
00377   {
00378     <span class="comment">// flush send buffer to make sure command gets sent</span>
00379     tcflush(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, TCOFLUSH);
00380     <span class="keywordflow">if</span>(echo &gt; 0)
00381       <span class="comment">// clear receive buffer if checking echo</span>
00382       <a class="code" href="classdi__serial__io.html#a8">flush_receive</a>();
00383 
00384     <span class="comment">// try to send all of it at once</span>
00385     write_return = write(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, data, amount);
00386     <span class="keywordflow">if</span>(write_return &lt;= 0)
00387     {
00388       my_errno = errno;
00389       <span class="keywordflow">return</span> <span class="keyword">true</span>;  <span class="comment">// error in send</span>
00390     }
00391 
00392     <span class="comment">// send whatever's left, if need to (one byte at a time)</span>
00393     <span class="keywordflow">for</span>(u_int16_t i = static_cast&lt;u_int16_t&gt;(write_return); i &lt; amount; i++)
00394     {
00395       <span class="keywordflow">if</span>(write(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, data + i, 1) &lt;= 0)
00396       {
00397         my_errno = errno;
00398         <span class="keywordflow">return</span> <span class="keyword">true</span>;  <span class="comment">// error in send</span>
00399       }
00400     }
00401 
00402     <span class="keywordflow">if</span>(echo &gt; 0)  <span class="comment">// check for at least 1 echo</span>
00403     {
00404       <span class="comment">// check if echo matches</span>
00405       my_errno = 0;
00406       <span class="keywordflow">if</span>(!<a class="code" href="classdi__serial__io.html#d2">di_echo</a>(data, echo))
00407       {
00408         my_errno = <a class="code" href="group__ADDITIONAL__CODES.html#ga1">EBADRSVP</a>;
00409         <span class="comment">// wait a little</span>
00410         usleep(500000);
00411         <span class="keywordflow">continue</span>;  <span class="comment">// didn't match, try again</span>
00412       }
00413       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(my_errno != 0)
00414       {
00415         <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// error in read</span>
00416       }
00417     }
00418 
00419     my_errno = 0;
00420     <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// data sent successfully</span>
00421   }
00422 
00423   <span class="keywordflow">return</span> <span class="keyword">true</span>;
00424 }
00425 
<a name="l00430"></a><a class="code" href="classdi__serial__io.html#a7">00430</a> <span class="keyword">const</span> int16_t <a class="code" href="classdi__serial__io.html#a7">di_serial_io::bytes_in_receive</a>()
00431 {
00432   <span class="keywordtype">int</span> bytes = 0;
00433   
00434   ioctl(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, FIONREAD, &amp;bytes);
00435   <span class="keywordflow">return</span> bytes;
00436 }
00437 
<a name="l00442"></a><a class="code" href="classdi__serial__io.html#a8">00442</a> <span class="keywordtype">void</span> <a class="code" href="classdi__serial__io.html#a8">di_serial_io::flush_receive</a>()
00443 {
00444   time_t time_start = time(NULL);
00445 
00446   <span class="keywordflow">while</span>(<a class="code" href="classdi__serial__io.html#a7">bytes_in_receive</a>() &gt; 0 &amp;&amp; (time(NULL) - time_start &lt; 2))
00447   {
00448     <span class="comment">// flush receive buffers to clear them</span>
00449     tcflush(<a class="code" href="classdi__serial__io.html#r1">m_comm_fd</a>, TCIFLUSH);
00450     usleep(50);
00451   }
00452 
00453   <span class="keywordflow">return</span>;
00454 }
00455 
<a name="l00466"></a><a class="code" href="classdi__serial__io.html#d0">00466</a> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="classdi__serial__io.html#d0">di_serial_io::di_valid</a>(<span class="keyword">const</span> u_int8_t *<span class="keyword">const</span> data,
00467                                   <span class="keyword">const</span> u_int8_t packet_len)
00468 {
00469   <span class="comment">// byte 1 has zero at end</span>
00470   <span class="keywordflow">if</span>((data[0] &amp; 0x1) != 0)
00471     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00472 
00473   <span class="comment">// remaining bytes have one at end</span>
00474   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; packet_len; i++)
00475   {
00476     <span class="keywordflow">if</span>((data[i] &amp; 0x1) != 1)
00477       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00478   }
00479 
00480   <span class="keywordflow">return</span> <span class="keyword">true</span>;
00481 }
00482 
<a name="l00495"></a><a class="code" href="classdi__serial__io.html#d1">00495</a> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="classdi__serial__io.html#d1">di_serial_io::di_synchronize</a>(u_int8_t *data,
00496                                              <span class="keyword">const</span> u_int8_t data_len,
00497                                              <span class="keyword">const</span> u_int8_t packet_len)
00498 {
00499   u_int8_t i = 0, j = 0;
00500 
00501   <span class="comment">// look for the trailing zero bit in current data</span>
00502   <span class="keywordflow">for</span>(i = 0; i &lt; data_len &amp;&amp; (data[i] &amp; 0x1) != 0; i++);
00503 
00504   <span class="comment">// copy that portion to beginning of data</span>
00505   <span class="keywordflow">for</span>(j = 0; i &lt; data_len; j++, i++)
00506     data[j] = data[i];
00507 
00508   <span class="comment">// read what is assumed to be the remainder of the packet</span>
00509   u_int16_t amount = packet_len - j;
00510   <span class="keywordflow">if</span>(<a class="code" href="classdi__serial__io.html#a5">di_read</a>(data + j, amount, 0))
00511     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00512 
00513   <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// Success.</span>
00514 }
00515 
<a name="l00527"></a><a class="code" href="classdi__serial__io.html#d2">00527</a> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="classdi__serial__io.html#d2">di_serial_io::di_echo</a>(<span class="keyword">const</span> u_int8_t *<span class="keyword">const</span> expected,
00528                                     <span class="keyword">const</span> u_int8_t amount)
00529 {
00530   u_int16_t bytes = amount;
00531   u_int8_t *buf = <span class="keyword">new</span> u_int8_t[bytes];
00532 
00533   <span class="keywordflow">if</span>(<a class="code" href="classdi__serial__io.html#a5">di_read</a>(buf, bytes, 0)) <span class="comment">// read data</span>
00534   {
00535     <span class="keyword">delete</span> [] buf;
00536     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00537   }
00538   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt;= bytes; i++)  <span class="comment">// try to match data</span>
00539   {
00540   <span class="comment">// need to shift expected because NULL isn't echoed</span>
00541     <span class="keywordflow">if</span>(expected[i] != buf[i-1])
00542     {
00543       <span class="keyword">delete</span> [] buf;
00544       <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// mismatch found</span>
00545     }
00546   }
00547   <span class="keyword">delete</span> [] buf;
00548   <span class="keywordflow">return</span> <span class="keyword">true</span>;  <span class="comment">// match succeeded</span>
00549 }
00550 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Aug 2 09:44:50 2004 for DataqSDK by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
