#!/usr/bin/perl -w
#
# Copyright (c) 2000-2021 University of Utah and the Flux Group.
# 
# {{{EMULAB-LGPL
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
# License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#

#
# snmpit - A tool for setting up VLANs on SNMP-controllable switches
#

#
# Configure variables
#
my $TESTMODE   = @TESTMODE@;
my $ELABINELAB = @ELABINELAB@;
my $NOSTACKMIB = @NOSTACKMIB@;
my $MAINSITE   = @TBMAINSITE@;
my $GENIRACK   = @PROTOGENI_GENIRACK@;
my $TB = '@prefix@';

use lib '@prefix@/lib';
use libdb;
use User;
use Experiment;
use libtblog;
use EmulabFeatures;
use Lan;
use English;
use Getopt::Long;
use emutil;
use strict;
use Data::Dumper;
use Carp qw(cluck);
use List::Util qw(shuffle);

# Optional alternate version of libraries.
#use lib '.';
#use lib '../../../testbed/tbsetup/snmpit';
use lib '@prefix@/lib/snmpit';
use snmpit_lib;
use snmpit_remote;

# Protos
sub parseStatusString($);
sub filterList($$);
sub debug($);
sub doListVlans($);
sub doListPorts($);
sub doPortStatus($@);
sub doGetStats($);
sub doVlansFromTables($$@);
sub syncVlansFromTables($$@);
sub doSyncVlansWithDB($);
sub doPruneStaleVlans($);
sub doReset($@);
sub doMakeVlan($$@);
sub doDeleteVlan($@);
sub doVlanNumber($$);
sub doPortControl($$@);
sub doRecreateVlans($);
sub doTrunkEnable($$$@);
sub doTrunkDisable($$);
sub doRestorePortStatus($@);
sub doSynchLeader($);
sub CreateOneVlan($$$@);
sub doOpenflowEnable($$);
sub doOpenflowDisable($$);
sub doSetOpenflowController($$$;$);
sub doSetOpenflowListener($$$);
sub doEnableOpenflowListener($$);
sub doReserveVlanTags($$@);
sub doUnReserveVlanTags($$@);
sub doSetVlanOnTrunks($$@);
sub doDeleteStaleVlansFromDevices($@);

#
# Defaults
#
my $debug = 0;
my $quiet = 0;
my $impotent = 0;
my $minOpenflowListenerPort = 5000;
my $maxOpenflowListenerPort = 65535;

######################################################################
# Step 1 - Process command-line arguments
#
# We have a fairly complex set of command line arguments, and we
# need to make sure that the user only specifies one command at a
# time.
######################################################################
sub usage {
    print << "END";
Usage: $0 [-h] [-v level] [-q] [-n] [-i device] [-S stack]
	  [-l] [-s] [-g] [-O]
	  [-m name pid eid [ports]]
	  [-T port name]
	  [-U port]
	  [-o name pid eid]
          [-N name]
          [-r pid eid]
	  [-t pid eid]
	  [-d ports] [-e ports] [-a ports]
	  [-p <10|100|1000> ports] [-u <half|full> ports]
	  [-c]
          [--redirect-err]
          [--of-disable name pid eid]
          [--of-enable name pid eid]
          [--of-controller name pid eid tcp:ip:port [fail-secure]]
          [--of-listener name pid eid]
General:
  -h              Display this help message
  -v <level>      Verbose mode
  -q              Quiet mode
  -n              Test mode - don't actually make any changes
  -i <device>     Operate on <device>, overriding default device list. Can be
                      given multiple times
  -S <stack>      Operate on the given stack, instead of the default of the
                      experimental network
  --skip-supplied If the -S option was given, start with the default stacks, 
                      but skip any switches in the stacks listed in -S.
  --redirect-err  Redirect STDERR to STDOUT, for easier capturing in logfiles

VLAN Control:
  -t <pid> <eid>    Create all VLANs for an experiment
  -r <pid> <eid>    Remove all VLANs for an experiment
                        (you can provide an optional list of vlan ids)
  -l                List all VLANs associated with experiments.
                        A second -l will list ALL vlans.
  -w                Used with -l, includes device-specific VLAN number
  -M                Used with -l, print MAC addresses instead of port numbers
  -O                Used with -l, list only orphaned VLANs
  -L <out#in[,o2#i2,...]> stylized -l for snmpit.proxy of specific vlans
  -m <name> <pid> <eid> [ports]
                    Create a new VLAN with name <name>, if it doesn't exist,
                        and put [ports] in it. The new VLAN will be
                        associated with the priject and experiment given
  -y <type>         When used with -m, the new VLAN becomes a private VLAN
                        of type <type>
  -x <primary>      When used with -y, assocates the new private VLAN with
                        the primary VLAN named <primary>
  -z <port>         Used with -y and -x, to specify which port is to be used
                        with the private VLAN
  -o <name> <pid> <eid>
                    Delete the VLAN with name <name>, which is associated with
                        the given experiment
  -N <name>         Print out the VLAN number for the named VLAN
  -c                Delete ALL VLANs, and recreate from the database. ** USE
                        WITH EXTREME CAUTION **
  -F                Create all vlans in the given stack on the leader for
		    use in leader->{ALLVLANSONLEADER} (Internal use only)
  --of-enable <name> <pid> <eid> 
                    Enable Openflow on VLAN with the name that is 
		        associated with the given experiment 
  --of-disable <name> <pid> <eid>
                    Disable Openflow on VLAN with the name that is 
		        associated with the given experiment
  --of-controller <name> <pid> <eid> tcp:ip:port
                    Set controller for Openflow-enabled VLAN with the 
		        name that is associated with the given experiment
  --of-listener <name> <pid> <eid> 
                    Enable listener for Openflow-enabled VLAN with the 
		        name that is associated with the given 
			experiment, snmpit will print out the listener 
			connection string

Port Control:
  -s                     List all ports, and show configuration information
  -g                     Get port statistics
  -d <ports>             Disable <ports>
  -e <ports>             Enable <ports>
  -a <ports>             Enable auto-negotiation of port speed/duplex
  -p <10|100> <ports>    Set speed of <ports> to 10 or 100 Mbps
  -u <half|full> <ports> Set duplex of <ports> to half or full
  -T <port> <names>      Enable trunking on the given <port>, and allow VLANs
                             with the given <names> across it
  -E <port> <names>      Like -T, but "Equal" mode; PVID is also tagged
  -U <ports>             Turn off trunking for the given <ports>
  -b <ports>             Print out port status for a set of ports
  -B <statstring>        Pass in a stat string from -b to restore status
  -D <pid> <eid>         Disable all control net ports for an experiment
  -R <pid> <eid>         (Re)enable all control net ports for an experiment

More than one operation can be specified - However, beware that the order in
which operations will occur is undefined, and some combinations of operations
(ie. -d and -e) are non-sensical.
END

    return 1;
}

my @SAVEARGV = @ARGV;
my %opt = ();
Getopt::Long::Configure("no_ignore_case");
GetOptions(\%opt,
    'a','c','d','e','b','B=s@','g','h','i=s@','l+','m=s@','M','n', 'A', 'C',
    'N=s@','p=s','q','r','s', 'S=s@','t','E=s','T=s','u=s','U','v=s','w',
    'y=s','x=s','z=s','F','L=s','O', 'D', 'R', 'f', 'X', 'Z', 'vlan_tag=i', 
    'of-disable=s', 'of-enable=s', 'of-controller=s', 'of-listener=s',
    'o=s@{1,1}', 'redirect-err', 'blockmode', 'syncvlans', 'impotent',
    'shadow', 'skip-supplied', 'whol-magic', 'backtraceonwarning',
    'prunestalevlans','setvlanontrunks','resetvlanontrunks',
    'clearvlanontrunks','deletestalevlans');

if ($opt{h}) {
    exit &usage;
}

#
# If requested, redirect STDERR to STDOUT - this makes it easier to capture
# error output in logfiles
#
if ($opt{'redirect-err'}) {
    open(STDERR, ">&STDOUT");
}
if ($opt{'backtraceonwarning'}) {
    BackTraceOnWarning(1);
}
if ($opt{'impotent'}) {
    $impotent = 1;
}

if ($opt{v}) {
    $debug = $opt{v};
    print "Debug level is $debug\n";
}

if ($opt{q}) {
    $quiet = 1;
    if ($opt{m} || $opt{o} || $opt{t} || $opt{r} || $opt{X} || $opt{T} ||
	  $opt{E} || $opt{U} || $opt{u} || $opt{d} || $opt{p} || $opt{e} ||
	  $opt{'of-enable'} || $opt{'of-disable'} || $opt{'of-controller'} || 
	  $opt{'of-listener'}) {
	my $nulldev;
        open($nulldev, ">>/dev/null");
	select $nulldev; # supresses print foo(); without explicit fileglob
    }
}

#if ($opt{F}) { push @commands, ["synchleader"]; }
# Values that may have been passed on the command line
#
my $pid;
my $eid;
my $experiment;
my @ports;
my @optvlanids  = ();
my %optvlantags = ();
my $equaltrunking = 0;
my $this_user;
my $ofconnstr; # Openflow connection string, for controller 
my $ofconnopt; # Openflow option string, for controller 
our $next_vlan_tag; # XXX see doMakeVlan for explanation
my %stack_ids = ();
my $optdev; # when -i only specify a single device


#
# Move this initialization ahead from its previous location so that
# the ports converters can be used when parsing command line args.
#
# snmpit_lib fills out some hashes for speed of lookup later. Initialize
# them now
#
snmpit_lib::init($debug);

if ($opt{i} && @{$opt{i}} == 1) {
    $optdev = $opt{i}->[0];
}

#
# Verify user and get his DB uid for later. 
#
if ($UID) {
    $this_user = User->ThisUser();
    if (! defined($this_user)) {
	die("*** $0:\n".
	    "    You ($UID) do not exist!\n");
    }
}

#
# Some operations have mandatory agruments - for others, make sure that
# the user didn't give any extraneous arguments
#
if ($opt{m} || $opt{o}) {
    if (@ARGV < 2 ||
	($opt{m} && ($ARGV[0] =~ /:/ || $ARGV[1] =~ /:/)) ||
	($opt{o} && ($ARGV[0] =~ /^\d+$/ || $ARGV[1] =~ /^\d+$/))) {
	if (! $opt{f}) {
	    tberror "pid/eid reqired!";
	    exit(usage());
	}
	$pid = VLAN_PID();
	$eid = VLAN_EID();
	print "Using internal experiment $pid/$eid for operations\n";
    }
    else {
	($pid, $eid) = (shift @ARGV, shift @ARGV);
    }
}
if ($opt{'syncvlans'} || $opt{l} || $opt{F}) {
    $pid = VLAN_PID();
    $eid = VLAN_EID();
    print "Using internal experiment $pid/$eid for operations\n";
}
if ($opt{t} || $opt{r} || $opt{D} || $opt{R} || $opt{X} ||
    $opt{A} || ($opt{C} && !$opt{o})) {
    #
    # Options that take 'pid eid'
    #
    if (!defined($pid)) {
	if (@ARGV < 2) {
	    tberror "pid/eid reqired!";
	    exit &usage;
	} else {
	    ($pid, $eid) = (shift @ARGV, shift @ARGV);
	}
    }
    if (@ARGV) {
	if ($opt{A} || ($opt{C} && !($opt{r} || $opt{o}))) {
	    # Allow a comma separated list of tags per lan.
	    foreach my $arg (@ARGV) {
		if ($arg =~ /^[-\w]*,\d*/) {
		    my @tmp = split(',', $arg);
		    my $id  = shift(@tmp);
		    push(@optvlanids, $id);
		    $optvlantags{$id} = \@tmp;
		}
		else {
		    push(@optvlanids, $arg);
		}
	    }
	}
	else {
	    @optvlanids = @ARGV;
	}
    }
} elsif ($opt{d} || $opt{e} || $opt{a} || $opt{p} || $opt{u} || $opt{m}
         || $opt{U} || $opt{b}) {
    #
    # Options that take a list of ports
    #
    @ports = @ARGV;
} elsif ($opt{T} || $opt{E}) {
    #
    # Options that take both a port and a list of VLANs - we require at least
    # one VLAN to be given
    #
    if ($opt{E}) { $opt{T} = $opt{E}; $equaltrunking = 1;}
    elsif (!@ARGV) {
	tberror "At least one VLAN required";
	exit &usage;
    }
    @optvlanids = @ARGV;

    #
    # Set the @ports array so that we'll do proper permission checking on it
    #
    @ports = ($opt{T});
} elsif ($opt{'setvlanontrunks'} || $opt{'resetvlanontrunks'} ||
         $opt{'clearvlanontrunks'} || $opt{'deletestalevlans'}) {
    if (!@ARGV) {
	tberror "At least one VLAN required";
	exit &usage;
    }
    @optvlanids = @ARGV;

} elsif ($opt{'of-controller'}) {
    #
    # Options that take the pid eid and connection string
    #
    if (@ARGV < 2) {
	tberror "pid/eid reqired!";
	exit &usage;
    } else {
	($pid, $eid) = (shift @ARGV, shift @ARGV);
    }
    if (@ARGV < 0) {
	tberror "Controller connection string reqired!";
	exit &usage;
    } else {
	$ofconnstr = shift @ARGV;
    }
    $ofconnopt = shift @ARGV
        if (@ARGV);
} elsif ($opt{'of-enable'} || $opt{'of-disable'} || $opt{'of-listener'}) {
    #
    # Options that need pid eid
    #
    if (@ARGV < 1) {
	tberror "pid/eid reqired!";
	exit &usage;
    } else {
	($pid, $eid) = (shift @ARGV, shift @ARGV);
    }    
} else {
    #
    # Everything else
    #
    if (@ARGV) {
	tberror({type => 'primary', severity => SEV_ERROR,
		 error => ['too_many_arguments']},
		"Too many arguments!");
	exit &usage;
    }
}

#
# Save the ports given in command line for future comparison
#
my @optports = @ports;

#
# Determine which operation we're performing. This is just for convenience,
# so that we can use switch-like constructs later. While we're at it, we
# pull out any arguments that were given in the $opt{} values.
#
my @commands;

#
# Simple commands
#
if ($opt{l}) { push @commands, ["listvlans"]; }
if ($opt{L}) { push @commands, ["listvlans"]; }
if ($opt{s}) { push @commands, ["listports"]; }
if ($opt{g}) { push @commands, ["getstats"]; }
if ($opt{t}) { push @commands, ["tables"]; }
if ($opt{r}) { push @commands, ["reset"]; }
if ($opt{X}) { push @commands, ["synctables"]; }
if ($opt{c}) { push @commands, ["recreate"]; }
if ($opt{U}) { push @commands, ["trunkdisable"]; }
if ($opt{b}) { push @commands, ["portstatus"]; }
if ($opt{F}) { push @commands, ["synchleader"]; }
if ($opt{A}) { push @commands, ["reservetags"]; }
if ($opt{'syncvlans'}) { push @commands, ["syncvlans"]; }
if ($opt{'prunestalevlans'}) { push @commands, ["prunestalevlans"]; }
if ($opt{'setvlanontrunks'}) { push @commands, ["setvlanontrunks"]; }
if ($opt{'resetvlanontrunks'}) { push @commands, ["resetvlanontrunks"]; }
if ($opt{'clearvlanontrunks'}) { push @commands, ["clearvlanontrunks"]; }
if ($opt{'deletestalevlans'}) { push @commands, ["deletestalevlans"]; }

# This option combines with reset/remove
if ($opt{C} && !($opt{r} || $opt{o})) { push @commands, ["unreservetags"]; }

#
# Commands that can appear once, and take an argument
#
if ($opt{d}) { push @commands, ["portcontrol","disable"]; }
if ($opt{e}) { push @commands, ["portcontrol","enable"]; }
if ($opt{a}) { push @commands, ["portcontrol","auto"]; }
if ($opt{D}) { push @commands, ["expcnetcontrol", "disable"]; }
if ($opt{R}) { push @commands, ["expcnetcontrol", "enable"]; }
if ($opt{T}) { push @commands, ["trunkenable", $opt{T}]; }
if ($opt{'of-enable'}) { push @commands, ["ofenable", $opt{'of-enable'}]; }
if ($opt{'of-disable'}) { push @commands, ["ofdisable", $opt{'of-disable'}]; }
if ($opt{'of-controller'}) { push @commands, ["ofcontroller", $opt{'of-controller'}]; }
if ($opt{'of-listener'}) { push @commands, ["oflistener", $opt{'of-listener'}]; }

#
# Commands that can occur more than once
#
if ($opt{m}) {
    foreach my $name (@{$opt{m}}) {
	push @commands, ["make",$name];
    }
}

if ($opt{o}) {
    foreach my $name (@{$opt{o}}) {
	push @commands, ["remove",$name];
    }
}

if ($opt{N}) {
    foreach my $name (@{$opt{N}}) {
	push @commands, ["vlannumber",$name];
    }
}

if ($opt{B}) {
    foreach my $statstring (@{$opt{B}}) {
	push @commands, ["restorestatus",$statstring];
        # Set up the @ports variable so that we get permissions checking. Note,
        # though, that we re-parse the strings again later, this is just for
        # permissions
        my %args = parseStatusString($statstring);
        if (!$args{port}) {
            tbdie "No port given in status string";
        }
        if ($args{port}) {
            push @ports, convertPortsFromStrings($optdev, $args{port});
        }
    }
    @optports = @ports;
}

#
# Commands that require 'translation' of their arguments
#
if ($opt{p}) {
    #
    # We'll put the argument in the form needed by the portControl function
    #
    if ($opt{p} =~ /^1000/) {
	push @commands, ["portcontrol","1000mbit"];
    } elsif ($opt{p} =~ /^100/) {
	push @commands, ["portcontrol","100mbit"];
    } elsif ($opt{p} =~ /^10/) {
	push @commands, ["portcontrol","10mbit"];
    } else {
	tbreport(SEV_ERROR, 'bad_data', 'port_speed', $opt{p});
	die "Bad port speed: $opt{p}. Valid values are 10, 100, and 1000\n";
    }
}
if ($opt{u}) {
    #
    # We'll put the argument in the form needed by the portControl function
    #
    if ($opt{u} =~ /half/) {
	push @commands, ["portcontrol","half"];
    } elsif ($opt{u} =~ /full/) {
	push @commands, ["portcontrol","full"];
    } else {
	die "Bad port duplex: $opt{u}. Valid values are full and half\n";
    }
}

#
# If this is an operation on an experiment, make sure that they have permission
# to modify that experiment
#
if ($pid && $eid) {
    #
    # First, make sure the experiment exists
    #
    $experiment = Experiment->Lookup($pid,$eid);
    if (!defined($experiment)) {
	die "There is no experiment $eid in project $pid\n";
    }
    # XXX Do not make this check when -f is used; called in user context.
    if (defined($this_user) && !$opt{f} && 
	!$experiment->AccessCheck($this_user, TB_EXPT_MODIFY)) {
	die "You do not have permission to modify experiment $pid/$eid\n";
    }
}

if (!@commands) {
    tbreport(SEV_ERROR, 'no_operation');
    die "No operation given\n";
}

#
# Options that affect other commands
#

#
# User-supplied switch lists
#

# See if we should we flip the behavior of -S and -i ?
my $skip_supplied = 0;
if ($opt{'skip-supplied'} && $opt{S}) {
    $skip_supplied = 1;
}

my @supplied_switches = ();
my @supplied_stacks   = ();
my $supplied_switches = 0; # Whether -i or -S was given
if ($opt{i}) {
    $supplied_switches = 1;
    #
    # Lets allow a comma separated list too. 
    #
    foreach my $arg (@{$opt{i}}) {
	my @tokens = split(",", $arg);
	push @supplied_switches, @tokens;
    }
}
if ($opt{S}) {
    foreach my $stack (@{$opt{S}}) {
	if ($ELABINELAB) {
	    # We are going to pass the stack argument through in the rpc call.
	    push(@supplied_stacks, $stack);
	}
	else {
	    $supplied_switches = 1;
	    my @switches = getSwitchesInStack($stack);
	    if (@switches) {
		push @supplied_stacks, $stack;
		push @supplied_switches, @switches;
	    } else {
		tbdie({type => 'primary', severity => SEV_ERROR,
		       error => ['invalid_switch_stack', $stack]},
		      "No such switch stack: $stack");
	    }
	}
    }
}
@supplied_switches = uniq(@supplied_switches);
@supplied_stacks   = uniq(@supplied_stacks);

#
# Arguments for making private VLANs
#
# Build up a list of extra arguments to be passed to createVlan()
my %pvlanArgs = ();
if ($opt{y}) {
    #
    # Make sure the private VLAN type they gave is valid, and make sure they
    # gave the other required arugments for certain types
    #
    if ($opt{y} ne "primary" && $opt{y} ne "isolated" &&
	$opt{y} ne "community") {
	die "Unknown private VLAN type $opt{y}\n";
    }
    $pvlanArgs{"pvtype"} = $opt{y};
    if ($opt{y} ne "primary") {
	if (!$opt{x} || !$opt{z}) {
	    tberror "-x and -z must be given when -y is $opt{y}!";
	    exit &usage;
	}
	#
	# Fix up ports given in the module/port format, like we do below for
	# ports from @ARGV
	#
	my ($c, $p) = Port->ParseCardPortString($opt{z});
	if (defined($c) && defined($p)) {
	    if (defined($optdev)) {
		$opt{z} = Port->Triple2Iface(Port->Tokens2TripleString($optdev, $c, $p));
		if (!defined($opt{z})) {
		    tbdie "Port $c:$p not found";
		}
	    } else {
		tbdie "The module/port format is only legal if exactly one -i " .
		    "argument has been given";
	    }
	}
	$pvlanArgs{"pvprimary"} = $opt{x};
	$pvlanArgs{"pvport"} = $opt{z};
    }
}

######################################################################
# Step 3 - Set up the stack objects
#
# Determine which devices to talk to, and make the appropriate
# stack objects
######################################################################

#
# If their operation involves a set of ports, make sure that the caller has
# access to the nodes that the ports are on
#
# Convert ports into the correct format
if (@ports) {	
    @ports = convertPortsFromStrings($optdev, @ports);
    if (scalar(@optports) != scalar(@ports)) {
	die "Bad format for ports: ".join(" ", @optports)."\n";
    }
}

if (@ports) {
    #
    # Allow ports to be given in one of two forms: node:port, or switch.port.
    # Only admins can do the latter, of course...
    #

    my @pcports = grep {!$_->is_switch_side()} @ports;
    my @nodes = map {$_->node_id()} @pcports;
    my @switchports = grep {$_->is_switch_side()} @ports;

    if (@pcports + @switchports != @ports) {
	tbreport(SEV_ERROR, 'bad_data', 'port', join(" ", @optports));
	die "Bad format for port ".join(" ", @optports)."\n";
    }

    if ($UID && !TBNodeAccessCheck($UID,TB_NODEACCESS_MODIFYVLANS,@nodes)) {
	tbreport(SEV_ERROR, 'insufficient_permissions');
	die "You do not have permission to modify some or all of the nodes\n" .
		"that will be affected by the operation you requested\n";
    }

    if (@switchports && !TBAdmin()) {
	die "Only admins are allowed to modify switch ports directly\n";
    }
}

if ($TESTMODE) {
    print "Test mode, exiting without touching hardware\n";
    exit(0);
}

my $exitval = 0;
COMMAND: foreach my $command (@commands) {

    #
    # Pull the operation and the arugments to it.
    #
    my ($operation,@args) = @$command;

    debug("Operation is $operation\n");

    #
    # Discover the set of devices we need to talk to. This differs depending
    # on the operation which we're performing. We also get a list of all ports
    # and vlan IDs involved in this operation, if appropriate. We use this
    # opportunity to bail out of the command if it appears we have no work
    # to do
    #
    my @devicenames;
    my @vlans;
    SWITCH: for ($operation) {
	(/listvlans/ || /getstats/ || /vlannumber/ || /synchleader/ ||
	 /syncvlans/ || /prunestalevlans/) && do {
	    @devicenames = ($supplied_switches && !$skip_supplied)?
			   @supplied_switches : getTestSwitches();
	    last;
	};
	(/listports/) && do {
	    @devicenames = ($supplied_switches && !$skip_supplied)? 
		           @supplied_switches :
			   (@ports? getDeviceNames(@ports) : getTestSwitches());
	    last;
	};
	( /make/ ) && do {
	    my ($vlan_name) = @args;

            if ($supplied_switches && !$skip_supplied) {
                @devicenames = @supplied_switches;
            } elsif (@ports) {
		my $vlanobj;
		if ($vlan_name =~ /^\d*$/) {
		    $vlanobj = VLan->Lookup($vlan_name);
		}
		else {
		    $vlanobj = VLan->Lookup($experiment, $vlan_name);
		}
		if (defined($vlanobj)) {
		    #
		    # Need to know the entire port set, since -m is also
		    # used to add ports to existing vlans.
		    #
		    # All devices needed includes trunks to transit.
		    @devicenames = mapPortsToSwitches(
			snmpit_lib::uniq_ports(getVlanPorts($vlanobj->lanid()),
					       @ports));

		}
		else {
		    # All devices needed includes trunks to transit.
		    @devicenames = mapPortsToSwitches(@ports);
		}
		debug("make: switch list: " . join(",",@devicenames) . "\n");
            } else {
                @devicenames = getTestSwitches();
            }
	    last;
	};
        (/remove/) && do {
            # Three levels of possible sources for device names (in order):
            #   passed in on command line
            #   vlan from the db
            #   if others fail, default to experimental switches
	    my ($vlan_name) = @args;
            if ($supplied_switches && !$skip_supplied) {
                debug("Remove: using supplied switches\n");
                @devicenames = @supplied_switches;
            }
	    else {
		my $vlanobj;
		if ($vlan_name =~ /^\d*$/) {
		    $vlanobj = VLan->Lookup($vlan_name);
		}
		else {
		    $vlanobj = VLan->Lookup($experiment, $vlan_name);
		}
		if (defined($vlanobj) && !$vlanobj->IsInternal()) {
		    @devicenames = mapVlansToSwitches($vlanobj->lanid());
		    debug("Remove: list from database: " . join(",",@devicenames) .
			  "\n");
		}
            }
            if (scalar(@devicenames == 0)) {
                debug("Remove: falling back to test swtiches\n");
                @devicenames = getTestSwitches();
            }
            last;
        };
        (/^tables$/ || /^reservetags$/ || /^unreservetags$/) && do {
            # Grab all stacks that any ports in the experiment are members
            # of.
            # (We need the entire stack, since the VLAN may have to traverse
            # devices that don't explicitly have a port in the VLAN.)
            @vlans = getExperimentVlans($pid,$eid,@optvlanids);
            if (!@vlans) {
                print "snmpit: $pid/$eid has no VLANs to create, skipping\n"
		    if (!$quiet);
                next COMMAND;
            }
            if ($supplied_switches && !$skip_supplied) {
                debug("Tables: using supplied switches\n");
                @devicenames = @supplied_switches;
		@vlans = filterVlansBySwitches(\@supplied_switches, @vlans);
		if (!@vlans) {
		    print "snmpit: $pid/$eid has no VLANs to create ".
			"on supplied devices, skipping\n"
			if (!$quiet);
		    next COMMAND;
		}
            } else {
                @devicenames = mapVlansToSwitches(@vlans);
                debug("Tables: list from database: " . join(",",@devicenames) .
		      "\n");
            }
            if ($skip_supplied) {
                debug("Tables: skipping supplied switches\n");
		@devicenames = filterList(\@devicenames,\@supplied_switches);
		@vlans = filterVlansBySwitches(\@devicenames, @vlans);
		if (!@devicenames || !@vlans) {
		    print "snmpit: $pid/$eid has no VLANs to create ".
			"on skip-filtered device list, skipping\n"
			if (!$quiet);
		    next COMMAND;
		}
            }
            if (scalar(@devicenames == 0)) {
                debug("Tables: falling back to test swtiches\n");
                @devicenames = getTestSwitches();
            }
            last;
        };
	(/resetvlanontrunks/ || /setvlanontrunks/ || /clearvlanontrunks/) && do {
	    @devicenames = ($supplied_switches && !$skip_supplied)?
			   @supplied_switches : getTestSwitches();
	    @vlans = @optvlanids;
	    last;
	};
	(/deletestalevlans/) && do {
	    if (!$supplied_switches) {
                print "snmpit: deletestalevlans requires -i option\n"
		    if (!$quiet);
                next COMMAND;
            }
	    if ($skip_supplied) {
                print "snmpit: deletestalevlans skip-supplied not allowed\n"
		    if (!$quiet);
                next COMMAND;
            }
	    @devicenames = @supplied_switches;
	    @vlans = @optvlanids;
	    last;
	};
	(/reset/) && do {
	    #
            # We operate on all stacks that we have recorded as having VLANs
            # that belong to this experiment.
	    #
	    @vlans = getExperimentVlans($pid,$eid,@optvlanids);
            if (!@vlans) {
                print "snmpit: $pid/$eid has no VLANs, skipping\n"
		    if (!$quiet);
                next COMMAND;
            }
	    if ($ELABINELAB) {
		#
		# Do not worry about the local state. Always go to outer
		# boss to make sure that the vlans are removed.
		#
		@devicenames = getTestSwitches();
		last;
	    }
            @vlans = filterPlannedVlans(@vlans);
            if (!@vlans) {
                print "snmpit: $pid/$eid has VLANs, but none have been " .
                    "created on switches\n  ... skipping\n";
                next COMMAND;
            }
            if ($supplied_switches && !$skip_supplied) {
                debug("Reset: using supplied switches\n");
                @devicenames = @supplied_switches;
		@vlans = filterVlansBySwitches(\@supplied_switches, @vlans);
		if (!@vlans) {
		    print "snmpit: $pid/$eid has no VLANs to reset ".
			"on supplied devices, skipping\n"
			if (!$quiet);
		    next COMMAND;
		}
            } else {
                @devicenames = mapVlansToSwitches(@vlans);
                debug("Reset: list from database: " . join(",",@devicenames) .
                    "\n");
            }

            if ($skip_supplied) {
                debug("Reset: skipping supplied switches\n");
		@devicenames = filterList(\@devicenames,\@supplied_switches);
		@vlans = filterVlansBySwitches(\@devicenames, @vlans);
		if (!@devicenames || !@vlans) {
		    print "snmpit: $pid/$eid has no VLANs to reset ".
			"on skip-filtered device list, skipping\n"
			if (!$quiet);
		    next COMMAND;
		}
            }

            # Fallthrough - if we haven't found any switches yet, operate
            # on the whole experimetnal net
            if (scalar(@devicenames) == 0) {
                debug("Reset: falling back to test swtiches\n");
                @devicenames = getTestSwitches();
            }
	    last;
	};
	(/synctables/) && do {
            # We operate on all stacks on which we think VLANs do, or should,
            # exist.
	    my @oldvlans = ();
	    @vlans = getExperimentVlans($pid,$eid,@optvlanids);
	    
	    if (!@optvlanids) {
		VLan->StaleVlanList($experiment,\@oldvlans);
	    }

	    #
	    # No old or new vlans, then skip all of this. 
	    #
	    if (! (@vlans || @oldvlans)) {
                print "snmpit: $pid/$eid has no old or new VLANs ... ".
		    "skipping\n";
                next COMMAND;
	    }

            if ($supplied_switches && !$skip_supplied && $opt{"i"}) {
		die("-X and -i cannot be used together\n");
            }
	    else {
                @devicenames = uniq(mapVlansToSwitches(@vlans),
				    mapStaleVlansToSwitches(@oldvlans));
                debug("Sync: list from database: " . join(",",@devicenames) .
		      "\n");
            }

            if ($skip_supplied) {
                debug("Sync: skipping supplied switches (dangerous!)\n");
		@devicenames = filterList(\@devicenames,\@supplied_switches);
		@vlans = filterVlansBySwitches(\@devicenames, @vlans);
		if (!@devicenames || !@vlans) {
		    print "snmpit: $pid/$eid has no VLANs to sync ".
			"on skip-filtered device list, skipping\n"
			if (!$quiet);
		    next COMMAND;
		}
            }

            # Fallthrough - if we haven't found any switches yet, operate
            # on the whole experimental net
            if (scalar(@devicenames) == 0) {
                debug("Reset: falling back to test swtiches\n");
                @devicenames = getTestSwitches();
            }
	    last;
	};
	(/portcontrol/ || /trunkdisable/ || /portstatus/) && do {
	    @devicenames = ($supplied_switches && !$skip_supplied)?
	    		   @supplied_switches : getDeviceNames(@ports);
	    last;
	};
	(/expcnetcontrol/) && do {
	    @ports = getExperimentControlPorts($pid, $eid);
	    @devicenames = getDeviceNames(@ports);
	};
	(/recreate/) && do {
	    #
	    # Safety check - cannot be used with -i . We have to operate on
	    # all experimental switches
	    #
	    if ($supplied_switches && !$skip_supplied) {
		die "-c and -i or -S cannot be used together\n";
	    }
	    @devicenames = getTestSwitches();
	    last;
	};
	(/trunkenable/) && do {
	    @devicenames = ($supplied_switches && !$skip_supplied)?
	    		   @supplied_switches : getDeviceNames(@ports);
	    @vlans = @optvlanids;
	    last;
	};
        (/restorestatus/) && do {
            # We start by parsing out the options string, then we'll reset
            # @args
            my ($statusarg) = @args;
            my %args = parseStatusString($statusarg);
            if (!$args{port}) {
                tbdie "No port given in status string";
            }
            @ports = convertPortsFromStrings($optdev, $args{port}); 
            if ($args{vlan}) {
                @vlans = ($args{vlan});
            }
	    @devicenames = ($supplied_switches && !$skip_supplied)?
		           @supplied_switches : getDeviceNames(@ports);
            @args = %args;
            last;
        };
	(/ofenable/ || /ofdisable/ || /ofcontroller/ || /oflistener/) && do {
	    my ($vlan_name) = @args;
	    my ($vlanobj, $stack);
	    if ($vlan_name =~ /^\d*$/) {
		$vlanobj = VLan->Lookup($vlan_name);
	    }
	    else {
		$vlanobj = VLan->Lookup($experiment, $vlan_name);
	    }
	    if (!defined($vlanobj)) {
		print STDERR "No such vlan '$vlan_name' in $experiment\n";
		next COMMAND;
	    }
	    @vlans = ($vlanobj->id());
	    
            if ($supplied_switches && !$skip_supplied) {
                debug("Openflow operations: using supplied switches\n");
                @devicenames = @supplied_switches;
            }
	    elsif (defined($stack = $vlanobj->GetStack())) {
                debug("Openflow operations: found stack $stack in database\n");
                @devicenames = getSwitchesInStack($stack);
            } else {
                debug("Openflow operations: using test switches\n");
                @devicenames = getTestSwitches();
            }
	    last;
	};
    }

    #
    # No matter what operation we're doing, we're safe to filter the 
    # devicenames list now!
    #
    @devicenames = filterList(\@devicenames,\@supplied_switches)
        if ($skip_supplied);

    debug("Device names: " . join(",",@devicenames) . "\n");
    debug("Ports: " . join(",", map($_->toIfaceString(), @ports)) . "\n");

    #
    # Order the vlans using the dependency information in the link field.
    #
    if (@vlans && ($opt{m} || $opt{t})) {
	my %vlans    = ();
 	my @newvlans = ();
 	my %newvlans = ();

	foreach my $vlanid (@vlans) {
	    #
	    # Lookup the vlan, but only numeric ones. Named vlans are
	    # special and not something we need to worry about here. 
	    #
	    if (! ($vlanid =~ /^\d*$/)) {
		push(@newvlans, $vlanid);
		next;
	    }
	    my $vlan = VLan->Lookup($vlanid);
	    if (!defined($vlan)) {
		# Bad.
		die("Cannot lookup vlan $vlanid\n");
	    }
	    $vlans{$vlanid} = $vlan;
	}
 	#
 	# The "link" field in the vlan points to the vlan it is dependent
 	# on. So, we actually build up the list in reverse order, and then
 	# flip it around at the end. 
 	#
	while (@vlans) {
	    my @tmp = ();
	    foreach my $vlanid (@vlans) {
		my $vlan = $vlans{$vlanid};

		if (!$vlan->link() ||
		    exists($newvlans{$vlan->link()}) ||
		    !exists($vlans{$vlan->link()})) {
		    push(@newvlans, $vlanid);
		    $newvlans{$vlanid} = $vlanid;
		}
		else {
		    push(@tmp, $vlanid);
		}
	    }
	    @vlans = @tmp;
	}
 	@vlans = reverse(@newvlans);
 	debug("VLANs: " . join(",",@vlans) . "\n");
    }

    my %stacks = ();
    if (! $ELABINELAB) {
	#
	# Map all the devices to stacks.
	#
	foreach my $devicename (@devicenames) {
	    my $stack = getSwitchPrimaryStack($devicename);
	    if (defined($stack)) {
		push @{$stacks{$stack}}, $devicename;
	    }
	}
    }

    #
    # Now, make the object for each stack that we discovered
    #
    my @stacks;
    %stack_ids = ();
    foreach my $stack_id (keys %stacks) {
	my ($stack_type, $supports_private, $single_domain, $community)
		= getStackType($stack_id);
	#
	# Safety check - make sure the stack supports private VLANs if -y was
	# given
	#
	if ($opt{y} && !$supports_private) {
	    die "Switch stack $stack_id does not support private VLANs\n";
	}

	my $stack;
	debug("Stack $stack_id has type $stack_type\n");
	SWITCH: for ($stack_type) {
	    (/cisco/ || /catalyst/) && do {
		require snmpit_cisco_stack;
		$stack = new snmpit_cisco_stack($stack_id,$debug,$single_domain,
 						@{$stacks{$stack_id}});
		last;
	    }; # /cisco/
	    /intel/ && do {
		require snmpit_intel_stack;
		$stack = new snmpit_intel_stack($stack_id,$debug,
						@{$stacks{$stack_id}});
		last;
	    };
	    /generic/ && do {
		require snmpit_stack;
		$stack = new snmpit_stack($stack_id,$debug,
					  @{$stacks{$stack_id}});
		last;
	    }; # /generic/

	    # 'default' case
	    die "Unknown stack type $stack_type for stack $stack_id\n";
	}

	#
	# Check for error in object creation and bail
	#
	if (!$stack) {
	    die "Unable to connect to one or more switches, exiting\n";
	} else {
	    push @stacks, $stack;
	    $stack_ids{$stack_id} = $stack;
	}
    }


    #
    # If we were given ports, make sure that the stack(s) that got created
    # cover all of them
    #
    if (@ports && !$ELABINELAB) {
	my %devicemap = mapPortsToDevices(@ports);
	my @devices = keys %devicemap;
	foreach my $device (@devices) {
	    my @stack_ids = getSwitchStacks($device);
	    my $matched = 0;
	    foreach my $stack_id (@stack_ids) {
		if ($stack_id && $stack_ids{$stack_id}) {
		    $matched = 1;
		}
	    }
	    if (!$matched) {
		tbdie({type => 'primary', severity => SEV_ERROR,
		       error => ['device_not_in_stack', $device]},
		      "One or more ports are on $device, but no " .
		      "stack containing it was specified!");
	    }
	}
    }
    if ($ELABINELAB) {
	#
	# Okay, now that we skipped all that stack stuff ...
	#
	@stacks = @supplied_stacks;
    }

######################################################################
# Step 4 - Actually perfrom the operation
#
# Finally, we just call the helper function for the operation that
# is to be performed.
######################################################################
    if ($opt{n}) {
	print "Test mode, skipping operation\n";
	next;
    }

    SWITCH: for ($operation) {
	/listvlans/ && do {
	    $exitval += doListVlans(\@stacks);
	    last;
	}; # /listvlans/ && do 
	/synchleader/ && do {
	    $exitval += doSynchLeader(\@stacks);
	    last;
	}; # /listvlans/ && do 
	/syncvlans/ && do {
	    $exitval += doSyncVlansWithDB(\@stacks);
	    last;
	}; # /listvlans/ && do 
	/prunestalevlans/ && do {
	    $exitval += doPruneStaleVlans(\@stacks);
	    last;
	}; # /listvlans/ && do 
	/listports/ && do {
	    $exitval += doListPorts(\@stacks);
	    last;
	}; # /listports/ && do
	/getstats/ && do {
	    $exitval += doGetStats(\@stacks);
	    last;
	}; # /ports/ && do
	/^tables$/ && do {
	    $exitval += doVlansFromTables($experiment,\@stacks,@vlans);
	    last;
	}; # /tables/ && do
	/^reservetags$/ && do {
	    $exitval += doReserveVlanTags($experiment,\@stacks,@vlans);
	    last;
	}; # /reservetags/ && do
	/^unreservetags$/ && do {
	    $exitval += doUnReserveVlanTags($experiment,\@stacks,@vlans);
	    last;
	}; # /reservetags/ && do
	/synctables/ && do {
	    $exitval += syncVlansFromTables($experiment,\@stacks,@vlans);
	    last;
	}; # /tables/ && do
	(/setvlanontrunks/ || /resetvlanontrunks/ || /clearvlanontrunks/) && do {
	    $exitval +=
		doSetVlanOnTrunks(\@stacks, $operation, @vlans);
	    last;
	}; # /trunkenable/ && do
	(/deletestalevlans/) && do {
	    $exitval += doDeleteStaleVlansFromDevices(\@stacks, @vlans);
	    last;
	}; # /trunkenable/ && do
	/reset/ && do {
	    $exitval += doReset(\@stacks,@vlans);
	    last;
	};
	/make/ && do {
	    my ($vlan_name) = @args;
	    $exitval += doMakeVlan(\@stacks,$vlan_name,@ports);
	    last;
	};
	/remove/ && do {
	    my ($vlan_name) = @args;
	    $exitval += doDeleteVlan(\@stacks,$vlan_name);
	    last;
	};
	/portcontrol/ && do {
	    my ($portcommand) = @args;
	    $exitval += doPortControl(\@stacks,$portcommand,@ports);
	    last;
	};
	/expcnetcontrol/ && do {
	    my ($portcommand) = @args;
	    $exitval += doPortControl(\@stacks,$portcommand,@ports);
	    last;
	};
	/recreate/ && do {
	    $exitval += doRecreateVlans(\@stacks);
	    last;
	};
	/trunkenable/ && do {
	    $exitval += doTrunkEnable(\@stacks,$ports[0],
				      $equaltrunking,@vlans);
	    last;
	}; # /trunkenable/ && do
	/trunkdisable/ && do {
	    $exitval += doTrunkDisable(\@stacks,$ports[0]);
	    last;
	}; # /trunkdisable/ && do
	/portstatus/ && do {
	    $exitval += doPortStatus(\@stacks,@ports);
	    last;
	}; # /portstatus/ && do
	/vlannumber/ && do {
	    my ($vlan_name) = @args;
	    $exitval += doVlanNumber(\@stacks,$vlan_name);
	    last;
	}; # /portstatus/ && do
	/restorestatus/ && do {
	    $exitval += doRestorePortStatus(\@stacks,@args);
	    last;
	}; # /portstatus/ && do
	(/ofenable/) && do {
	    $exitval += doOpenflowEnable(\@stacks,$vlans[0]);
	    last;
	}; # /ofenable/ && do
	(/ofdisable/) && do {
	    $exitval += doOpenflowDisable(\@stacks,$vlans[0]);
	    last;
	}; # /ofdisable/ && do
	(/ofcontroller/) && do {
	    $exitval += doSetOpenflowController(\@stacks,$vlans[0],
						$ofconnstr, $ofconnopt);
	    last;
	}; # /ofcontroller/ && do
	(/oflistener/) && do {
	    $exitval += doEnableOpenflowListener(\@stacks,$vlans[0]);
	    last;
	}; # /oflistener/ && do
    }
}

exit $exitval;

######################################################################
# Subs
######################################################################

#
# Print given message to STDERR, only if debug mode is on
#
sub debug($) {
    if ($debug) {
	print STDERR @_;
    }
}

#
# Parse a port status string. Returns a key-value hash pair
#
sub parseStatusString($) {
    my ($string) = @_;
    chomp $string;

    my %pairs;
    foreach my $pair (split /;/, $string) {
        my ($key, $value) = split /=/,$pair,2;
        if (!$key || !$value) {
            tbdie "Bad port status string: $string";
        } else {
            $pairs{$key} = $value;
        }
    }

    return %pairs;
}

#
# Lists all vlans on all stacks
#
sub doListVlans ($) {

    my $stacks = shift;
    my %vlans;
    my %tags;
    my $emptyList;
    my @vlanList;

    #
    # We need to 'coallate' the results from each stack by putting together
    # the results from each stack, based on the VLAN identifier
    #
    if ($ELABINELAB) {
        #
        # Sklower deliberately uglified this.  The intent is that eventually
        # $stack->listVlans() will call a $<remotedevobj>->listVlans() and
        # it will just work.  For now, we dup the code.
        #
        @vlanList = RemoteDoList();
        foreach my $vlan (@vlanList) {
            my ($id,$ddep,$memberref) = @$vlan;
            ${$vlans{$id}}[0] = $ddep;
	    $tags{$ddep} = $id;
            push @{${$vlans{$id}}[1]}, @$memberref;
        }
    } else {
        foreach my $stack (@$stacks) {
            @vlanList = $stack->listVlans(\$emptyList);
            foreach my $vlan (@vlanList) {
                my ($id,$ddep,$memberref) = @$vlan;
                ${$vlans{$id}}[0] = $ddep;
		$tags{$ddep} = $id;
                push @{${$vlans{$id}}[1]}, @$memberref;
            }
        }
    }

    #
    # less code to do this for snmpit.proxy than for it to popen snmpit
    # parse the output, and glue it back together.
    #
    if ($opt{L}) {
	my @results;
	foreach my $pair (split ',', $opt{L}) {
	    my ($out,$in) = split "#", $pair;
	    my $vlan = "$in#" . ${$vlans{$out}}[0] . "#";
	    my $memberref = ${$vlans{$out}}[1];
	    if (scalar(@$memberref) > 0 && ref(${$memberref}[0])) {
	    	$vlan = $vlan.Port->toStrings(@$memberref);
	    } else {
	    	$vlan = join(' ', @$memberref);
	    }
	    push @results, $vlan;
	}
	print join(',', @results);
	exit(0);
    }
    #
    # These need to be declared here for the benefit of the format string
    # See perlform(1) for help with formats
    # Note that they are declared 'our' rather than 'my' due to a stupid
    # bug in perl 5.10
    #
    our ($vlan_id,$ddep,$pideid,$vname,$members);

    #
    # Check to see if they want device-specific VLAN numbers, which makes the
    # display more cramped, but is useful for debugging
    #
    if (!$opt{w}) { 
	print << "END";
VLAN     Project/Experiment VName     Members
--------------------------------------------------------------------------------
END
	format vlanlist =
@<<<<<<< @<<<<<<<<<<<<<<<<< @<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$vlan_id,$pideid,           $vname,   $members
~~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                      $members
.
	$FORMAT_NAME = 'vlanlist';
    } else {
    	print << "END";
VLAN     Number   Project/Experiment VName     Members
----------------------------------------------------------------------------------
END
	format vlanlist2 =
@<<<<<<< @<<<<<<< @<<<<<<<<<<<<<<<<< @<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$vlan_id,$ddep, $pideid,           $vname,   $members
~~                                             ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                             $members
.
	$FORMAT_NAME = 'vlanlist2';
    }
    my @sorted = ($opt{w} ?
                  map {$tags{$_}} sort {tbsort($a,$b)} keys %tags :
                  sort {tbsort($a,$b)} keys %vlans);

    foreach my $vid (@sorted) {
        $vlan_id = $vid;
	my $memberref;
        my $vlan;
	($ddep,$memberref) = @{$vlans{$vid}};
	my $empty = (exists($emptyList->{$vlan_id}) ?
		     $emptyList->{$vlan_id} : undef);

	if ($vlan_id =~ /^\d*$/) {
	    $vlan = VLan->Lookup($vlan_id);
	}
	else {
	    #
	    # Watch for oddly named vlans on switches we do not fully
	    # control (say, scidmz in Utah).
	    #
	    $vlan = VLan->Lookup($experiment, $vlan_id);
	}
        if (!defined($vlan)) {
	    print("No such VLAN $vlan_id in lans table\n");
            # Only print unknown VLANs if -l was given twice, or the 
            # -O option was given
	    next unless ($opt{l} > 1 || $opt{O});

            # If only printing orphaned VLANs, consider only ones that have IDs
            # that look like the ones we assign in the database
            if ($opt{O} && $vlan_id !~ /^\d+$/) {
                next;
            }

            # Only admins get to see this. Possibly a silly check.
	    if (!TBAdmin()) {
		&debug("Failed TBAdmin check\n");
		next;
	    }
	    $pideid = "";
            $vname  = $vlan_id;
        }
	else {
            # If only printing orphaned VLANs, skip ones for which we know the
            # pid and eid
            if ($opt{O}) {
                next;
            }
            my $vlanexp = $vlan->GetExperiment();
	    if (!defined($vlanexp)) {
		$pideid = "UNKNOWN";
		$vname  = "UNKNOWN";
	    }
            else {
                if ($UID && 
		    !$vlanexp->AccessCheck($this_user, TB_EXPT_READINFO)) {
                    &debug("$this_user failed access check to $experiment\n");
                    next;
                 }
   	         # Setup $pideid for a more compact display
                 $pideid = $vlan->pid() . "/" . $vlan->eid();
                 $vname  = $vlan->vname();
	    }
	}

	#
	# Check to see if we were supposed to print out MAC addresses
	#
	if ($opt{M}) {
	    # Rather than node:port, print out node:MAC (if we know the MAC)
	    if (scalar(@$memberref) > 0 && ref(${$memberref}[0])) { 
	    	$members = join(" ", map
		    {
			$_->mac()? $_->node_id().":".$_->mac():$_->toString()
		    } @$memberref);
	    } else {		
	    	my @ptobjs = map {Port->LookupByStringForced($_)} @$memberref;
	    	 
	    	$members = join(" ", map
		{
		    defined($_)?($_->mac()? $_->node_id().":".$_->mac():$_->toString()):""		    
		} @ptobjs);
	    }
	} else {
	    if (scalar(@$memberref) > 0 && ref(${$memberref}[0])) { 
	    	$members = Port->toStrings(@$memberref); 
	    } else {
	    	$members = join(" ",@$memberref);
	    }
	    if (defined($empty)) {
		$members .= " " . join(" ", @{$empty});
	    }
	}
	write;
    }

    return 0;
}

#
# This routine does a number of illegal things.  It is used
# to make sure the leader of a stack contains all vlans on all switches
# in the stack and is only useful for moving a stack back and forth
# between types "cisco" and "generic" (where $stack->{ALLVLANSONLEADER} must be
# set to 1.
#
sub doSynchLeader ($) {

    my $stacks = shift;
    my $errors = 0;
    if (!TBAdmin()) {
	die "Only admins are allowed to synchronize stacks\n";
    }

    foreach my $stack (@$stacks) {
	my $leader = $stack->{LEADER};
	my %vlans = $stack->findVlans();
	while (my ($id,$num) = each %vlans) {
	    my $vlan;
	    
	    if ($id =~ /^\d*$/) {
		$vlan = VLan->Lookup($id);
	    }
	    else {
		$vlan = VLan->Lookup($experiment, $id);
	    }
	    if (!defined($vlan)) {
		print "Skipping $id/$num cause it is not in the DB\n";
		$errors++;
		next;
	    }
	    
	    if (($num >= $leader->{MIN_VLAN}) &&
		($num <= $leader->{MAX_VLAN}) &&
		!($leader->vlanNumberExists($num))) {
		$errors += $leader->createVlan($id, $vlan->lanid(), $num);
	    }
	}
    }
    return $errors;
}

#
# Lists all ports on all stacks
#
sub doListPorts($) {

    my $stacks = shift;

    #
    # Get a listing from all stacks
    #
    my @portList = ();
    foreach my $stack (@$stacks) {
	push @portList, $stack->listPorts;
    }

    #
    # See perlform(1) for help with formats
    #
    our ($port,$enabled,$up,$speed,$duplex);
    print << "END";
Port              Enabled Up   Speed      Duplex
------------------------------------------------
END
# make port field much longer because we use the 'triple' format of port string
    format portlist =
@<<<<<<<<<<<<<<<< @<<<<<< @<<< @<<<<<<<<< @<<<<<<<<<
$port,$enabled,$up,$speed,$duplex
.
    $FORMAT_NAME = 'portlist';
    foreach my $line (sort {tbsort($$a[0],$$b[0])} @portList) {
	($port,$enabled,$up,$speed,$duplex) = @$line;
	#
	# Only let people see information about ports in their experiments
	#
	#$port =~ /^(.+):/;
	my $node = $port->node_id();
	$port = $port->toString();

	&debug("node is $node\n");
	if (!$node) {
	    if (!TBAdmin($UID)) {
		next;
	    }
	} elsif ($UID && !TBNodeAccessCheck($UID,TB_NODEACCESS_READINFO,$node)) {
	    next;
	}
	write;
    }

    return 0;
}

#
# Get information on a particular port - the idea is that this string can later
# be passed back to us to restore the status of the port.
# This is inefficient, because it gets information about all ports and only
# uses it for one (or a few). BUT, it doesn't require changes to the
# vendor-specific modules, so I think it's worth it for portability.
#
sub doPortStatus($@) {

    my $stacks = shift;
    my @port = @_;

    my $errors = 0;

    #
    # Get a listing from all stacks
    #
    my @portList = ();
    foreach my $stack (@$stacks) {
	push @portList, $stack->listPorts;
    }

    #
    # Find the port(s) we're looking for in the portlist
    #
    my %ports = ();
    foreach my $port (@ports) {
        $ports{$port->toString()} = undef;
    }
    foreach my $portrecord (@portList) {
	my ($port,$enabled,$up,$speed,$duplex) = @$portrecord;
        if (exists $ports{$port->toString()}) {
            $ports{$port->toString()} = "enabled=$enabled";
            $ports{$port->toString()} .= ";speed=$speed";
            if ($speed ne "autoDetect") {
                $ports{$port->toString()} .= ";duplex=$duplex";
            }
        }
    }

    #
    # Now find out what VLAN it's in
    #
    foreach my $stack (@$stacks) {
	my @vlanList = $stack->listVlans();
	foreach my $vlan (@vlanList) {
	    my ($id,$ddep,$memberref) = @$vlan;
            # Now we have to look through the memberref for our ports
            foreach my $port (@$memberref) {
                if ($ports{$port->toString()}) {
                    $ports{$port->toString()} .= ";vlan=$id";
                }
            }
	}
    }

    #
    # XXX - This is gonna be a mess if the port is a trunk port, or otherwise
    # somehow more complicated. For now, we just ignore this, I guess
    #

    #
    # Check to see if we missed any
    #
    foreach my $port (keys %ports) {
        if (!$ports{$port}) {
	    tberror({type => 'primary', severity => SEV_ERROR,
		     error => ['get_port_status_failed', $port]},
		    "Unable to get status information for $port!");
            $errors++;
        } else {
            print "port=$port;$ports{$port}\n";
        }
    }

    if ($errors) {
        return $errors;
    }

}

#
# Restore port status. Takes a single argument, which is an array that will be
# turned back into a param hash
#
sub doRestorePortStatus($@) {

    my $stacks = shift;
    my %params = @_; # Yes, this does work
    my $errors = 0;

    my $port = $params{port};
    if (!$port) {
        tbdie "No port passed to -B option";
    }
    
    if (!ref($port)) {
	    my $tport = convertPortFromString($port);
	    if ($tport) {
		    $port = $tport;
	    } else {
		    die "Port $port does not exist!\n";
	    }
    }

    if (@$stacks > 1) {
	die "Port restoration across multiple stacks is not yet supported\n" .
	    "Stacks are " . join(", ",map {$_->{STACKID}} @$stacks) . "\n";
    }
    my ($stack) = @$stacks;

    #
    # See where the port is; might be in the default vlan in which case it is
    # not technically in a vlan.
    #
    my $source_vlan = VLan->FindVlanByPort(undef, $port);
    my $target_vlan;

    #
    # Put the port in the specified VLAN
    # If they didn't give us a VLAN, we assume that means they want it removed
    # from its vlan and put into the default vlan.
    #
    my $vlan_id = $params{vlan};
    if ($vlan_id) {
	$target_vlan = VLan->Lookup($vlan_id);
	if (!defined($target_vlan)) {
            tbwarn "No such vlan in the DB: $vlan_id\n";
	    return 1;
	}
    }
    else {
	$vlan_id = "default";
    }
    print "Putting port in VLAN ...\n"
	if (!$quiet);
    $errors += $stack->setPortVlan($vlan_id, $port);
    if ($errors) { return $errors; }

    #
    # Do not worry about mucking with the switch trunk paths.
    # This call exists to temporarily move ports back and forth.
    #
    if (defined($source_vlan) && $source_vlan->KeepInSync()) {
	if ($source_vlan->DelPort($port)) {
	    print "Could not yank $port from $source_vlan\n";
	    $errors++;
	}
	if (VLan->RecordVlanInsertion($source_vlan->id(), $stack->{STACKID})){
	    print "Could not record vlan insertion for $source_vlan\n";
	    $errors++;
	}
    }
    if (defined($target_vlan) && $target_vlan->KeepInSync()) {
	if ($target_vlan->AddPort($port)) {
	    print "Could not add $port to $target_vlan\n";
	    $errors++;
	}
	if (VLan->RecordVlanInsertion($target_vlan->id(), $stack->{STACKID})){
	    print "Could not record vlan insertion for $target_vlan\n";
	    $errors++;
	}
    }

    # Enable or disable the port
    # If they didn't tell us either way, we assume they wanted it disabled
    my $enabled = $params{enabled};
    # If they are putting the port into the default VLAN, force it to be
    # disabled, so that a user cannot use this method to break into that VLAN
    if ($vlan_id eq "default") { $enabled = "no"; }
    if ($enabled eq "yes") {
        $errors = $stack->portControl("enable",$port);
    } else {
        $errors = $stack->portControl("disable",$port);
    }

    #
    # Set the speed and duplex on the port if given
    #
    my $speed = $params{speed};
    if ($speed && $speed ne " ") {
        if ($speed eq "autoDetect") {
            $errors = $stack->portControl("auto",$port);
        } else {
            #
            # Check for a valid speed - convert Mbps to mbit if necessary
            #
            if ($speed =~ /(\d+)(Mbps|mbit)/) {
                $errors = $stack->portControl("${1}mbit",$port);
            } else {
                tbwarn "Bad speed given for ".$port->toString().": $speed";
                $errors++;
            }
        }
    }
    my $duplex = $params{duplex};
    if ($duplex && $duplex ne " ") {
        if ($duplex eq "half") {
            $errors = $stack->portControl("half",$port);
        } elsif ($duplex eq "full") {
            $errors = $stack->portControl("full",$port);
        } else {
            tbwarn "Bad duplex given for ".$port->toString().": $duplex";
            $errors++;
        }
    }
    return $errors;
}

#
# Get statistics for all ports on all stacks
#
sub doGetStats($) {

    my $stacks = shift;

    #
    # Get a listing from all stacks
    #
    my @statList = ();
    foreach my $stack (@$stacks) {
	push @statList, $stack->getStats();
    }

    our ($port, $inoctets, $inunicast, $innunicast, $indiscards, $inerr,
        $inunk, $outoctets, $outunicast, $outnunicast, $outdiscards,
	$outerr,$outq);
    #
    # See perlform(1) for help with formats
    #
    print << "END";
                                 In         InUnicast  InNUnicast In         In         Unknown    Out        OutUnicast OutNUcast  Out       Out         OutQueue
Port                             Octets     Packets    Packets    Discards   Errors     Protocol   Octets     Packets    Packets    Discards  Errors      Length
-------------------------------------------------------------------------------------------------------------------------------------------------
END
    format stats =
@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> 
$port,    $inoctets, $inunicast,$innunicast,$indiscards,$inerr,  $inunk,    $outoctets,$outunicast,$outnunicast,$outdiscards,$outerr,$outq
.
    $FORMAT_NAME = 'stats';
    foreach my $line (sort {tbsort($a,$b)} @statList) {
	($port, $inoctets, $inunicast, $innunicast, $indiscards, $inerr,
	 $inunk, $outoctets, $outunicast, $outnunicast, $outdiscards,
	 $outerr, $outq) = @$line;
	 $port = $port->toString();
	write;
    }

    return 0;
}

#
# Creates all VLANs given. Looks up identifiers in the database to determine
# the membership.
#
sub doVlansFromTables($$@) {
    my $experiment = shift;
    my $stacks  = shift;
    my @vlanids = @_;
    my %vlans   = ();

    my $errors = 0;
    my $vlan_number;

    if (@$stacks > 1) {
	die "VLAN creation across multiple stacks is not yet supported\n" .
	    "Stacks are " . join(", ",map {$_->{STACKID}} @$stacks) . "\n";
    }
    
    #
    # Hand over to outer boss.
    # 
    if ($ELABINELAB) {
	return RemoteDoVlansFromTables($experiment, @vlanids);
    }

    my ($stack) = @$stacks;

#    $debug = 1;
#    $stack->FlipDebug(1);   

    my %trunkedPorts = getExperimentTrunks($experiment->pid(),
					   $experiment->eid(), @vlanids);

    #
    # Look for a lan that requires dual mode trunking. The ports in that
    # lan need to be trunked after the native lan is created, so that we
    # can call doTrunkEnable with dual mode instead of equalmode. This is
    # not a general solution to this, but I have not found a solution I am
    # really happy with. 
    #
    my %dualTrunkPorts = ();
    
    foreach my $id (@vlanids) {
	my $vlan = VLan->Lookup($id);
	if (!defined($vlan)) {
	    die("Could not locate vlan $id in the DB\n");
	}
	$vlans{"$id"} = $vlan;
    }
    
    foreach my $vlan (values(%vlans)) {
	my $vlanid = $vlan->id();
	my $trunk_mode;
	$vlan->GetAttribute("trunk_mode", \$trunk_mode);
	my $trunk_vlanid;
	$vlan->GetAttribute("trunk_vlan", \$trunk_vlanid);

	# This is set in libvtop.
	if (defined($trunk_mode) && $trunk_mode eq "dual") {
	    my @ports = getVlanPorts($vlanid);

	    #
	    # If a specific vlan listed, it must already exist.
	    #
	    if (defined($trunk_vlanid)) {
		my $trunk_vlan = VLan->Lookup($trunk_vlanid);
		if (!defined($trunk_vlan)) {
		    die("Trunk vlanid $trunk_vlanid does not exist\n");
		}
		if (!$trunk_vlan->CreatedOnSwitches()) {
		    die("Trunk vlanid $trunk_vlan is not instantiated\n");
		}
		#
		# To maintain backwards compatibility with how snmpit used
		# to operate, "internal" vlans are sometimes named on the switch
		# by the symbolic name instead of the lanid.
		#
		if ($trunk_vlan->IsInternal() &&
		    !$stack->vlanExists($trunk_vlanid)) {
		    $trunk_vlanid = $trunk_vlan->vname();
		}
		    
		#
		# For each port that has not yet been put into trunk
		# mode, do that using the trunk_vlanid as the native.
		#
		foreach my $port (@ports) {
		    if (!IsPortTagged($port) &&
			doTrunkEnable($stacks,$port,0,$trunk_vlanid)) {
			die("Could not put $port ($trunk_vlan) into ".
			    "dual trunk mode\n");
		    }
		    delete($trunkedPorts{$port->toString()});
		}
		# Now we can create the actual vlan.
		if (CreateOneVlan($experiment,$stack, $vlanid, @ports))  {
		    die("Could not create dual trunked $vlan\n");
		}
	    }
	    else {
		# Create this vlan now.
		if (CreateOneVlan($experiment,$stack, $vlanid, @ports))  {
		    die("Could not create dual trunked $vlan\n");
		}
		# Trunk these ports, removing from list.
		foreach my $port (@ports) {
		    if (doTrunkEnable($stacks,$port,0,$vlanid)) {
			die("Could not port $port ($vlan) into ".
			    "dual trunk mode\n");
		    }
		    delete($trunkedPorts{$port->toString()});
		}
	    }

	    # Delete this vlan from the list that will be created below.
	    delete($vlans{"$vlanid"});
	}
    }
    #
    # Do the rest of the trunked ports in equalmode.
    #
    foreach my $port (values(%trunkedPorts)) {
	$errors += doTrunkEnable($stacks,$port,1);
    }

    #
    # Sanity check: make sure that this experiment does not use more VLANs than
    # we can put on the stack. Note that we don't try to check how many are
    # available (ie. total - used), because getting the 'used' value is not
    # trivial.
    #
    my $leader = getStackLeader($stack->{STACKID});
    if (!defined $leader) {
        tberror "Unable to get stack leader for $stack->{STACKID}";
        return 1;
    }
    my $switch_options = getDeviceOptions($leader);
    if (!defined $switch_options) {
        tberror "Unable to get stack leader for $stack->{STACKID}";
        return 1;
    }
    my $vlan_count = $switch_options->{'max_vlan'} -
                     $switch_options->{'min_vlan'};
    my $expt_vlan_count = scalar(keys(%vlans));
    if ($expt_vlan_count > $vlan_count) {
        tberror "Too many VLANs in experiment: $expt_vlan_count requested, " .
                "$vlan_count available";
        return 1;
    }

    foreach my $vlan (values(%vlans)) {
	my $vlanid = $vlan->id();
	my @ports  = getVlanPorts($vlanid);

	$errors += CreateOneVlan($experiment, $stack, $vlanid, @ports);	
    }
    return $errors;
}

#
# Create a single vlan.
#
sub CreateOneVlan($$$@)
{
    my $experiment = shift();
    my $stack  = shift();
    my $vlanid = shift();
    my @ports  = @_;
    my %otherargs = ();
    my $errors = 0;

    if ($stack->vlanExists($vlanid)) {
	print "  VLAN $vlanid already exists\n"
	    if (!$quiet);

	if ($stack->checkVlanConsistency($vlanid, 1)) {
	    $errors++;
	}
	elsif ($stack->setPortVlan($vlanid,@ports)) {
	    $errors++;
	}
    }
    else {
	#
	# Check and see if OF was requested.  If so, check to make sure
	# all switches in scope support it.  Fail early if not.
	#
	my $vlan = VLan->Lookup($vlanid);
	if (!defined($vlan)) {
	    die("Could not locate vlan $vlanid in the DB\n");
	}
	my $ofenabled;
	$vlan->GetAttribute("ofenabled", \$ofenabled);
	$ofenabled = (defined($ofenabled) && $ofenabled == 1) ? 1 : 0;
	if ($ofenabled) {
	    if (!$stack->isOpenflowSupported(@ports)) {
		tberror({type => 'secondary', severity => SEV_SECONDARY,
			 error => ['create_vlan_failed', $vlanid]},
			"OpenFlow requested for VLAN $vlanid, but ".
			"is not supported on all switches in scope.\n");
		return 1;
	    }
	    $otherargs{"ofenabled"} = 1;
	    # XXX: Some internal calls to snmpit_stack::createVlan()
	    # still need to get special vlan arguments this way.
	    $stack->{VLAN_SPECIALARGS}->{$vlanid}->{"ofenabled"} = 1;
	}

	my $vlan_number = $stack->createVlan($vlanid, $vlanid, 
					     \@ports, \%otherargs);
	if (!$vlan_number) {
	    tberror({type => 'secondary', severity => SEV_SECONDARY,
		     error => ['create_vlan_failed', $vlanid]},
		    "Failed to create VLAN with id $vlanid");
	    #
	    # Don't try to put ports in a VLAN if it couldn't be created.
	    # Lets make sure the vlan is not partially created, lest we
	    # have a vlan on the switch but not in the DB.
	    #
	    if (!$stack->removeVlan($vlanid)) {
		print STDERR "*** Could not remove failed vlan: $vlanid\n";
	    }
	    $errors++;
	} else {
	    #
	    # Set up and enable openflow, if requested.
	    #
	    if ($ofenabled) {
	        my $ofcontroller;
	        $vlan->GetAttribute("ofcontroller", \$ofcontroller);
	        if (defined($ofcontroller) && $ofcontroller ne "") {
	            $errors += doSetOpenflowController([$stack], $vlanid,
						       $ofcontroller);
	        }
	        $errors += doEnableOpenflowListener([$stack], $vlanid);
	        $errors += doOpenflowEnable([$stack], $vlanid);

	        # doEnableOpenflowListener updates the lan_attributes table,
	        # so vlan should refresh itself.
	        $vlan->Refresh();
	    }
	}
    }
    return $errors
	if ($errors);

    #
    # Record an insertion to make sure the DB reflects the current state
    # of the vlan. 
    #
    if (VLan->RecordVlanInsertion($vlanid, $stack->{STACKID})) {
	print STDERR "Could not record vlan insertion for $vlanid\n";
	$errors++;
    }

    #
    # Set the speed and duplex of each interface depending on the
    # value in the database
    #
    if (!$NOSTACKMIB) {
	foreach my $port (@ports) {
	    my ($speed,$duplex) = getInterfaceSettings($port);
	    #
	    # If either is not set, we do nothing. We could make
	    # a 0 mean 'auto'
	    #
	    # For now, we ignore it if the switch doesn't support the
	    # commands.
	    #
	    if ($speed) {
		my $cmd = $speed . "mbit";
		my $rv = $stack->portControl($cmd, $port);
		if ($rv > 0) {
		    $errors += $rv;
		}
	    }
	    if ($duplex) {
		my $rv = $stack->portControl($duplex, $port);
		if ($rv > 0) {
		    $errors += $rv;
		}
	    }
	}
    }
    #
    # Look for a layer 1 link; There is a logical wire that needs to be
    # activated once it is created. 
    #
    my $vlan = VLan->Lookup($vlanid);
    if ($vlan->type() eq "wire") {
	my $wireid;
	
	if ($vlan->GetAttribute("logicalwireid", \$wireid) == 0) {
	    my $wire = Interface::LogicalWire->LookupByWireID($wireid);
	    if (!defined($wire)) {
		print STDERR "Could not get logical wire for $vlan ($wireid)\n";
		$errors++;
	    }
	    else {
		if ($wire->Activate($vlan) != 0) {
		    print STDERR "Could not activate $wire for $vlan\n";
		    $errors++;
		}
	    }
	}
    }
    return $errors;
}

#
# Remove all VLANs given from every switch in the stack. All ports in the
# VLANs are removed, irrespective of what the database says membership should
# be
#
sub doReset($@) {
    my $stacks = shift;
    my @vlans = @_;
    my %wires = ();

    #
    # Hand over to outer boss.
    # 
    if ($ELABINELAB) {
	return RemoteDoReset($experiment,
			     scalar(@optvlanids) == 0, $opt{C}, @vlans);
    }

    my $errors = 0;
    my %trunkedPorts = getExperimentTrunks($pid, $eid, @vlans);
    my @controlports = ();
    foreach my $port (values(%trunkedPorts)) {
	#
	# If operating on the control interface, the trunk disable
	# will remove the port from the control vlan. Move it back.
	#
	if (doTrunkDisable($stacks,$port) == 0) {
	    push(@controlports, $port)
		if ($port->role() eq TBDB_IFACEROLE_CONTROL());
	}
	else {
	    $errors++;
	}
    }
    return -1
	if ($errors);
    
    if (@controlports) {
	if (@$stacks[0]->{'STACKID'} ne "Control") {
	    print STDERR "Need the Control stack move ports back.\n";
	    return -1;
	}
	debug("Moving ports back into control vlan: @controlports\n");
	
	if (@$stacks[0]->setPortVlan("Control", @controlports)) {
	    print STDERR "Failed to move some ports back: @controlports\n";
	    return -1;
	}
    }
    
    # In case of error, do not clear the DB state.
    my %notdeleted = ();

    # Get a list of openflow enabled vlans we have to undo.
    my %ofenabled = ();
    
    foreach my $vlan_id (@vlans) {
	my $vlan = VLan->Lookup($vlan_id);

	my $flag;
	$vlan->GetAttribute("ofenabled", \$flag);
	if (defined($flag) && $flag == 1) {
	    $ofenabled{"$vlan_id"} = 1;
	}
    }

    $debug = 1;
    
    #
    # Look for a layer 1 link; There is a logical wire that needs to be
    # deactivated once it is created, but must ensure that the logical
    # wire is not actually in use.
    #
    foreach my $vlan_id (@vlans) {
	my $vlan = VLan->Lookup($vlan_id);
	my $wireid;

	next
	    if (! $vlan->type() eq "wire");
	
	if ($vlan->GetAttribute("logicalwireid", \$wireid) == 0) {
	    my $wire = Interface::LogicalWire->LookupByWireID($wireid);
	    if (!defined($wire)) {
		print STDERR "Could not get logical wire for $vlan ($wireid)\n";
		return -1;
	    }
	    # need the interfaces.
	    my ($interface1, $interface2) = $wire->Interfaces();
	    if (!defined($interface1)) {
		print STDERR "No interface for logical wire $wire\n";
		return -1;
	    }
	    # Find the vlan that uses this interface.
	    my $vlanusing = VLan->FindVlanByInterface($experiment, $interface1);
	    if (defined($vlanusing) && $vlanusing->CreatedOnSwitches()) {
		print STDERR "Logical wire $wire is in use by $vlanusing; ".
		    "not allowed to remove $vlan\n";
		return -1;
	    }
	    $wires{$vlan->lanid()} = $wire;
	}
    }

    #
    # Just remove the VLAN from every stack on which it exists. We keep a
    # list and do them all at once for efficiency.
    #
    foreach my $stack (@$stacks) {
#	$stack->FlipDebug(1);

	my @existant_vlans = $stack->existantVlans(@vlans);
	#
	# Disable openflow if needed.
	#
	foreach my $vlan_id (@existant_vlans) {
	    if (exists($ofenabled{"$vlan_id"})) {
		$errors += doOpenflowDisable($stacks, $vlan_id);
	    }
	}
	
	if (!$stack->removeVlan(@existant_vlans)) {
	    #
	    # Find out what still exists so that we keep the DB state.
	    #
	    foreach my $vlan_id (@existant_vlans) {
		if ($stack->vlanExists($vlan_id)) {
		    print "  $vlan_id was not deleted.\n";
		    $notdeleted{$vlan_id} = 1;
		}
	    }
	    $errors++;
	}
    }
    foreach my $vlan_id (@vlans) {
	next
	    if (exists($notdeleted{$vlan_id}));
	
	VLan::ClearReservedVlanTag($vlan_id)
	    if ($opt{C});
	VLan->RecordVLanDeletion($vlan_id);

	# Deactivate the logical wire.
	if (exists($wires{$vlan_id})) {
	    my $wire = $wires{$vlan_id};
	    
	    print "Deactivating logical wire $wire\n";
	    if ($wire->DeActivate() != 0) {
		print STDERR "Could not deactivate $wire for vlan $vlan_id\n";
		$errors++;
	    }
	}
    }
    return $errors;
}

#
# Sync vlans from the DB for a single experiment. This is a swapmod helper
# to avoid churning the switches.
#
sub syncVlansFromTables($$@) {
    my $experiment = shift;
    my $stacks     = shift;
    my @vlanids    = @_;
    my %expvlans   = ();
    my %curvlans   = ();
    my %stale      = ();
    my $errors     = 0;
    my $sharedvlans= 0;
    my $sharedlock;
    my $vlan_number;

    if (@$stacks > 1) {
	die "VLAN creation across multiple stacks is not yet supported\n" .
	    "Stacks are " . join(", ",map {$_->{STACKID}} @$stacks) . "\n";
    }
    my ($stack) = @$stacks;

    $debug = 1;
    $stack->FlipDebug(1);

    #
    # Get list of vlans that should exist.
    #
    my @tmp;
    VLan->ExperimentVLans($experiment, \@tmp) == 0 or
	die("Could not get current vlans for $experiment\n");
    foreach my $vlan (@tmp) {
	# Narrow to provided vlanids.
	$expvlans{$vlan->id()} = $vlan
	    if (!@vlanids || grep {$_ == $vlan->id()} @vlanids);

	if ($vlan->IsShared()) {
	    $sharedvlans++;
	}
    }
    debug("Experiment vlans: " . join(" ", keys(%expvlans)) . "\n");;

    #
    # When dealing with shared vlans we need to serialize. We know
    # that shared vlans are updated as a separate call to snmpit,
    # so bail if we get more then a single vlan when we get a shared
    # vlan, to make the locking simple.
    #
    if ($sharedvlans && $sharedvlans != 1 && scalar(keys(%expvlans)) != 1) {
	die("Not allowed to update more then one shared vlan at a time.\n");
    }
    if ($sharedvlans) {
	my $vlan = (values(%expvlans))[0];
	$sharedlock = "shared_vlan_" . $vlan->lanid();
	if (snmpit_lock($sharedlock)) {
	    die("Could not get the lock for shared vlan\n");
	}
	debug("Got shared vlan lock $sharedlock\n");
    }

    #
    # List of trunks for the above set of vlans.
    #
    my %needTrunking = getExperimentTrunks($pid, $eid, values(%expvlans));
    debug("Trunk Ports: ".Port->toStrings(keys(%needTrunking))."\n");

    #
    # Get list of vlans that we think are on the switch (vlans table).
    #
    @tmp = ();
    VLan->StaleVlanList($experiment, \@tmp) == 0 or
	die("Could not get stale vlans for $experiment\n");
    foreach my $vlanid (@tmp) {
	#
	# Narrow to vlans that came in on the command line, not
	# the ones sent to this function. When a specific vlan is
	# provided on the command line, we consider only that one as
	# potentially stale. If no vlans on the command line, then all
	# vlans in the experiment are potentially stale. 
	#
	next
	    if (@optvlanids && ! grep {$_ == $vlanid} @optvlanids);
	
	$curvlans{$vlanid} = 1;

	# Not in the new set; must delete.
	$stale{$vlanid} = 1
	    if (!exists($expvlans{$vlanid}));
    }
    debug("Existing vlans: " . join(" ", keys(%curvlans)) . "\n");
    debug("Stale vlans: " . join(" ", keys(%stale)) . "\n");

    #
    # Get a list of interfaces that are currently trunked.
    #
    my %currentTrunks = getExperimentCurrentTrunks($pid, $eid, keys(%curvlans));
    debug("Existing Trunk Ports: ".Port->toStrings(keys(%currentTrunks))."\n");

    #
    # Okay, kill off stale vlans.
    #
    if (keys(%stale)) {
	my @existant_vlans = $stack->existantVlans(keys(%stale));

	if (@existant_vlans) {
	    debug("Removing stale vlans @existant_vlans\n");

	    if (!$impotent) {
		foreach my $vlanid (@existant_vlans) {
		    my @curports   = getExperimentVlanPorts($vlanid);
		    my @trunkports = ();

		    foreach my $port (@curports) {
			if (exists($currentTrunks{$port->toString()})) {
			    push(@trunkports, $port);
			}
		    }
		    if (@trunkports) {
			$stack->removeSomePortsFromTrunk($vlanid, @trunkports)
			    or goto bad;
		    }
		    # Disable OpenFlow, if set for vlan
		    my $vlan = VLan->Lookup($vlanid);
		    if ($vlan) {
			my $ofenabled;
			$vlan->GetAttribute("ofenabled",\$ofenabled);
			if (defined($ofenabled) && $ofenabled == 1) {
			    if (!$stack->disableOpenflow($vlanid)) {
				print STDERR "Could not disable openflow ".
				             "on stale vlan: $vlanid\n";
				goto bad;
			    }
			}
		    }
		    if (!$stack->removeVlan($vlanid)) {
			print STDERR "Could not remove vlan: $vlanid\n";
			goto bad;
		    }
		    VLan->RecordVLanDeletion($vlanid) == 0
			or goto bad;
		    VLan::ClearReservedVlanTag($vlanid) == 0
			or goto bad;
		}
	    }
	}
    }

    #
    # Remove stale ports from existing vlans. 
    #
    foreach my $vlanid (keys(%expvlans)) {
	# This one will be built later.
	next
	    if (!exists($curvlans{$vlanid}));

	my $vlan       = $expvlans{$vlanid};
	my @expports   = getVlanPorts($vlanid);
	my @curports   = getExperimentVlanPorts($vlanid);
	my @staleports = ();
	my @staletrunks= ();

	#
	# As a simplification for the backend, keep trunked ports separate
	# from regular ports. Better then the backend figuring it out.
	#
	foreach my $port (@curports) {
	    if (! grep {$_->toString() eq $port->toString()} @expports) {
		if (exists($currentTrunks{$port->toString()})) {
		    push(@staletrunks, $port);
		}
		else {
		    push(@staleports, $port);
		}
	    }
	}
	next
	    if (! (@staleports || @staletrunks));
	    
	#
	# Clear the switch trunks since we are removing ports, which
	# changes that set. 
	#
	$stack->setVlanOnSwitchTrunks($vlanid, 0);

	if (@staleports) {
	    debug("Removing stale ports from vlan $vlanid: @staleports\n");

	    if (!$impotent) {
		$stack->removeSomePortsFromVlan($vlanid, @staleports)
		    or goto bad;
	    }
	}
	if (@staletrunks) {
	    debug("Removing stale trunked ports from vlan $vlanid: ".
	    Port->toStrings(@staletrunks)."\n");
	    
	    if (!$impotent) {
		$stack->removeSomePortsFromTrunk($vlanid, @staletrunks)
		    or goto bad;
	    }
	}
	#
	# Must record a modification so that the loop below that adds new 
	# ports does not get confused.
	#
	my $tmp = Port->toIfaceStrings(@staleports, @staletrunks);
	my @tmp = split(/\s+/, $tmp);
	if (VLan->RecordVLanModification($vlanid, undef, \@tmp)) {
	    print STDERR "Could not record vlan modification: $vlanid - @tmp\n";
	    goto bad;
	}

	#
	# THIS MUST BE LAST, so that when we add the trunks back, it is
	# for the current set. If this fails, we will be left in an
	# inconsistent state. But you can use --resetvlanontrunks option.
	#
	$stack->setVlanOnSwitchTrunks($vlanid, 1);

	#
	# For shared vlans, we want to record new switch path in the DB
	# so it reflects reality. 
	#
	if ($vlan->IsShared()) {
	    my $switchpath = $vlan->GetSwitchPath();
	    debug("Storing switch trunk path for $vlan: $switchpath\n");

	    # This updates the vlans table.
	    if ($vlan->SetVlanSwitchPath($switchpath)) {
		print STDERR "Could not store new vlan switchpath for $vlan\n";
		goto bad;
	    }
	}
    }

    #
    # Now untrunk the ports that are no longer trunked.
    #
    my @controlports = ();
    
    foreach my $port (values(%currentTrunks)) {
	#
	# Look at the actual physical port; whatever it says goes.
	#
	if (!$port->trunk()) {
	    debug("Disabling trunking on $port\n");
	    
	    next
		if ($impotent);

	    #
	    # If operating on the control interface, the trunk disable
	    # will remove the port from the control vlan. Move it back.
	    #
	    if (doTrunkDisable($stacks, $port) == 0) {
		push(@controlports, $port)
		    if ($port->role() eq TBDB_IFACEROLE_CONTROL());
		delete($currentTrunks{"$port"});
	    }
	    else {
		goto bad;
	    }
	}	
    }
    if (@controlports) {
	if (@$stacks[0]->{'STACKID'} ne "Control") {
	    print STDERR "Need the Control stack move ports back.\n";
	    goto bad;
	}
	debug("Moving ports back into control vlan: @controlports\n");

	if (@$stacks[0]->setPortVlan("Control", @controlports)) {
	    print STDERR "Failed to move some ports back: @controlports\n";
 	    goto bad;
	}
    }

    #
    # Look for special vlans that need dual trunking. The vlan becomes
    # the native vlan, but it must be created before enabling trunking
    # on the port. 
    #
    foreach my $vlanid (keys(%expvlans)) {
	my $vlan = $expvlans{$vlanid};
	my $trunk_mode;
	$vlan->GetAttribute("trunk_mode", \$trunk_mode);
	my $trunk_vlanid;
	$vlan->GetAttribute("trunk_vlan", \$trunk_vlanid);

	# This is set in libvtop.
	if (defined($trunk_mode) && $trunk_mode eq "dual") {
	    my @ports = getVlanPorts($vlanid);
	    my @saveports = @ports;

	    #
	    # If the vlan exists, still want to call CreateOneVlan(),
	    # but only if some ports are not yet in the vlan.
	    #
	    if (exists($curvlans{$vlanid})) {
		my @curports = getExperimentVlanPorts($vlanid);
		my @newports = ();

		foreach my $port (@ports) {
		    push(@newports, $port)
			if (! grep {$_->toString() eq $port->toString()} @curports);
		}
		@ports = @newports;
	    }
	    
	    #
	    # If a specific vlan listed, it must already exist.
	    #
	    if (defined($trunk_vlanid)) {
		my $trunk_vlan = VLan->Lookup($trunk_vlanid);
		if (!defined($trunk_vlan)) {
		    die("Trunk vlanid $trunk_vlanid does not exist\n");
		}
		if (!$trunk_vlan->CreatedOnSwitches()) {
		    die("Trunk vlanid $trunk_vlan is not instantiated\n");
		}
		#
		# To maintain backwards compatibility with how snmpit used
		# to operate, "internal" vlans are sometimes named on the switch
		# by the symbolic name instead of the lanid.
		#
		if ($trunk_vlan->IsInternal() &&
		    !$stack->vlanExists($trunk_vlanid)) {
		    $trunk_vlanid = $trunk_vlan->vname();
		}
		    
		#
		# For each port that has not yet been put into trunk
		# mode, do that using the trunk_vlanid as the native.
		#
		foreach my $port (@ports) {
		    if (!IsPortTagged($port)) {
			debug("Enabling dual mode trunking on ".
			      "$port:$trunk_vlanid\n");

			if (!$impotent &&
			    doTrunkEnable($stacks,$port,0,$trunk_vlanid)) {
			    print STDERR "Could not put $port ($trunk_vlanid) ".
				"into dual trunk mode\n";
			    goto bad;
			}
		    }
		    # Mark is as being trunked.
		    $currentTrunks{"$port"} = $port;
		}
		# Now we can create the actual vlan.
		debug("Creating dual mode trunking vlan $vlanid: @ports\n")
		    if (@ports);
		
		if (!$impotent && @ports &&
		    CreateOneVlan($experiment, $stack, $vlanid, @ports)) {
		    print STDERR "Could not create dual trunked $vlan\n";
		    goto bad;
		}
		# So it is not created below.
		$curvlans{$vlanid} = 1;
	    }
	    else {
		# Create this vlan now. 
		debug("Creating dual mode trunking vlan $vlanid: @ports\n")
		    if (@ports);

		if (!$impotent && @ports &&
		    CreateOneVlan($experiment, $stack, $vlanid, @ports))  {
		    print STDERR "Could not create dual trunked $vlan\n";
		    goto bad;
		}
		# So it is not created below.
		$curvlans{$vlanid} = 1;
	    
		# Trunk ports.
		foreach my $port (@saveports) {
		    if (!exists($currentTrunks{$port->toString()})) {
			debug("Enabling dual mode trunking on $port:$vlanid\n");
		    
			if (!$impotent &&
			    doTrunkEnable($stacks,$port,0,$vlanid)) {
			    print STDERR
				"Could not put $port ($vlanid) into ".
				"dual trunk mode\n";
			    goto bad;
			}
		    }
		    # Mark is as being trunked.
		    $currentTrunks{"$port"} = $port;
		}
	    }
	}
    }

    #
    # Do the rest of the trunked ports in equal mode.
    #
    foreach my $port (values(%needTrunking)) {
	if (!exists($currentTrunks{$port})) {
	    if (!IsPortTagged($port)) {
		debug("Enabling trunking on $port\n");
	    
		next
		    if ($impotent);
	
		doTrunkEnable($stacks, $port, 1) == 0
		    or goto bad;
	    }
	    # Mark is as being trunked.
	    $currentTrunks{$port} = $needTrunking{$port};
	}
    }

    #
    # Now add ports to existing vlans.
    #
    foreach my $vlanid (keys(%expvlans)) {
	# This one will be built later.
	next
	    if (!exists($curvlans{$vlanid}));

	my $vlan       = $expvlans{$vlanid};
	my @expports   = getVlanPorts($vlanid);
	my @curports   = getExperimentVlanPorts($vlanid);
	my @newports   = ();

	foreach my $port (@expports) {
	    push(@newports, $port)
		if (! grep {$_->toString() eq $port->toString()} @curports);
	}
	next
	    if (!@newports);
	    
	debug("Adding new ports to vlan $vlanid: ".Port->toStrings(@newports)."\n");

	next
	    if ($impotent);
	
	#
	# Clear the switch trunks since we are adding ports, which
	# changes that set. The trunks are added back in CreateOneVlan.
	#
	$stack->setVlanOnSwitchTrunks($vlanid, 0);
 	
	if (CreateOneVlan($experiment, $stack, $vlanid, @newports)) {
	    goto bad;
	}
	#
	# For shared vlans, we want to record new switch path in the DB
	# so it reflects reality. 
	#
	if ($vlan->IsShared()) {
	    my $switchpath = $vlan->GetSwitchPath();
	    debug("Storing switch trunk path for $vlan: $switchpath\n");

	    # This updates the vlans table.
	    if ($vlan->SetVlanSwitchPath($switchpath)) {
		print STDERR "Could not store new vlan switchpath for $vlan\n";
		goto bad;
	    }
	}
    }

    #
    # Now create vlans that did not exist.
    #
    foreach my $vlanid (keys(%expvlans)) {
	next
	    if (exists($curvlans{$vlanid}));
	    
	my @ports  = getVlanPorts($vlanid);

	debug("Creating new vlan $vlanid: ".Port->toStrings(@ports)."\n");

	next
	    if ($impotent);
	
	if (CreateOneVlan($experiment, $stack, $vlanid, @ports)) {
	    goto bad;
	}
    }
    snmpit_unlock($sharedlock)
	if (defined($sharedlock));
    return 0;

 bad:
    snmpit_unlock($sharedlock)
	if (defined($sharedlock));
    return -1;
}

#
# Reserve vlan tags.
# 
sub doReserveVlanTags($$@) {
    my $experiment = shift;
    my $stacks  = shift;
    my @vlanids = @_;
    my %vlans   = ();
    my %vstacks = ();
    my $errors  = 0;
    my @stacknames = map { $_->{STACKID} } @$stacks;

    if ($ELABINELAB) {
	return RemoteDoReserveVlanTags($experiment, \%optvlantags, @vlanids);
    }
    
    #
    # First do sanity checks on the entire set of vlans
    #
    foreach my $id (@vlanids) {
	my $vlan = VLan->Lookup($id);
	if (!defined($vlan)) {
	    die("Could not locate vlan $id in the DB\n");
	}
	$vlans{"$id"} = $vlan;

	my @planned = getPlannedStacksForVlans($id);
	if (@planned > 1) {
	    print STDERR "$vlan crosses multiple stacks. Cannot reserve tag\n";
	    $errors++;
	    next;
	}
	elsif (@planned == 0) {
	    # Default to the provided stack. Correct thing to do?
	    @planned = @stacknames;
	}
	my $stack = $planned[0];
	
	if (! (grep {$_ eq $stack} @stacknames)) {
	    print STDERR "$vlan is in stack $stack, but not in given stacks!\n";
	    $errors++;
	    next;
	}
	$vstacks{"$id"} = $stack_ids{$stack};
    }
    return $errors
	if ($errors);

    #
    # Now do the reservations. Have to deal with roll back on error.
    #
    my @assigned = ();
    
    foreach my $vlan (values(%vlans)) {
	my $vlanid  = $vlan->id();
	my $stack   = $vstacks{"$vlanid"};
	my @tags    = ();

	#
	# Option to assign a specific tag. This needs to be better.
	#
	if (exists($optvlantags{$vlanid})) {
	    @tags = @{ $optvlantags{$vlanid} };
	    # Shuffle for better handling.
	    @tags = shuffle(@tags);
	}
	elsif ($vlan->GetReservedVlanTag()) {
	    # Wanted any tag, but lan has a tag.
	    next;
	}

      again:
	if (@tags) {
	    $next_vlan_tag = pop(@tags);
	}
	#
	# If we can assign a tag, remember we did so that we can
	# undo whatever we did, if there is an error. 
	#
	my $tag = $stack->newVlanNumber($vlanid, $vlanid);
	if ($tag) {
	    push(@assigned, [$vlan,$tag]);
	    # Keep going in blockmode to get all tags.
	    next
		if (!$opt{'blockmode'});
	}
	goto again
	    if (@tags);

	#
	# No more tags to try. In blockmode that is fine, the caller will
	# figure it out by looking to see which tags are reserved. But
	# when not in blockmode it is an error if we cannot get one of the
	# tags in the list we were given. We get here only when we have run
	# out of tags to try.
	#
	if (!$opt{'blockmode'}) {
	    print STDERR "Could not pre-reserve a tag for $vlan\n";
	    $errors++;
	    last;
	}
    }
    if ($errors) {
	foreach my $ref (@assigned) {
	    my ($vlan, $tag) = @{ $ref };
	    $vlan->ClearReservedVlanTag($tag);
	}
    }
    return $errors;
}

sub doUnReserveVlanTags($$@) {
    my $experiment = shift;
    my $stacks  = shift;
    my @vlanids = @_;
    my %vlans   = ();
    my %vstacks = ();
    my $errors  = 0;
    my @stacknames = map { $_->{STACKID} } @$stacks;

    if ($ELABINELAB) {
	return RemoteDoUnReserveVlanTags($experiment, \%optvlantags, @vlanids);
    }
    
    #
    # First do sanity checks on the entire set of vlans
    #
    foreach my $id (@vlanids) {
	my $vlan = VLan->Lookup($id);
	if (!defined($vlan)) {
	    die("Could not locate vlan $id in the DB\n");
	}
	$vlans{"$id"} = $vlan;

	my @planned = getPlannedStacksForVlans($id);
	if (@planned > 1) {
	    print STDERR "$vlan crosses multiple stacks. Cannot reserve tag\n";
	    $errors++;
	    next;
	}
	elsif (@planned == 0) {
	    # Default to the provided stack. Correct thing to do?
	    @planned = @stacknames;
	}
	my $stack = $planned[0];
	
	if (! (grep {$_ eq $stack} @stacknames)) {
	    print STDERR "$vlan is in stack $stack, but not in given stacks!\n";
	    $errors++;
	    next;
	}

	#
	# Not allowed to clear the reservation if the lan exists.
	#
	if ($stack_ids{$stack}->vlanExists($id)) {
	    print STDERR
		"$vlan exists on stack $stack; cannot clear reserved tag\n";
	    $errors++;
	    next;
	}
    }
    return $errors
	if ($errors);

    #
    # Now clear the reservations. 
    #
    foreach my $vlan (values(%vlans)) {
	my $vlanid = $vlan->id();

	if (exists($optvlantags{$vlanid})) {
	    foreach my $tag (@{ $optvlantags{$vlanid} }) {
		$vlan->ClearReservedVlanTag($tag);
	    }
	}
	else {
	    $vlan->ClearReservedVlanTag();
	}
    }
    return $errors;
}

#
# Sync the switches and the DB.
# 
sub doSyncVlansWithDB($) {
    my $stacks  = shift;
    my $errors  = 0;
    my %portmap = ();
    my %allports = ();

    if (@$stacks > 1) {
	die "VLAN synchronization across multiple stacks not supported\n" .
	    "Stacks are " . join(", ",map {$_->{STACKID}} @$stacks) . "\n";
    }
    my ($stack) = @$stacks;
    my $stackid = ($ELABINELAB ? $stack : $stack->{STACKID});

    #
    # Grab a port mapping of all vlans.
    #
    my @vlanList = $stack->listVlans();
    foreach my $ref (@vlanList) {
	my ($vlan_id,undef,$memberref) = @$ref;
	$portmap{$vlan_id} = []
	    if (!exists($portmap{$vlan_id}));
	$allports{$vlan_id} = []
	    if (!exists($allports{$vlan_id}));

	foreach my $port (@$memberref) {
	    push(@{ $allports{$vlan_id} }, $port);
	    # Convert the ports to node:iface for the next call.
	    push (@{ $portmap{$vlan_id} }, $port);
	}
    }
    #
    # Now check every vlan.
    #
    my %vlans = $stack->findVlans();

    foreach my $vlan_id (keys(%vlans)) {
	my $tag = $vlans{$vlan_id};
	my $vlan;
	    
	if ($vlan_id =~ /^\d*$/) {
	    $vlan = VLan->Lookup($vlan_id);
	}
	else {
	    $vlan = VLan->Lookup($experiment, $vlan_id);
	}
	if (defined($vlan)) {
	    #
	    # Make sure things are consistent.
	    #
	    # This looks in the vlans table.
	    #
	    my $otag = $vlan->GetTag();
	    if (defined($otag) && $otag == $tag) {
		#
		# Make sure in the reserved vlantags table. 
		#
		if (!$vlan->HasVlanTagReserved($tag)) {
		    #
		    # Make consistent by entering into reserved tags.
		    #
		    print "$vlan is using unreserved vlan tag $otag\n";
		    if (!$impotent) {
			print "  attempting to reserve ...\n";
			if (! $vlan->ReserveVlanTag($tag, 0, 1)) {
			    die("  could not reserve tag\n");
			}
		    }
		}
	    }
	    elsif (defined($otag)) {
		print "$vlan is using tag $tag but DB says $otag\n";
		$errors++;
	    }
	    elsif ($vlan->IsAlias()) {
		my $aliasid  = $vlan->IsAlias();
		my $aliaslan = VLan->Lookup($aliasid);
		if (!defined($aliaslan)) {
		    die("$vlan is aliased to nonexistent lan $aliasid\n");
		}
		my $aliastag = $aliaslan->GetTag();
		if ($tag != $aliastag) {
		    die("$vlan is aliased to $aliaslan,".
			"but tags are different\n")
		}
	    }
	    else {
		print "$vlan is using tag $tag but DB says no tag\n";
		#
		# Make consistent by entering into reserved tags and vlans.
		#
		if (!$impotent) {
		    print "  attempting to reserve ...\n";
		    if (!$vlan->HasVlanTagReserved($tag) &&
			!$vlan->ReserveVlanTag($tag, 0, 1)) {
			die("  could not reserve tag\n");
		    }
		    if (VLan->RecordVlanInsertion($vlan->id(), $stackid)) {
			die("  could not record insertion for $vlan");
		    }
		}
	    }
	    next;
	}
	elsif ($vlan_id =~ /^\d*$/) {
	    #
	    # If the vlan name is an integer, then it is an orphan that
	    # was mistakenly left behind after an experiment was
	    # terminated. Or it is for an experiment that existed
	    # prior to the code that reserves all vlan tags.
	    #
	    print "$vlan_id appears to be an orphan but using tag $tag\n";
	    my @ports = (exists($portmap{$vlan_id}) ?
			 @{ $portmap{$vlan_id} } : ());

	    #
	    # Always delete orphans that have no ports in them. 
	    #
	    if (!$impotent && !@ports) {
		print "  removing vlan since it has no ports.\n";
		if (!$stack->removeVlan($vlan_id)) {
		    print "  *** error deleting $vlan_id from $stack\n";
		    $errors++;
		}
		elsif (VLan->RecordVLanDeletion($vlan_id)) {
		    $errors++;
		}
		elsif (VLan::ClearReservedVlanTag($vlan_id)) {
		    $errors++;
		}
	    }
	    next;
	}
	my @swports = (exists($portmap{$vlan_id}) ?
		       @{ $portmap{$vlan_id} } : ());
	    
	#
	# Check for inconsistent use of the tag.
	#
	$vlan = VLan->FindVlanByTag($tag);
	if ($vlan) {
	    print "*** $vlan_id is using tag $tag, but DB says its $vlan\n";

	    #
	    # Create an alias vlan. This should not happen often.
	    #
	    if (!$impotent) {
		print "  creating internal alias vlan.\n";

		my $alias = VLan->Create($experiment, $vlan_id);
		if (!defined($alias)) {
		    die("  could not create VLan object for $vlan_id\n");
		}
		$alias->MarkManual();
		$alias->MarkInternal();
		$alias->SetAlias($vlan);
	    }
	    next;
	}
	if ($impotent) {
	    print "$vlan_id is using unreserved tag $tag";

	    if (@swports) {
		print ": ".join(" ", map($_->toString(), @swports))."\n";
	    }
	    else {
		print " but has no node ports\n";
	    }
	}
	else {
	    print "Creating internal vlan for $vlan_id using tag $tag\n";
		
	    #
	    # Make consistent by creating a vlan object. We do not
	    # worry about the ports for these vlans. 
	    #
	    $vlan = VLan->Create($experiment, $vlan_id);
	    if (!defined($vlan)) {
		die("  could not create VLan object for $vlan_id\n");
	    }
	    $vlan->MarkManual();
	    $vlan->MarkInternal();

	    # XXX: Need a better way to figure out whether class is
	    # Experimental or Control
	    if ($stackid eq "Control") {
		$vlan->SetClass("Control");
	    }
	    else {
		$vlan->SetClass("Experimental");
	    }
	    
	    if (!$vlan->HasVlanTagReserved($tag) &&
		!$vlan->ReserveVlanTag($tag, 0, 1)) {
		die("  could not reserve tag\n");
	    }
	    if (VLan->RecordVlanInsertion($vlan->id(), $stackid)) {
		die("  could not record insertion for $vlan");
	    }
	}
    }
    #
    # Now lets do a port consistency check.
    #
    my @allvlans = ();
    if (VLan->AllVLans(\@allvlans)) {
	die("Could not get list of all vlans from the DB!\n");
    }
    foreach my $vlan (@allvlans) {
	my $vlan_id = ($vlan->IsInternal() ?
		       $vlan->vname() : $vlan->id());

	my @swports = (exists($portmap{$vlan_id}) ?
		       @{ $portmap{$vlan_id} } : ());
	@swports = map($_->getPCPort()->toIfaceString(), @swports);
	my @dbports = ();
	if ($vlan->PortList(\@dbports)) {
	    die("Could not get list of ports for $vlan!\n");
	}

	# Sort to make debugging easier.
	@dbports = sort {tbsort($a,$b)} @dbports;
	@swports = sort {tbsort($a,$b)} @swports;

	#
	# Skip vlans that are in the DB but not created on the switches.
	#
	next
	    if (!@swports && !exists($vlans{$vlan_id}));

	# Skip alias vlans.
	next if
	    ($vlan->IsAlias());
	
	# Skip vlans that are on another stack.
	next if
	    ($vlan->GetStack() ne $stackid);

	#
	# Skip vlans that have matching port lists.
	#
	if (scalar(@swports) == scalar(@dbports)) {
	    my $diff = 0;

	    foreach my $port (@swports) {
		$diff = 1
		    if (! grep {$_ eq $port} @dbports);
	    }
	    foreach my $port (@dbports) {
		$diff = 1
		    if (! grep {$_ eq $port} @swports);
	    }
	    next
		if (!$diff);
	}
	if (!$vlan->KeepInSync()) {
	    print "$vlan portlist is not consistent:\n";
	    print "  This is okay since its a low numbered vlan. ";
	    print "Skipping ...\n";
	    next;
	}
	
	#
	# If the DB has no ports recorded, but the switch does, then make
	# the DB consistent with the switch. 
	#
	print "$vlan portlist is not consistent:\n";
	print "  Switch: @swports\n" if (@swports);
	print "  Database: @dbports\n" if (@dbports);
	if (!$impotent) {
	    if (!@dbports) {
		print "  Making it consistent\n";
		foreach my $port (@swports) {
		    if (!defined($vlan->AddPort($port))) {
			print "Could not add $port to $vlan\n";
			$errors++;
		    }
		}
		if (VLan->RecordVlanInsertion($vlan->id(), $stackid)) {
		    print "Could not record vlan insertion for $vlan\n";
		    $errors++;
		}
	    }
	}
    }
    return $errors;
}

#
# Create a vlan with name $vlan_name. It is not an error to try to create a
# VLAN that already exists, as this can be used to add ports to an existing
# VLAN. If ports are given, they are put into the VLAN.
#
sub doMakeVlan($$@) {
    my $stacks = shift;
    my $vlan_name = shift;
    my @ports = @_;
    my $errors = 0;
    my $vlanexists = 0;
    my $target_vlan;
    my $source_vlan;

    if (@$stacks > 1) {
	die "VLAN creation across multiple stacks is not yet supported\n" .
	    "Stacks are " . join(", ",map {$_->{STACKID}} @$stacks) . "\n";
    }
    my ($stack) = @$stacks;
    my $stackid = ($ELABINELAB ? $stack : $stack->{STACKID});	    

    #
    # We require a target VLan object for all vlans related to experiments,
    # unless we are moving ports back into the control network. There are
    # probably other special caes as well, but this is all we need at the
    # moment. 
    #
    if (defined($experiment)) {
	#
	# These ports might be in another vlan, or they are free
	# and not recorded in a vlan (we do not keep internal vlans
	# uptodate).
	#
	foreach my $port (@ports) {
	    my $vlan = VLan->FindVlanByPort(undef, $port);
	    next
		if (!defined($vlan));
	    
	    if (defined($source_vlan) && !$vlan->SameVlan($source_vlan)) {
		if (IsPortTagged($port)) {
		    print "$port is tagged and already in $source_vlan. ".
			"But doing it anyway!\n";
		}
		else {
		    die("Ports must be in a single vlan\n");
		}
	    }
	    $source_vlan = $vlan;
	}
	#
	# Allow lookup by integer id.
	#
	if (defined($stack) &&
	    $stackid eq "Control" && $vlan_name eq "Control") {
	    #
	    # XXX Backwards compatability with older snmpit; allow "Control"
	    # which is really in the holding experiment. 
	    #
	    my $exp = Experiment->Lookup(VLAN_PID(), VLAN_EID());
	    if (!defined($exp)) {
		die("Could not lookup vlan holding experiment\n");
	    }
	    $target_vlan = VLan->Lookup($exp, $vlan_name);
	    if (!defined($target_vlan)) {
		die("Could not lookup the control network vlan\n");
	    }
	}
	elsif ($vlan_name =~ /^\d*$/) {
	    $target_vlan = VLan->Lookup($vlan_name);
	}
	else {
	    $target_vlan = VLan->Lookup($experiment, $vlan_name);
	}
	if (!defined($target_vlan)) {
	    if ($vlan_name =~ /^\d*$/) {
		die("Please do not use an integer name for new vlan\n");
	    }
		
	    #
	    # Create a new vlan object and put the ports into it.
	    #
	    $target_vlan = VLan->Create($experiment, $vlan_name);
	    if (!defined($target_vlan)) {
		die("Could not create VLan object for $vlan_name\n");
	    }
	    $target_vlan->MarkManual();
	    # XXX: Need a better way to figure out whether class is
	    # Experimental or Control
	    if ($stackid eq "Control") {
		$target_vlan->SetClass("Control");
	    } else {
		$target_vlan->SetClass("Experimental");
	    }

	    if ($experiment->pid() eq VLAN_PID() &&
		$experiment->eid() eq VLAN_EID()) {
		$target_vlan->MarkInternal();
	    }
	}
    }
    else {
	#
	# We no longer allow vlans to be created without an experiment.
	# Use the -f option, which tells snmpit to use internal experiment.
	#
	die("Cannot use -m option without experiment or -f option\n");
    }

    #
    # Pass to outer boss.
    #
    if ($ELABINELAB) {
	foreach my $port (@ports) {
	    $target_vlan->AddPort($port);
	}
	return RemoteDoVlansFromTables($experiment, $target_vlan->id());
    }

    #
    # Check DB to make sure the tag is available.
    #
    if (my $number = $opt{'vlan_tag'}) {
	if ($target_vlan->HasVlanTagReserved($number)) {
	    # Tag is reserved but might not be on the switches.
	}
	elsif (! VLan->VlanTagAvailable($number)) {
	    my $owner_vlan = VLan->FindVlanByTag($number);
	    if (!defined($owner_vlan)) {
		print "Could not find owner vlan for tag $number\n";
		return 1;
	    }
	    print "$owner_vlan already has vlan_tag $number\n";
	    return 1;
	}
	elsif (! $target_vlan->ReserveVlanTag($number)) {
	    print "Not able to reserve vlan_tag $number\n";
	    return 1;
	}
    }

    #
    # If this is a "shadow" we do not actually create it; we
    # are just shadowing (with a tag reservation) a vlan that either
    # exists on the switch, or should never actually exist on the
    # switch. The point is to have the data in the DB, but not worry
    # about what is actually on the switch.
    #
    return 0
	if ($opt{'shadow'});
    
    #
    # To maintain backwards compatibility with how snmpit used
    # to operate, "internal" vlans are named on the switch by the
    # symbolic name instead of the lanid.
    #
    my $device_id;

    if ($target_vlan->IsInternal() &&
	$stack->vlanExists($target_vlan->vname())) {
	$vlanexists = 1;
	$device_id  = $target_vlan->vname();
    }
    else {
	$device_id  = $target_vlan->id();
	$vlanexists = $stack->vlanExists($device_id);
    }

    #
    # Remove the current set of switch trunks since we have to generate
    # a new set anyway. 
    #
    if (!$opt{'whol-magic'}) {
	if ($vlanexists && $target_vlan->KeepInSync()) {
	    print STDERR "Disabling switch trunks on $target_vlan\n";
	    if (!$stack->setVlanOnSwitchTrunks($target_vlan->lanid(), 0)) {
		print STDERR
		    "Could not disable switch trunks on $target_vlan\n";
		return ++$errors;
	    }
	}
	# This causes fallback to snmpit switch path generation.
	$target_vlan->ClrSwitchPath();
    }

    #
    # Same goes for the source vlan, but worse since once we forget
    # the port, there is no way to recover the path.
    #
    if (defined($source_vlan) &&
	!$source_vlan->SameVlan($target_vlan) &&
	$source_vlan->KeepInSync()) {

	if (!$opt{'whol-magic'}) {
	    if (!$stack->setVlanOnSwitchTrunks($source_vlan->lanid(), 0)) {
		print STDERR
		    "Could not disable switch trunks on $source_vlan\n";
		return ++$errors;
	    }

	    # This causes fallback to snmpit switch path generation.
	    $source_vlan->ClrSwitchPath();
	}

	# Yank the ports out of the old vlan now, unless it is tagged,
	# cause we assume the user knows what they want.
	foreach my $port (@ports) {
	    next
		if (IsPortTagged($port));
	    
	    if ($source_vlan->DelPort($port)) {
		print STDERR "Could not yank $port from $source_vlan\n";
		return ++$errors;
	    }
	}
    }
    # And add ports to new vlan so the path can be generated. 
    foreach my $port (@ports) {
	if (!defined($target_vlan->AddPort($port))) {
	    print STDERR "Could not add $port to $target_vlan\n";
	    return ++$errors;
	}
    }

    #
    # Create/Update
    #
    if ($vlanexists) {
	print "VLAN $target_vlan already exists\n"
	    if (!$quiet);

	#
	# Put requested ports into the VLAN
	#
	if (@ports) {
	    print "Putting ports in VLAN ...\n"
		if (!$quiet);
	    my $perrors = $stack->setPortVlan($device_id, @ports);
	    if (!$quiet) {
		print "VLAN change ";
		print $perrors? "failed":"succeeded",".\n";
	    }
	    $errors += $perrors;
	}
    } else {
	print "Creating VLAN $target_vlan ...\n"
	    if (!$quiet);
	my $vlan_number = $stack->createVlan($device_id, $target_vlan->lanid(),
					     \@ports,\%pvlanArgs);
	if (!$quiet) {
	    print "VLAN creation ";
	    print $vlan_number? "succeeded":"failed",".\n";
	}
	if (!$vlan_number) {
	    #
	    # Do not leave a partially created vlan.
	    # 
	    if (!$stack->removeVlan($device_id)) {
		print STDERR "*** Could not remove failed vlan: $device_id\n";
	    }
	    $errors++;
	}

    }
    if ($errors) {
	$errors++;
    }
    else {
	if (defined($source_vlan) && !$source_vlan->SameVlan($target_vlan) &&
	    $source_vlan->KeepInSync()) {
	    # Have to do this cause setPortVlan does not.
	    if (!$opt{'whol-magic'} &&
		!$stack->setVlanOnSwitchTrunks($source_vlan->lanid(), 1)) {
		print STDERR "Could not enable switch trunks on $source_vlan\n";
		$errors++;
	    }
	    # This stores the newly computed switch trunk path in the lans
	    # table entry.
	    setSwitchTrunkPath($source_vlan);
	    if (VLan->RecordVlanInsertion($source_vlan, $stack->{STACKID})) {
		print "Could not record vlan insertion for $source_vlan\n";
		$errors++;
	    }
	}
	if (defined($target_vlan) && $target_vlan->KeepInSync()) {
	    # Have to do this cause we cleared it above
	    if (!$opt{'whol-magic'} &&
		!$stack->setVlanOnSwitchTrunks($target_vlan->lanid(), 1)) {
		print STDERR "Could not enable switch trunks on $target_vlan\n";
		$errors++;
	    }
	    # This stores the newly computed switch trunk path in the lans
	    # table entry. 
	    setSwitchTrunkPath($target_vlan);
	    if (VLan->RecordVlanInsertion($target_vlan, $stack->{STACKID})) {
		print "Could not record vlan insertion for $target_vlan\n";
		$errors++;
	    }
	}
    }
    return $errors;
}

#
# Delete the given VLAN, if it exists
#
sub doDeleteVlan($@) {
    my $stacks = shift;
    my @vlan_names = @_;
    my %vlans  = ();
    my $errors = 0;

    #
    # We require a VLan object for all vlans related to experiments.
    #
    if (defined($experiment)) {
	foreach my $vlan_name (@vlan_names) {
	    my $vlan;
	    if ($vlan_name =~ /^\d*$/) {
	       $vlan = VLan->Lookup($vlan_name);
	    }
	    else {
	       $vlan = VLan->Lookup($experiment, $vlan_name);
	    }
	    if (defined($vlan) && !$opt{'f'} &&
		!$experiment->SameExperiment($vlan->GetExperiment())) {
		die("$vlan is not in the correct experiment\n");
	    }
	    if (!defined($vlan) && !$opt{'f'}) {
		die("VLan object for $vlan_name does not exist\n");
	    }
	    if (defined($vlan) && $vlan->GetAliases()) {
		die("$vlan has aliases; cannot delete before aliases\n");
	    }
	    if (defined($vlan) && $vlan->IsShared()) {
		die("$vlan is shared; cannot delete while shared\n");
	    }
	    # Allow deletion by name without vlan object, by force only.
	    $vlans{$vlan_name} = $vlan || $vlan_name;
	}
    }
    else {
	#
	# We no longer allow vlans to be created without an experiment.
	# Use the -f option, which tells snmpit to use internal experiment.
	#
	die("Cannot use -o option without experiment or -f option\n");
    }

    #
    # Hand over to outer boss.
    # If experiment was specified, list is vlan names (manual invocation).
    # 
    if ($ELABINELAB) {
	foreach my $vlan (values(%vlans)) {
	    if (RemoteDeleteVlan($vlan, $opt{C}) == 0) {
		if (ref($vlan) && $vlan->Destroy() != 0) {
		    print STDERR "*** Could not destroy $vlan\n";
		}
	    }
	    else {
		$errors++;
	    }
	}
	return $errors;
    }

    #
    # We do not do this enough to worry about optimizing it.
    #
    foreach my $key (keys(%vlans)) {
	my $vlan  = $vlans{$key};
	my $error = 0;
	my $vlan_name;
	my $vlan_id;

	foreach my $stack (@$stacks) {
	    #
	    # To maintain backwards compatibility with how snmpit used
	    # to operate, "internal" vlans are (sometimes) named on the
	    # switch by the symbolic name instead of the lanid. 
	    #
	    if (ref($vlan)) {
		if ($vlan->IsInternal() && $stack->vlanExists($vlan->vname())) {
		    $vlan_name = $vlan->vname();
		}
		else {
		    $vlan_name = $vlan->id();
		}
		$vlan_id   = $vlan->id();
	    }
	    else {
		$vlan_name = $vlan_id = $vlan;
	    }

	    next
		if (! $stack->vlanExists($vlan_name));
		
	    print "Deleting VLAN $vlan from $stack ...\n"
		if (!$quiet);

	    my $ok = $stack->removeVlan($vlan_name);
	    if (!$quiet) {
		print "VLAN deletion on $stack ";
		print $ok? "succeeded":"failed",".\n";
	    }
	    if (!$ok) {
		print "*** $vlan was not deleted from $stack\n";
		$error++;
	    }
	}
	# Do not delete DB state if we failed to remove it.
	if ($error) {
	    $errors++;
	    next;
	}
	
	VLan->RecordVLanDeletion($vlan_id) == 0
	    or $errors++;

	VLan::ClearReservedVlanTag($vlan_id) == 0 or $errors++
	    if ($opt{C} || (ref($vlan) && $vlan->IsManual()));

	next
	    if (!ref($vlan));
	
	if ($vlan->IsManual()) {
	    $vlan->Destroy() == 0
		or $errors++;
	}
    }
    return $errors;
}

#
# Print the device-dependant VLAN number for a given named VLAN
#
sub doVlanNumber ($$) {

    my $stacks = shift;
    my $name = shift;
    my $found = 0;

    #
    # Allow the user to give us multiple stacks
    #
    foreach my $stack (@$stacks) {
        #
        # TODO: This is horrendously inefficient! But, it allows me to write
        # this function without requiring more from the switch/stack modules.
        # Once a specialized function has been added to the switch/stack API,
        # we should use it here.
        #
	my @vlanList = $stack->listVlans();
	foreach my $vlan (@vlanList) {
	    my ($id,$ddep,$memberref) = @$vlan;
            if ($id eq $name) {
                $found = 1;
                print "$name $stack->{STACKID} $ddep\n";
            }
	}
    }

    if ($found) {
        return 0; 
    } else {
        return 1;
    }

}

#
# Send $command to @ports.
# TODO: List of commands
#
sub doPortControl($$@) {
    my $stacks = shift;
    my $command = shift;
    my @ports = @_;
    my $errors;

    if ($ELABINELAB) {
	# As below, only one stack.
	my ($stack) = @$stacks;
	$errors = RemoteDoPortControl($stack,$command, @optports);
	goto finish;
    }

    if (@$stacks > 1) {
	die "Port control accross multiple stacks is not yet supported\n" .
	    "Stacks are " . join(", ",map {$_->{STACKID}} @$stacks) . "\n";
    }
    my ($stack) = @$stacks;

    print "Applying command '$command' to ports " . Port->toStrings(@ports) . " ...\n"
	if (!$quiet);
    $errors = $stack->portControl($command,@ports);
    if (!$quiet) {
	print "Port command ";
	print $errors? "failed":"succeeded",".\n";
    }
  finish:
    return $errors
	if ($errors);
    if ($command eq "enable" || $command eq "disable") {
	foreach my $port (@ports) {
	    setPortEnabled($port, ($command eq "enable" ? 1 : 0));
	}
    }
    return $errors;

}

#
# Remove all VLANs from the switch, and re-create them from the database
# tables.
#
sub doRecreateVlans($) {
    my $stacks = shift;

    #
    # Make sure the user REALLY wants to do this
    #

    if (!TBAdmin()) {
	warn "Sorry, only admins get to use this function\n";
	return 0;
    }

    warn "WARNING: Using this function will cause all VLANS to be\n";
    warn "deleted and re-created. This will cause temporary disruption,\n";
    warn "and you will lose all hand-created VLANs. This function operates\n";
    warn "on ALL experimental switches.\n";
    warn "\nAre you SURE you want to do this? (yes/no)\n";

    my $doit = <>;

    if (!($doit =~ /^y/i)) {
	warn "Not recreating VLANs\n";
	return 0;
    } else {
	warn "Okay, recreating VLANs\n";
    }

    #
    # Get a list of all VLANs on all of the given switches, so that we can
    # nuke them.
    #
    my @vlansToNuke = ();
    foreach my $stack (@$stacks) {
	my @stackVlans = $stack->listVlans();
	foreach my $vlan (@stackVlans) {
	    my $id = $$vlan[0];
	    #
	    # Special case - don't try to delete the 'switch-control' VLAN,
	    # because that's the one we're talking to the switches on.
	    #
	    if ($id ne 'switch-control') {
		push (@vlansToNuke,$id);
	    }
	}
    }

    debug("Going to nuke " . join(',',@vlansToNuke) . "\n");

    doDeleteVlan($stacks,@vlansToNuke);

    #
    # Get a list of all experiments, so that we can re-create their VLANs
    #
    my @experiments = Experiment->AllActive();
    foreach my $experiment (@experiments) {
	my @vlans = getExperimentVlans($experiment->pid(), $experiment->eid());
	
	doVlansFromTables($experiment, $stacks, @vlans)
	    if (@vlans);
    }
    return 1;
}

#
# Enable trunking on a port, and enable a set of VLANs on it 
#
sub doTrunkEnable($$$@) {
    my $stacks = shift;
    my $port = shift;
    my $equaltrunking = shift;
    my @vlans = @_;
    my $errors = 0;


    if ($ELABINELAB) {
	my $mode = $equaltrunking ? "-E" : "-T";
	# As below, only one stack.
	my ($stack) = @$stacks;	
	$errors = RemoteDoTrunking($stack,$mode,$optports[0],@vlans);
	goto finish;
    }
    #
    # Sanity checking
    #
    if (@$stacks != 1) {
	die "Enabling trunk ports should only involve one stack\n" .
	    "Stacks are " . join(",",@$stacks) . "\n";
    }

    #
    # Simple, just call the right function on the stack
    #
    my $stack = $$stacks[0];
    print "Enabling " . ($equaltrunking ? "equal" : "dual") .
	" trunking (tagging) on $port" . (@vlans ? " @vlans" : "") . "\n"
	if (!$quiet);
    if (!$stack->enableTrunking2($port,$equaltrunking,@vlans)) {
	$errors++;
    }
  finish:
    setPortTagged($port, 1)
	if (!$errors);
    return $errors;
}

#
# Disable trunking on a port
#
sub doTrunkDisable($$) {
    my $stacks = shift;
    my $port = shift;
    my $errors = 0;

    if ($ELABINELAB) {
	my @vlans=();
	# As below, only one stack.
	my ($stack) = @$stacks;
	$errors = RemoteDoTrunking($stack,"-U",$optports[0],@vlans);
	#$errors = RemoteDoTrunking($stack,"-U",$port,@vlans);
	goto finish;
    }
    #
    # Sanity checking
    #
    if (@$stacks != 1) {
	die "Disabling trunk ports should only involve one stack\n" .
	    "Stacks are " . join(",",@$stacks) . "\n";
    }

    #
    # Simple, just call the right function on the stack
    #
    my $stack = $$stacks[0];
    print "Disabling trunking (tagging) on port ".$port->toString()." ...\n"
	if (!$quiet);
    if (!$stack->disableTrunking($port)) {
	$errors++;
    }
  finish:
    setPortTagged($port, 0)
	if (!$errors);
    return $errors;
}
 
#
# Simple little list filtering util function.
#
sub filterList($$) {
    my ($srclist,$filterlist) = @_;
    my @retval = ();

    foreach my $item (@$srclist) {
	my $found = 0;
	foreach my $filter (@$filterlist) {
	    if ($item eq $filter) {
		$found = 1;
		last;
	    }
	}
	push @retval, $item 
	    if (!$found);
    }

    return @retval;
}

#
# Openflow lock and functions
# 
my $of_lock_held = 0;

sub oflock() {
    if (snmpit_lock("of_snmpit")) {
	die("Could not get the snmpit lock");
    }
    $of_lock_held = 1;
}

sub ofunlock() {
    if ($of_lock_held) { snmpit_unlock("of_snmpit"); $of_lock_held = 0;}
}

#
# doOpenflowEnable(stacks, vlan)
# Enable Openflow on a VLAN
#
sub doOpenflowEnable($$) {
    my $stacks = shift;
    my $vlan = shift;
    my $errors = 0;

    #
    # Enabling Openflow on each stack
    #
    print "Enabling Openflow on VLAN $vlan ...\n"
	if (!$quiet);
    foreach my $stack (@$stacks) {
	$errors += $stack->enableOpenflow($vlan);	
    }

    if (!$errors) {
	print "Done! \n" if (!$quiet);
    }
    
    return $errors;
}

#
# doOpenflowDisable(stack, vlan)
# Disable Openflow on a VLAN
#
sub doOpenflowDisable($$) {
    my $stacks = shift;
    my $vlan = shift;
    my $errors = 0;

    #
    # Disabling Openflow on each stack
    #
    print "Disabling Openflow on VLAN $vlan ...\n"
	if (!$quiet);
    foreach my $stack (@$stacks) {
	$stack->FlipDebug(1);
	$errors += $stack->disableOpenflow($vlan);	
    }
             
    #
    # TODO:clear controllers/listeners here. Now in HP stack code.
    #

    if (!$errors) {
	print "Done! \n" if (!$quiet);
    }
    
    return $errors;
}

#
# doSetOpenflowController(stack, vlan, controller)
# Set controller for an Openflow-enabled VLAN
#
sub doSetOpenflowController($$$;$) {
    my $stacks = shift;
    my $vlan = shift;
    my $controller = shift;
    my $option = shift if (@_);
    my $errors = 0;

    # Always enable this on geniracks for now.
    $option = "fail-secure"
	if ($GENIRACK && !defined($option));

    #
    # Set controller on each stack
    #
    print "Set controller for VLAN $vlan ...\n"
	if (!$quiet);
    foreach my $stack (@$stacks) {
        $errors += $stack->setOpenflowController($vlan, $controller, $option);
    }
    
    if (!$errors) {
	print "Done! \n" if (!$quiet);
    }

    return $errors;
}

#
# doSetOpenflowListener(stack, vlan, listener)
# Set listener for an Openflow-enabled VLAN
#
sub doSetOpenflowListener($$$) {
    my $stacks = shift;
    my $vlan = shift;
    my $listener = shift;
    my $errors = 0;

    #
    # Set controller on each stack
    #
    print "Set listener for VLAN $vlan ...\n"
	if (!$quiet);
    foreach my $stack (@$stacks) {
	$errors += $stack->setOpenflowListener($vlan, $listener);	
    }

    if (!$errors) {
	print "Done! \n" if (!$quiet);
    }

    return $errors;
}

#
# doEnableOpenflowListener(stacks, vlan)
# enable openflow listener on the given VLAN
# this function prints out the connection string of the listener
#
sub doEnableOpenflowListener($$) {
    my $stacks = shift;
    my $vlan = shift;

    my %usedports = ();
    my $port = $minOpenflowListenerPort;
    my $errors = 0;
    my $set_ok = 0;
    my $listenerConnStr;

    #
    # get used ports
    #
    # Here a big lock is better than many small locks, it avoids dead locks
    # because multiple small locks have to be held one by one, which
    # brings the risk of dead lock.
    #
    oflock();
    foreach my $stack (@$stacks) {
        my %tmports = $stack->getUsedOpenflowListenerPorts($vlan);
	@usedports{ keys %tmports } = values %tmports;
    }

    # get the available port
    while (defined($usedports{$port}) && $port <= $maxOpenflowListenerPort) {
	$port++;
    }
    
    if ($port > $maxOpenflowListenerPort) {
	print "ERROR: No port available for Openflow listener on VLAN $vlan. \n";
	$errors++;
    } else {
	#
	# set listener
	#
	$listenerConnStr = "ptcp:".$port;
        my $err = doSetOpenflowListener($stacks, $vlan, $listenerConnStr);
        if ($err == 0 && $set_ok == 0) {
            $set_ok = 1;
        }
    }

    if ($set_ok) {
        print "Openflow listener connection string for VLAN $vlan is $listenerConnStr \n";
    }

    ofunlock();
    
    #
    # update the vlan object with the new listener string
    # other openflow functions may also need this, especially doOpenflowEnable/doOpenflowDisable
    #
    my $vlaninst = VLan->Lookup($vlan);
    $vlaninst->SetAttribute('oflistener', $listenerConnStr, 'string');

    return $errors;
}

#
# Check for and delete stale vlans.
#
sub doPruneStaleVlans($)
{
    my $stacks = shift;
    my $errors = 0;
    my $empty;

    my $deletestalevlans = sub {
	my ($id, @devices) = @_;

	my $command = "$TB/bin/snmpit --deletestalevlans ";
	$command .= "--impotent "
	    if ($impotent);
	$command .= "-i " . join(" -i ", @devices);
	$command .= " '$id'";

	print "  Invoking: '$command'\n";

	my $child_pid = open(PIPE, "-|");
	if (!defined($child_pid)) {
	    print STDERR "popen failed!\n";
	    return 1;
	}
	if ($child_pid) {
	    while (<PIPE>) {
		print "  " . $_;
	    }
	    close(PIPE);
	}
	else {
	    open(STDERR, ">&STDOUT");
	    exec($command);
	    die("Exec failure\n");
	}
    };

    if ($ELABINELAB) {
	die "Not allowed to do this inside an ELABINELAB\n";
    }
    #
    # Sanity checking
    #
    if (@$stacks != 1) {
	die "Disabling trunk ports should only involve one stack\n" .
	    "Stacks are " . join(",",@$stacks) . "\n";
    }
    my $stack  = @$stacks[0];

    if (0) {
	$stack->checkVlanConsistency(1581964, 0);
	return 0;
    }
    my $leader = getStackLeader($stack->{STACKID});
    if (!defined $leader) {
        die "Unable to get stack leader for $stack->{STACKID}\n";
    }
    my $switch_options = getDeviceOptions($leader);
    if (!defined $switch_options) {
        die "Unable to get stack leader for $stack->{STACKID}\n";
    }
    my $min_vlan = $switch_options->{'min_vlan'};
    my $max_vlan = $switch_options->{'max_vlan'};
    my %vlans;
    my @vlanList = @$stacks[0]->listVlans(\$empty);

    #
    # First check consistency of existing vlans. Cleaning those up first
    # will take care of a lot of the stale vlans.
    #
    foreach my $vlan (@vlanList) {
	my ($id,$tag,$memberref) = @$vlan;
	
	next
	    if ($id !~ /^\d+$/);

	my $vlan = VLan->Lookup($id);
	if (defined($vlan)) {
	    my $tag = getReservedVlanTag($id);
	    if ($tag) {
		print "Checking vlan $id ($tag) consistency.\n";
		if ($stack->checkVlanConsistency($id, !$impotent)) {
		    if (!$impotent) {
			next;
		    }
		}
	    }
	}
    }

    #
    # Now reload and and do a second pass.
    #
    @vlanList = @$stacks[0]->listVlans(\$empty);
    
    foreach my $vlan (@vlanList) {
	my ($id,$tag,$memberref) = @$vlan;

	#
	# If we get back a tag and and the name is "Vlan XXX" then this
	# is a dangling vlan.
	#
	if ($id !~ /^\d+$/) {
	    if ($id =~ /^Vlan (\d+)$/ && $1 != 1) {
		print "Orphan VLAN '$id' ($tag)\n";
		if (@$memberref) {
		    print "  Ports: ";
		    foreach my $member (@$memberref) {
			my $port = Port->Triple2Iface($member);
			if (defined($port)) {
			    print $port;
			}
			else {
			    print $member;
			}
			print " ";
		    }
		    print "\n";
		}
		if (exists($empty->{$id})) {
		    print "  But some devices have this vlan but no members: ";
		    print join(",", @{$empty->{$id}}) . "\n";
		    &$deletestalevlans($id, @{$empty->{$id}});
		}
	    }
	    next
	}
	${$vlans{$id}}[0] = $tag;
        push @{${$vlans{$id}}[1]}, @$memberref;
    }
    my @sorted = sort {tbsort($a,$b)} keys %vlans;

    foreach my $vlan_id (@sorted) {
        my $vlan;
	my ($tag,$memberref) = @{$vlans{$vlan_id}};

	if ($vlan_id =~ /^\d*$/) {
	    $vlan = VLan->Lookup($vlan_id);
	}
        else {
	    debug("Skipping non-numeric VLAN: $vlan_id ($tag)\n");
	    next;
	}
	if (!defined($vlan)) {
	    my $delete = 1;
	    
	    print("No such VLAN $vlan_id ($tag) in lans table.\n");
	    if (@$memberref) {
		print "  Ports: ";
		foreach my $member (@$memberref) {
		    my $port = Port->Triple2Iface($member);
		    if (defined($port)) {
			print $port;
		    }
		    else {
			print $member;
		    }
		    print " ";
		}
		print "\n";
	    }
	    my $vlantablerow = VLan->FindTableEntryByLanid($vlan_id);
	    if (defined($vlantablerow)) {
		my $pid = $vlantablerow->{'pid'};
		my $eid = $vlantablerow->{'eid'};
		
		print("  there is a vlan table entry: $pid,$eid,\n");
		my $experiment = Experiment->Lookup($vlantablerow->{'exptidx'});
		if (defined($experiment)) {
		    print "  and the experiment exists and is ";
		    if ($experiment->state() eq EXPTSTATE_ACTIVE() ||
			$experiment->state() eq EXPTSTATE_SWAPPING() ||
			$experiment->state() eq EXPTSTATE_ACTIVATING()) {
			print "active\n";
			$delete = 0;
		    }
		    else {
			print "inactive\n";
		    }
		}
		else {
		    print "  but the experiment does not exist.\n";
		}
	    }
	    my $vlantablerow2 = VLan->FindTableEntryByTag($tag);
	    if (defined($vlantablerow2) &&
		(!defined($vlantablerow) ||
		 $vlantablerow2->{'id'} != $vlantablerow->{'id'})) {
		my $pid = $vlantablerow2->{'pid'};
		my $eid = $vlantablerow2->{'eid'};
		
		print("  the tag is in use by: $pid,$eid,\n");
		my $experiment = Experiment->Lookup($vlantablerow2->{'exptidx'});
		if (defined($experiment)) {
		    print "  and the experiment exists and is ";
		    if ($experiment->state() eq EXPTSTATE_ACTIVE() ||
			$experiment->state() eq EXPTSTATE_SWAPPING() ||
			$experiment->state() eq EXPTSTATE_ACTIVATING()) {
			print "active\n";
			$delete = 0;
		    }
		    else {
			print "inactive\n";
		    }
		}
		else {
		    print "  but the experiment does not exist.\n";
		}
	    }
	    if ($delete) {
		print "  so we will delete VLAN $vlan_id ($tag)\n";
		if (!$impotent) {
		    if (!$stack->removeVlan($vlan_id)) {
			print STDERR "*** Could not remove vlan: $vlan_id\n";
			return -1;
		    }
		    #
		    # Also delete the vlan table rows since they reference
		    # experiments that no longer exist. Lets do
		    # reserved_vlantags too.
		    #
		    if (defined($vlantablerow)) {
			VLan->RecordVLanDeletion($vlantablerow->{'id'});
			VLan->DeleteReservedVlanTag($vlantablerow->{'id'});
		    }
		    if (defined($vlantablerow2)) {
			VLan->RecordVLanDeletion($vlantablerow2->{'id'});
			VLan->DeleteReservedVlanTag($vlantablerow2->{'id'});
		    }
		}
	    }
	    else {
		print "  so we will keep the entry.\n";
		if (exists($empty->{$vlan_id})) {
		    print "  But some devices have this vlan but no members: ";
		    &$deletestalevlans($vlan_id, @{$empty->{$vlan_id}});
		}
	    }
	}
    }
    return 0;
}

#
# Set vlans on the trunks it needs to span switches.
#
sub doSetVlanOnTrunks($$@) {
    my $stacks = shift;
    my $op = shift;
    my @vlans = @_;
    my $errors = 0;

    my $reset = ($op eq "resetvlanontrunks" ? 1 : 0);
    my $clear = ($op eq "clearvlanontrunks" ? 1 : 0);

    if ($ELABINELAB) {
	print STDERR "doSetVlanOnTrunks: not in ELABINELAB!\n";
	return 1;
    }
    if (@$stacks != 1) {
	die "setvlanontrunks should only involve one stack\n" .
	    "Stacks are " . join(",",@$stacks) . "\n";
    }
    my $stack = $$stacks[0];

    foreach my $vlanid (@vlans) {
	if ($reset || $clear) {
	    print "Clearing vlan $vlanid on trunks\n";
	    if (! $stack->setVlanOnSwitchTrunks($vlanid, 0)) {
		print STDERR "*** could not clear vlan $vlanid on trunks\n";
		$errors++;
		next;
	    }
	    # requested just a clear operation.
	    next
		if ($clear);
	}
	print "Setting vlan $vlanid on trunks\n";
	if (! $stack->setVlanOnSwitchTrunks($vlanid, 1)) {
	    print STDERR "*** could not set vlan $vlanid on trunks\n";
	    $errors++;
	    next;
	}
    }
    return $errors;
}

#
# Remove vlan id from specfic devices. This is used as a cleanup operation
# only when a stale vlan_id/tag exists on a device but with no members. We
# have no way to clean this up, except to log into the switch (and be
# familiar with the switch CLI).
#
sub doDeleteStaleVlansFromDevices($@) {
    my $stacks = shift;
    my @vlans = @_;
    my $errors = 0;

    if ($ELABINELAB) {
	print STDERR "doDeleteStaleVlansFromDevices: not in ELABINELAB!\n";
	return 1;
    }
    if (@$stacks != 1) {
	die "doDeleteStaleVlansFromDevices should only involve one stack\n" .
	    "Stacks are " . join(",",@$stacks) . "\n";
    }
    my $stack = $$stacks[0];
    my @existant_vlans = $stack->existantVlans(@vlans);
    if (!@existant_vlans) {
	print "Cannot find any of the vlans on supplied devices\n";
	return 1;
    }
    if ($impotent) {
	print "Would remove @existant_vlans from devices\n";
	return 0;
    }

    if (!$stack->removeVlan(@existant_vlans)) {
	#
	# Find out what still exists.
	#
	foreach my $vlan_id (@existant_vlans) {
	    if ($stack->vlanExists($vlan_id)) {
		print "  $vlan_id was not deleted.\n";
	    }
	}
	$errors++;
    }
    return $errors;
}

