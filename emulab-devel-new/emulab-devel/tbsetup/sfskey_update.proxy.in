#!/usr/bin/perl -wT
#
# Copyright (c) 2000-2002 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
use English;
use Getopt::Std;

#
# Manage the sfs_users files remotely from boss. The keys to change are
# passed in via stdin. Must use locking of course.
#
sub usage()
{
    print "Usage: sfskey_update.proxy\n";
    exit(-1);
}
my  $optlist = "";

#
# Configure variables
#
my $TB      = "@prefix@";
my $TBOPS   = "@TBOPSEMAIL@";

#
# Locals
#
my $tmpkey  = "/var/tmp/sfs_users";
my $tmppub  = "/var/tmp/sfs_users.pub";
my $realkey = "/etc/sfs/sfs_users";
my $realpub = "/etc/sfs/sfs_users.pub";
my @newkeys = ();

# un-taint path
$ENV{'PATH'} = '/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

# Turn off line buffering on output
$| = 1; 

#
# We don't want to run this script unless its the real version.
#
if ($UID != 0) {
    die("*** $0:\n".
	"    Must be root! Maybe the wrong version?\n");
}

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV != 0) {
    usage();
}

#
# Take in our input and stash it. First field is the unique key.
#
while (<STDIN>) {
    chomp();
    push(@newkeys, $_);
}

if (! @newkeys) {
    print STDERR "No keys! Exiting ...\n";
    exit(0);
}

#
# Create two temp files, one for the key file and one for the pub file.
#
system("rm -f $tmpkey $tmppub") == 0
    or fatal("Could not remove old tmp files");
	     
my $oldmask = umask(0077);
open(OUTKEY, "> $tmpkey")
    or fatal("Could not open $tmpkey: $!");
umask(0022);
open(OUTPUB, "> $tmppub")
    or fatal("Could not open $tmppub: $!");
umask($oldmask);

print OUTKEY "#\n";
print OUTKEY "# This file is autogenerated from boss. DO NOT EDIT!\n";
print OUTKEY "#\n";
print OUTPUB "#\n";
print OUTPUB "# This file is autogenerated from boss. DO NOT EDIT!\n";
print OUTPUB "#\n";

#
# Parse each input line, separating the various sections (by colon).
#
foreach my $key ( @newkeys ) {
    if (! ($key =~ /^(.*):(.*):(.*):(.*):(.*)$/)) {
	print STDERR "Bad key line: $key\n";
	next;
    }

    print OUTKEY "$1:$2:$3:$4:$5\n";
    print OUTPUB "$1:$2:$3::\n";
}
close(OUTKEY)
    or fatal("Error closing $tmpkey: $!");
close(OUTPUB)
    or fatal("Error closing $tmppub: $!");

#
# Back up old ones and move new ones into place.
#
system("cp -pf $realkey ${realkey}.old") == 0
    or fatal("Could not backup $realkey");
system("cp -pf $realpub ${realpub}.old") == 0
    or fatal("Could not backup $realpub");
system("mv -f $tmpkey $realkey") == 0
    or fatal("Could not install $realkey");
system("mv -f $tmppub $realpub") == 0
    or fatal("Could not install $realpub");

exit(0);

#
# Caller will catch error and send email.
# 
sub fatal {
    local($msg) = $_[0];

    die("*** $0:\n".
	"    $msg\n");
}

