#!/usr/bin/perl -w
#
# Copyright (c) 2008-2020 University of Utah and the Flux Group.
# 
# {{{GENIPUBLIC-LICENSE
# 
# GENI Public License
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and/or hardware specification (the "Work") to
# deal in the Work without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Work, and to permit persons to whom the Work
# is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Work.
# 
# THE WORK IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS
# IN THE WORK.
# 
# }}}
#
use strict;
use English;
use Getopt::Std;
use Data::Dumper;
use Date::Parse;
use POSIX qw(strftime);

#
# Look for things that need to be expired and resources released. This is
# incredibly primitive at the moment.
#
# Also TODO. On the clearinghouse we also want to expire things in the
# the geni-ch DB.
# 
sub usage()
{
    print "Usage: expire_daemon [-d] [-i]\n";
    exit(1);
}
my $optlist   = "dnis";
my $debug     = 0;
my $idlecheck = 0;
my $impotent  = 0;
my $oneshot   = 0;

#
# Configure variables
#
my $TB		  = "@prefix@";
my $TBOPS         = "@TBOPSEMAIL@";
my $TBLOGS        = "@TBLOGSEMAIL@";
my $TBAUTOMAIL    = "@TBAUTOMAILEMAIL@";
my $PGENIDOMAIN   = "@PROTOGENI_DOMAIN@";
my $OURDOMAIN     = "@OURDOMAIN@";
my $PGENISUPPORT  = @PROTOGENI_SUPPORT@;
my $CLUSTER_PORTAL= "@CLUSTER_PORTAL@";
my $LOGFILE       = "$TB/log/expire_daemon.log";
my $IDLETIMES	  = "$TB/sbin/idletimes";
my $EMULAB_PEMFILE = "$TB/etc/genicm.pem";
my $REGISTER      = "$TB/sbin/protogeni/register_sliver";
my $TRIGGERUPDATE = "$TB/sbin/protogeni/triggerimageupdate";
my $POSTIMAGEDATA = "$TB/sbin/protogeni/postimagedata";
my $DELETEIMAGEDATA = "$TB/sbin/protogeni/deleteimagedata";
my $IMPORTER      = "$TB/sbin/image_import";
my $CLEANUPSLICE  = "$TB/sbin/cleanupslice";
my $CLEANUPTICKET = "$TB/sbin/cleanupticket";
my $MYSAURN       = "urn:publicid:IDN+@OURDOMAIN@+authority+sa";
my $SLEEP_INTERVAL= 60;

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin:/usr/site/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

# Protos
sub fatal($);
	  
#
# Turn off line buffering on output
#
$| = 1; 

if ($UID != 0) {
    fatal("Must be root to run this script\n");
}

#
# Exit if not a protogeni site.
#
if (! $PGENISUPPORT) {
    exit(0);
}

#
# Check args early so we get the right DB.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $debug++;
}
if (defined($options{"i"})) {
    $idlecheck = 1;
}
if (defined($options{"s"})) {
    $oneshot = 1;
}
if (defined($options{"n"})) {
    $impotent = 1;
}

# Do this early so that we talk to the right DB.
use vars qw($GENI_DBNAME);
$GENI_DBNAME = "geni-cm";

# Load the Testbed support stuff.
use lib "@prefix@/lib";
use emdb;
require GeniDB;
require GeniUtil;
require GeniTicket;
require GeniSlice;
require GeniCM;
require GeniCertificate;
require GeniCredential;
require GeniAggregate;
require Genixmlrpc;
require GeniImage;
use GeniResponse;
use Experiment;
use EmulabConstants;
use Node;
use libtestbed;
use emutil;
use libEmulab;
use Logfile;
use Project;
use OSImage;

#
# So we know who/what we are acting as.
#
my $certificate = GeniCertificate->LoadFromFile($EMULAB_PEMFILE);
if (!defined($certificate)) {
    fatal("Could not get uuid/urn from $EMULAB_PEMFILE\n");
}
Genixmlrpc->SetContext(Genixmlrpc->Context($certificate));
Genixmlrpc->SetTimeout(10);
$ENV{'MYUUID'} = $certificate->uuid();
$ENV{'MYURN'} = "urn:publicid:IDN+@OURDOMAIN@+authority+cm";

if (!$oneshot) {
    if (!$impotent && CheckDaemonRunning("expire_daemon")) {
	fatal("Not starting another expire daemon!");
    }
    # Go to ground.
    if (! $debug) {
	if (TBBackGround($LOGFILE)) {
	    exit(0);
	}
    }
    if (!$impotent && MarkDaemonRunning("expire_daemon")) {
	fatal("Could not mark daemon as running!");
    }
}
#
# Setup a signal handler for newsyslog.
#
sub handler()
{
    my $SAVEEUID = $EUID;
    
    $EUID = 0;
    ReOpenLog($LOGFILE);
    $EUID = $SAVEEUID;
}
$SIG{HUP} = \&handler
    if (! ($debug || $oneshot));

GeniUtil::FlipToGeniUser();

#
# Look for tickets.
#
sub ExpireTickets()
{
    my $query_result =
	GeniDB::DBQueryWarn("select idx from geni_tickets ".
			    "where UNIX_TIMESTAMP(now()) > ".
			    "      UNIX_TIMESTAMP(redeem_before)");

    while (my ($idx) = $query_result->fetchrow_array()) {
	my $ticket = GeniTicket->Lookup($idx);

	if (!defined($ticket)) {
	    # Ticket is gone, lets not worry.
	   next;
	}
	if ($ticket->Lock() != 0) {
	    print STDERR "Could not lock ticket $ticket\n";
	    goto skip;
	}
	my $slice = $ticket->slice();
	#
	# Lock the slice from further access.
	#
	if ($slice->Lock() != 0) {
	    $ticket->UnLock();
	    print STDERR "Could not lock ticket slice $slice\n";
	    goto skip;
	}
	my $experiment = $slice->GetExperiment();
	if (!defined($experiment)) {
	    $ticket->UnLock();
	    $slice->UnLock();
	    print STDERR "Could not get experiment for $ticket\n";
	    goto skip;
	}
	my $ticket_idx = $ticket->idx();
	    
	print "Expiring ticket $ticket\n";
	my $output = emutil::ExecQuiet("$CLEANUPTICKET -f $ticket_idx");
	my $status = $?;
	my $logfile = Logfile->CreateFromString($experiment->gid_idx(),
						$output);
	if (defined($logfile)) {
	    $logfile->SetMetadata([["ticket_idx",  $ticket->idx()],
				   ["slice_idx",   $slice->idx()],
				   ["slice_urn",   $slice->urn()],
				   ["slice_uuid",  $slice->uuid()],
				   # For web interface listing
 				   ["Method",     "CleanupTicket"],
				  ], 1);
	    $logfile->Store();
	}
	if ($status) {
	    print STDERR "Could not delete $ticket\n";
	    SENDMAIL($TBOPS, "Could not delete ticket $idx",
		     "Could not delete ticket $ticket\nfor $slice");
	    # We leave it locked.
	}
	else {
	    print STDERR "$ticket has been deleted\n";
	    $slice->UnLock();
	}
      skip:
	$ticket->Flush()
	    if (defined($ticket));
	$slice->Flush()
	    if (defined($slice));
	$experiment->Flush()
	    if (defined($experiment));
    }
}

#
# Keep track of who has been warned. Do not expire until 24 hours after
# warning.
#
my %warned  = ();
my %expires = ();
my $hours   = 24;
my $grace   = $hours * 3600;
# Always warn within an hour of expiration, even short lived slices.
my $minwarn = 3600;

#
# Send out warnings about 24 hours ahead of time.
#
sub WarnSlices()
{
    my $query_result =
	GeniDB::DBQueryWarn("select idx,expires,UNIX_TIMESTAMP(expires), ".
			    "   UNIX_TIMESTAMP(created) ".
			    "  from geni_slices ".
			    "where shutdown is null and ".
			    "      hosed=0 and lockdown=0 and isplaceholder=0");

    while (my ($idx,$expires,$stamp,$created) =
	   $query_result->fetchrow_array()) {
	my $slice = GeniSlice->Lookup($idx);
	if (!defined($slice)) {
	    # Slice is gone, lets not worry.
	    delete($expires{$idx});
	    delete($warned{$idx});
	    next;
	}
	#
	# This stops us from expiring portal based experiments, the
	# Portal will fire the DeleteSlice() operation when it decides to.
	# Only some sites get this (Fixed Endpoints, Buses).
	#
	if (@PROTOGENI_NOPORTALEXPIRE@ && defined($slice->portal_tag()) &&
	    defined($slice->speaksfor_urn())) {
	    if ($slice->speaksfor_urn() eq $MYSAURN ||
		$slice->speaksfor_urn() eq $GeniUtil::MOTHERSHIP_SAURN) {
  		goto skip;
	    }
	}
	if (exists($expires{$idx})) {
	    #
	    # We use expires to mark first warning, and to indicate that
	    # the user changed the expiration time since the that first
	    # warning.
	    #
	    if ($expires{$idx} != $stamp) {
		# Expiration changed, delete and catch in the next loop
		print STDERR "Expiration changed for slice $idx to $expires\n";
		delete($expires{$idx});
		delete($warned{$idx});
		next;
	    }
	    # Already warned. We skip after first warning, until within
	    # an hour of expiration, and then skip again after the second
	    # warning. The warned array marks the second warning.
	    next if
		(exists($warned{$idx}));

	    # Waiting to send out second warning. 
	    next 
		if ($stamp - time() > $minwarn);
	}
	#
	# If expiration is greater then 24 hours out, skip. 
	#
	#print STDERR "$stamp, $created, $grace, ". time() . "\n";

	if ($stamp > time() + $grace) {
	    delete($expires{$idx});
	    delete($warned{$idx});
	    next;
	}
	if ($slice->Lock() != 0) {
	    print STDERR "Could not lock slice $slice.\n";
	    goto skip;
	}

	# We want the aggregate for the sliver urn, but it might
	# not actually exist yet.
	my $aggregate = GeniAggregate->SliceAggregate($slice);
	if (!defined($aggregate)) {
	    print STDERR "No aggregate created yet for $slice\n";
	    $slice->UnLock();
	    goto skip;
	}
	my $geniuser  = GeniUser->Lookup($slice->creator_uuid(), 1);
	my $emailaddr = $geniuser->email();
	my $urn       = $slice->urn();
	my $hrn       = $slice->hrn();
	my $sliver_urn= $aggregate->urn();
	my $diff      = $stamp - time();
	my $unit;
	if ($diff < 0) {
	    $diff = 0;
	    $unit = "minutes";
	}
	elsif ($diff < 60) {
	    $diff = POSIX::ceil($diff / 60);
	    $unit = "minutes";
	}
	else {
	    $diff = POSIX::ceil($diff / 3600);
	    $unit = "hours";
	}

	#
	# If nothing is in the expires array, then this is first warning. 
	#
	# If this was created in the last hour, skip the actual
	# email. Wait until the second warning. 
	#
	if (time() - $created < $minwarn) {
	    print STDERR "Skipping email for just created sliver $aggregate\n";
	    $expires{$idx} = $stamp;
	    $slice->UnLock();
	    goto skip;
	}
	
	if ($impotent) {
	    print STDERR
		"Would send mail to $geniuser: $idx,$hrn,$diff $unit\n";
	}
	else {
	    print STDERR
		"Sending mail to $geniuser about expiring sliver $aggregate\n";
	}
	if (!exists($expires{$idx})) {
	    print STDERR "--> This is first warning\n";
	    $expires{$idx} = $stamp;

	    #
	    # Watch for startup condition; we do not want to send two
	    # emails right away cause we started up close to expiraton
	    # time of a sliver.
	    #
	    if ($stamp - time() <= $minwarn) {
		print STDERR "--> And second warning\n";
		$warned{$idx} = time();
	    }
	}
	else {
	    print STDERR "--> This is second warning\n";
	    $warned{$idx} = time();
	}
	if (! $impotent) {
	    my $subject;
	    my $message;
	    if (!defined($slice->portal_tag())) {
		$subject = "Sliver expiring at $OURDOMAIN";
		$message = "Sliver $sliver_urn\n".
		    "from slice $urn,\n".
		    "is going to expire in approximately $diff $unit.\n\n".
		    "Please renew it".
		    " or let it expire if you are not using it anymore.\n";
	    }
	    else {
		my $tag = ucfirst($slice->portal_tag());
		my $url = $slice->portal_url();
		my $eid = $slice->portal_eid();
		$subject = "$tag portal experiment is expiring";
		$message = "Your $tag portal experiment $eid at $OURDOMAIN".
		    (defined($url) ?
		     ":\n\n" . "   $url" . "\n\n" : "\n") .
		    "is going to expire in approximately $diff $unit.\n\n".
		    "Please extend it".
		    " or let it expire if you are not using it anymore.\n";
	    }
	    SENDMAIL($emailaddr, $subject, $message, "$TBOPS");
	}
	$slice->UnLock();
      skip:
	$slice->Flush()
	    if (defined($slice));
    }
}

#
# Look for slices that need to be expired. Do not expire shutdown slices;
# Handled below, and we want to keep the record around.
#
sub ExpireSlices()
{
    my $query_result =
	GeniDB::DBQueryWarn("select idx from geni_slices where ".
			    " (UNIX_TIMESTAMP(now()) > ".
			    "     UNIX_TIMESTAMP(expires) or ".
			    "  (isplaceholder=1 and ".
			    "     (UNIX_TIMESTAMP(now()) - ".
			    "      UNIX_TIMESTAMP(created)) > 3600)) ".
			    " and shutdown is null and lockdown=0");

    while (my ($idx) = $query_result->fetchrow_array()) {
	my $slice = GeniSlice->Lookup($idx);

	if (!defined($slice)) {
	    # Slice is gone, lets not worry.
	    next;
	}
	#
	# This stops us from expiring portal based experiments, the
	# Portal will fire the DeleteSlice() operation when it decides to.
	# Only some sites get this (Fixed Endpoints, Buses).
	#
	if (@PROTOGENI_NOPORTALEXPIRE@ && defined($slice->portal_tag()) &&
	    defined($slice->speaksfor_urn())) {
	    if ($slice->speaksfor_urn() eq $MYSAURN ||
		$slice->speaksfor_urn() eq $GeniUtil::MOTHERSHIP_SAURN) {
  		goto skip;
	    }
	}
	if ($slice->Lock() != 0) {
	    print STDERR "Could not lock slice $slice.\n";
	    goto skip;
	}
	my $experiment = $slice->GetExperiment();
	if (!defined($experiment)) {
	    print STDERR "Could not get experiment for $slice. Expiring ...\n";
	    $slice->UnLock();
	    goto cleanup;
	}
	if ($experiment->Refresh() != 0) {
	    print STDERR "Could not flush $experiment\n";
	    $slice->UnLock();
	    goto skip;
	}
	if ($experiment->state() eq EXPTSTATE_PANICED()) {
	    print STDERR "Refusing to terminate a paniced experiment\n";
	    $slice->UnLock();
	    goto skip;
	}
	
	#
	# See if we have any local nodes. No point in using the idle
	# check if there are no nodes. 
	#
	if (0 && $idlecheck && !$slice->isplaceholder()) {
	    my @localnodes = ();
	    $experiment->LocalNodeListNames(\@localnodes);
	    if (@localnodes) {
		my $pid = $experiment->pid();
		my $eid = $experiment->eid();
		
		#
		# Use the idletimes program in summary mode to see if the
		# the nodes are idle. If they are then it gets swapped.
		# This is going to have to get more sophisticated.
		#
		print STDERR "Checking to see if $slice ($eid) is idle\n";
		system("$IDLETIMES -s $pid,$eid");
		if (! $?) {
		    $slice->UnLock();
		    goto skip;
		}
	    }
	    print STDERR "$slice ($experiment) is idle; releasing.\n";
	}
	else {
	    if ($slice->isplaceholder()) {
		print STDERR "Releasing placeholder $slice";
		print STDERR " - $experiment"
		    if (defined($experiment));
		print STDERR "\n";
	    }
	    else {
		print STDERR "Expiring $slice";
		print STDERR " - $experiment"
		    if (defined($experiment));
		print STDERR "\n";
	    }
	}
      cleanup:
	my $slice_uuid  = $slice->uuid();
	my $output = emutil::ExecQuiet("$CLEANUPSLICE -f -m $slice_uuid");
	my $status = $?;
	if (defined($experiment)) {
	    my $gid_idx = $experiment->gid_idx();
	    my $logfile = Logfile->CreateFromString($gid_idx, $output);
	    if (defined($logfile)) {
		$logfile->SetMetadata([["slice_idx",  $slice->idx()],
				       ["slice_urn",  $slice->urn()],
				       ["slice_uuid", $slice->uuid()],
				       # For web interface listing
				       ["Method",     "Cleanup"],
				      ], 1);
		$logfile->Store();
	    }
	}
	else {
	    print STDERR "$output\n";
	}
	if ($status) {
	    print STDERR "Could not release $slice\n";
	    SENDMAIL($TBOPS, "Could not release slice $slice",
		     "Could not release slice $slice");
	    # Leave it locked. 
	    goto skip;
	}
	delete($warned{"$idx"});
	delete($expires{"$idx"});
	$slice->UnLock();
      skip:
	$slice->Flush()
	    if (defined($slice));
	$experiment->Flush()
	    if (defined($experiment));
    }
}

#
# Terminate slices that are pending, see GeniCMV2::DeleteSlice().
#
sub TerminateSlices()
{
    my $query_result =
	GeniDB::DBQueryWarn("select idx from geni_slices ".
			    "where termination_pending is not null and ".
			    "      shutdown is null and isshutdown=0");

    while (my ($idx) = $query_result->fetchrow_array()) {
	my $slice = GeniSlice->Lookup($idx);
	my $aggregate;

	if (!defined($slice)) {
	    # Slice is gone, lets not worry.
	    next;
	}
	if ($slice->Lock() != 0) {
	    print STDERR "Could not lock slice $slice.\n";
	    goto skip;
	}
	$aggregate = GeniAggregate->SliceAggregate($slice);
	# This would be unusual, so call it quits.
	if (!defined($aggregate)) {
	    print STDERR "No aggregate for slice, skipping\n";
	    $slice->UnLock();
	    goto skip;
	}
	if (!$aggregate->Busy()) {
	    if (GeniCM::CleanupDeadSlice($slice, 1) != 0) {
		print STDERR "Could not terminate $slice\n";
		SENDMAIL($TBOPS, "Could not terminate slice",
			 "Could not terminate slice $slice");
	    }
	}
	else {
	    print STDERR "TerminateSlices: $slice is busy\n";
	}
	$slice->UnLock();
      skip:
	$slice->Flush()
	    if (defined($slice));
	$aggregate->Flush()
	    if (defined($aggregate));
    }
}

#
# Look for slices that need to be shutdown
#
sub ShutdownSlices()
{
    my $query_result =
	GeniDB::DBQueryWarn("select idx from geni_slices ".
			    "where shutdown is not null and isshutdown=0");

    while (my ($idx) = $query_result->fetchrow_array()) {
	my $slice = GeniSlice->Lookup($idx);

	if (!defined($slice)) {
	    # Slice is gone, lets not worry.
	    next;
	}
	if ($slice->Lock() != 0) {
	    print STDERR "Could not lock slice $slice.\n";
	    goto skip;
	}

	#
	# The isshutdown flag avoids churning the system.
	#
	if (GeniCM::CleanupDeadSlice($slice, 0) != 0) {
	    print STDERR "Could not shutdown $slice\n";
	    SENDMAIL($TBOPS, "Could not shutdown slice",
		     "Could not shutdown slice $slice");
	}
	$slice->SetShutdownFlag(1);
	$slice->UnLock();
      skip:
	$slice->Flush()
	    if (defined($slice));
    }
}

#
# Look for slices that need to be registered.
#
sub RegisterSlices()
{
    # Only toplevel aggregates. 
    my $query_result =
	GeniDB::DBQueryWarn("select idx from geni_aggregates ".
			    "where type='Aggregate' and registered is null");

    while (my ($idx) = $query_result->fetchrow_array()) {
	my $aggregate = GeniAggregate->Lookup($idx);

	if (!defined($aggregate)) {
	    # aggregate is gone, lets not worry.
	    next;
	}
	my $slice = $aggregate->GetSlice();
	if (!defined($slice)) {
	    # slice is gone, lets not worry.
	    $aggregate->Flush();
	    next;
	}
	# Run the register script. Ignore errors; we will retry again later.
	print STDERR "Registering $slice ($aggregate)\n";
	system("$REGISTER " . $slice->idx());
	$slice->Flush();
	$aggregate->Flush();
    }
}

sub ReportLockedSlices()
{
    my $msg = "";
    
    my $query_result =
	GeniDB::DBQueryWarn("select idx,locked,expires,hosed,now() > expires ".
			    "  from geni_slices ".
			    "where locked is not null and ".
			    "      DATE_SUB(NOW(),INTERVAL 1 DAY) >= locked");
    if (!$query_result) {
	print STDERR "ReportLockedSlices: Error getting info from the DB.\n";
	return;
    }
    return
	if (!$query_result->numrows);

    while (my ($idx, $locked, $expires,$hosed, $expired) =
	   $query_result->fetchrow_array()) {
	my $slice = GeniSlice->Lookup($idx);

	if (!defined($slice)) {
	    # Slice is gone, lets not worry.
	    next;
	}
	my $urn = $slice->urn();
	
	# If hosed, we have already tried to clean it up, but failed.
	# Just add to the report, again.
	goto hosed
	    if ($hosed);

	goto hosed
	    if ($impotent);

	if ($expired) {
	    my $logfile;
	    my $experiment  = $slice->GetExperiment();
	    my $slice_uuid  = $slice->uuid();
	    my $output = emutil::ExecQuiet("$CLEANUPSLICE -f -m $slice_uuid");
	    my $status = $?;
	    if (defined($experiment)) {
		my $gid_idx = $experiment->gid_idx();
		my $logfile = Logfile->CreateFromString($gid_idx, $output);
		if (defined($logfile)) {
		    $logfile->SetMetadata([["slice_idx",  $slice->idx()],
					   ["slice_urn",  $slice->urn()],
					   ["slice_uuid", $slice->uuid()],
					   # For web interface listing
					   ["Method",     "Cleanup"],
					  ], 1);
		    $logfile->Store();
		}
	    }
	    else {
		print STDERR "$output\n";
	    }
	    if ($status) {
		$hosed = 1;
		$slice->SetHosedFlag(1);
	    }
	}
	
      hosed:
	$msg .= ($hosed ? "Hosed - " : "") . "$urn : $locked, $expires\n";
	print STDERR
	    ($hosed ? "Hosed - " : "") . "$urn : locked since $locked, expires at $expires\n";
	$slice->Flush();
    }
    return
	if ($msg eq "");

    #
    # Send a message to the testbed list. 
    #
    SENDMAIL($TBOPS,
	     "ProtoGENI CM daemon: Locked Slices",
	     "The following CM slices have been locked for a long time\n\n".
	     $msg,
	     $TBOPS);
}

#
# Look for orphaned certificates.
#
sub ReportOrphanedCerts()
{
    my $msg = "";

    GeniDB::DBQueryWarn("lock tables geni_certificates as c write, ".
			"  geni_users as u write, ".
			"  geni_slices as s write, ".
			"  geni_slivers as sl write, ".
			"  geni_aggregates as a write, ".
			"  geni_authorities as auth write, ".
			"  geni_components as cm write, ".
			"  geni_credentials as cr write")
	or return;
    
    my $query_result =
	GeniDB::DBQueryWarn("select c.uuid,c.urn from geni_certificates as c ".
		   "  left join geni_users as u on u.uuid=c.uuid ".
		   "  left join geni_slices as s on s.uuid=c.uuid ".
		   "  left join geni_slivers as sl on sl.uuid=c.uuid ".
		   "  left join geni_aggregates as a on a.uuid=c.uuid ".
		   "  left join geni_authorities as auth on auth.uuid=c.uuid ".
		   "  left join geni_components as cm on cm.uuid=c.uuid ".
	           "  left join geni_credentials as cr on cr.uuid=c.uuid ".
	     	   "  where u.uuid is null and ".
		   "        s.uuid is null and ".
		   "        sl.uuid is null and ".
		   "        a.uuid is null and ".
		   "        auth.uuid is null and ".
		   "        cm.uuid is null and ".
		   "        cr.uuid is null ");

    GeniDB::DBQueryWarn("unlock tables");
    if (!$query_result) {
	print STDERR "ReportOrphanedCerts: Error getting info from the DB.\n";
	return;
    }
    return
	if (!$query_result->numrows);

    while (my ($uuid, $urn) = $query_result->fetchrow_array()) {
	if (!$impotent) {
	    GeniDB::DBQueryWarn("delete from geni_certificates ".
				"where uuid='$uuid'");
	}
	else {
	    $msg .= "$uuid : $urn\n";
	}
	print STDERR "$uuid,$urn : orphaned certificates\n";
    }
    return
	if ($msg eq "");

    #
    # Send a message to the testbed list. 
    #
    SENDMAIL($TBOPS,
	     "ProtoGENI CM daemon: Orphaned Certificates",
	     "The following CM certificates are orphans\n\n".
	     $msg,
	     $TBOPS);
}

#
# Push stats up to the clearing house.
#
sub PushStats()
{
    my $lastidx = VersionInfo("aggregates_pushed");
    if (!defined($lastidx)) {
	$lastidx = 0;
	UpdateVersionInfo("aggregates_pushed", 0) == 0
	    or return -1;
    }

    #
    # Look for any records we have not reported. Note that we do not mark
    # a record as reported until it actually has a destroyed date. We still
    # send in the record though, we just might report it again when it is
    # destroyed. The CH will notice that.
    #
    # Limit to small number of records at a time to avoid pounding the CH.
    #
    my $query_result =
	GeniDB::DBQueryWarn("select * from aggregate_history ".
			    "where type='Aggregate' and ".
			    "      (idx>$lastidx or ".
			    "       (idx<=$lastidx and reported is null)) ".
			    "limit 100");
    return -1
	if (!$query_result);
    return 0
	if (!$query_result->numrows);
    
    my $clearinghouse = GeniRegistry::ClearingHouse->Create();
    if (!defined($clearinghouse)) {
	print STDERR "Could not create a clearinghouse client\n";
	return -1;
    }
    
    while (my $row = $query_result->fetchrow_hashref()) {
	my $aggregate_uuid = $row->{'uuid'};
	my $aggregate_idx  = $row->{'idx'};

	# Older records do not have this, but easy to generate.
	if (!defined($row->{'urn'}) || $row->{'urn'} eq "") {
	    $row->{'urn'} =
		GeniHRN::Generate($OURDOMAIN, "sliver", $aggregate_idx);
	}
	my $aggregate_urn = $row->{'urn'};

	#
	# If not destroyed, check for active aggregate. Maybe something
	# went wrong. There is a bit of race here; the aggregate might
	# have been destroyed in the meantime. Try to deal with that, but
	# in the end it is not that important, we can just fix up the
	# record.
	#
	if (!defined($row->{'destroyed'})) {
	    my $aggregate = GeniAggregate->Lookup($aggregate_idx);
	    if (!defined($aggregate)) {
		sleep(2);
		my $history_result =
		    GeniDB::DBQueryWarn("select destroyed from aggregate_history ".
					"where idx='$aggregate_idx'");

		return -1
		    if (!defined($history_result));

		if ($history_result->numrows == 0) {
		    #
		    # No idea what happened and not much to do.
		    #
		    print STDERR "aggregate_history record for ".
			"$aggregate_uuid ($aggregate_idx) is gone!\n";
		    next;
		}
		my ($destroyed) = $history_result->fetchrow_array();
		if (!defined($destroyed)) {
		    #
		    # Fix up the record.
		    #
		    print STDERR "aggregate_history says $aggregate_idx not ".
			"destroyed, but no aggregate exists. Fixing record\n";
		    GeniDB::DBQueryWarn("update aggregate_history set ".
					"  destroyed=now() ".
					"where idx='$aggregate_idx'")
			or return -1;
		    # We can catch it next loop.
		    next;
		}
		# Update and continue.
		$row->{'destroyed'} = $destroyed;
	    }
	}
	
	#
	# Find the manifests that have not been reported. We do not
	# record updates in a formal manner, except that there will
	# be a manifest record for each update.
	#
	my $manifest_results =
	    GeniDB::DBQueryWarn("select idx,created,manifest ".
				"  from manifest_history ".
				"where aggregate_uuid='$aggregate_uuid' and ".
				"      reported is null");
	return -1
	    if (!$manifest_results);

	#
	# If there are no manifests, and the index is less then then
	# the cutoff, this is one that is waiting to terminate. There
	# is no reason to send a new record. 
	#
	my $count = $manifest_results->numrows;

	if (!$count && $aggregate_idx <= $lastidx &&
	    !defined($row->{'destroyed'})) {
	    print STDERR "Skipping running aggregate $aggregate_idx\n";
	    next;
	}

	#
	# No manifests is okay, probably means we are reporting the demise
	# of an aggregate we reported earlier.
	#
	do {
	    $count--;
	    my ($manifest_idx, $manifest_created, $manifest) =
		$manifest_results->fetchrow_array();

	    if (defined($manifest_idx)) {
		$row->{'manifest'} = $manifest;
		# convert to gmt
		$row->{'created'} =
		    POSIX::strftime("20%y-%m-%dT%H:%M:%SZ",
				    gmtime(str2time($manifest_created)));
	    }
	    else {
		# convert to gmt
		$row->{'created'} =
		    POSIX::strftime("20%y-%m-%dT%H:%M:%SZ",
				    gmtime(str2time($row->{'created'})));
	    }
	    if (defined($row->{'destroyed'})) {
		# convert to gmt
		$row->{'destroyed'} =
		    POSIX::strftime("20%y-%m-%dT%H:%M:%SZ",
				    gmtime(str2time($row->{'destroyed'})));
	    }
	    else {
		# Do not send undefined value.
		delete($row->{'destroyed'});
	    }
	    # Do not send this. 
	    delete($row->{'reported'});
	    
	    if ($impotent) {
		print STDERR "Would post:\n";
		print STDERR Dumper($row);
		next;
	    } else {
		print STDERR "Posting aggregate record: $aggregate_urn\n";
		print STDERR "Posting with manifest: $manifest_idx\n"
		    if (defined($manifest_idx));
	    }
	    my $response = $clearinghouse->PostHistoryRecord($row);
	    if (!defined($response)) {
		print STDERR "Could not talk to clearinghouse\n";
		return -1;
	    }
	    if ($response->code() != GENIRESPONSE_SUCCESS) {
		print STDERR "Error posting history record: ".
		    $response->output() . "\n";
		return -1;
	    }
	    #
	    # Mark manifest reported.
	    #
	    if (defined($manifest_idx)) {
		GeniDB::DBQueryWarn("update manifest_history set reported=now() ".
				    "where idx='$manifest_idx'")
		    or return -1;
	    }
	    sleep(1);
	} while ($count > 0);

	next
	    if ($impotent);

	#
	# Mark aggregate record reported if destroyed.
	#
	if (defined($row->{'destroyed'})) {
	    GeniDB::DBQueryWarn("update aggregate_history set reported=now() ".
				"where idx='$aggregate_idx'")
		or return -1;
	}
	#
	# Update the last idx we reported on, for the next time.
	#
	UpdateVersionInfo("aggregates_pushed", $aggregate_idx) == 0
	    or return -1;
    }
    return 0;
}

#
# Look for idle slivers. 
#
sub CheckIdle()
{
    my $mailinterval        = 1;
    my $idlecheck_threshold = 1;
    my $idlecheck_norenew   = 0;
    my $debug = 1;

    if (! (GetSiteVar("idle/mailinterval", \$mailinterval) &&
	   GetSiteVar("protogeni/idlecheck_threshold", \$idlecheck_threshold) &&
	   GetSiteVar("protogeni/idlecheck_norenew",\$idlecheck_norenew))) {
	print STDERR "Could not get idle parameters.\n";
	return;
    }
    # Threshold in hours, convert to minutes.
    $idlecheck_threshold = $idlecheck_threshold * 60;
    
    my $query_result =
	GeniDB::DBQueryWarn("select idx,UNIX_TIMESTAMP(created) ".
			    "  from geni_slices ".
			    "where shutdown is null and ".
			    "      hosed=0 and lockdown=0 and isplaceholder=0");

    while (my ($idx,$created) = $query_result->fetchrow_array()) {
	my $slice = GeniSlice->Lookup($idx);

	if (!defined($slice)) {
	    # Slice is gone, lets not worry.
	    next;
	}
	if ($slice->Lock() != 0) {
	    print STDERR "Could not lock slice $slice.\n";
	    goto skip;
	}

	# We want the aggregate for the sliver urn, but it might
	# not actually exist yet.
	my $aggregate = GeniAggregate->SliceAggregate($slice);
	if (!defined($aggregate)) {
	    print STDERR "No aggregate created yet for $slice\n"
		if ($debug);
	    $slice->UnLock();
	    goto skip;
	}
	my $experiment = $slice->GetExperiment();
	if (!defined($experiment)) {
	    print STDERR "Could not get experiment for $slice. Expiring ...\n";
	    $slice->UnLock();
	    goto skip;
	}
	if ($experiment->Refresh() != 0) {
	    print STDERR "Could not flush $experiment\n";
	    $slice->UnLock();
	    goto skip;
	}
	my $exptidx = $experiment->idx();

	if ($debug) {
	    print STDERR "Checking idle for $slice\n";
	}

	#
	# This query comes out of db/idlemail.in ... I'm not willing
	# to mess with that code.
	#
	my $idle_result =
	    emdb::DBQueryWarn(
		        "select r.pid, e.gid, r.eid, idleswap_timeout, ".
			"  swap_requests, idle_ignore, idleswap, ".
			"  round((unix_timestamp(now()) - ".
			"         unix_timestamp(last_swap_req))/3600,2) ".
			"    as lastreq, ".
			"  count(r.node_id) as nodes ".
			"from node_activity as na ".
			"left join reserved as r on na.node_id=r.node_id ".
		        "left join nodes as n on na.node_id=n.node_id ".
		        "left join node_types as nt on nt.type=n.type ".
			"left join experiments as e on r.exptidx=e.idx ".
			"where r.exptidx=$exptidx and nt.isvirtnode=0 ".
			"group by pid,eid having nodes > 0 ");
	if (!defined($idle_result)) {
	    print STDERR "Could not get idle data for $experiment\n";
	    $slice->UnLock();
	    goto skip;
	}
	my $row = $idle_result->fetchrow_hashref();

	my $idleswap   = $row->{'idleswap'};
	# idleswap_timeout in minutes
	my $timeout    = $row->{'idleswap_timeout'};
	my $ignore     = $row->{'idle_ignore'};
	my $swapreqs   = $row->{'swap_requests'};
	# lastreq in hours
	my $lastreq    = $row->{'lastreq'};
	my $nodes      = $row->{'nodes'};
	my $urn        = $slice->urn();

	#
	# Now pull in per-node data. We want to compute a percentage
	# of idle nodes so that we can be a little smarter.
	#
	my $node_result =
	    emdb::DBQueryWarn("select r.node_id, ".
			"  greatest(last_tty_act,last_net_act,last_cpu_act,".
			"           last_ext_act) as lastact,".
			"  round((unix_timestamp(now()) - ".
			"         unix_timestamp(greatest(last_tty_act, ".
			"           last_net_act, last_cpu_act, ".
			"           last_ext_act)))/60,1) as idle_time, ".
			"  (unix_timestamp(now()) - ".
			"   unix_timestamp(last_report)) as staleness, ".
			"  unix_timestamp(last_report) as last_report ".
			"from reserved as r ".
			"left join node_activity as na on ".
			"     na.node_id=r.node_id ".
		        "left join nodes as n on n.node_id=r.node_id ".
		        "left join node_types as nt on nt.type=n.type ".
			"left join experiments as e on r.exptidx=e.idx ".
			"where r.exptidx=$exptidx and nt.isvirtnode=0");

	if (!defined($node_result)) {
	    print STDERR "** Could not get node idle data for $experiment\n";
	    $slice->UnLock();
	    goto skip;
	}
	# Skip if no physical nodes; eventually come back to this.
	if (!$node_result->numrows) {
	    print STDERR "-> No physical nodes; skipping\n";
	    $slice->UnLock();
	    goto skip;
	}
	my %node_idledata = ();
	my $stalenodes    = 0;
	my $idlenodes     = 0;
	my $reporting     = 0;

	#
	# staleness. If undef, the node has not reported any idle data
	# since inception, lets skip since we do not know anything. Note
	# that idletime will also be null. If the staleness is really big,
	# all of the nodes have stopped reporting, and that means they are
	# all offline or otherwise munged to stop reporting. I am going to
	# treat those as idle. The user can argue with us about it.  If the
	# staleness is small, we trust the data idle data to be accurate.
	# If the staleness is medium, then wait longer.
	#
	while (my $noderow = $node_result->fetchrow_hashref()) {
	    my $node_id   = $noderow->{'node_id'};
	    my $lastact   = $noderow->{'lastact'};
	    # idletime in in minutes
	    my $idletime  = $noderow->{'idle_time'};
	    # staleness in in seconds
	    my $staleness = $noderow->{'staleness'};
	    # This indicates if the node_activity is getting updates.
	    my $last_report = $noderow->{'last_report'};
	    $node_idledata{$node_id} = $noderow;

	    #
	    # if last_report is null, the node is not reporting any idle
	    # data since inception; lets skip it since we do not know
	    # anything. We view these nodes at not idle for now. Needs
	    # more thought.
	    #
	    next
		if (!defined($staleness) || $last_report == 0);

	    $reporting++;

	    #
	    # If the staleness is big the node has stopped reporting,
	    # and that means it is offline or otherwise munged to stop
	    # reporting. I am going to treat those as idle. The user can
	    # argue with us about it.
	    #
	    if ($staleness > ($idlecheck_threshold * 60)) {
		$idlenodes++;
		$noderow->{'idle'} = 1;
		next;
	    }

	    #
	    # Otherwise, if the staleness is small, we trust the 
	    # idle data to be accurate. If the staleness is medium, then
	    # wait longer before using this node.
	    #
	    if ($staleness > (15 * 60)) {
		$stalenodes++;
		$noderow->{'stale'} = 1;
		next;
	    }

	    #
	    # Finally, look at the idle time.
	    #
	    if ($idletime > $idlecheck_threshold) {
		$idlenodes++;
		$noderow->{'idle'} = 1;
		next;
	    }
	}
	#
	# If no idle data, nothing do do.
	#
	if (! $reporting) {
	    print STDERR "-> No idle data for $slice. Skipping ...\n"
		if ($debug);
	    $slice->UnLock();
	    goto skip;
	}
	print STDERR "-> $urn is using $nodes physical nodes:\n";
	print STDERR "   reporting:$reporting, idle:$idlenodes, ".
	    "stale:$stalenodes\n";
	print STDERR "   But idle ignore is set.\n"
	    if ($ignore);
	
	#
	# We want to report as much idle data as possible, but
	# if the slice has not passed its idletime setting, or
	# if idleswap is off, we skip.
	#
	my $geniuser  = GeniUser->Lookup($slice->creator_uuid(), 1);
	my $emailaddr = $geniuser->email();
	my $sliver_urn= $aggregate->urn();
	
	if ($idleswap && ($idlenodes / ($reporting * 1.0) >= 0.50)) {
	    my $stats     = "";

	    foreach my $node (keys(%node_idledata)) {
		if (exists($node_idledata{$node}->{'idle'})) {
		    $stats .=
			sprintf("%40s - %.2f hours idle\n",
				"${node}.${OURDOMAIN}",
				$node_idledata{$node}->{'idle_time'}/60.0);
		}
	    }
	    
	    #
	    # Send email if none sent or if the minimum time since
	    # since the last message has passed. In general, we will not
	    # send more then one message in a 24 hour period to avoid
	    # annoying people to much.
	    #
	    if ($idlecheck_norenew &&
		$swapreqs && ($lastreq * 60) > (2 * $idlecheck_threshold)) {
		if (!defined($slice->renew_limit()) ||
		    $slice->renew_limit_stamp()) {
		    #
		    # Current policy is no second warnings; the 
		    # slice may not be renewed, even if it goes non idle
		    # again. Setting the renew limit to zero tells the CM
		    # to not allow any renew.
		    #
		    print STDERR "** Slice can no longer be renewed!\n";

		    if (!$impotent) {
			my $subject;
			my $message;
			if (defined($slice->portal_tag())) {
			    my $tag = ucfirst($slice->portal_tag());
			    my $url = $slice->portal_url();
			    my $eid = $slice->portal_eid();
			    $subject = "$tag portal experiment ".
				"may not be extended";
			    $message = "Your $tag portal experiment $eid at ".
				"$OURDOMAIN".
				(defined($url) ?
				 ":\n\n" . "   $url" . "\n\n" : "\n");
			}
			else {
			    $subject = "Sliver $sliver_urn may not be renewed";
			    $message = "Sliver $sliver_urn\n".
				"from slice $urn,\n";
			}
			$message .= 
			    "has been mostly idle for too long,\n".
			    "and is using $nodes physical nodes.\n\n".
			    "$stats\n".
			    "You will not be allowed to extend it!\n";
		
			SENDMAIL($emailaddr, $subject, $message,
				 $TBOPS, "CC: $TBAUTOMAIL");
			$slice->SetRenewLimit(0);
		    }
		}
	    }
	    elsif ($swapreqs == 0 || $lastreq > 24 || $debug > 1) {
		my $norenew   =
		    (defined($slice->renew_limit()) &&
		     $slice->renew_limit_stamp() == 0 ? 1 : 0);

		if ($impotent) {
		    print STDERR "   Would send email to $geniuser\n";
		    print STDERR $stats if ($stats ne "");
		}
		else {
		    print STDERR "   Sending mail to $geniuser about ".
			"idle sliver $aggregate\n";

		    my $subject;
		    my $message;
		    if (defined($slice->portal_tag())) {
			my $tag = ucfirst($slice->portal_tag());
			my $url = $slice->portal_url();
			my $eid = $slice->portal_eid();
			$subject = "$tag portal experiment ".
			    "is mostly idle";
			$message = "Your $tag portal experiment $eid at ".
			    "$OURDOMAIN".
			    (defined($url) ?
			     ":\n\n" . "   $url" . "\n\n" : "\n") .
			    "has been mostly idle for an unusual length ".
			    "of time,\n".
			    "and is using $nodes physical nodes.\n\n".
			    "$stats\n".
			    ($idlecheck_norenew ?
			     ($norenew ?
			      "You may no longer extend this experiment, and ".
			      "it might be terminated " :
			      "You will not be allowed to extend this ".
			      "experiment ") :
			     "This experiment might be terminated ") .
			    "if it stays idle.\n",
		    }
		    else {
			$subject = "Sliver $sliver_urn is mostly idle";
			$message = "Sliver $sliver_urn\n".
			    "from slice $urn,\n".
			    "has been mostly idle for an unusual length ".
			    "of time,\n".
			    "and is using $nodes physical nodes.\n\n".
			    "$stats\n".
			    ($idlecheck_norenew ?
			     ($norenew ?
			      "You may no longer renew this sliver, and it ".
			      "might be terminated " :
			      "You will not be allowed to renew this sliver ") :
			     "This sliver might be terminated ") .
			    "if it stays idle.\n",
		    }
		    SENDMAIL($emailaddr, $subject, $message,
			     $TBOPS, "CC: $TBAUTOMAIL");

		    emdb::DBQueryWarn("update experiments set ".
				      "   swap_requests=swap_requests+1, ".
				      "   last_swap_req=now() ".
				      "where idx='$exptidx'");
		}
	    }
	}
	else {
	    # Reset warnings.
	    print STDERR "Resetting swap_requests for $slice\n"
		if ($debug);
	   
	    emdb::DBQueryWarn("update experiments set swap_requests=0 ".
			      "where idx='$exptidx'")
		if (!$impotent);
	}
	$slice->UnLock();
      skip:
	$slice->Flush()
	    if (defined($slice));
    }
}

#
# Check Aggregate states/status. 
#
sub CheckAggregates()
{
    my $query_result =
	GeniDB::DBQueryWarn("select idx from geni_aggregates ".
			    "where type='Aggregate' and status!='ready'");

    while (my ($idx) = $query_result->fetchrow_array()) {
	my $aggregate = GeniAggregate->Lookup($idx);

	if (!defined($aggregate)) {
	    # aggregate is gone, lets not worry.
	    next;
	}
	my $slice = $aggregate->GetSlice();
	if (!defined($slice)) {
	    # slice is gone, lets not worry.
	    $aggregate->Flush();
	    next;
	}
	if ($slice->Lock() != 0) {
	    goto skip;
	}
	my $state  = $aggregate->state();
	my $status = $aggregate->status();
	my $stamp  = $aggregate->status_state_timestamp();
	
	#
	# If an aggregate have been trying to update users for more then
	# 30 minutes, kill that and return the aggregate to normal status.
	#
	if ($state eq "updating_users" && time() - $stamp > 1 * 60) {
	    if ($impotent) {
		print STDERR "Would cancel update accounts for $aggregate\n";
	    }
	    else {
		print STDERR "Canceling update accounts for $aggregate\n";
		$aggregate->CancelUpdateAccounts();
	    }
	}
	$slice->UnLock();
      skip:
	$slice->Flush();
	$aggregate->Flush();
    }
}

#
# Notify the "portal" of the status of all slivers. Might be the local
# portal or the Cloudlab portal. Or both since a cluster might be part
# of Cloudlab, but allowing use of the local portal UI.
#
my %notify_timestamps = ();

sub NotifyPortal()
{
    my %slices     = ();
    my %aggregates = ();
    my $count      = 0;
    my $max        = 15;  # 15 at a time.
    my $interval   = 600; # 10 minutes;
    
    my $query_result =
	GeniDB::DBQueryWarn("select idx from geni_aggregates ".
			    "where type='Aggregate'");
    
    while (my ($idx) = $query_result->fetchrow_array()) {
	my $aggregate = GeniAggregate->Lookup($idx);

	if (!defined($aggregate)) {
	    # aggregate is gone, lets not worry.
	    next;
	}
	my $slice = $aggregate->GetSlice();
	if (!defined($slice)) {
	    # slice is gone, lets not worry.
	    $aggregate->Flush();
	    next;
	}
	$slices{$slice->uuid()} = $slice;
	$aggregates{$slice->uuid()} = $aggregate;
    }
    foreach my $slice (values(%slices)) {
	my $aggregate = $aggregates{$slice->uuid()};
	
	if ($slice->Lock() != 0) {
	    print STDERR "NotifyPortal: Could not lock slice $slice.\n";
	    goto skip;
	}
	#
	# Send events every 10 minutes for a slice, but do not want to
	# do all of them at exactly the same time, so lets spread things
	# out a bit.
	#
	if (!exists($notify_timestamps{$slice->uuid()})) {
	    $notify_timestamps{$slice->uuid()} = time();
	}
	my $last = $notify_timestamps{$slice->uuid()};
	if (time() - $last < $interval) {
	    if ($debug) {
		print STDERR "NotifyPortal: Skipping $slice this time\n";
	    }
	    $slice->UnLock();
	    goto skip;
	}
	
	#
	# If this causes anything to change, events will get sent.
	#
	if ($debug) {
	    print STDERR "NotifyPortal: $slice\n";
	}
	$aggregate->SendAllStatusEvents();
	$slice->UnLock();
	$count++;
	$notify_timestamps{$slice->uuid()} = time();
	# Lets not flood too fast.
	sleep(1);
      skip:
	$slice->Flush();
	$aggregate->Flush();
	# Only this many per minute.
	last
	    if ($count >= $max);
    }
    my %tmp = ();
    # Watch for slices that are gone so that this array does not get big.
    foreach my $uuid (keys(%notify_timestamps)) {
	$tmp{$uuid} = $notify_timestamps{$uuid} if (exists($slices{$uuid}));
    }
    %notify_timestamps = %tmp;
}

if ($oneshot) {
    CheckIdle();
    exit(0);
}

# Do this once at startup
if (! NoLogins()) {
    sleep(5);
    ReportLockedSlices();
    ReportOrphanedCerts();
    CheckIdle();
}

my $reportcounter = 0;
my $idlecounter   = 0;

while (1) {
    if (NoLogins()) {
	sleep(5);
	next;
    }
    my $doidlechecks;

    # Site var normally controls idle checks, but it can be turned
    # via the command line as well.
    if (! GetSiteVar('protogeni/idlecheck', \$doidlechecks)) {
	# Cannot get the value, default it to off.
	$doidlechecks = 0;
    }
    
    $reportcounter += $SLEEP_INTERVAL;
    $idlecounter   += $SLEEP_INTERVAL;
    
    print "Running at ".
	POSIX::strftime("20%y-%m-%d %H:%M:%S", localtime()) . "\n";

    if (0) {
	WarnSlices();
	goto loop;
    }
    
    ExpireTickets();
    WarnSlices();
    ExpireSlices();
    TerminateSlices();

    #
    # Run the idle check periodically. 
    # 
    if ($idlecounter >= (10 * 60)) {
	CheckIdle()
	    if ($idlecheck || $doidlechecks);
	$idlecounter = 0;
    }
    ShutdownSlices();
    RegisterSlices();
    PushStats();

    if ($reportcounter >= (24 * 60 * 60)) {
	ReportLockedSlices();
	ReportOrphanedCerts();
	$reportcounter = 0;
    }
    NotifyPortal();
    CheckAggregates();

    # Be certain stale info is gone.
    emutil::FlushCaches();
    GeniUtil::FlushCaches();

  loop:
    print "Sleeping for $SLEEP_INTERVAL seconds ...\n";
    sleep($SLEEP_INTERVAL);
}
exit(0);

sub fatal($)
{
    my ($msg) = @_;

    #
    # Send a message to the testbed list. 
    #
    SENDMAIL($TBOPS,
	     "ProtoGENI expire daemon died",
	     $msg,
	     $TBOPS);
    MarkDaemonStopped("expire_daemon");
    die("*** $0:\n".
	"    $msg\n");
}
