#!/usr/bin/perl -wT
#
# Copyright (c) 2008-2017, 2020 University of Utah and the Flux Group.
# 
# {{{GENIPUBLIC-LICENSE
# 
# GENI Public License
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and/or hardware specification (the "Work") to
# deal in the Work without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Work, and to permit persons to whom the Work
# is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Work.
# 
# THE WORK IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS
# IN THE WORK.
# 
# }}}
#
package GeniAM;

#
# The server side of the CM interface on remote sites. Also communicates
# with the GMC interface at Geni Central as a client.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

use GeniStd;
use GeniCMV2;
use GeniResponse;
use GeniCredential;
use GeniRegistry;
use GeniXML;
use emutil;

use Compress::Zlib;
use MIME::Base64;
use XML::LibXML;
use Date::Parse;
use Data::Dumper;
use Frontier::RPC2;
use POSIX qw(strftime);
use File::Temp qw(tempfile);

my $TB             = "@prefix@";
my $RSPECLINT      = "$TB/sbin/protogeni/rspeclint";

# Disable UUID checks in GeniCredential.
$GeniCredential::CHECK_UUID = 0;

my $API_VERSION = 2;
my $MAINSITE    = @TBMAINSITE@;

sub SetGeniVersion($)
{
    my ($new_version) = @_;
    if ($new_version eq "1.0") {
	$API_VERSION = 1;
    } elsif ($new_version eq "2.0") {
	$API_VERSION = 2;
    } elsif ($new_version eq "3.0") {
	$API_VERSION = 3;
    } else {
	$API_VERSION = 4;
    }
}
sub InitModule($) { SetGeniVersion($_[0]); }

#
# Tell the client what API revision we support.  The correspondence
# between revision numbers and API features is to be specified elsewhere.
# No credentials are required.
#
sub GetVersion()
{
    # $options is optional here for all versions
    my ($options) = @_;
    my $me = GeniAuthority->Lookup($ENV{'MYURN'});
    if (!defined($me)) {
	print STDERR "Could not find local authority object\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    my $commithash = VersionInfo("commithash") || "";
    my $hostname   = `hostname`;
    chomp($hostname);
    my $peers      = {};

    #
    # Ask the Clearinghouse for the peers info.
    #
    if (0 && $MAINSITE) {
	my $clearinghouse = GeniRegistry::ClearingHouse->Create();
	if (!defined($clearinghouse)) {
	    print STDERR "Could not create clearinghouse object.\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	my $versioninfo;
	if ($clearinghouse->GetVersion(\$versioninfo)) {
	    print STDERR "Could not get peers from clearinghouse.\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	$peers = $versioninfo->{"peers"};

	foreach my $urn (keys(%{ $peers })) {
	    my $url = $peers->{$urn};
	    $url =~ s/cm$/am/;
	    $peers->{$urn} = $url;
	}
    }

    #
    # We have some confusion here. This is the AM interface, and the
    # URL is different, but the URN and HRN are that of the CM.
    #
    my $url = $me->url();
    $url =~ s/cm$/am/;

    my $coder = Frontier::RPC2->new('use_objects' => 1);

    my $default_ad = {
	"type" => "ProtoGENI",
	"version" => $coder->string("2") };
    my $request_0_1 = {
	"type" => "ProtoGENI",
	"version" => $coder->string("0.1"),
	"schema" => "http://www.protogeni.net/resources/rspec/0.1/request.xsd",
	"namespace" => "http://www.protogeni.net/resources/rspec/0.1",
	"extensions" => []
    };
    my $request_0_2 = {
	"type" => "ProtoGENI",
	"version" => $coder->string("0.2"),
	"schema" => "http://www.protogeni.net/resources/rspec/0.2/request.xsd",
	"namespace" => "http://www.protogeni.net/resources/rspec/0.2",
	"extensions" => []
    };
    my $request_2 = {
	"type" => "ProtoGENI",
	"version" => $coder->string("2"),
	"schema" => "http://www.protogeni.net/resources/rspec/2/request.xsd",
	"namespace" => "http://www.protogeni.net/resources/rspec/2",
	"extensions" => [$GeniXML::EMULAB_NS],
    };
    my $request_3 = {
	"type" => "GENI",
	"version" => $coder->string("3"),
	"schema" => "http://www.geni.net/resources/rspec/3/request.xsd",
        "namespace" => "http://www.geni.net/resources/rspec/3",
	"extensions" => [$GeniXML::EMULAB_NS],
    };
    my $ad_0_1 = {
        "type" => "ProtoGENI",
        "version" => $coder->string("0.1"),
        "schema" => "http://www.protogeni.net/resources/rspec/0.1/ad.xsd",
        "namespace" => "http://www.protogeni.net/resources/rspec/0.1",
        "extensions" => []
    };
    my $ad_0_2 = {
        "type" => "ProtoGENI",
        "version" => $coder->string("0.2"),
        "schema" => "http://www.protogeni.net/resources/rspec/0.2/ad.xsd",
        "namespace" => "http://www.protogeni.net/resources/rspec/0.2",
        "extensions" => []
    };
    my $ad_2 = {
        "type" => "ProtoGENI",
        "version" => $coder->string("2"),
        "schema" => "http://www.protogeni.net/resources/rspec/2/ad.xsd",
        "namespace" => "http://www.protogeni.net/resources/rspec/2",
	"extensions" => [$GeniXML::EMULAB_NS, $GeniXML::SITEINFO_NS],
    };
    my $ad_3 = {
	"type" => "GENI",
	"version" => $coder->string("3"),
	"schema" => "http://www.geni.net/resources/rspec/3/ad.xsd",
        "namespace" => "http://www.geni.net/resources/rspec/3",
	"extensions" => [$GeniXML::EMULAB_NS, $GeniXML::SITEINFO_NS],
    };

    my $request_name = "request_rspec_versions";
    my $ad_name = "ad_rspec_versions";
    if ($API_VERSION > 1) {
	$request_name = "geni_request_rspec_versions";
	$ad_name = "geni_ad_rspec_versions";
    }

    my $blob = {
	"geni_api"   => $API_VERSION,
	"urn"        => $me->urn(),
	"hrn"        => $me->hrn(),
	"url"        => $url,
	"interface"  => "aggregate",
	"code_tag"   => $commithash,
	# XXX
	"hostname"   => $hostname,
	$request_name => [$request_0_1, $request_0_2, $request_2,
			   $request_3],
	$ad_name => [$ad_0_1, $ad_0_2, $ad_2, $ad_3],
	"geni_api_versions" => {
	    "1" => "$url/1.0",
	    "2" => "$url/2.0",
	    "3" => "$url/3.0"
	}
    };
    $blob->{"peers"} = $peers
	if (0 && $MAINSITE);
    $blob->{"default_ad_rspec"} = $default_ad
	if ($API_VERSION == 1);

    if ($API_VERSION >= 3) {
	$blob->{"geni_single_allocation"} = $coder->string("1");
	$blob->{"geni_allocate"} = "geni_disjoint";
	$blob->{"geni_credential_types"} = [
	    {"geni_type" => "geni_sfa",
	     "geni_version" => $coder->string("2")},
	    {"geni_type" => "geni_sfa",
	     "geni_version" => $coder->string("3")}
	    ];
    }
    if (defined($options) && exists($options->{'trustroots'})) {
	my @roots = ();
	my @certs = GeniCertificate::SplitCertBundle("$TB/etc/genica.bundle");
	foreach my $root (@certs) {
	    my $cert = GeniCertificate->LoadFromString($root);
	    next
		if (!defined($cert));
	    next
		if (!defined($cert->urn()));

	    push(@roots, {"CN"      => $cert->CommonName(),
			  "Serial"  => $cert->serial(),
			  "Expires" => $cert->enddate(),
			  "SubjAltNameURIs" => [$cert->urn()],
		 });
	}
	$blob->{"trustroots"} = \@roots;
    }
    my $response = GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
    if ($API_VERSION > 1) {
	$response->{"geni_api"} = $API_VERSION;
    }
    return $response;
}

# List this aggregates resources. Invokes GeniCMV2::Resolve or
# GeniCMV2::DiscoverResources.
sub ListResources()
{
    my ($credential_args, $options) = @_;
    if (! defined($credential_args) || ! defined($options)
	|| ($API_VERSION > 1 && ! defined($options->{'geni_rspec_version'}))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my $available = $options->{'geni_available'};
    my $compress = $options->{'geni_compressed'};
    my $slice_urn = $options->{'geni_slice_urn'};
    my $version;
    if ($API_VERSION == 1) {
	$version    = $options->{'rspec_version'} || undef;
    } else {
	$version    = $options->{'geni_rspec_version'};
    }

    my $credentials = $credential_args;
    if ($API_VERSION >= 3) {
	$credentials = GeniStd::FilterCredentials($credential_args);
    }

    my $xml = undef;
    if ($slice_urn) {
	main::AddLogfileMetaData("slice_urn", $slice_urn);

        # If $slice_urn is defined, this turns into a Resolve call.  We
        # need to resolve twice: once to get the sliver urn from the
        # slice, then to get the resources associated with the sliver (a
        # manifest rspec).
        my $resolve_args = {
            'urn' => $slice_urn,
            'credentials' => $credentials
        };
        my $response = GeniCMV2::Resolve($resolve_args);
        if (GeniResponse::IsError($response)) {
            return $response;
        }
        # Get the hash out of the response
        my $slice_hash = GeniResponse::value($response);
        # Resolve the sliver to get the manifest RSpec
	if (! exists($slice_hash->{'sliver_urn'}) ||
	    ! defined($slice_hash->{'sliver_urn'})) {
	    #
	    # Hmm, see if its busy. In the middle of creating.
	    #
	    return GeniResponse->BusyResponse();
	}
	my $sliver = $slice_hash->{'sliver_urn'};
	$resolve_args->{'urn'} = $sliver;
	$response = GeniCMV2::Resolve($resolve_args);
	if (GeniResponse::IsError($response)) {
	    return $response;
	}
	$xml = GeniResponse::value($response)->{'manifest'};
    } else {
	my $pgversion = undef;
	if (! defined($version)) {
	    $pgversion = "2";
	} elsif (defined($version->{'type'}) &&
		 defined($version->{'version'}) &&
		 (lc($version->{'type'}) eq "protogeni"
		  || lc($version->{'type'}) eq "geni")) {
	    $pgversion = $version->{'version'};
	} else {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Only ProtoGENI RSpec advertisements are supported");
	}
        # No slice was specified, so get the advertisement RSpec.
        my $discover_args = {
            'credentials' => $credentials,
            'available' => $available,
	    'rspec_version' => $pgversion,
        };
        my $response = GeniCMV2::DiscoverResources($discover_args);
        if (GeniResponse::IsError($response)) {
            return $response;
        } else {
            $xml = GeniResponse::value($response)
        }

    }

    # Was compression requested?
    if (defined($compress) && ref($compress) eq 'Frontier::RPC2::Boolean') {
	$compress = $compress->value;
    }
    # If compression was requested, do it. The result is a String
    # whose contents are a base64 encoding of a zlib compressed RSpec.
    if ($compress) {
        my $coder = Frontier::RPC2->new();
        $xml = encode_base64( compress( $xml ) );
    }
    # Finally, return the RSpec
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $xml);
}

###############################################################################
# AM API V2
###############################################################################

# Create a sliver by allocating and starting resources.
sub CreateSliver()
{
    my ($slice_urn, $credentials, $rspec, $users, $options) = @_;
    if (! defined($slice_urn) || ! defined($credentials)
	|| ! defined($rspec) || ! defined($users)
	|| (! defined($options) && $API_VERSION > 1)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }

    foreach my $cred (@$credentials) {
        # If we want to remove the SA(s) after this call, push them
        # onto a list here and remove them at the end of this
        # function. The other AM calls do not need the dynamically
        # added SA.
        GeniStd::auto_add_sa($cred);
    }

    # Package the caller_keys in a list of hashes the way the CM wants
    # it. Each hash has two keys ('type' and 'key'). 'type' is always
    # 'ssh' for us, and 'key' is the key.
    my $sliver_keys = undef;
    if (@$users) {
	$sliver_keys = [];
	foreach my $user (@$users) {
	    my $user_urn  = $user->{'urn'};
	    my @user_keys = ();

	    foreach my $key (@{ $user->{keys} }) {
		# The CMV2 does not like newlines at the end of the keys.
		chomp($key);
		push(@user_keys, {'type' => 'ssh', 'key' => $key});
	    }
	    my $blob = {'urn'  => $user_urn,
			'keys' => \@user_keys};
	    if (exists($user->{'privs'})) {
		$blob->{'privs'} = $user->{'privs'};
	    }
	    push(@{$sliver_keys}, $blob);
	}
    }
    # Invoke CreateSliver
    my $create_args = {
        'slice_urn' => $slice_urn,
        'rspec' => $rspec,
        'credentials' => $credentials,
        'keys' => $sliver_keys
    };
    if (defined($options)) {
	if (exists($options->{'geni_certificate'})) {
	    $create_args->{'certificate'} = $options->{'geni_certificate'};
	}
	if (exists($options->{'geni_key'})) {
	    $create_args->{'key'} = $options->{'geni_key'};
	}
    }
    my $response = GeniCMV2::CreateSliver($create_args);
    if (!ref($response)) {
	# This is cause GeniCMV2::CreateSliver does a fork, and the child
	# returns plain status code, which should go to our caller. 
	return $response;
    }
    if (GeniResponse::IsError($response)) {
        # The create failed, so return the response.
        return $response
    }

    # The create succeeded so gather the response info
    my $listref = GeniResponse::value($response);
    my ($sliver_credential, $manifest_rspec) = @{$listref};
    return GeniResponse->Create( GENIRESPONSE_SUCCESS, $manifest_rspec );
}

# Just delegate to CMV2::DeleteSlice. If we ever change to sliver_urns
# for this call, we'll probably want to call CMV2::DeleteSliver
# instead.
sub DeleteSliver()
{
    my ($slice_urn, $credentials, $options) = @_;
    if (! defined($slice_urn) || ! defined($credentials)
	|| (! defined($options) && $API_VERSION > 1)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }

    my $delete_args = {
        'slice_urn' => $slice_urn,
        'credentials' => $credentials
    };
    # Optional blocking.
    if (defined($options) &&
	exists($options->{'blocking'}) && $options->{'blocking'}) {
	$delete_args->{'blocking'} = 1;
    }
    # And cancel
    if (defined($options) &&
	exists($options->{'cancel'}) && $options->{'cancel'}) {
	$delete_args->{'cancel'} = 1;
    }
    
    my $response = GeniCMV2::DeleteSlice($delete_args);
    if (!ref($response)) {
	# This is cause GeniCMV2::DeleteSlice does a fork, and the child
	# returns plain status code, which should go to our caller. 
	return $response;
    }
    if (GeniResponse::IsError($response)) {
        return $response;
    } else {
        # Return an XML-RPC boolean
        my $coder = Frontier::RPC2->new();
        return GeniResponse->Create(GENIRESPONSE_SUCCESS, $coder->boolean(1));
    }
}

# No prototype because it is recursive and as such, the prototype
# causes a warning.
#
# Return a hash containing a JSONish representation of the given node.
sub XmlToJson
{
    my ($node) = @_;
    my $coder = Frontier::RPC2->new();
 
    my $attrs = {};
    foreach my $attr ($node->attributes) {
        $attrs->{$attr->nodeName()} = $coder->string($attr->nodeValue());
    }

    my $children = [];
    foreach my $child ($node->childNodes) {
        if ($child->nodeType() == XML_ELEMENT_NODE) {
            push(@$children, XmlToJson($child));
        }
    }

    my $result = {
        "name" => $node->nodeName(),
        "attributes" => $attrs,
        "children" => $children
    };
    return $result;
}

# Get the status of the sliver associated with the given slice. This
# just passes on to the CM SliverStatus operation.
sub SliverStatus()
{
    my ($slice_urn, $credentials, $options) = @_;
    if (! defined($slice_urn) || ! defined($credentials)
	|| (! defined($options) && $API_VERSION > 1)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }

    my $status_args = {
        'slice_urn' => $slice_urn,
        'credentials' => $credentials,
    };
    my $response = GeniCMV2::SliverStatus($status_args);
    if (GeniResponse::IsError($response)) {
        return $response
    }
    # $status is a hash ref
    my $pgstatus = GeniResponse::value($response);
    my $status = {};

    $status->{'geni_urn'} = $slice_urn;

    # Determine geni_status. XXX how to determine 'configuring'?
    if ($pgstatus->{'status'} eq 'ready') {
        $status->{'geni_status'} = 'ready';
    } elsif ($pgstatus->{'status'} eq 'failed') {
        $status->{'geni_status'} = 'failed';
    } else {
        $status->{'geni_status'} = 'unknown';
    }

    # include the pg status
    $status->{'pg_status'} = $pgstatus->{'status'};
    $status->{'pg_public_url'} = $pgstatus->{'public_url'}
        if (exists($pgstatus->{'public_url'}));

    # include the expiration, converting to UTC
    my $slice = GeniSlice->Lookup($slice_urn);
    my @expires = gmtime(str2time($slice->expires()));
    my $expires_str = POSIX::strftime("%Y-%m-%dT%H:%M:%SZ", @expires);
    $status->{'pg_expires'} = $expires_str;

    # Grab the keys (logins) for inclusion.
    my $slice_experiment = $slice->GetExperiment();
    if (!defined($slice_experiment)) {
	print STDERR "*** No Experiment for $slice\n";
    }
    else {
	my $bindings;
	if ($slice_experiment->NonLocalUsers(\$bindings)) {
	    print STDERR "*** No bindings for $slice_experiment\n";
	}
	elsif (@{ $bindings }) {
	    $status->{'users'} = $bindings;
	}
    }

    my $details = $pgstatus->{'details'};
    my @children = ();
    while ( my ($pgurn, $pgrstat) = each(%$details) ) {
        my $child = {
            'geni_urn' => $pgurn,
	    'geni_client_id' => $pgrstat->{'client_id'},
            # XXX Need to massage status to one of the AM status values
            'geni_status' => $pgrstat->{'status'},
            'geni_error' => $pgrstat->{'error'},
            'pg_status' => $pgrstat->{'status'},
        };
        # Look up the sliver so we can extract info from the manifest.
        my $sliver = GeniSliver->Lookup($pgurn);
	if (!defined($sliver)) {
	    $sliver = GeniAggregate->Lookup($pgurn);
	}
	# Signal an error?
	next
	    if (!defined($sliver));

        push @children, $child;
    }
    $status->{'geni_resources'} = \@children;

    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $status);
}

sub RenewSliver()
{
    my ($slice_urn, $credentials, $expiration_time, $options) = @_;
    if (! defined($slice_urn) || ! defined($credentials)
	|| ! defined($expiration_time)
	|| (! defined($options) && $API_VERSION > 1)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }

    my $renew_args = {
        'slice_urn' => $slice_urn,
        'expiration' => $expiration_time,
        'credentials' => $credentials,
	'alap' => 0,
    };
    # extend as long as possible.
    if (exists($options->{'geni_extend_alap'}) &&
	$options->{'geni_extend_alap'}) {
	$renew_args->{'alap'} = 1;
    }
    my $response = GeniCMV2::RenewSlice($renew_args);
    if (GeniResponse::IsError($response)) {
        return $response;
    }

    # Return an XML-RPC boolean
    my $coder = Frontier::RPC2->new();
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $coder->boolean(1));
}

sub Shutdown()
{
    my ($slice_urn, $credentials, $options) = @_;
    if (! defined($slice_urn) || ! defined($credentials)
	|| (! defined($options) && $API_VERSION > 1)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }

    my $shutdown_args = {
        'slice_urn' => $slice_urn,
        'credentials' => $credentials
    };
    my $response = GeniCMV2::Shutdown($shutdown_args);
    if (GeniResponse::IsError($response)) {
        return $response;
    }

    # Return an XML-RPC boolean
    my $coder = Frontier::RPC2->new();
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $coder->boolean(1));
}

sub CreateImage()
{
    my ($slice_urn, $imagename, $sliver_urn, $credential_args, $options) = @_;
    if (! defined($slice_urn) || ! defined($credential_args) ||
	! defined($sliver_urn) || ! defined($imagename)
	|| (! defined($options) && $API_VERSION > 1)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }

    my $credentials = $credential_args;
    if ($API_VERSION >= 3) {
	$credentials = GeniStd::FilterCredentials($credential_args);
    }

    my $args = {
        'slice_urn' => $slice_urn,
        'sliver_urn' => $sliver_urn,
        'imagename' => $imagename,
        'credentials' => $credentials
    };
    $args->{'global'} = $options->{'global'}
        if (defined($options) && exists($options->{'global'}));
    $args->{'update_prepare'} = $options->{'update_prepare'}
        if (defined($options) && exists($options->{'update_prepare'}));
	
    my $response = GeniCMV2::CreateImage($args);
    return $response;
}

sub DeleteImage()
{
    my ($image_urn, $credentials, $options) = @_;
    if (! defined($image_urn) || ! defined($credentials) ||
	(! defined($options) && $API_VERSION > 1)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }

    my $args = {
        'image_urn' => $image_urn,
        'credentials' => $credentials
    };
    $args->{'creator_urn'} = $options->{'creator_urn'}
        if (defined($options) && exists($options->{'creator_urn'}));
    
    my $response = GeniCMV2::DeleteImage($args);
    if (GeniResponse::IsError($response)) {
        return $response;
    }

    # Return an XML-RPC boolean
    my $coder = Frontier::RPC2->new();
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $coder->boolean(1));
}

sub ListImages()
{
    my ($user_urn, $credentials, $options) = @_;
    if (! defined($user_urn) || ! defined($credentials) ||
	(! defined($options) && $API_VERSION > 1)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }

    my $args = {
        'user_urn' => $user_urn,
        'credentials' => $credentials
    };
    my $response = GeniCMV2::ListImages($args);
    return $response;
}

#----------------------------------------------------------------------
# Morph the ProtoGENI response (a hash with three keys; a
# GeniResponse) into a GENI AMv1 response (a single value or a fault if
# there is an error).
#
# $geni_response is an XML RPC response, which is a three element hash. The
# value element is the GeniResponse hash.
#----------------------------------------------------------------------
sub ConvertResponseV1($)
{
    my ($geni_response) = @_;

    my $decoder = Frontier::RPC2->new();
    my $response;
    
    if (GeniResponse::IsError($geni_response)) {
	# An error result gets mapped to an XML RPC fault
	$response =
	    $decoder->encode_fault(GeniResponse::code($geni_response),
				   GeniResponse::output($geni_response));
    } else {
	# A successful result means return the value
	$response =
	    $decoder->encode_response(GeniResponse::value($geni_response));
    }
    return $response;
}

#----------------------------------------------------------------------
# Morph the ProtoGENI response (a hash with three keys; a
# GeniResponse) into a GENI AMv2 response (same value and output, but
# more complex code format).
#
# $geni_response is an XML RPC response, which is a three element hash. The
# value element is the GeniResponse hash.
#----------------------------------------------------------------------
sub ConvertResponseV2($)
{
    my ($geni_response) = @_;

    my $decoder = Frontier::RPC2->new();
    my $version = $geni_response->{"geni_api"};
    my $am_code = GeniResponse::code($geni_response);
    # For standard GENI errors, the geni_code is the same as our am_code
    my $geni_code = $am_code;
    if ($am_code < GeniResponse::GENIRESPONSE_SUCCESS() ||
	$am_code > GeniResponse::GENIRESPONSE_ALREADYEXISTS()) {
	# If the code is outside of the standard GENI code range, set
	# the geni_code to ERROR
	$geni_code = GeniResponse::GENIRESPONSE_ERROR();
    }
    my $blob = {
	"value" => GeniResponse::value($geni_response),
	"output" => GeniResponse::output($geni_response),
	"code" => {
	    "geni_code" => $geni_code,
	    "am_code" => $am_code,
	    "am_type" => "protogeni"
	}
    };
    if (exists($geni_response->{'protogeni_error_log'})) {
	$blob->{'code'}->{'protogeni_error_log'} =
	    $geni_response->{'protogeni_error_log'};
    }
    if (exists($geni_response->{'protogeni_error_url'})) {
	$blob->{'code'}->{'protogeni_error_url'} =
	    $geni_response->{'protogeni_error_url'};
    }

    if (defined($version)) {
	$blob->{"geni_api"} = $version;
    }

    return $decoder->encode_response($blob);
}

###############################################################################
# AM API V3
###############################################################################

sub Describe
{
    my ($urn_args, $credential_args, $options) = @_;
    if (! defined($urn_args) || ! defined($credential_args)
	|| ! defined($options)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my @urns = @{ $urn_args };
    my $credentials = GeniStd::FilterCredentials($credential_args);

    my $cred = GeniStd::CheckCredentials($credentials);
    return $cred
	if (GeniResponse::IsResponse($cred));

    my ($slice, $aggregate) = GeniCMV2::Credential2SliceAggregate($cred);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));
    return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				"No such slice here")
	if (! defined($slice));
    
    my $ticket = GeniTicket->SliceTicket($slice);
    if (! defined($slice) ||
	(! defined($ticket) && ! defined($aggregate))) {

	my $blob = {
	    'geni_rspec' => GeniStd::GenerateEmptyManifest(),
	    'geni_urn' => $cred->target_urn(),
	    'geni_slivers' => []
	};

	return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
    }

    if (scalar(@urns) != 1 || $urns[0] ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				    "Must pass only slice URN");
    }

    my $manifest;
    if (defined($aggregate)) {
	$aggregate->ComputeState();
	$manifest = $aggregate->GetManifest()
    }
    $manifest = $ticket->rspec()
	if (defined($ticket));
    my @geni_slivers = ();
    my $sliver_blob;

    # Add any slivers that are provisioned (exist in the aggregate)
    if (defined($aggregate)) {
	my @slivers = ();
	if ($aggregate->SliverList(\@slivers) != 0) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Could not get slivers list");
	}
	foreach my $sliver (@slivers) {
	    $sliver_blob = {
		'geni_sliver_urn' => $sliver->sliver_urn(),
		'geni_client_id' => $sliver->nickname(),
		'geni_expires' => $slice->ExpirationUTC(),
		'geni_allocation_status' => "geni_provisioned",
		'geni_operational_status' => GetOpState($sliver),
		'geni_error' => ''
	    };
	    push(@geni_slivers, $sliver_blob);
	}
    }
    # Add any slivers which are allocated (exist in the ticket)
    if (defined($ticket)) {
	# Get expiration date from ticket
	my $parser = XML::LibXML->new;
	my $doc;
	eval {
	    $doc = $parser->parse_string($ticket->asString());
	};
	if ($@) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Failed to parse ticket string: $@");
	}
	my ($expires_node) = $doc->getElementsByTagName("expires");
	if (!defined($expires_node)) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Ticket is missing expires node");
	}
	my $expires = $expires_node->to_literal();

	# Get list of slivers from the rspec
	my $rspec = $ticket->rspec();
	my $sliverids = RspecToSlivers(GeniXML::Serialize($rspec));
	foreach my $sliverid (@{ $sliverids }) {
	    $sliver_blob = {
		'geni_sliver_urn' => $sliverid,
		'geni_expires' => $expires,
		'geni_allocation_status' => "geni_allocated",
		'geni_operational_status' => "geni_pending_allocation",
		'geni_error' => ''
	    };
	    push(@geni_slivers, $sliver_blob);
	}
    }

    my $blob = {
	'geni_rspec' => ( defined($manifest) ? GeniXML::Serialize($manifest) : GeniStd::GenerateEmptyManifest() ),
	'geni_urn' => $slice->urn(),
	'geni_slivers' => \@geni_slivers
    };
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
}

sub Allocate
{
    my ($slice_urn, $credential_args, $rspec, $options) = @_;
    Update($slice_urn, [], $credential_args, $rspec, $options);
}

sub Update
{
    my ($slice_urn, $urn_args, $credential_args, $rspec, $options) = @_;
    if (! defined($slice_urn) || ! defined($urn_args) ||
	! defined($credential_args) || ! defined($rspec) ||
	! defined($options)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my @urns = @{ $urn_args };
    my $credentials = GeniStd::FilterCredentials($credential_args);
    my $cred = GeniStd::CheckCredentials($credentials);
    return $cred
	if (GeniResponse::IsResponse($cred));

    my ($slice, $aggregate) = GeniCMV2::Credential2SliceAggregate($cred);
    if (defined($slice)) {
	if (GeniResponse::IsError($slice)) {
	    return $slice;
	}
	main::AddLogfileMetaDataFromSlice($slice);

	# If a monitor process is running, we are "busy".
	if ($slice->monitor_pid()) {
	    return GeniResponse->MonitorResponse();
	}
    }

    # The URN list must be either empty or contain the slice URN.
    if (scalar(@urns) > 1 ||
	(scalar(@urns) == 1 && $urns[0] ne $slice->urn())) {
	return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				    "Must pass only slice URN");
    }

    # If the URN list is empty, then we just create new slivers,
    # combining the new rspec with the old.
    my $isCreate = 0;
    if (scalar(@urns) == 0) {
	$isCreate = 1;
    }

    my $response = CheckRspec("REQUEST", $rspec);
    return $response
	if (defined($response));

    my $ticket;
    if (defined($slice)) {
	return $slice
	    if (GeniResponse::IsResponse($slice));
	$ticket = GeniTicket->SliceTicket($slice);
    }

    my $combined = $rspec;
    if (defined($ticket)) {
	if ($isCreate) {
	    $combined = CombineDisjoint(GeniXML::Serialize($ticket->rspec()),
					$rspec);
	    $response = CheckRspec("COMBINED W/ TICKET", $combined);
	    return $response
		if (defined($response));
	}
	$response = AllocateTicket($slice_urn, $combined, $credentials,
				   $ticket->asString());
    } elsif (defined($aggregate)) {
	if ($isCreate) {
	    $combined = CombineDisjoint( $aggregate->GetManifest(1), $rspec);
	    $response = CheckRspec("COMBINED W/ AGGREGATE", $combined);
	    return $response
		if (defined($response));
	}
	$response = AllocateAggregate($slice_urn, $combined, $credentials,
				      $aggregate->urn());
    } else {
	$response = AllocateEmpty($slice_urn, $rspec, $credentials);
    }

    if (! GeniResponse::IsError($response)) {
	my $description = Describe([$slice_urn], $credential_args, []);
	if (! GeniResponse::IsError($description)) {
	    my $rspec = $description->{'value'}->{'geni_rspec'};
	    my $blob = {
		'geni_rspec' => $rspec,
		'geni_slivers' => []
	    };
	    for my $sliver (@{ $description->{'value'}->{'geni_slivers'} }) {
		my $out = {
		    'geni_sliver_urn' => $sliver->{'geni_sliver_urn'},
		    'geni_expires' => $sliver->{'geni_expires'},
		    'geni_allocation_status' =>
			$sliver->{'geni_allocation_status'}
		};
		push (@{ $blob->{'geni_slivers'} }, $out);
	    }
	    $response = GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
	} else {
	    $response = $description;
	}
    }
    return $response;
}

# Allocate when there is a ticket or ticket+sliver
sub AllocateTicket
{
    my ($slice_urn, $combined, $credentials, $ticketStr) = @_;
    if (GeniResponse::IsResponse($combined)) {
	return $combined;
    }

    my $args = {
	'slice_urn' => $slice_urn,
	'ticket' => $ticketStr,
	'rspec' => $combined,
	'credentials' => $credentials
    };
    return GeniCMV2::UpdateTicket($args);
}

# Allocate when there is a sliver but no ticket
sub AllocateAggregate
{
    my ($slice_urn, $combined, $credentials, $sliver_urn) = @_;
    if (GeniResponse::IsResponse($combined)) {
	return $combined;
    }
    my $args = {
	'sliver_urn' => $sliver_urn,
	'rspec' => $combined,
	'credentials' => $credentials
    };
    return GeniCMV2::UpdateSliver($args);
}

# Allocate when there are no slices or slivers
sub AllocateEmpty
{
    my ($slice_urn, $rspec, $credentials) = @_;
    my $args = {
	'slice_urn' => $slice_urn,
	'rspec' => $rspec,
	'credentials' => $credentials
    };

    return GeniCMV2::GetTicket($args);
}

sub Renew
{
    my ($urn_args, $credential_args, $expiration_time, $options) = @_;
    if (! defined($urn_args) || ! defined($credential_args) ||
	! defined($expiration_time) || ! defined($options)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my $credentials = GeniStd::FilterCredentials($credential_args);
    my @urns = @{ $urn_args};
    return GeniResponse->MalformedArgsResponse("Empty URN List")
	if (scalar(@urns) < 1);
    my $args = {
	'slice_urn' => $urns[0],
	'expiration' => $expiration_time,
	'credentials' => $credentials,
	'alap' => 0,
    };
    # extend as long as possible.
    if (exists($options->{'geni_extend_alap'}) &&
	$options->{'geni_extend_alap'}) {
	$args->{'alap'} = 1;
    }
    my $response = GeniCMV2::RenewSlice($args);
    if (! GeniResponse::IsError($response)) {
	my $description = Describe($urn_args, $credential_args, []);
	if (! GeniResponse::IsError($description)) {
	    $response = GeniResponse->Create(GENIRESPONSE_SUCCESS,
				      $description->{'value'}->{'geni_slivers'});
	} else {
	    $response = $description;
	}
    }
    return $response;
}

sub Provision
{
    my ($urn_args, $credential_args, $options) = @_;
    if (! defined($urn_args) || ! defined($credential_args) ||
	! defined($options)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my @urns = @{ $urn_args };
    return GeniResponse->MalformedArgsResponse("Empty URN List")
	if (scalar(@urns) < 1);
    my $credentials = GeniStd::FilterCredentials($credential_args);
    my $users = $options->{'geni_users'};
    my $sliver_keys = [];
    if (defined($users) && @$users) {
	foreach my $user (@$users) {
	    my $user_urn  = $user->{'urn'};
	    my @user_keys = ();

	    foreach my $key (@{ $user->{keys} }) {
		# The CMV2 does not like newlines at the end of the keys.
		chomp($key);
		push(@user_keys, {'type' => 'ssh', 'key' => $key});
	    }
	    my $blob = {'urn'  => $user_urn,
			'keys' => \@user_keys};
	    if (exists($user->{'privs'})) {
		$blob->{'privs'} = $user->{'privs'};
	    }
	    push(@{$sliver_keys}, $blob);
	}
    }

    my $cred = GeniStd::CheckCredentials($credentials);
    return $cred
	if (GeniResponse::IsResponse($cred));

    my ($slice, undef) = GeniCMV2::Credential2SliceAggregate($cred);
    return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
			"No slice here that matches the provided credentials")
	if (! defined($slice));

    return $slice
	if (GeniResponse::IsResponse($slice));

    if (scalar(@urns) != 1 || $urns[0] ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				    "Must pass only slice URN");
    }

    my $ticket = GeniTicket->SliceTicket($slice);
    return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				"No allocated slivers exist")
	if (! defined($ticket));

    my $args = {
	'slice_urn' => $urns[0],
	'ticket' => $ticket->ticket_string(),
	'credentials' => $credentials,
	'keys' => $sliver_keys
    };
    if (defined($options)) {
	if (exists($options->{'geni_certificate'})) {
	    $args->{'certificate'} = $options->{'geni_certificate'};
	}
	if (exists($options->{'geni_key'})) {
	    $args->{'key'} = $options->{'geni_key'};
	}
    }
    my $response = GeniCMV2::RedeemTicket($args);
    if (! GeniResponse::IsError($response)) {
	my $description = Describe($urn_args, $credential_args, []);
	if (! GeniResponse::IsError($description)) {
	    my $blob = {
		'geni_rspec' => $description->{'value'}->{'geni_rspec'},
		'geni_slivers' => $description->{'value'}->{'geni_slivers'}
	    };
	    $response = GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
	} else {
	    $response = $description;
	}
    }
    return $response;
}

sub Status
{
    my $response = Describe(@_);
    if (! GeniResponse::IsError($response)) {
	my $blob = {
	    'geni_urn' => $response->{'value'}->{'geni_urn'},
	    'geni_slivers' => $response->{'value'}->{'geni_slivers'}
	};
	$response = GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
    }
    return $response;
}

sub PerformOperationalAction
{
    my ($urn_args, $credential_args, $action, $options) = @_;
    my @urns = @{ $urn_args };
    return GeniResponse->MalformedArgsResponse("Empty URN List")
	if (scalar(@urns) < 1);

    my $credentials = GeniStd::FilterCredentials($credential_args);
    my $args = {
	'credentials' => $credentials
    };

    my $cred = GeniStd::CheckCredentials($credentials);
    return $cred
	if (GeniResponse::IsResponse($cred));

    my ($slice, $aggregate) = GeniCMV2::Credential2SliceAggregate($cred);
    return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
			"No slice here that matches the provided credentials")
	if (! defined($slice));

    if ($urns[0] eq $slice->urn()) {
	$args->{'slice_urn'} = $slice->urn();
    } else {
	$args->{'sliver_urns'} = $urn_args;
    }

    if ($action eq 'geni_start') {
	return GeniCMV2::StartSliver($args);
    } elsif ($action eq 'geni_restart') {
	return GeniCMV2::RestartSliver($args);
    } elsif ($action eq 'geni_stop') {
	return GeniCMV2::StopSliver($args);
    } elsif ($action eq 'geni_reload' || $action eq 'pg_reload') {
	return GeniCMV2::ReloadSliver($args);
    } elsif ($action eq 'geni_update_users') {
	if (!exists($options->{"geni_users"})) {
	    return GeniResponse->MalformedArgsResponse("No keys provided!");
	}
	my $users = $options->{'geni_users'};
	if (! (ref($users) && ref($users) eq "ARRAY")) {
	    return GeniResponse->MalformedArgsResponse("Malformed keys!");
	}
	my $sliver_keys = [];
	foreach my $user (@$users) {
	    my $user_urn  = $user->{'urn'};
	    my @user_keys = ();
	    
	    foreach my $key (@{ $user->{'keys'} }) {
		# The CMV2 does not like newlines at the end of the keys.
		chomp($key);
		push(@user_keys, {'type' => 'ssh', 'key' => $key});
	    }
	    push(@{$sliver_keys}, {'urn'  => $user_urn,
				   'keys' => \@user_keys});
	}
	$args->{'slice_urn'} = $slice->urn();
	$args->{'keys'}      = $sliver_keys;
 	$args->{'amapiv3'}   = 1;
	
	return GeniCMV2::BindToSlice($args);
    }
    elsif ($action eq 'geni_update_users_cancel') {
	#
	# All we care about is making sure the state is cleared
	# from the aggregate and all of the slivers. 
	#
	if ($slice->Lock() != 0) {
	    return GeniResponse->BusyResponse();
	}
	if ($aggregate->state() ne "updating_users") {
	    $slice->UnLock();
	    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
	}
	if ($aggregate->CancelUpdateAccounts()) {
	    $slice->UnLock();
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_SUCCESS);
    }
    elsif ($action eq 'geni_sharelan') {
	if (!exists($options->{"geni_sharelan_lanname"})) {
	    return GeniResponse->MalformedArgsResponse("No lanname provided!");
	}
	if (!exists($options->{"geni_sharelan_token"})) {
	    return GeniResponse->MalformedArgsResponse("No token provided!");
	}
	$args->{'slice_urn'} = $slice->urn();
	$args->{'token'}     = $options->{"geni_sharelan_token"};
	$args->{'lanname'}   = $options->{"geni_sharelan_lanname"};
	if (exists($options->{"geni_sharelan_restricted"})) {
	    $args->{'restricted'} = $options->{"geni_sharelan_restricted"};
	}
	return GeniCMV2::ShareLan($args);
    }
    elsif ($action eq 'geni_unsharelan') {
	if (!exists($options->{"geni_sharelan_lanname"})) {
	    return GeniResponse->MalformedArgsResponse("No lanname provided!");
	}
	$args->{'slice_urn'} = $slice->urn();
	$args->{'lanname'}   = $options->{"geni_sharelan_lanname"};
	
	return GeniCMV2::UnShareLan($args);
    }
    elsif ($action eq 'geni_console_url') {
	if (!exists($args->{'sliver_urns'})) {
	    return GeniResponse->MalformedArgsResponse("No sliver provided!");
	}
	my ($sliver_urn) = @{$args->{'sliver_urns'}};
	
	$args->{'slice_urn'}   = $slice->urn();
	$args->{'sliver_urn'}  = $sliver_urn;

	return GeniCMV2::ConsoleURL($args);
    }
    return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				"Invalid operational action");
}

sub Delete
{
    my ($urn_args, $credential_args, $option_args) = @_;
    my @urns = @{ $urn_args };
    return GeniResponse->MalformedArgsResponse("Empty URN List")
	if (scalar(@urns) < 1);

    # Must create return structure before deletion because this data
    # won't exist afterwards.
    my $description = Describe($urn_args, $credential_args, []);
    return $description
	if (GeniResponse::IsError($description));
    my $slivers = [];
    foreach my $sliver (@{ $description->{'value'}->{'geni_slivers'} }) {
	my $blob = {
	    'geni_sliver_urn' => $sliver->{'geni_sliver_urn'},
	    'geni_allocation_status' => 'geni_unallocated',
	    'geni_expires' => $sliver->{'geni_expires'},
	    'geni_error' => ''
	};
	push(@{ $slivers }, $blob);
    }

    my $credentials = GeniStd::FilterCredentials($credential_args);
    my $args = {
	'slice_urn' => $urns[0],
	'credentials' => $credentials
    };
    # Optional blocking.
    if (defined($option_args) &&
	exists($option_args->{'blocking'}) && $option_args->{'blocking'}) {
	$args->{'blocking'} = 1;
    }
    my $response = GeniCMV2::DeleteSlice($args);
    if (!ref($response)) {
	# This is cause GeniCMV2::DeleteSlice does a fork, and the child
	# returns plain status code, which should go to our caller. 
	return $response;
    }
    if (! GeniResponse::IsError($response)) {
	$response = GeniResponse->Create(GENIRESPONSE_SUCCESS, $slivers);
    }
    return $response;
}

sub Cancel
{
    my ($urn_args, $credential_args, $option_args) = @_;
    my @urns = @{ $urn_args };
    return GeniResponse->MalformedArgsResponse("Empty URN List")
	if (scalar(@urns) < 1);

    my $credentials = GeniStd::FilterCredentials($credential_args);
    my $cred = GeniStd::CheckCredentials($credentials);
    return $cred
	if (GeniResponse::IsResponse($cred));

    my ($slice, undef) = GeniCMV2::Credential2SliceAggregate($cred);
    my $response;
    my $ticket = GeniTicket->SliceTicket($slice);
    if (defined($ticket)) {
	my $credentials = GeniStd::FilterCredentials($credential_args);
	my $args = {
	    'slice_urn' => $urns[0],
	    'ticket' => $ticket->ticket_string(),
	    'credentials' => $credentials
	};
	$response = GeniCMV2::ReleaseTicket($args);
    }
    if (! GeniResponse::IsError($response)) {
	$response = Describe($urn_args, $credential_args, []);
    }
    return $response;
}

# Determines operational state based on the state/status of a sliver.
sub GetOpState
{
    my ($sliver) = @_;
    #NOTE: geni_ready (or geni_failed) should not be the default.
    #      better to return "unknown", instead of risking a wrong status.
    my $result = 'unknown';
    if ($sliver->status() eq 'failed') {
	$result = 'geni_failed';
    } elsif ($sliver->status() eq 'unknown') {
	$result = 'unknown';
    } elsif ($sliver->status() eq 'ready') {
	$result = 'geni_ready';
    } elsif ($sliver->status() eq 'changing'
	     && $sliver->state() eq 'started') {
	$result = 'geni_configuring';
    } elsif ($sliver->status() eq 'notready') {
	$result = 'geni_notready';
    } elsif ($sliver->status() eq 'changing'
	     && $sliver->state() eq 'stopped') {
	$result = 'geni_stopping';
    } elsif ($sliver->status() eq 'created'
	     && $sliver->state() eq 'new') {
	$result = 'geni_notready';
    } elsif ($sliver->status() eq 'changing'
	     && $sliver->state() eq 'new') {
	$result = 'geni_notready';
    } elsif ($sliver->status() eq 'changing'
	     && $sliver->state() eq 'updating_users') {
	$result = 'geni_updating_users';
    } else {
        print STDERR "\nWARNING AMv3 Status processing: unknown status." .
                     " Details:\n   sliver->status=".$sliver->status() .
                     "\n    sliver->state=".$sliver->state()."\n\n";
        $result = 'unknown';
    }
    return $result;
}

# Rspec is expected to be in string form.
# Returns a list of sliver URNs found in the rspec.
sub RspecToSlivers
{
    my $result = [];
    my ($rspecStr) = @_;
    my $rspec = GeniXML::Parse($rspecStr);
    if (defined($rspec)) {
	foreach my $noderef (GeniXML::FindNodes("n:node",
						$rspec)->get_nodelist()) {
	    my $sliver_id = GeniXML::GetSliverId($noderef);
	    if (defined($sliver_id)) {
		push(@{ $result }, $sliver_id);
	    }
	}
    }
    return $result;
}

# Rspec is an XML tree.
# Returns a table of client_ids
sub RspecToClientIds
{
    my $result = {};
    my ($rspec) = @_;
    if (defined($rspec)) {
	my @nodes = GeniXML::FindNodes("n:node",
				       $rspec)->get_nodelist();
	my @links = GeniXML::FindNodes("n:link",
				       $rspec)->get_nodelist();
	my @ifaces = GeniXML::FindNodes("n:node/n:interface",
					$rspec)->get_nodelist();
	push(@nodes, @links, @ifaces);
	foreach my $noderef (@nodes) {
	    my $id = GeniXML::GetVirtualId($noderef);
	    if (defined($id)) {
		$result->{$id} = 1;
	    }
	}
    }
    return $result;    
}

# currentStr and newStr are both rspec strings
# Returns a combined rspec string or a GeniResponse error
sub CombineDisjoint
{
    my ($currentStr, $newStr) = @_;
    my $current = GeniXML::Parse($currentStr);
    my $new = GeniXML::Parse($newStr);
    if (! defined($current) || ! defined($new)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Could not parse rspecs on allocate");
    }
    my $currentIds = RspecToClientIds($current);
    my $newIds = RspecToClientIds($new);
    my $found = 0;
    foreach my $id (keys(%{ $newIds })) {
	if (exists($currentIds->{$id})) {
	    $found = 1;
	    last;
	}
    }
    if ($found) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "New rspec is not disjoint from sliver");
    }

    foreach my $child ($new->childNodes()) {
	$current->appendChild($child);
    }

    return GeniXML::Serialize($current);
}

# Returns true if the list of slivers has a slice urn
sub HasSliceUrn
{
    my ($slice, $slivers) = @_;
    my $result = 0;
    foreach my $item (@{ $slivers }) {
	if ($slice->urn() eq $item) {
	    $result = 1;
	    last;
	}
    }
    return $result;
}

# Returns true if left and right are the same set of slivers.
sub SameSlivers
{
    my ($left, $right) = @_;
    my $result = 1;
    my %leftTable = ();
    foreach my $item (@{ $left }) {
	$leftTable{$item} = 1;
    }
    if (scalar(keys(%leftTable)) != scalar(@{ $right })) {
	$result = 0;
    } else {
	foreach my $item (@{ $right }) {
	    if (! exists($leftTable{$item})) {
		$result = 0;
		last;
	    }
	}
    }
    return $result;
}

# Check rspec using rspeclint
# Returns undefined on success or a GeniResponse on error.
sub CheckRspec
{
    my ($type, $rspec) = @_;
    my $result;

    my ($fh, $filename) = tempfile(UNLINK => 0);
    if (!defined($fh)) {
	$result = GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				       "Could not check rspec");
    } else {
	print $fh $rspec;
	close($fh);
	my $rspecerrors = `$RSPECLINT $filename 2>&1`;
	#if ($?) {
	#    unlink($filename);
	#    $result = GeniResponse->Create(GENIRESPONSE_ERROR,
	#				   $rspecerrors,
	#				   $type . " rspec does not validate");
	#}
	if ($rspecerrors ne "") {
	    print STDERR "--- BEGIN RSPECLINT ERRORS $type ---\n";
	    print STDERR $rspecerrors;
	    print STDERR "--- END RSPECLINT ERRORS $type ---\n\n";
	}
	unlink($filename);
    }
    return $result;
}

# _Always_ make sure that this 1 is at the end of the file...
1;
