#!/usr/bin/perl -w
#
# Copyright (c) 2005-2020 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
package libvtop_stable;

use strict;
use Exporter;
use vars qw(@ISA @EXPORT @EXPORT_OK
	    $VTOP_FLAGS_UPDATE $VTOP_FLAGS_VERBOSE $VTOP_FLAGS_QUIET
	    $VTOP_FLAGS_FIXNODES $VTOP_FLAGS_IMPOTENT $VTOP_FLAGS_ALLOCONLY
	    $VTOP_FLAGS_REGRESSION $VTOP_FLAGS_FIXLANNODES
	    $VTOP_FLAGS_PREASSIGN $VTOP_FLAGS_COMMITMODE);

@ISA    = "Exporter";
@EXPORT = qw( );

use libdb;
use libtblog_simple;
use libtestbed;
use Experiment;
use EmulabConstants;
use VirtExperiment;
use Node;
use NodeType;
use Lan;
use OSImage;
use Image;   # For datasets.
use Blockstore;
use Lease;
use Port;
use English;
use emutil qw(SpanningTree GenFakeMac);
use Data::Dumper;
use Carp;
use POSIX;
use XML::LibXML;
use XML::Simple;

# Configure variables
my $TB		  = "@prefix@";
my $BOSSNODE      = "@BOSSNODE@";
my $AVAIL         = "$TB/bin/avail";
my $NALLOC        = "$TB/bin/nalloc";
my $NFREE         = "$TB/bin/nfree";
my $OS_SELECT     = "$TB/bin/os_select";
my $DELAYCAPACITY = @DELAYCAPACITY@;	# Can be overridden by user.
my $DELAYTHRESH   = @DELAYTHRESH@;
my $PGENISUPPORT  = @PROTOGENI_SUPPORT@;
my $OURDOMAIN     = "@OURDOMAIN@";
my $MAINSITE      = @TBMAINSITE@;
my $mycmurn       = "";

if ($PGENISUPPORT) {
  require GeniHRN;
  $mycmurn = GeniHRN::Generate("@OURDOMAIN@", "authority", "cm");  
}

# Flags.
$VTOP_FLAGS_VERBOSE	= 0x01;
$VTOP_FLAGS_UPDATE	= 0x02;
$VTOP_FLAGS_FIXNODES	= 0x04;
$VTOP_FLAGS_IMPOTENT	= 0x08;
$VTOP_FLAGS_REGRESSION  = 0x10;
$VTOP_FLAGS_QUIET       = 0x20;
$VTOP_FLAGS_ALLOCONLY	= 0x40;
$VTOP_FLAGS_FIXLANNODES	= 0x80;
$VTOP_FLAGS_PREASSIGN	= 0x100;
$VTOP_FLAGS_COMMITMODE	= 0x200;

@EXPORT_OK = qw($VTOP_FLAGS_UPDATE $VTOP_FLAGS_VERBOSE $VTOP_FLAGS_FIXNODES
		$VTOP_FLAGS_IMPOTENT $VTOP_FLAGS_REGRESSION $VTOP_FLAGS_QUIET
		$VTOP_FLAGS_ALLOCONLY $VTOP_FLAGS_FIXLANNODES
		$VTOP_FLAGS_PREASSIGN $VTOP_FLAGS_COMMITMODE);

#
# Create an object representing the stuff we need to create the vtop file.
#
sub Create($$$$;$)
{
    my ($class, $experiment, $user, $flags, $realuser) = @_;

    my $virtexperiment = VirtExperiment->Lookup($experiment);
    if (!defined($virtexperiment)) {
	tberror("Could not load virtual experiment object for $experiment\n");
	return undef;
    }
    # Permission checks made for real user, not effective user.
    $realuser = $user
	if (!defined($realuser));

    my $self              = {};
    $self->{'EXPERIMENT'} = $experiment;
    $self->{'USER'}       = $user;
    $self->{'REALUSER'}   = $realuser;
    $self->{'VIRTEXPT'}   = $virtexperiment;
    $self->{'FLAGS'}      = $flags;
    $self->{'TYPES'}      = {};
    $self->{'FIXED'}      = {};
    $self->{'VNODES'}     = {};
    $self->{'DELAYNODES'} = {};
    $self->{'LANNODES'}   = {};
    $self->{'BRIDGES'}    = {};
    $self->{'BLOCKSTORES'}= {};
    $self->{'SANHOSTS'}   = {};
    $self->{'VLANS'}      = {};
    $self->{'VPATHS'}     = {};
    $self->{'MEMBEROF'}   = {};
    $self->{'COUNTERS'}   = {};
    $self->{'EXPTSTATS'}  = {};
    $self->{'DELAYLINKS'} = {};
    $self->{'VLINKS'}     = {};
    $self->{'OPTIONS'}    = {};
    $self->{'DELAYID'}    = 0;
    $self->{'PHOSTID'}    = 0;
    $self->{'IFACEID'}    = 32768;
    $self->{'PORTBW'}     = {};
    $self->{'RESULTS'}    = { "nodes"  => [],
			      "links"  => [],
			      "class"  => [],
			      "fixed"  => [] };
    $self->{'RSPEC'}      = {};
    $self->{'GENIRSPEC'}  = undef;
    $self->{'IMAGES'}     = {};

    # For forcing untyped nodes to an architecture.
    $self->{'FORCEARCH'}  = undef;
    
    # Mostly for update mode.
    $self->{'FIXEDNODES'}  = {};
    $self->{'CURRENT_V2P'} = {};
    $self->{'CURRENT_V2P'} = {};
    $self->{'CURRENT_P2V'} = {};
    $self->{'CURRENT_V2V'} = {};
    $self->{'OLDRSRVCLEAN_FLAG'}  = 0;
    $self->{'OLDRSRVCLEAN_NODES'} = {};

    # This is just for lannodes.
    $self->{'CURRENT_V2PMAP'} = {};

    # Below is for interpretation of assign results.
    $self->{'PNODES'}      = {};
    $self->{'SOLUTION'}    = {};
    $self->{'NEWRESERVED'} = {};	# Newly reserved nodes.
    $self->{'NORECOVER'}   = 0;	
    
    bless($self, $class);
    $virtexperiment->Dump()
	if (0 && $self->verbose());

    return $self;
}
# accessors
sub experiment($)       { return $_[0]->{'EXPERIMENT'}; }
sub user($)             { return $_[0]->{'USER'}; }
sub realuser($)         { return $_[0]->{'REALUSER'}; }
sub virtexperiment($)   { return $_[0]->{'VIRTEXPT'}; }
sub flags($)            { return $_[0]->{'FLAGS'}; }
# These two go back to the mapper for admission control.
sub types($)            { return $_[0]->{'TYPES'}; }
sub fixed($)            { return $_[0]->{'FIXED'}; }
sub vnodes($)           { return $_[0]->{'VNODES'}; }
sub delaynodes($)       { return $_[0]->{'DELAYNODES'}; }
sub bridges($)          { return $_[0]->{'BRIDGES'}; }
sub blockstores($)      { return $_[0]->{'BLOCKSTORES'}; }
sub sanhosts($)         { return $_[0]->{'SANHOSTS'}; }
sub lannodes($)         { return $_[0]->{'LANNODES'}; }
sub vlans($)            { return $_[0]->{'VLANS'}; }
sub memberof($)         { return $_[0]->{'MEMBEROF'}; }
sub vpaths($)           { return $_[0]->{'VPATHS'}; }
sub counters($)         { return $_[0]->{'COUNTERS'}; }
sub counter($$)         { return $_[0]->{'COUNTERS'}->{$_[1]}; }
sub options($)          { return $_[0]->{'OPTIONS'}; }
sub option($$)          { return (exists($_[0]->{'OPTIONS'}->{$_[1]}) ?
				  $_[0]->{'OPTIONS'}->{$_[1]} : undef); }
sub exptstats($)        { return $_[0]->{'EXPTSTATS'}; }
sub vlinks($)           { return $_[0]->{'VLINKS'}; }
sub delaylinks($)       { return $_[0]->{'DELAYLINKS'}; }
sub delaynodecount()    { return scalar(keys(%{ $_[0]->delaynodes() })); }
sub portbw($)           { return $_[0]->{'PORTBW'}; }
sub results($)          { return $_[0]->{'RESULTS'}; }
sub current_v2p($)      { return $_[0]->{'CURRENT_V2P'}; }
sub current_p2v($)      { return $_[0]->{'CURRENT_P2V'}; }
sub current_v2v($)      { return $_[0]->{'CURRENT_V2V'}; }
sub current_v2pmap($)   { return $_[0]->{'CURRENT_V2PMAP'}; }
sub pnodes($)           { return $_[0]->{'PNODES'}; }
sub fixednodes($)       { return $_[0]->{'FIXEDNODES'}; }
sub newreserved($)      { return $_[0]->{'NEWRESERVED'}; }
sub clearnewreserved($) { $_[0]->{'NEWRESERVED'} = {}; }
sub allimages($)        { return $_[0]->{'IMAGES'}; }
sub rspec($)            { return $_[0]->{'RSPEC'}; }
sub genirspec($)        { return $_[0]->{'GENIRSPEC'}; }
sub forcedarchitecture($){ return $_[0]->{'FORCEARCH'}; }
sub newreservednodes($) { return keys(%{ $_[0]->{'NEWRESERVED'} }); }
sub oldreservednodes($) { return $_[0]->{'OLDRSRVCLEAN_NODES'}; }
sub norecover($)        { return $_[0]->{'norecover'}; }
sub pid($)		{ return $_[0]->experiment()->pid(); }
sub pid_idx($)		{ return $_[0]->experiment()->pid_idx(); }
sub eid($)		{ return $_[0]->experiment()->eid(); }
sub exptidx($)		{ return $_[0]->experiment()->idx(); }

# The virtual tables from the DB.
sub virt_table($$)      { return $_[0]->virtexperiment()->Table($_[1]); }
sub virt_vtypes($)	{ return $_[0]->virt_table("virt_vtypes"); }
sub virt_nodes($)       { return $_[0]->virt_table("virt_nodes"); }
sub virt_lans($)        { return $_[0]->virt_table("virt_lans"); }
sub virt_lan_lans($)    { return $_[0]->virt_table("virt_lan_lans"); }
sub virt_paths($)       { return $_[0]->virt_table("virt_paths"); }
sub virt_bridges($)     { return $_[0]->virt_table("virt_bridges"); }
sub virt_desires($)	{ return $_[0]->virt_table("virt_node_desires"); }
sub virt_attributes($)	{ return $_[0]->virt_table("virt_node_attributes"); }
sub virt_startloc($)	{ return $_[0]->virt_table("virt_node_startloc"); }
sub virt_trafgens($)	{ return $_[0]->virt_table("virt_trafgens"); }
sub virt_lan_settings($){ return $_[0]->virt_table("virt_lan_settings"); }
sub virt_lan_member_settings($)	{
    return $_[0]->virt_table("virt_lan_member_settings"); }
sub virt_blockstores($) { return $_[0]->virt_table("virt_blockstores"); }
sub virt_blockstore_attributes($) {
    return $_[0]->virt_table("virt_blockstore_attributes"); }

# Given a vname, is it a node in the topo (or something else like a delay).
sub isatoponode($$)     { return exists($_[0]->vnodes()->{$_[1]}); }
sub isadelaynode($$)    { return exists($_[0]->delaynodes()->{$_[1]}); }
sub isasanhost($$)      { return exists($_[0]->sanhosts()->{$_[1]}); }

# Debug output.
sub verbose($)		{ return $_[0]->flags() & $VTOP_FLAGS_VERBOSE; }
sub quiet($)		{ return $_[0]->flags() & $VTOP_FLAGS_QUIET; }
sub updating($)		{ return $_[0]->flags() & $VTOP_FLAGS_UPDATE; }
sub fixcurrent($)	{ return $_[0]->flags() & $VTOP_FLAGS_FIXNODES; }
sub fixlanodes($)	{ return $_[0]->flags() & $VTOP_FLAGS_FIXLANNODES; }
sub impotent($)		{ return $_[0]->flags() & $VTOP_FLAGS_IMPOTENT; }
sub alloconly($)	{ return $_[0]->flags() & $VTOP_FLAGS_ALLOCONLY; }
sub regression($)	{ return $_[0]->flags() & $VTOP_FLAGS_REGRESSION; }
sub preassign($)	{ return $_[0]->flags() & $VTOP_FLAGS_PREASSIGN; }
sub commitmode($)	{ return $_[0]->flags() & $VTOP_FLAGS_COMMITMODE; }
sub printdb($$)		{ print $_[1] if ($_[0]->verbose()); return 1; }

# We name delay nodes internally as they are needed.
sub nextdelayname($)    { return "tbdelay" . $_[0]->{'DELAYID'}++; }
# For when the user wants a specific delay os. Use a desire.
# sub delay_desire($)	{ return $_[0]->option("delay_desire_string"); }
sub delay_desire_type($)	{ return $_[0]->option("delay_desire_type"); }
sub delay_desire_name($)	{ return $_[0]->option("delay_desire_name"); }
sub delay_desire_penalty($)	{ return $_[0]->option("delay_desire_penalty"); }
# For XML
sub nextifacenumber($)  { return $_[0]->{'IFACEID'}++; }
sub nextphostnumber($)  { return $_[0]->{'PHOSTID'}++; }

# Virtual Types. 
sub virttypeisvtype($$) { return $_[0]->virt_vtypes()->Find($_[1]); }
sub VirtTypes($)        { return $_[0]->virt_vtypes()->Rows(); }

# Caller will want these.
sub minimum_nodes($)    { return $_[0]->counter("minimum_nodes"); }
sub maximum_nodes($)    { return $_[0]->counter("maximum_nodes"); }
sub nodecount($)	{ return $_[0]->counter("nodecount"); }
sub plabcount($)	{ return $_[0]->counter("plabcount"); }
sub genicount($)	{ return $_[0]->counter("genicount"); }
sub virtnodecount($)	{ return $_[0]->counter("virtcount"); }
sub simnodecount($)	{ return $_[0]->counter("simcount"); }
sub remotenodecount($)	{ return $_[0]->counter("remotecount"); }
sub sharednodecount($)	{ return $_[0]->counter("sharedcount"); }
sub bstorecount($)	{ return $_[0]->counter("bstorecount"); }
sub gblinks($)		{ return $_[0]->counter("Gblinks"); }
sub mgblinks($)		{ return $_[0]->counter("MGblinks"); }

sub createLink($$$$$$$$$)
{
    # $others here will be a hashtable for the link flags.  The table
    # could also contain non-default values for latency and
    # packet_loss
    my ($self, $name, $plink, $cm, $src, $dst, $bw, $type, $others) = @_;
    my $ref = {
	'virtual_id'     => $name,
	'plink'		 => $plink,
	'manager_urn'    => $cm,
	'link_type'      => $type,
	'interface_ref'  => [$src, $dst],
	'capacity'       => $bw,
	'packet_loss'    => "0",
	'latency'        => "0"
    };
    
    if ($others) {
	while ( my ($key, $value) = each %{$others} ) {
	    $ref->{$key} = $value;
	}
    }
    if (!exists($self->rspec()->{'link'})) {
	$self->rspec()->{'link'} = [];
    }
    push(@{ $self->rspec()->{'link'} }, $ref);
}

sub createNode ($$$$$$$;$)
{
    # $others here will be a hashtable for the desires
    # The key will be the desire name and the value will be a pair
    # of the desire type and the penalty
    my ($self, $name, $cm, $type, $typecount, $desires, $others, $ifaces) = @_;
    my $ref = {
	'virtual_id'    => $name,
	'manager_urn'   => $cm,
    };
    
    my $typename = $type;
    my $typeslots = $typecount;
    my $isstatic = 0;
    if ($typename =~ /^\*([-\w]*)$/) {
	$typename = $1;
	$isstatic = 1;
    }
    if ($typecount eq '*') {
	$typeslots = 'unlimited';
    }

    # We will need this to generate interface names later
    $ref->{'interface_count'} = 0;
    $ref->{'interfaces'} = $ifaces;

    $ref->{'node_type'} = $typename;
    $ref->{'type_slots'} = $typecount;
    $ref->{'node_static'} = $isstatic;

    my $desiretable = {};
    if ($desires) {
	while ( my ($key, $value) = each %{$desires} ) {
	    $desiretable->{$key} = $value;
	}
    }
    $ref->{'desires'} = $desiretable;
    
    if ($others) {
	while ( my ($key, $value) = each %{$others} ) {
	    $ref->{$key} = $value;
	}
    }
    
    if (!exists($self->rspec()->{'node'})) {
	$self->rspec()->{'node'} = [];
    }
    push(@{ $self->rspec()->{'node'} }, $ref);
}

sub createVClass ($$$$)
{
    my ($self, $name, $weight, $members) = @_;
    my $ref = {
	'name'    => $name,
	'weight'  => $weight,
	'members' => $members
    };
    if (!exists($self->rspec()->{'vclass'})) {
	$self->rspec()->{'vclass'} = [];
    }
    push(@{ $self->rspec()->{'vclass'} }, $ref);
}

sub createFixedNode ($$$)
{
    my ($self, $vnode, $pnode) = @_;
    my $ref = { 'vnode' => $vnode,
		# XXX Going to need a URN in rspec output ...
		'pnode' => $pnode,
    };
    if (!exists($self->rspec()->{'fixed'})) {
	$self->rspec()->{'fixed'} = [];
    }
    push(@{ $self->rspec()->{'fixed'} }, $ref);
}

###############################################################################
# Virtual Nodes. A separate package so we can create objects for each one
# and then add local stuff to them.
#
package libvtop::virt_node;
use Carp;
use vars qw($AUTOLOAD);
use overload ('""' => 'Stringify');

# To avoid wrtting out all the methods.
sub AUTOLOAD {
    my $self = shift;
    my $type = ref($self) or croak "$self is not an object";

    my $name = $AUTOLOAD;
    $name =~ s/.*://;   # strip fully-qualified portion

    if (@_) {
	return $self->{'HASH'}->{$name} = shift;
    }
    elsif (exists($self->{'HASH'}->{$name})) {
	return $self->{'HASH'}->{$name};
    }
    else {
	return $self->virt_node()->$name();
    }
}

#
# Wrap up a virt node.
#
sub Create($$$)
{
    my ($class, $vtop, $virt_node) = @_;

    my $self = {};
    bless($self, $class);

    $self->{'VIRTNODE'}   = $virt_node;
    $self->{'VTOP'}       = $vtop;
    $self->{'HASH'}       = {};
    # The virtlans this virtnode is a member of. 
    $self->{'MEMBERSHIP'} = {};
    
    return $self;
}
# accessors
sub virt_node($)	{ return $_[0]->{'VIRTNODE'}; }
sub vtop($)		{ return $_[0]->{'VTOP'}; }
sub hash($)		{ return $_[0]->{'HASH'}; }
sub membership($)       { return $_[0]->{'MEMBERSHIP'}; }
sub memberlist($)       { return values(%{ $_[0]->{'MEMBERSHIP'} }); }

# Break circular reference someplace to avoid exit errors.
sub DESTROY {
    my $self = shift;

    $self->{'VIRTNODE'}   = undef;
    $self->{'VTOP'}       = undef;
    $self->{'HASH'}       = undef;
    $self->{'MEMBERSHIP'} = undef;
}

sub Stringify($)
{
    my ($self) = @_;
    my $vname  = $self->vname();

    return "[vnode:$vname]";
}

###############################################################################
# Virtual Lans. This wraps up the virt_lan_lan table, and allows storing
# the members (virt_lans table entries).
#
package libvtop::virt_lan;
use Carp;
use vars qw($AUTOLOAD);
use overload ('""' => 'Stringify');

# To avoid wrtting out all the methods.
sub AUTOLOAD {
    my $self = shift;
    my $type = ref($self) or croak "$self is not an object";

    my $name = $AUTOLOAD;
    $name =~ s/.*://;   # strip fully-qualified portion

    if (@_) {
	return $self->{'HASH'}->{$name} = shift;
    }
    elsif (exists($self->{'HASH'}->{$name})) {
	return $self->{'HASH'}->{$name};
    }
    else {
	return $self->virt_lanlan()->$name();
    }
}

#
# Wrap up a virt lan.
#
sub Create($$$$)
{
    my ($class, $vtop, $virt_lanlan) = @_;

    my $self = {};
    bless($self, $class);

    $self->{'VIRTLANLAN'}    = $virt_lanlan;
    $self->{'VTOP'}          = $vtop;
    $self->{'MEMBERHASH'}    = {};
    $self->{'MEMBERLIST'}    = [];
    $self->{'SHAPEDMEMBERS'} = {};
    $self->{'HASH'}          = {};

    return $self;
}
# accessors
sub virt_lanlan($)	{ return $_[0]->{'VIRTLANLAN'}; }
sub members($)		{ return $_[0]->{'MEMBERHASH'}; }
sub memberlist($)       { return @{ $_[0]->{'MEMBERLIST'} }; }
sub member($$)          { return @{ $_[0]->{'MEMBERLIST'} }[$_[1]]; }
sub shapedmembers($)	{ return $_[0]->{'SHAPEDMEMBERS'}; }
sub vtop($)		{ return $_[0]->{'VTOP'}; }
sub hash($)		{ return $_[0]->{'HASH'}; }
sub islink($)           { return (@{ $_[0]->{'MEMBERLIST'} } == 2 ? 1 : 0); }

# Break circular reference someplace to avoid exit errors.
sub DESTROY {
    my $self = shift;

    $self->{'VIRTLANLAN'} = undef;
    $self->{'MEMBERHASH'} = undef;
    $self->{'MEMBERLIST'} = undef;
    $self->{'VTOP'}       = undef;
    $self->{'HASH'}       = undef;
}

sub Stringify($)
{
    my ($self) = @_;
    my $vname  = $self->vname();

    return "[vlan:$vname]";
}

sub addmember($$)
{
    my ($self, $vlanmember) = @_;
    
    $self->members()->{$vlanmember->member()} = $vlanmember;

    @{ $self->{'MEMBERLIST'} }[$vlanmember->vindex()] = $vlanmember;

    return 0;
}

#
# Other support functions.
#
sub usevirtiface($)
{
    my ($self) = @_;
    my $encap  = $self->_encapstyle();

    return ($encap eq "veth-ne" || $encap eq "vlan");
}
sub membershaped($$) {
    my ($self, $member) = @_;
    return $self->shapedmembers()->{"$member"};
}
sub setmembershaped($$) {
    my ($self, $member) = @_;
    $self->shapedmembers()->{"$member"} = 1;
    $member->_shaped(1);
}

###############################################################################
# Virtual Lans Member. A separate package so we can create objects for
# each one and then add local stuff to them.
#
package libvtop::virt_lan_member;
use Carp;
use vars qw($AUTOLOAD);
use overload ('""' => 'Stringify', 'eq' => 'StringEQ');

# To avoid wrtting out all the methods.
sub AUTOLOAD {
    my $self = shift;
    my $type = ref($self) or croak "$self is not an object";

    my $name = $AUTOLOAD;
    $name =~ s/.*://;   # strip fully-qualified portion

    if (@_) {
	return $self->{'HASH'}->{$name} = shift;
    }
    elsif (exists($self->{'HASH'}->{$name})) {
	return $self->{'HASH'}->{$name};
    }
    else {
	return $self->virt_member()->$name();
    }
}

#
# Wrap up a virt lan member.
#
sub Create($$$$)
{
    my ($class, $vtop, $virt_member, $virt_lan) = @_;

    my $self = {};
    bless($self, $class);

    $self->{'VIRTMEMBER'} = $virt_member;
    $self->{'VIRTLAN'}    = $virt_lan;
    $self->{'VIRTNODE'}   = $vtop->vnodes()->{$virt_member->vnode()};
    $self->{'VTOP'}       = $vtop;
    $self->{'HASH'}       = {};

    return $self;
}
# accessors
sub virt_member($)	{ return $_[0]->{'VIRTMEMBER'}; }
sub virt_lan($)		{ return $_[0]->{'VIRTLAN'}; }
sub virt_node($)	{ return $_[0]->{'VIRTNODE'}; }
sub vtop($)		{ return $_[0]->{'VTOP'}; }
sub hash($)		{ return $_[0]->{'HASH'}; }

# Break circular reference someplace to avoid exit errors.
sub DESTROY {
    my $self = shift;

    $self->{'VIRTLAN'}    = undef;
    $self->{'VIRTNODE'}   = undef;
    $self->{'VIRTMEMBER'} = undef;
    $self->{'VTOP'}       = undef;
    $self->{'HASH'}       = undef;
}

sub Stringify($)
{
    my ($self) = @_;
    my $vnode  = $self->vnode();
    my $vport  = $self->vport();

    return "$vnode:$vport";
}

sub StringEQ($$)
{
    my ($self, $other) = @_;

    return ($self->Stringify() eq "$other" ? 1 : 0);
}

sub usevirtiface($)
{
    my ($self) = @_;
    my $encap  = $self->_encapstyle();

    return ($encap eq "veth-ne" || $encap eq "vlan");
}

###############################################################################
# Virtual Paths This wraps up the virt_paths table
#
package libvtop::virt_path;
use Carp;
use vars qw($AUTOLOAD);
use overload ('""' => 'Stringify');

# To avoid wrtting out all the methods.
sub AUTOLOAD {
    my $self = shift;
    my $type = ref($self) or croak "$self is not an object";

    my $name = $AUTOLOAD;
    $name =~ s/.*://;   # strip fully-qualified portion

    if (@_) {
	return $self->{'HASH'}->{$name} = shift;
    }
    elsif (exists($self->{'HASH'}->{$name})) {
	return $self->{'HASH'}->{$name};
    }
    else {
	return $self->virt_path()->$name();
    }
}

#
# Wrap up a virt path
#
sub Create($$$$)
{
    my ($class, $vtop, $pathname, $layer) = @_;

    my $self = {};
    bless($self, $class);

    $self->{'PATHNAME'}      = $pathname;
    $self->{'LAYER'}         = $layer;
    $self->{'VTOP'}          = $vtop;
    $self->{'MEMBERHASH'}    = {};
    $self->{'MEMBERLIST'}    = [];
    $self->{'VIRTLANHASH'}   = {};
    $self->{'VIRTLANLIST'}   = [];
    $self->{'IMPLEMENTS'}    = {};
    $self->{'HASH'}          = {};

    return $self;
}
# accessors
sub pathname($)		{ return $_[0]->{'PATHNAME'}; }
sub layer($)		{ return $_[0]->{'LAYER'}; }
sub members($)		{ return $_[0]->{'MEMBERHASH'}; }
sub memberlist($)       { return @{ $_[0]->{'MEMBERLIST'} }; }
sub virtlanlist($)      { return @{ $_[0]->{'VIRTLANLIST'} }; }
sub member($$)		{ return $_[0]->{'MEMBERLIST'}->[$_[1]]; }
sub lanlink($$)		{ return $_[0]->{'VIRTLANLIST'}->[$_[1]]; }
sub vtop($)		{ return $_[0]->{'VTOP'}; }
sub hash($)		{ return $_[0]->{'HASH'}; }
sub implements($)	{ return $_[0]->{'IMPLEMENTS'}; }

# Break circular reference someplace to avoid exit errors.
sub DESTROY {
    my $self = shift;

    $self->{'LAYER'}      = undef;
    $self->{'PATHNAME'}   = undef;
    $self->{'MEMBERHASH'} = undef;
    $self->{'MEMBERLIST'} = undef;
    $self->{'VIRTLANHASH'} = undef;
    $self->{'VIRTLANLIST'} = undef;
    $self->{'VTOP'}       = undef;
    $self->{'IMPLEMENTS'} = undef;
    $self->{'HASH'}       = undef;
}

sub Stringify($)
{
    my ($self) = @_;
    my $vname  = $self->pathname();
    my $layer  = $self->layer();

    return "[vpath:$vname:$layer]";
}

sub addmember($$$)
{
    my ($self, $vpath, $virtlan) = @_;
    
    $self->members()->{$vpath->segmentname()} = $vpath;
    $self->{'VIRTLANHASH'}->{$vpath->segmentname()} = $virtlan;
    # We care about this ordering.
    $self->{'MEMBERLIST'}->[$vpath->segmentindex()]  = $vpath;
    $self->{'VIRTLANLIST'}->[$vpath->segmentindex()] = $virtlan;
    return 0;
}

sub firstmember($)
{
    my ($self) = @_;

    # The lanlink for the first segment.
    my $virtlan = $self->lanlink(0);

    # Both members of a link.
    my ($member0,$member1) = $virtlan->memberlist();

    # The first member.
    return $member0;
}

sub lastmember($)
{
    my ($self) = @_;

    # The lanlink for the last segment.
    my $virtlan = $self->lanlink(scalar($self->memberlist()) - 1);

    # Both members of a link.
    my ($member0,$member1) = $virtlan->memberlist();

    # The last member.
    return $member1;
}

sub addimplements($$)
{
    my ($self, $virtlan) = @_;

    $self->implements()->{$virtlan->vname()} = $virtlan;
}
sub doesimplement($$)
{
    my ($self, $virtlan) = @_;

    return exists($self->implements()->{$virtlan->vname()});
}

#############################################################################
# Back to the main package.
#
package libvtop_stable;

#
# Load some physical info (for types, interfaces, speeds).
#
sub LoadPhysInfo($)
{
    my ($self) = @_;

    $self->printdb("Loading physical info\n");

    #
    # Interface capabilities, for getting speeds.
    #
    my %interface_capabilities = ();

    my $query_result =
	DBQueryWarn("select * from interface_capabilities");
    return -1
	if (!$query_result);

    while (my ($type, $capkey, $capval) = $query_result->fetchrow()) {
	$interface_capabilities{$type} = {}
  	    if (!defined($interface_capabilities{$type}));
	$interface_capabilities{$type}->{$capkey} = $capval;
    }

    #
    # Now get interface speeds for each type/class. We use this for
    # determining if a delay node is required. Very hacky, quite
    # wrong.
    #
    my %node_type_linkbw = ();
    
    $query_result =
	DBQueryWarn("select distinct i.interface_type,n.type ".
		    "  from interfaces as i ".
		    "left join nodes as n on n.node_id=i.node_id ".
		    "left join wires as w on ".
		    "     (w.node_id1=i.node_id and w.iface1=i.iface) or ".
		    "     (w.node_id2=i.node_id and w.iface2=i.iface) ".
		    "where n.type is not null and ".
		    "      (w.node_id2 is not null or ".
		    #       This special case needs work. See ptopgen.
		    "       i.interface_type='P2PLTE') and ".
		    "      n.role='testnode' and ".
		    "      i.role='" . TBDB_IFACEROLE_EXPERIMENT . "'");

    return -1
	if (!$query_result);

    # XXX Special hack for sim nodes.
    $node_type_linkbw{"sim"} = {};

    while (my ($iface_type, $node_type) = $query_result->fetchrow()) {
	my $typeinfo = NodeType->Lookup($node_type);
	if (!defined($typeinfo)) {
	    warn("No type info for node type $node_type\n");
	    return -1;
	}
	my $node_class = $typeinfo->class();

	$node_type_linkbw{$node_type} = {}
	    if (!defined($node_type_linkbw{$node_type}));
	$node_type_linkbw{$node_class} = {}
	    if (!defined($node_type_linkbw{$node_class}));

	if (!defined($interface_capabilities{$iface_type}->{"protocols"})) {
	    warn("No protocols listed in capabilities for $iface_type!\n");
	    return -1;
	}
	my @protolist =
	    split(",", $interface_capabilities{$iface_type}->{"protocols"});

	foreach my $proto (@protolist) {
	    my $def_speed =
		$interface_capabilities{$iface_type}->{"${proto}_defspeed"};

	    if (!defined($def_speed)) {
		warn("No default speed in capabilites for $iface_type!\n");
		return -1;
	    }

	    my $auxspeeds =
		$interface_capabilities{$iface_type}->{"${proto}_auxspeeds"};
	    my @auxspeedlist = ();
	    if ($auxspeeds) {
		@auxspeedlist = split(",", $auxspeeds);
	    }

	    foreach my $speed ($def_speed, @auxspeedlist) {
		$node_type_linkbw{$node_type}{$proto}->{$speed} = 1;
		$node_type_linkbw{$node_class}{$proto}->{$speed} = 1;

		#
		# If the type/class has a non-zero simnode capacity, then add
		# entries for the interface speed so that requires_delay can
		# figure out interface speeds the underlying node type
		# supports.
		#
		if ($typeinfo->simnode_capacity()) {
		    $node_type_linkbw{"sim"}{$proto}->{$speed} = 1;
		}
	    }
	}
    }

    #
    # Ug, it just gets worse and worse. We also need to map between the
    # auxtypes that a node (its physical type) can take on. For example,
    # a link between two pcvm nodes is really a link between a pc600 and
    # pc850.
    #
    $query_result =
	DBQueryFatal("select distinct n.type,at.type from node_auxtypes as at ".
		     "left join nodes as n on n.node_id=at.node_id");

    while (my ($phystype, $auxtype) = $query_result->fetchrow()) {
	next
	    if (!exists($node_type_linkbw{$phystype}));
	
	$node_type_linkbw{$auxtype} = $node_type_linkbw{$phystype};
    }

    #
    # Here it goes getting even worse - we have to do a similar thing for
    # vtypes.
    #
    foreach my $ref ($self->VirtTypes()) {
	my $vtype   = $ref->name();
	my @members = split(" ", $ref->members());

	foreach my $phystype (@members) {
	    next
		if (!exists($node_type_linkbw{$phystype}));

	    $node_type_linkbw{$vtype} = {}
	        if (!defined($node_type_linkbw{$vtype}));

	    foreach my $protocol (keys(%{ $node_type_linkbw{$phystype} })) {
		my @list = keys(%{ $node_type_linkbw{$phystype}{$protocol} });
		foreach my $speed (@list) {
		    $node_type_linkbw{$vtype}{$protocol}->{$speed} = 1;
		}
	    }
	}
    }

    if ($self->verbose()) {
	$self->printdb("Interface Speeds:\n");
	foreach my $type (keys(%node_type_linkbw)) {
	    foreach my $protocol (keys(%{ $node_type_linkbw{$type} })) {
		my @list = keys(%{ $node_type_linkbw{$type}{$protocol} });

		$self->printdb(" $type:$protocol - @list\n");
	    }
	}
    }
    
    $self->{'IFACECAPS'}  = \%interface_capabilities;
    $self->{'TYPELINKBW'} = \%node_type_linkbw;
    
    return 0;
}
sub interfacespeedmbps($$$)
{
    my ($self, $type, $which) = @_;

    if (!exists($self->{'IFACECAPS'}->{$type})) {
	print STDERR "interfacespeedmbps: $type does not exist\n";
	return 0;
    }
    if (!exists($self->{'IFACECAPS'}->{$type}->{"${which}_defspeed"})) {
	print STDERR "interfacespeedmbps: $type $which does not exist\n";
	return 0;
    }
    return $self->{'IFACECAPS'}->{$type}->{"${which}_defspeed"}/1000.0;
}

#
# When updating with fixednodes turned on, we need the current set
# of nodes that need to be fixed.
#
sub LoadCurrentResources($)
{
    my ($self) = @_;
    my $exptidx = $self->exptidx();

    $self->counters()->{'reserved_simcount'}  = 0;
    $self->counters()->{'reserved_virtcount'} = 0;
    $self->counters()->{'reserved_physcount'} = 0;

    $self->printdb("Loading current resources" .
		   ($self->regression() ? " in regression mode" : "") . "\n");

    my @nodelist = $self->experiment()->NodeList(0, 1);
    return 0
	if (!@nodelist);

    if ($self->regression()) {
	#
	# In regression mode, we just store the p2v mapping for fixnode.
	#
	foreach my $pnode (@nodelist) {
	    my $vname   = $pnode->vname();
	    my $node_id = $pnode->node_id();

	    if ($pnode->isvirtnode()) {
		$node_id = $pnode->phys_nodeid();
	    }
	    $self->fixednodes()->{$vname} = $node_id;
	    $self->printdb("  fixing $vname -> $node_id\n");
	}
	return 0;
    }

    foreach my $pnode (@nodelist) {
	my $vname   = $pnode->vname();
	my $node_id = $pnode->node_id();
	my $rsrv    = $pnode->ReservedTableEntry();

	# A list of vnodes on this pnode.
	$self->current_p2v()->{$pnode->phys_nodeid()} = []
	    if (! exists($self->current_p2v()->{$pnode->phys_nodeid()}));
	$self->pnodes()->{$node_id} = $pnode;

	#
	# WIDEAREA nodes are going to break.
	#
	if ($pnode->isremotenode() &&
	    !($pnode->isplabdslice() || $pnode->isfednode() ||
	      $pnode->isvirtnode() || $pnode->isdedicatedremote())) {
	    tberror("Cannot update widearea nodes yet!\n");
	    return -1;
	}
	if ($pnode->isvirtnode()) {
	    $self->counters()->{'reserved_virtcount'}++;

	    # Get the underlying physical node.
	    my $ppnode = Node->Lookup($pnode->phys_nodeid());
	    if (!defined($ppnode)) {
		tberror("Cannot map $pnode to its real physnode");
		return -1;
	    }
	    my $ppnode_id = $ppnode->node_id();

	    $self->fixednodes()->{$vname} = $ppnode_id
		if ($self->fixcurrent());
	    
	    #
	    # Record the mappings. 
	    #
	    $self->current_v2v()->{$vname} = $pnode->node_id();
	    $self->current_v2p()->{$vname} = $ppnode->node_id();
	    push(@{ $self->current_p2v()->{$ppnode->node_id()} }, $vname);
	    
	    # Mark the node as unused until later.
	    $pnode->_reuse("unused");
	    $ppnode->_reuse("unused");

	    #
	    # Add the pnode node to the oldreserved list for nfree.
	    # See the comment below. We cannot use p2v because we
	    # might not own all those nodes, if on a shared node.
	    # We do not add the ppnode. It will get added in the
	    # next clause if we actually own it.
	    #
	    $self->oldreservednodes()->{$pnode->node_id()} = $pnode;
	    
	    $self->printdb("current v2p: $node_id ($ppnode_id) -> $vname\n");
	}
	else {
	    #
	    # All the sim stuff is bit rotting cause no one understands it.
	    #
	    if ($rsrv->{'erole'} eq TBDB_RSRVROLE_SIMHOST) {
		tberror("Cannot update sim nodes yet!\n");
		return -1;
	    }
	    else {
		$self->fixednodes()->{$vname} = $pnode->node_id()
		    if ($self->fixcurrent());
		
		$self->counters()->{'reserved_physcount'}++;

		#
		# Record the mapping. 
		#
		$self->current_v2p()->{$vname} = $pnode->node_id();
		push(@{ $self->current_p2v()->{$node_id} }, $vname);
		# Mark the node as unused until later.
		$pnode->_reuse("unused");

		#
		# Add the pnode node to the oldreserved list for nfree.
		# See the comment below. We cannot use p2v because we
		# might not own all those nodes, if on a shared node.
		#
		$self->oldreservednodes()->{$pnode->node_id()} = $pnode;

		$self->printdb("current v2p: $node_id -> $vname\n");
	    }
	}
    }
    #
    # Grab the v2pmap table so we can find out where lan nodes were
    # assigned last time.
    #
    my $query_result =
	DBQueryWarn("select vname,node_id from v2pmap where exptidx='$exptidx'");
    return -1
	if (!$query_result);

    while (my ($vname,$nodeid) = $query_result->fetchrow_array()) {
	$self->printdb("current v2p: $nodeid -> $vname\n");
	
	$self->current_v2pmap()->{$vname} = $nodeid;
    }
    return 0;
}

sub LoadVirtNodes($)
{
    my ($self) = @_;
    my $gotgeninodes = 0;

    $self->printdb("Loading virtual nodes\n");

    my $pid    = $self->pid();
    my $eid    = $self->eid();
    my $table  = $self->virt_nodes();

    foreach my $virt_node ($table->Rows()) {
	my $vnode    = libvtop::virt_node->Create($self, $virt_node);
	my $vname    = $vnode->vname();
	my $desires  = {};
	my $attrs    = {};
	my $startloc = undef;
	my $nodetype = undef;

	# Other fields we need.
	my $ips     = $vnode->ips() || "";
	my $type    = $vnode->type();
	my $fixed   = $vnode->fixed();
	my $osname  = $vnode->osname();
	my $parent_osname  = $vnode->parent_osname();

	# XXX
	# If its a vtype, there will not be any node_type data. This
	# can break things, if one were to mix a virt/remote type with
	# a nonvirt/local type! Need to actually verify the vtypes
	# for consistency. 
	#
	my $isremote= 0;
	my $isvirt  = 0;
	my $issub   = 0;
	my $isplab  = 0;
	my $issim   = 0;
	my $isdyn   = 0;	# Only virtnodes are dynamic.
	my $isvtyped= 0;
	my $isded   = 0;
	my $isgeni  = 0;

	# If we have a real type or auxtype ...
	$nodetype = NodeType->LookupAny($type);
	if (!defined($nodetype)) {
	    my $vtype = $self->virttypeisvtype($type);
	    if (defined($vtype)) {
		# For now, just pick the first member type.
		my @memberlist = split(" ", $vtype->members());
		my $vtypename = $memberlist[0];
		$nodetype = NodeType->Lookup($vtypename);
		if (!defined($nodetype)) {
		    warn("Improper type $vtypename in vtype $type ".
			 "for node $vnode!\n");
		    return -1;
		}
	    }
	    else {
		my @memberlist = NodeType->GlobalVtypeTypes($type);
		if (!@memberlist) {
		    warn("Improper type $type for node $vnode!\n");
		    return -1;
		}
		# For now, just pick the first member type.
		$nodetype = $memberlist[0];
	    }
	    $isvtyped = 1;
	}
	$vnode->_typeinfo($nodetype);
	
	$isremote = $nodetype->isremotenode();
	$isvirt   = $nodetype->isvirtnode();
	$issub    = $nodetype->issubnode();
	$isplab   = $nodetype->isplabdslice();
	$isgeni   = $nodetype->isfednode();
	$issim    = $nodetype->issimnode();
	$isdyn    = $nodetype->isdynamic();
	$isded    = $nodetype->isdedicatedremote();

	# Mark this as being a virtual typed node.
	$vnode->_isvtyped($isvtyped);

	# dynamic inclusion below.
	$gotgeninodes++ if ($isgeni);

	# All this info is stashed in our local object.
	$vnode->_nodeweight(undef);
	$vnode->_isremotenode($isremote);
	$vnode->_isvirtnode($isvirt);
	$vnode->_issubnode($issub);
	$vnode->_isplabnode($isplab);
	$vnode->_isgeninode($isgeni);
	$vnode->_issimnode($issim);
	$vnode->_isdynamic($isdyn);
	$vnode->_isdedremote($isded);
	# Set below from a desire.
	$vnode->_sharedokay(0);
	$vnode->_fixedvm(undef);
	$vnode->_isbridge(($vnode->role() eq "bridge" ? 1 : 0));
	$vnode->_blockstore(undef);
	$vnode->_blockstore_attributes(undef);
	$vnode->_sanhostname(undef);
	$vnode->_forcedarchitecture(undef);

	#
	# Explicit type request desire to match feature.
	#
	my $explict_type_request;
	$nodetype->GetAttribute("explicit_request", \$explict_type_request);
	$vnode->_explicit_type_request($explict_type_request);

	# For a list of interfaces on this node, as for rspec generation
	$vnode->_virtifaces([]);

	# dynamic inclusion below.
	$gotgeninodes++ if ($isgeni);

	# The mapped osname to actual osinfo structure.
	$vnode->_osinfo(undef);
	# If the virtnode tries to specify its parent os in addition
	# to its own, store that osinfo here.
	$vnode->_parent_osinfo(undef);
	# Eventual physical mapping. 
	$vnode->_physnode(undef);
	# Handy to combine these.
	$vnode->_settings([ $vnode->cmd_line(),
			    $vnode->rpms(),
			    $vnode->startupcmd(),
			    $vnode->tarfiles(),
			    $vnode->loadlist(),
			    $vnode->failureaction(),
			    $vnode->routertype() ]);

	#
	# If a subnode, kill the fixed mapping. That was just to
	# tell us the connection. We do not want to overload "fixed"
	# within assign wrapper since its already overloaded.
	#
	if ($issub) {
	    # Must be a parent. Set in the parser, either explicitly, or else
	    # one is created if the user leaves it out.
	    if (!defined($fixed) || $fixed eq "") {
		warn("Subnode $vname must be fixed to its parent!\n");
		return -1;
	    }
	    $vnode->_parent($fixed);
	    $vnode->fixed(undef);
	    undef($fixed);
	}

	# Can fixed really get set to ""?
	if (defined($fixed) && $fixed ne "") {
	    # Store the name since we use FIXED_NODES for delay nodes too.
	    $self->fixednodes()->{$vname} = $fixed;

	    # We do not know until all the nodes are loaded, if fixing
	    # to a physical node or another node in the topology. See
	    # the post pass loop below.
	    $vnode->_fixedvm($fixed)
		if ($isvirt && !$isgeni);
	}
	else {
	    $vnode->fixed(undef);
	    undef($fixed);
	}

	# For the moment, geni nodes must be bound to a CM.
	if ($isgeni) {
	    if (!defined($fixed) || $fixed eq "") {
		tberror("Geninode $vnode must be fixed to a CM.");
		return -1;
	    }
	    my ($authority,$gtype,undef) = GeniHRN::Parse($fixed);
	    #
	    # We allow an authority instead of a node urn. This is just a
	    # kludge so I can test against the AM interface. 
	    #
	    if ($gtype eq "node") {
		$vnode->_cmurn(GeniHRN::Generate($authority,
						 "authority", "cm"));
	    }
	    elsif ($gtype eq "authority") {
		$vnode->_cmurn($fixed);
		$fixed = GeniHRN::Generate($authority, "node", "*");
		$vnode->fixed($fixed);
	    }
	}
	else {
	    $vnode->_cmurn($mycmurn);
	}

	#
	# Record the type selections for the mapper. If this was a vtype,
	# then we selected the first real type from the list. Might not be
	# what we want to do.
	#
	if (!$vnode->_typeinfo()->IsClass() || defined($fixed)) {
	    my $t = $vnode->_typeinfo()->type();
	    
	    if (!exists($self->types()->{$t})) {
		$self->types()->{$t} = 0;
	    }
	    $self->types()->{$t}++;

	    #
	    # If the node is fixed to a physical node, we want to pass that
	    # info back to the mapper for admission control and reservation
	    # checks, wrt reservable nodes. But at this point, we do not
	    # know if this is a VM fixed to another node in the topology,
	    # so just record it, and down below in the post pass we will
	    # clean it up.
	    #
	    # Note that we do not use fixednodes(), since that includes
	    # more then just what is specified in topology.
	    #
	    if (defined($fixed)) {
		$self->fixed()->{$fixed} = $t;
	    }
	}
	elsif (defined($self->forcedarchitecture())) {
	    my $arch = $self->forcedarchitecture();
	    if ($isvirt) {
		$arch .= "-vm";
	    }
	    $vnode->_forcedarchitecture($arch);
	}

	$self->printdb("  $vname type:$type ips:$ips\n");
	$self->printdb("         isrem:$isremote isvirt:$isvirt");
	$self->printdb(" architecture:" . $vnode->_forcedarchitecture())
	    if (defined($vnode->_forcedarchitecture()));
	$self->printdb(" fixed:$fixed")
	    if (defined($fixed) && $fixed ne "");
	$self->printdb("\n");
	
	# We need to check the names to make sure they do not clash with
	# our internal delay node names.
	if (($vname =~ /^tbdelay\d+/) ||
	    ($vname =~ /^tbsdelay\d+/)) {
	    print "Warning: $vname is a reserved name. Working around it.\n";
	    my ($num) = ($vname =~ /(\d+)/);
	    $self->delayid($num + 1);
	}

	# Take apart the IP list.
	my @iplist  = split(" ", $ips);
	foreach my $ipinfo (@iplist) {
	    my ($port,$ip) = split(":",$ipinfo);
	    
	    $self->{'IPS'}->{"$vname:$port"} = $ip;
	}

	#
	# Map the osname to an OSID now so that we can check max_concurrent.
	# This also avoids the work and *check* later after we have done 90%
	# of assign_wrapper. If no osname was specified, we have to wait and
	# use the default for the type of phys node that assign picks.
	#
	if (defined($osname) && $osname ne "") {
	    my $osimage;
	    
	    if ($osname =~ /^(ftp|http|https):/) {
		$osimage = OSImage->LookupByURL($osname);
	    }
	    elsif ($osname =~ /^(.*)\/(.*)$/) {
		$osimage = OSImage->Lookup($osname);
	    }
	    else {
		$osimage = OSImage->Lookup($pid, $osname);
		if (!defined($osimage)) {
		    $osimage = OSImage->LookupByName($osname);
		}
	    }
	    if (!defined($osimage)) {
		tberror({cause => 'user', type => 'primary',
			 severity => SEV_ERROR,
			 error => ['invalid_os', undef, $osname, $pid]},
			"Invalid OS $osname!");
		return -1;
	    }
	    $vnode->_osinfo($osimage);
	}
	elsif ($isvirt) {
	    my $osimage;
	    
	    if ($nodetype->type() eq "pcvm") {
		# Silly default.
		$osimage = OSImage->LookupByName("OPENVZ-STD");
	    }
	    else {
		# Grab it from the typeinfo.
		$osimage = OSImage->Lookup($nodetype->default_osid());
	    }
	    $vnode->_osinfo($osimage);
	}

	#
	# Map the parent_osname to an OSID now.
	#
	if (defined($parent_osname) && $parent_osname ne "") {
	    my $osimage;
	    
	    if ($parent_osname =~ /^(.*)\/(.*)$/) {
		$osimage = OSImage->Lookup($parent_osname);
	    }
	    else {
		$osimage = OSImage->Lookup($pid, $parent_osname);
		if (!defined($osimage)) {
		    $osimage = OSImage->LookupByName($parent_osname);
		}
		if (!defined($osimage)) {
		    tberror({cause => 'user', type => 'primary',
			     severity => SEV_ERROR,
			     error => ['invalid_os', undef, $parent_osname, $pid]},
			    "Invalid parent OS $parent_osname in project $pid!");
		    return -1;
		}
	    }
	    $vnode->_parent_osinfo($osimage);
	}
	elsif ($isvirt && $vnode->_osinfo()->DefaultParent()) {
	    my $osimage = $vnode->_osinfo()->DefaultParent();
	    if (!defined($osimage)) {
		tberror("Invalid default parent os for " .
			$vnode->_osinfo() . "\n");
		return -1;
	    }
	    $vnode->_parent_osinfo($osimage);
	}

	#
	# Add in desires.
	#
	foreach my $desire ($self->virt_desires()->Rows()) {
	    next
		if ($desire->vname() ne $vname);
	    
	    $desires->{$desire->desire()} = $desire->weight();

	    # User says a shared node is okay. We need this info later
	    # when generating links/lans for the vtop.
	    $vnode->_sharedokay(1)
		if ($isvirt && $desire->desire() eq "pcshared");
	}
	$vnode->_desires($desires);

	#
	# Add in attributes.
	#
	foreach my $attr ($self->virt_attributes()->Rows()) {
	    next
		if ($attr->vname() ne $vname);
	    
	    $attrs->{$attr->attrkey()} = $attr->attrvalue();

	    if ($attr->attrkey() eq "XEN_MEMSIZE" ||
		$attr->attrkey() eq "MEMORYSIZE") {
		$vnode->_desires()->{"?+ram"} = $attr->attrvalue();
	    }
	    elsif ($attr->attrkey() eq "XEN_CORES") {
		# Overridden below for shared nodes.
		$self->experiment()->SetVirtNodeAttribute($vname,
							  "VM_VCPUS",
							  $attr->attrvalue());
	    }
	}
	$vnode->_atttributes($attrs);

	#
	# Need to set a default. But this needs to be seen on
	# the client too, via virt_node_attributes.
	#
	# We need a way to associate these defaults with the virtualization
	# type, but that is a function of the image. Needs more thought.
	#
	if ($isvirt &&
	    !($vnode->type() eq "blockstore" ||
	      $vnode->type() eq "interconnect" ||
	      $vnode->type() eq "interconnect-vm")) {
	    my $defmem = 128;
	    my $minmem = 128;
	    my $maxmem = 128;

	    if (defined($vnode->_parent_osinfo())
		&& $vnode->_parent_osinfo()->FeatureSupported("xen-host")) {
		$defmem = 1024;
		$minmem = 256;
		$maxmem = 1024 * 64;
	    }	    
	    if (!exists($vnode->_desires()->{"?+ram"})) {
		$self->printdb("Setting VM memsize to $defmem for $vname\n");
		$vnode->_desires()->{"?+ram"} = $defmem;
	    }
	    else {
		#
		# If the user wants a shared node, they are not allowed to
		# ask for more then the max, unless its an admin. 
		#
		if ($vnode->_desires()->{"?+ram"} > $maxmem &&
		    $vnode->_sharedokay() &&
		    !$self->user()->IsAdmin()) {
		    tberror("You asked for too much memory (> $maxmem) ".
			    "on $vnode\n");
		    return -1;
		}
		# Ditto min memory.
		if ($vnode->_desires()->{"?+ram"} < $minmem) {
		    tberror("You asked for too little memory (< $minmem) ".
			    "on $vnode\n");
		    return -1;
		}
	    }
	    $self->experiment()->SetVirtNodeAttribute($vname, "VM_MEMSIZE",
					      $vnode->_desires()->{"?+ram"});

	    # We will deal with later, but set a default=1 for now.
	    $self->experiment()->SetVirtNodeAttribute($vname, "VM_VCPUS", 1)
		if (0 && $vnode->_sharedokay() && !$self->user()->IsAdmin());
	}

	#
	# And the startloc, but doubt this is used anymore.
	#
	foreach my $startloc ($self->virt_startloc()->Rows()) {
	    if ($startloc->vname() eq $vname) {
		$startloc = $startloc->building();
		last;
	    }
	}
	$vnode->_startloc($startloc);

	# Counters
	$self->{'COUNTERS'}->{'nodecount'}++;
	$self->{'COUNTERS'}->{'simcount'}++
	    if ($issim);
	$self->{'COUNTERS'}->{'remotecount'}++
	    if ($isremote);
	$self->{'COUNTERS'}->{'virtcount'}++
	    if ($isvirt);
	$self->{'COUNTERS'}->{'plabcount'}++
	    if ($isplab);
	$self->{'COUNTERS'}->{'genicount'}++
	    if ($isgeni);
	$self->{'COUNTERS'}->{'physcount'}++
	    if (!$issim && !$isvirt);
	$self->{'COUNTERS'}->{'sharedcount'}++
	    if ($isvirt && $vnode->_sharedokay());
	# stats
	my $ipcount = scalar(@iplist);

	$self->exptstats()->{"maxlinks"} = $ipcount
	    if ($ipcount > $self->exptstats()->{"maxlinks"});
	$self->exptstats()->{"minlinks"} = $ipcount
	    if (!defined($self->exptstats()->{"minlinks"}) ||
		$ipcount < $self->exptstats()->{"minlinks"});

	# Add to the list.
	$self->vnodes()->{$vname} = $vnode;
    }
    if ($gotgeninodes) {
	if ($PGENISUPPORT) {
	    require libGeni;
	    require GeniXML;
	    import GeniXML;
	}
	else {
	    tberror("Using geni nodes but PROTOGENI_SUPPORT is not defined\n");
	    return -1;
	}
    }

    #
    # Go back and look for any VMs that were fixed to nodes. Need to make
    # the OS consistent.
    #
    foreach my $vname (sort(keys(%{ $self->{'VNODES'} }))) {
	my $vnode = $self->vnodes()->{$vname};
	my $osid;

	next
	    if ($vnode->_isgeninode());

	next
	    if (! ($vnode->_isvirtnode() && $vnode->_fixedvm()));

	my $fixnode = $self->vnodes()->{$vnode->_fixedvm()};

	#
	# If the node is fixed to a physical node, skip. This is a
	# plain old fixnode operation, not our new support for fixing
	# a VM to a real node in the topology.
	#
	# It is silly to fix a node to yourself, so what this probably
	# means is that the user really wants to fix to a physical node
	# of the same name. 
	#
	if (!defined($fixnode) || $vnode->_fixedvm() eq $vname) {
	    # Lets make sure its a real node.
	    my $fixvname = $vnode->_fixedvm();
	    
	    if (!defined(Node->Lookup($fixvname))) {
		tberror("Cannot fix $vnode to $fixvname; No such phys node\n");
		return -1;
	    }
	    $vnode->_fixedvm(undef);
	    next;
	}
	my $osimage;

	if (!defined($fixnode->_osinfo())) {
	    if (defined($vnode->_parent_osinfo())) {
		$osimage = $vnode->_parent_osinfo();
	    }
	    elsif ($self->option("jail_osid")) {
		$osimage = OSImage->Lookup($self->option("jail_osid"));
	    }
	    else {
		$osimage = $self->nodejailosinfo($vnode);
	    }
	    return -1
		if (!defined($osimage));
	
	    $fixnode->_osinfo($osimage);
	}
	else {
	    $osimage = $fixnode->_osinfo();
	}
	# Convert from the name to the local object.
	$vnode->_fixedvm($fixnode);

	$self->printdb("Fixing VM $vname to $fixnode, $osimage\n");
	#
	# Clear from the fixed() list since this is not a physical node.
	# See comment above.
	#
	delete($self->fixed()->{$fixnode})
    }

    #
    # Load up the blockstore stuff since we have to spit out the
    # attributes as desires.
    #
    foreach my $virt_bs ($self->virt_blockstores()->Rows()) {
	#
	# The blockstore is fixed to a node in the topo.
	#
	my $fixnode = $self->vnodes()->{$virt_bs->fixed()};
	if (!defined($fixnode)) {
	    tberror("Blockstore $virt_bs is fixed to non-existent node\n");
	    return -1;
	}

	# XXX: If the virt blockstore object isn't fixed to a
	# blockstore pseudo-VM, then abort the bookkeeping and mapping
	# for it.  This means we are dealing with local node storage
	# via a features and desires hack.  Check that the OS on the
	# host has the local blockstore feature.
	if ($fixnode->type() ne "blockstore") {
	    my $fosinfo = $fixnode->_osinfo();
	    if (!defined($fosinfo)) {
		tberror("OS unknown on node $fixnode: ".
			"Can't check for local blockstore support!");
		return -1;
	    } elsif (!$fosinfo->FeatureSupported("loc-bstore")) {
		tberror("OS $fosinfo on $fixnode hosting $virt_bs doesn't ".
			"support local blockstores.\n");
		return -1;
	    }
	    next;
	}

	#
	# We need a place to hang the attributes, but they are split
	# between the blockstore and the blockstore_attributes. Another
	# wrinkle is that the blockstore is assigned to a node in the
	# topo, and it is that node that we have to hang the desires off.
	#
	$self->blockstores()->{$virt_bs->vname()} = $fixnode;
	$fixnode->_blockstore($virt_bs);
	$fixnode->_sanhostname("sanhost-" . $virt_bs->vname());
	$fixnode->_blockstore_attributes({});
	# XXX Are these always in shared mode?
	$fixnode->_sharedokay(1);
	
	$self->{'COUNTERS'}->{'bstorecount'}++;
    }

    #
    # Make a quick pass of the virt_blockstores looking for RO and RW clone
    # attributes.
    # We do this before we make the main pass below so that we have this
    # info available when we lookup a lease.
    #
    my %roleases = ();
    my %cloneleases = ();
    my %prereserves = ();
    foreach my $virt_bs_attr ($self->virt_blockstore_attributes()->Rows()) {
	if ($virt_bs_attr->attrkey() eq "readonly") {
	    $roleases{$virt_bs_attr->vname()} = $virt_bs_attr->attrvalue();
	}
	elsif ($virt_bs_attr->attrkey() eq "rwclone") {
	    $cloneleases{$virt_bs_attr->vname()} = $virt_bs_attr->attrvalue();
	}
	elsif ($virt_bs_attr->attrkey() eq "prereserve") {
	    $prereserves{$virt_bs_attr->vname()} = $virt_bs_attr->attrvalue();
	}
    }

    foreach my $virt_bs_attr ($self->virt_blockstore_attributes()->Rows()) {
	my $vname   = $virt_bs_attr->vname();
	my $attrkey = $virt_bs_attr->attrkey();
	my $attrval = $virt_bs_attr->attrvalue();
	my $isdesire = $virt_bs_attr->isdesire();

	#
	# If this is a persistent blockstore (identified by a lease
	# index attribute) then make sure the user has appropriate
	# access to the lease and that the associated blockstore is
	# not already mapped in a conflicting way.
	#
	# We also check and make sure that leases in the grace state are
	# only mounted RO. We make this check in the parser as well, but
	# the state of the lease can change between parses.
	#
	# Note: we do not make these checks during a pre-assign pass.
	#
	# Exclusive use semantics:
	#
	# If the sitevar "simultaneous_ro_datasets" is zero (or unset)
	# or the dataset has the "exclusive_use" attribute set, only one
	# mapping at a time can be in effect for a dataset whether it
	# is RO or RW. This condition is embodied in the IsExclusiveUse()
	# Lease method.
	#
	# Shared use semantics:
	#
	# To be shared, the global "simultaneous_ro_datasets" sitevar
	# must be non-zero and a dataset's "exclusive_use" attribute must
	# either not exist or be set to zero (!IsExclusiveUse). Additionally,
	# the dataset must have a snapshot. Currently a snapshot is created
	# upon termination of any RW mapping (see Blockstore->Release).
	# Snapshot creation may be explicit in the future.
	#
	# A RW clone or a RO mapping of a dataset always gets the most recent
	# snapshot of the dataset. This is true whether the dataset is currently
	# in use or not. If the dataset does not have a snapshot, it is
	# an error.
	#
	# A RW mapping of a dataset always gets the dataset itself.
	# If a RW mapping already exists, it is an error.
	#
	if ($attrkey eq "lease" && !$self->preassign()) {
	    my $lease = Lease->Lookup($attrval);
	    # Valid lease?
	    if (!$lease) {
		warn("Lease $attrval for blockstore $vname does not exist!\n");
		return -1;
	    }

	    my $exclusive = $lease->IsExclusiveUse();
	    my $snapshot = $lease->HasResourceSnapshot();

	    # If sitevar or dataset disables simultaneous use, catch it now.
	    if ($exclusive && $lease->InUse()) {
		tberror("Exclusive-use dataset $lease is currently in use ".
			"and cannot be mapped at this time.\n");
		return -1;
	    }

	    # Do sanity/permission checks based on requested mode (RW/RO)
	    if (exists($roleases{$vname}) && $roleases{$vname} == 1 ||
		exists($cloneleases{$vname}) && $cloneleases{$vname} == 1) {
		# Does user have read rights to this lease?
		if (!$lease->AccessCheck($self->realuser(),
					 LEASE_ACCESS_READ())) {
		    tberror("Not allowed to use dataset $lease in ".
			    "RO or RW-clone mode\n");
		    return -1;
		}

		# For shared use, a snapshot must exist
		if (!$exclusive) {
		    if (!$snapshot) {
			tberror("Dataset $lease has no snapshot and cannot ".
				"be mapped RO or cloned at this time.\n");
			return -1;
		    }
		}

		#
		# XXX we want the attribute to get listed as "bs-clone-<lease>"
		# rather than bs-lease-<lease> in the vtop file.
		#
		$attrkey = "clone";
	    } else {
		# Does user have RW rights?
		if (!$lease->AccessCheck($self->realuser(),
					 LEASE_ACCESS_MODIFY())) {
		    tberror("Not allowed to use dataset $lease in RW mode\n");
		    return -1;
		}
		# Deny RW access if lease is in grace period.
		if ($lease->state() eq LEASE_STATE_GRACE()) {
		    tberror("Dataset $lease in grace period, must ".
			    "specify '\$$vname set-readonly 1' in NS file.\n");
		    return -1;
		}
		if (!$exclusive) {
		    # only one RW mapping
		    if ($lease->InUseReadWrite()) {
			tberror("Dataset $lease is currently in use (RW) ".
				"and cannot be mapped RW at this time.\n");
			return -1;
		    }

		    # Make sure there is a snapshot in place
		    if (!$snapshot) {
			if ($lease->InUse()) {
			    tberror("Dataset $lease is in use (RO) but ".
				    "has no snapshot ".
				    "and cannot be mapped RW at this time.\n");
			    return -1;
			}
			tbwarn("Dataset $lease has no snapshot ".
			       "and cannot be cloned at this time.\n");
		    }
		}
	    }
	}
	elsif ($attrkey eq "dataset" && !$self->preassign()) {
	    #
	    # Image backed dataset.
	    #
	    my $image = Image->Lookup($attrval);
	    if (!defined($image)) {
		warn("Dataset $attrval for blockstore $vname ".
		     "does not exist!\n");
		return -1;
	    }
	    if (!$image->isdataset()) {
		warn("$attrval for blockstore $vname is not a dataset!\n");
		return -1;
	    }
	    # Does user have read rights to this image?
	    if (!$image->AccessCheck($self->realuser(),
				     TB_IMAGEID_READINFO())) {
		tberror("Not allowed to use dataset $attrval\n");
		return -1;
	    }
	    $image->BumpLastUsed();
	}

	# Skip any blockstores that don't have a corresponding entry in the
	# 'blockstores' libvtop hash.  Also skip any attributes that are not
	# marked as a desire.
	next
	    if (! exists($self->blockstores()->{$vname}) ||
		! $isdesire);

	my $fixnode = $self->blockstores()->{$vname};
	$fixnode->_blockstore_attributes()->{$attrkey} = $attrval;

	# Make it easier to figure out our perms later on
	if (exists($roleases{$vname}) && $roleases{$vname} == 1) {
	    $fixnode->_bsperms("RO");
	} elsif (exists($cloneleases{$vname}) && $cloneleases{$vname} == 1) {
	    if (exists($prereserves{$vname}) && $prereserves{$vname} == 1) {
		$fixnode->_bsperms("CLONE-PRERES");
	    } else {
		$fixnode->_bsperms("CLONE");
	    }
	} else {
	    $fixnode->_bsperms("RW");
	}
    }
    return 0;
}

sub LoadVirtLans($)
{
    my ($self) = @_;

    $self->printdb("Loading virtual lans\n");

    my $pid    = $self->pid();
    my $eid    = $self->eid();
    my $table  = $self->virt_lans();

    foreach my $virt_lan_member ($table->Rows()) {
	my $vlanname = $virt_lan_member->vname();

	# Local wrapper for virt_lan_lan table entry (the "lan").
	my $virtlan = $self->vlans()->{$vlanname};
	if (!defined($virtlan)) {
	    my $virt_lan_lan = $self->virt_lan_lans()->Find($vlanname);
	    $virtlan = libvtop::virt_lan->Create($self, $virt_lan_lan);
	    # Add it to the toplevel list of lans.
	    $self->vlans()->{$vlanname} = $virtlan;
	    $virtlan->_accesspoint(undef);
	    $virtlan->_sanlan(0);
	}

	# Now the local wrapper for the virt_lan table entry (the "member").
	my $vlanmember = libvtop::virt_lan_member->Create($self,
							  $virt_lan_member,
							  $virtlan);

	# Which we add to the member hash for the lan by vnode:vport
	# Note that $vlanmember->member() returns vnode:port.
	$virtlan->addmember($vlanmember);

	# Global map from vnode:port back to the lan object
	$self->memberof()->{$vlanmember->member()} = $virtlan;

	# Each virt_node has a list of all virt_lans it belongs to.
	$vlanmember->virt_node()->membership()->{"$virtlan"} = $virtlan;

	# Other fields we need below
	my $delay          = $vlanmember->delay();
	my $bandwidth      = $vlanmember->bandwidth();
	my $est_bandwidth  = $vlanmember->est_bandwidth();
	my $backfill       = $vlanmember->backfill();
	my $lossrate       = $vlanmember->lossrate();
	my $rdelay         = $vlanmember->rdelay();
	my $rbandwidth     = $vlanmember->rbandwidth();
	my $rest_bandwidth = $vlanmember->rest_bandwidth();
	my $rbackfill      = $vlanmember->rbackfill();
	my $rlossrate      = $vlanmember->rlossrate();
	my $widearea       = $vlanmember->widearea();
	my $isemulated     = $vlanmember->emulated();
	my $uselinkdelay   = $vlanmember->uselinkdelay();
	my $nobwshaping    = $vlanmember->nobwshaping();
	my $nointerswitch  = $vlanmember->nointerswitch();
	my $trivial_ok     = $vlanmember->trivial_ok();
	my $protocol       = $vlanmember->protocol();
	my $mustdelay      = $vlanmember->mustdelay();
	my $encap          = $vlanmember->encap_style();
	my $mask           = $vlanmember->mask();
	my $ip             = $vlanmember->ip();
	my $layer          = $vlanmember->layer();
	my $implemented_by = $vlanmember->implemented_by_path();
	my $fixed_iface    = $vlanmember->fixed_iface();
	my ($vname,$vport) = split(":", $vlanmember->member());

	# virt_nodes:ips is actually deprecated; this overrides it.
	$self->{'IPS'}->{"$vname:$vport"} = $ip;

	#
	# So all this stuff is really per-lan state, but an artifact of
	# the original implementation is that it is duplicated in every
	# single member row. So, push the info up a level to make it easy
	# to figure out how each lan is set up.
	#

	# If RED, must insert traffic shapping.
	$virtlan->_mustdelay($mustdelay);
	# User has requested the link/lan be emulated. Not typical.
	$virtlan->_emulated($isemulated);
	# User has requested "endnodeshaping" (dummynet on end nodes).
	$virtlan->_uselinkdelay($uselinkdelay);
        # The nobwshaping flag is used in conjunction with emulated
        # links to turn off actual bw traffic shaping on an emulated
        # link. This allows assign to match the specified bws, but not
        # force them to be such with delay nodes (leaves it up to the
        # user to moderate the bw).
	$virtlan->_nobwshaping($nobwshaping);
	$virtlan->_encapstyle($encap);
	# User has said that colocating is okay. Not typical.
	$virtlan->_trivial_ok($trivial_ok);
	$virtlan->_nointerswitch($nointerswitch);
	# Link is connected to a remote node, and gets a tunnel.
	$virtlan->_tunnel(0);
	# Netmask for the entire lan.
	$virtlan->_mask($mask);
	$virtlan->_widearea($widearea);
	# Whether all member nodes are simulated
	$virtlan->_allsim(0);
	$virtlan->_protocol($protocol);
	$virtlan->_layer($layer);
	$virtlan->_accesspoint($vlanmember)
	    if ($vlanmember->is_accesspoint());
	$virtlan->_sharednodes(0);
	$virtlan->_geninodes(0);
	$virtlan->_implemented_by($implemented_by);
	$virtlan->_vpaths(undef);
	$virtlan->_bridged(0);
	$virtlan->_wiretype( $protocol eq "P2PLTE" ? $protocol : "ethernet");
	if ($vlanmember->ofenabled()) {
	    $virtlan->_ofenabled(1);
	    $virtlan->_ofcontroller($vlanmember->ofcontroller());
	}
	
	if (defined($encap) &&
	    ($encap eq "vtun" || $encap eq "gre" || $encap eq "egre")) {
	    $virtlan->_tunnel(1);
	}

	# Store this stuff as a unit to make it easier to grab later.
	$vlanmember->_delayinfo([ $delay,
				  $bandwidth,
				  $est_bandwidth,
				  $backfill,
				  $lossrate,
				  $rdelay,
				  $rbandwidth,
				  $rest_bandwidth,
				  $rbackfill,
				  $rlossrate ]);

	#
	# Ditto for the Q stuff, which is not needed until the delay
	# links are created. There are no "r" params either; Queue
	# stuff is handled in just the to-switch direction.
	#
	$vlanmember->_queueinfo([$vlanmember->q_limit(),
				 $vlanmember->q_maxthresh(),
				 $vlanmember->q_minthresh(),
				 $vlanmember->q_weight(),
				 $vlanmember->q_linterm(),
				 $vlanmember->q_qinbytes(),
				 $vlanmember->q_bytes(),
				 $vlanmember->q_meanpsize(),
				 $vlanmember->q_wait(),
				 $vlanmember->q_setbit(),
				 $vlanmember->q_droptail(),
				 $vlanmember->q_red(),
				 $vlanmember->q_gentle() ]);

	#
	# The trace info is stored along with the QUEUEINFO, but its
	# easier if I split it out.
	#
	$vlanmember->_traceinfo([$vlanmember->traced(),
				 $vlanmember->trace_endnode(),
				 $vlanmember->trace_type(),
				 $vlanmember->trace_expr(),
				 $vlanmember->trace_snaplen(),
				 $vlanmember->trace_db() ]);

	#
	# This will get set on a per-member basis when it is determined
	# that the link is getting a delaynode cause its really being
	# shaped, or because it is being traced or monitored.
	#
	$virtlan->shapedmembers()->{"$vlanmember"} = 0;
	$vlanmember->_shaped(0);
	$virtlan->_delayed(0);
	$vlanmember->_bridged(0);
	$vlanmember->_virtiface(undef);

	#
	# Look for a sharedvlan setting, which is the name of the
	# shared vlan that this lan wants its ports put into.
	#
	$virtlan->_portvlan(undef);
	
	foreach my $lan_setting ($self->virt_lan_settings()->Rows()) {
	    next
		if ($vlanname ne $lan_setting->vname());

	    my $capkey = $lan_setting->capkey();
	    my $capval = $lan_setting->capval();

	    if ($capkey eq "sharedvlan" || $capkey eq "portvlan") {
		$virtlan->_portvlan($capval);
		last;
	    }
	}
	
	#
	# XXX - Whenever a delay node is inserted, port speeds are set to
	#       the next fastest interface type we have, even if they requested
	#       exactly some speed that can be done without a delay node such
	#       as 10Mbs or 100Mbs. This is a simplification. At some point we
	#       might want to force all the ports along the way to 10Mbs, and
	#       have the delay node worry about delay only, and not bandwidth.
	#       That will be harder to to do in this mess. See companion XXX
	#       below where the delays table is initialized. Initially, we set
	#       the speed to 10Mbs, if a delay node is insterted below, it
	#       resets this to 100Mbs.
	#
	my $portbw = $self->getbandwidth($vlanmember, $virtlan, $bandwidth);
	$self->portbw()->{"$vlanmember"} = 0;
	
	$self->printdb("  $vlanname $vlanmember portbw:$portbw - ".
		       "$delay $bandwidth $lossrate ".
		       "$rdelay $rbandwidth $rlossrate\n");

	# Temporary, for generating rspecs.
	push(@{ $vlanmember->virt_node()->_virtifaces() }, $vlanmember);

	#
	# Currently a virtual fakenode implies that the physical node is
	# shared, and that different experiments can allocate portions of 
	# interfaces. 
	#
	$vlanmember->_reservebw(0);
	$vlanmember->_needtrunk(0);
	if ($vlanmember->virt_node()->_typeinfo()->isfakenode() &&
	    $vlanmember->virt_node()->_typeinfo()->isvirtnode()) {
	    $vlanmember->_reservebw($bandwidth);
	    $vlanmember->_needtrunk(1);
	    $vlanmember->_nobwshaping(1);
	    $self->printdb("  Forcing $vlanmember to reserve shared bandwidth\n");
	}

	# If any vlan member is a blockstore pseudo-VM, then mark the virtlan
	# as a sanlan.  This designation is used later to do an OS feature
	# check.
	if ($vlanmember->virt_node()->type() eq "blockstore") {
	    $virtlan->_sanlan(1);
	}
	
    }

    #
    # Look for lans with reserved tags in the highvlan range. Ick.
    # Luckily, only at Utah.
    #
    if ($MAINSITE) {
	foreach my $virtlan (values(%{ $self->vlans() })) {
	    my $tag = VLan::GetReservedVlanTag($self->experiment(),
					       $virtlan->vname());
	    if (defined($tag) && $tag > 1000) {
		$virtlan->_wiretype("ethernet-highvlan");
	    }
	    elsif ($virtlan->_protocol =~ /^ethernet-/) {
		$virtlan->_wiretype($virtlan->_protocol());
	    }
	}
    }

    #
    # Sanity check the shared lan requests.
    #
    foreach my $virtlan (values(%{ $self->vlans() })) {
	next
	    if (!defined($virtlan->_portvlan()));

	my $porttoken = $virtlan->_portvlan();

	#
	# Map the token.
	#
	my $rowref = Lan->LookupSharedVLanByToken($porttoken);
	if (!defined($rowref)) {
	    tberror("No shared vlan exists for $porttoken!\n");
	    return -1;
	}
	my $portvlan = VLan->Lookup($rowref->{'lanid'});
	if (!defined($portvlan)) {
	    tberror("Target vlan for $porttoken does not exist!\n");
	    return -1;
	}
	# Very primitive access check. But not for Geni experiments,
	# we made the checks in the CM
	if (! ($rowref->{'open'} || $self->user()->IsAdmin() ||
	       exists($ENV{"GENIURN"}))) {
	    tberror("Target vlan for $porttoken is not open!\n");
	    return -1;
	}

	#
	# Oh this is bogus; Utah's Ciscos run firmware that dates back to
	# the age of the dinosaurs, and so we cannot do vlans greater
	# then 1000 on them. This means that we have to put a feature
	# on those nodes that are attached to switches that *are* able
	# to (the procurves).
	#
	if ($MAINSITE) {
	    my $tag = $portvlan->GetTag();
	    if (defined($tag) && $tag > 1000) {
		#
		# Add a desire to all of the nodes.
		#
		#foreach my $member ($virtlan->memberlist()) {
		#    $member->virt_node()->_desires()->{"highvlan"} = "1.0";
		#}
		$virtlan->_wiretype("ethernet-highvlan");
	    }
	}
	# Convert to actual object for later
	$virtlan->_portvlan($portvlan);
    }

    #
    # Load up the virt_bridges.
    #
    foreach my $virt_bridge ($self->virt_bridges()->Rows()) {
	my $bridgename = $virt_bridge->vname();
	my $bridgevlan = $virt_bridge->vlink();
	my $bridgeport = $virt_bridge->vport();

	if (!exists($self->vlans()->{$bridgevlan})) {
	    tberror("virt_bridge: no such vlan $bridgevlan\n");
	    return -1;
	}
	if (!exists($self->vnodes()->{$bridgename})) {
	    tberror("virt_bridge: no such node $bridgename\n");
	    return -1;
	}
	my $memberof = $self->memberof()->{"$bridgename:$bridgeport"};
	if (!defined($memberof)) {
	    tberror("virt_bridge: ".
		    "$bridgename:$bridgeport is not in $bridgevlan\n");
	    return -1;
	}
	my $vlan = $self->vlans()->{$bridgevlan};
	my $member = $vlan->members()->{"$bridgename:$bridgeport"};

	$self->bridges()->{$bridgename} = {}
	    if (!exists($self->bridges()->{$bridgename}));

	# Store the list of members of this bridge. We assume that
	# a lan is not in a bridge more then once.
	$self->bridges()->{$bridgename}->{"$member"} = $member;
    }

    #
    # Check the bridge requests and set the cross links.
    #
    foreach my $virtlan (values(%{ $self->vlans() })) {
	foreach my $member ($virtlan->memberlist()) {
	    next
		if (!defined($member->bridge_vname()));

	    my $bridge_vname = $member->bridge_vname();
	    if (!exists($self->bridges()->{$bridge_vname})) {
		tberror("$virtlan: no such bridge $bridge_vname\n");
		return -1;
	    }
	    if (!$member->virt_node()->_isbridge()) {
		tberror("$member is bridged but is not a bridge\n");
		return -1;
	    }
	    my $bridged_member = $self->bridges()->{$bridge_vname}->{"$member"};
	    if (!defined($bridged_member)) {
		tberror("$member is bridged to nonexistent member\n");
		return -1;
	    }
	    $member->_bridged(1);
	    $virtlan->_bridged(1);
	    $self->printdb("$virtlan bridge: $member to $bridged_member\n");

	    #
	    # Check tracing. Only on links attached to the bridge.
	    # One side might be a lan, but tracing is allowed on the
	    # link side only. This mirrors the delay node impl, where
	    # tracing is done only at ingress to the lan.
	    #
	    if ($member->traced() && !$virtlan->islink()) {
		tberror("$member is traced, but $virtlan is not a link\n");
		return -1;
	    }
	}
    }
    
    #
    # Load the virt paths.
    #
    foreach my $vpath ($self->virt_paths()->Rows()) {
	my $pathname     = $vpath->pathname();
	my $segmentname  = $vpath->segmentname();
	my $segmentindex = $vpath->segmentindex();
	my $layer        = $vpath->layer();

	# Local wrapper for virt_path table entry;
	my $virtpath = $self->vpaths()->{$pathname};
	if (!defined($virtpath)) {
	    $virtpath = libvtop::virt_path->Create($self, $pathname,$layer);
	    # Add it to the toplevel list of paths.
	    $self->vpaths()->{$pathname} = $virtpath;
	}

	# Find the link this path segment refers to.
	my $virtlan = $self->vlans()->{$vpath->segmentname()};
	if (!defined($virtlan)) {
	    tberror("Cannot virtlan $segmentname in $virtpath\n");
	    return -1;
	}
	# All the segments in the path must be the same layer.
	if ("$layer" ne $virtpath->layer()) {
	    tberror("Path layer mismatch: $segmentname in $virtpath\n");
	    return -1;
	}
	# MLE Constraint:
	#  * A link cannot be in two paths at once unless all the paths are
	#    layer 1. A layer 2 path is special (used in bridging).
	#
	if (defined($virtlan->_vpaths())) {
	    my $oops = ($vpath->layer() == 2 ? 1 : 0);
	    if (!$oops) {
		foreach my $vp (@{ $virtlan->_vpaths() }) {
		    $oops++
			if ($vp->layer() == 2);
		}
	    }
	    if ($oops) {
		tberror("$vpath: $virtlan is more then one path and at least ".
			"one of the paths is layer 2\n");
		return -1;
	    }
	}
	else {
	    $virtlan->_vpaths([]);
	}
	$virtlan->_vpaths([ $vpath, @{ $virtlan->_vpaths() }]);
	$virtpath->addmember($vpath, $virtlan);

	$self->printdb("$virtpath segment: $virtlan\n");
    }
    #
    # Now sanity check the implemented_by relationships to make sure they
    # are layered properly.
    #
    foreach my $virtlan (values(%{ $self->vlans() })) {
	my $implemented_by = $virtlan->_implemented_by();

	next
	    if (!defined($implemented_by));

	my $vpath = $self->vpaths()->{$implemented_by};
	if (!defined($vpath)) {
	    tberror("Could not find path $implemented_by for $virtlan");
	    return -1;
	}
	if ($vpath->layer() == $virtlan->_layer() && $vpath->layer() != 2) {
	    tberror("Path $vpath at the same layer as $virtlan");
	    return -1;
	}
	if ($vpath->layer() > $virtlan->_layer()) {
	    tberror("Path $vpath at a higher layer then $virtlan");
	    return -1;
	}
	if (scalar($virtlan->memberlist()) == 2) {
	    #
	    # Endpoint equivalence: The first and last nodes of the link
	    # must be the same as the first and last nodes of the path.
	    # This constraint is very important; it means we have to solve
	    # *just* the lowest layer with assign, and everything is plopped
	    # down on top of that.
	    #
	    my ($member0,$member1) = $virtlan->memberlist();
	    my $virtnode0 = $member0->virt_node();
	    my $virtnode1 = $member1->virt_node();
	    # Look for VMs that have been "fixed" to another node.
	    if ($virtnode0->_isvirtnode() && $virtnode0->fixed()) {
		$virtnode0 = $self->vnodes()->{$virtnode0->fixed()};
	    }
	    if ($virtnode1->_isvirtnode() && $virtnode1->fixed()) {
		$virtnode1 = $self->vnodes()->{$virtnode1->fixed()};
	    }
	    my $firstnode = $vpath->firstmember()->virt_node();
	    my $lastnode  = $vpath->lastmember()->virt_node();

	    if ("$virtnode0" ne "$firstnode") {
		tberror("First node of $vpath is not the same as $virtlan ".
			"$virtnode0, $firstnode, $member0, $member1\n");
		return -1;
	    }
	    if ("$virtnode1" ne "$lastnode") {
		tberror("Last node of $vpath is not the same as $virtlan ".
			"$virtnode1, $lastnode, $member0, $member1\n");
		return -1;
	    }
	}
	else {
	    #
	    # Not sure what sanity checking to do on lans yet. Revisit.
	    #
	    $self->printdb("$virtlan is a lan implemented by $vpath\n");
	}
	$self->printdb("$virtlan is implemented by $vpath\n");
	$virtlan->_implemented_by($vpath);
	$vpath->addimplements($virtlan);
    }
    return 0;
}

#
# Dump the vtype list.
#
sub GenVirtTypes($)
{
    my ($self) = @_;
    my @types  = $self->VirtTypes();
    
    foreach my $vtype (@types) {
	my $name    = $vtype->name();
	my $weight  = $vtype->weight();
	my @members = split(" ", $vtype->members());

	$self->createVClass ($name, $weight, \@members);
    }
    return 0;
}

#
# Dump the virt nodes.
#
sub GenVirtNodes($)
{
    my ($self) = @_;
    my $experiment = $self->experiment();
    my $pid    = $experiment->pid();
    my $eid    = $experiment->eid();
    
    foreach my $vname (sort(keys(%{ $self->{'VNODES'} }))) {
	my $vnode = $self->vnodes()->{$vname};
	my $type  = $vnode->type();

	#
	# If the user specifed that a VM is fixed to a particular
	# node in the topo, do not insert that into the top file.
	# These are handled later in a post pass after assign runs.
	#
	next
	    if ($vnode->_isvirtnode() && $vnode->_fixedvm());

	my $desires = {};
	my $others = {};
	if ($vnode->_issubnode()) {
	    $others->{'subnode'} = $vnode->_parent();
	}
	if (defined($vnode->_blockstore())) {
	    my $virt_bs  = $vnode->_blockstore();
	    my $bs_vname = $virt_bs->vname();
	    my $size     = $virt_bs->size();

	    #
	    # RO clones have no cost in capacity.
	    #
	    # RW clones come in two flavors: best-effort (zero bytes) or
	    # guaranteed (full size of cloned dataset). The former is
	    # signaled by CLONE, the latter by CLONE-PRERES.
	    #
	    if ($vnode->_bsperms() eq "RO") {
	    	$size = 0;
	    }
	    elsif ($vnode->_bsperms() eq "CLONE") {
	    	$size = 0;
	    }
	    # XXX "zfs clone" or the FreeNAS API does not have an interface
	    # for creating a pre-allocated clone. You can do it (I think!)
	    # by using "zfs set refreserved=..." after the clone call, but
	    # I am not ready to go there yet, so we ignore the "prereserve"
	    # attribute for now.
	    #
	    elsif ($vnode->_bsperms() eq "CLONE-PRERES") {
		$size = 0;
	    }
	    $vnode->_bsallocsize($size);

	    # This is an additive desire. 
	    $desires->{"bs-capacity"} = ['+', $size];

	    # The rest come from the attributes.
	    foreach my $attrkey (keys(%{ $vnode->_blockstore_attributes() })) {
		my $attrval = $vnode->_blockstore_attributes()->{$attrkey};

		$desires->{"bs-${attrkey}-${attrval}"} = ['', 1.0];
	    }
	    my $sanhost = $vnode->_sanhostname();
	    
	    #
	    # Create a parent node for the sanhost. 
	    #
	    my $sandesires = {"pcstorage" => ['', 1.0]};
	    # Are we loving subnodes?
	    if ($self->sharednodecount()) {
		$sandesires->{"pcshared"} = ['' , "1.0"];
	    }
	    $self->createNode($sanhost, $mycmurn,
			      "pcsanhost", '1', $sandesires, undef);
	    $self->sanhosts()->{$sanhost} = $sanhost;

	    #
	    # We must do this so that assign maps the blockhost and
	    # sanhost as a unit. Otherwise, it might allocate a subnode
	    # but pick some other physical node to be the parent. Note that
	    # ptop file also has subnode decls in it. 
	    #
	    $others->{'subnode'} = $sanhost;
	}
	foreach my $desirename (keys(%{ $vnode->_desires() })) {
	    my $weight = $vnode->_desires()->{$desirename};
	    $desires->{$desirename} = ['', $weight];
	}
	if ($vnode->_isplabnode() && $experiment->cpu_usage()) {
	    # Yuck
	    $desires->{'load'} = ['+', (($experiment->cpu_usage() - 1) / 5.0)];
	}
	if ($self->updating()) {
	    $desires->{'already_reserved'} = ['', 0.2];
	}
	if (defined($vnode->_startloc())) {
	    $desires->{"area-" . $vnode->_startloc()} = ['', 1.000000];
	}
	# Tell assign to favor nodes that are pre-reserved to the project.
	$desires->{'prereserved'} = ['', 0.2];
	
	# Require that this vnode be placed onto a pnode that supports
	# the OS it is going to run. However, if the OS is one with a
	# 'path' (like an OSKit kernel), we don't have an entry in
	# osidtoimageid for it, and thus we leave it off of the desire list
	if (defined($vnode->_osinfo()) && !defined($vnode->_blockstore())) {
	    my $osinfo = $vnode->_osinfo();

	    #
	    # Support subOSes with a multi-OS desire.  Since the pnodes
	    # will have features like OS-parent and OS-parent-subos, we 
	    # generate desire to match.  Parent is major since then this 
	    # all works seamlessly with non-subos stuff.
	    # 
	    my $posinfo = $vnode->_parent_osinfo();
	    
	    if ($vnode->_sharedokay()) {
		if (!defined($posinfo)) {
		    my $jailosinfo = $self->nodejailosinfo($vnode);
		    $desires->{"OS-" . $jailosinfo->osid()} = ['', 1.000000];
		    # For ptopgen.
		    $self->allimages()->{$jailosinfo->osid()} = 1;
		}
		else {
		    my $osid  = $osinfo->osid();
		    my $posid = $posinfo->osid();
		    $desires->{"OS-" . $posid} = ['', 1.000000];
		    $desires->{"OS-" . $posid . "-" . $osid} = ['', 1.000000];
		    # For ptopgen.
		    $self->allimages()->{$posid} = 1;
		    $self->allimages()->{$posid . "-" . $osid} = 1;
		}
	    }
	    elsif (!$osinfo->mfs()) {
		#
		# Regarding path; we no longer have oskit kernels, but we
		# have some special cases where we specify an MFS (APT).
		#
		if (!defined($posinfo)) {
		    $desires->{"OS-" . $osinfo->osid()} = ['', 1.000000];
		    # For ptopgen.
		    $self->allimages()->{$osinfo->osid()} = 1;
		}
		else {
		    my $osid  = $osinfo->osid();
		    my $posid = $posinfo->osid();
		    $desires->{"OS-" . $posid} = ['', 1.000000];
		    $desires->{"OS-" . $posid . "-" . $osid} = ['', 1.000000];
		    # For ptopgen.
		    $self->allimages()->{$posid} = 1;
		    $self->allimages()->{$posid . "-" . $osid} = 1;
		}
	    }
	}
	my @interfaces = ();
	my @ifaces     = @{ $vnode->_virtifaces() };
	if (@ifaces) {
	    my @refs = ();
	    foreach my $vlanmember (@ifaces) {
		my $virtlan = $vlanmember->virt_lan();
		my $iface   = {'virtual_id'   => "$vlanmember"};
		    
		if ($vlanmember->fixed_iface() ne "") {
		    $iface->{'component_id'}  = $vlanmember->fixed_iface();
		}
		push(@interfaces, $iface);
	    }
	}
	
	#
	# Now the type string, which might include some stuff for
	# simnodes that I do not understand. 
	#
	my $typestr = $type;
	my $nodeweight = '1';
	if ($vnode->_issimnode()) {
	    my $query_result =
		DBQueryWarn("select nodeweight from virt_simnode_attributes ".
			    "where pid='$pid' and eid='$eid' and ".
			    "      vname='$vname'");
	    if ($query_result && $query_result->numrows) {
		($nodeweight) = $query_result->fetchrow_array();
	    }
	}
	elsif ($vnode->_isbridge()) {
	    $type = ($type eq "pc" ? "bridge" : "bridge-" . $type);
	}
	elsif (defined($vnode->_forcedarchitecture())) {
	    $type = $vnode->_forcedarchitecture();
	}
	if ($vnode->_explicit_type_request()) {
	    $desires->{"$type" . "-explicit"} = ['', 1.0];
	}
	$self->createNode($vname, $vnode->_cmurn(),
			  $type, $nodeweight, $desires, $others, \@interfaces);
    }
    
    #
    # Now that the node list is out, set OSID for nodes
    #
    # Huh?
    #
    foreach my $vnode (values(%{ $self->{'VNODES'} })) {
	my $vname  = $vnode->vname();
	my $type   = $vnode->type();
	my $osinfo = $vnode->_osinfo();

	if ($vnode->_issubnode() && $type eq "ixp-bveil" && !defined($osinfo)){
	    my $osinfo = OSImage->LookupByName("RHL73-IXPHOST");
	    $vnode->_osinfo($osinfo);
	}
    }
    return 0;
}

#
# Print out the fix nodes.
#
sub GenFixNodes($)
{
    my ($self) = @_;

    #
    # Be sure NOT to print out nodes which are no longer in the experiment.
    #
    # XXX This must be done last since we create internal nodes above.
    #
    foreach my $vname (sort(keys(%{ $self->fixednodes() }))) {
	my $vnode = $self->vnodes()->{$vname};
	my $fixed = $self->fixednodes()->{$vname};

	if (!defined($fixed)) {
	    tbwarn("GenFixNodes: No fixed node for $vname\n");
	}

	# Normal nodes have a vnode but delay nodes do not.
	if (!defined($vnode) && !$self->isadelaynode($vname) &&
	    !$self->isasanhost($vname)) {
	    tbinfo("GenFixNodes: No vnode for $vname\n");
	}

	#
	# Temporary rspec generation.
	#
	next
	    if (defined($vnode) && $vnode->_isgeninode());

	#
	# When fixing a vnode to a particular physnode, ignore the 
	# fix specification here; we do this as a post pass, and
	# assume the user knows what she is doing (the number of
	# nodes is okay for the machine).
	#
	next
	    if (defined($vnode) && 
		$vnode->_isvirtnode() && defined($vnode->_fixedvm()));

	if ($self->isatoponode($vname) || $self->isadelaynode($vname) ||
	    $self->isasanhost($vname)) {
	    if (defined($vnode) &&
		defined($vnode->_sanhostname())) {
		$self->createFixedNode($vnode->_sanhostname(), $fixed);
	    }
	    else {
		$self->createFixedNode($vname, $fixed);
	    }
	}
    }
    if ($self->fixlanodes()) {
	#
	# Add lan node fixnodes.
	#
	foreach my $lannode (sort(keys(%{ $self->lannodes() }))) {
	    next
		if (!exists($self->current_v2pmap()->{$lannode}));

	    $self->createFixedNode($lannode,
				   $self->current_v2pmap()->{$lannode});
	}
	foreach my $delaynode (sort(keys(%{ $self->delaynodes() }))) {
	    next
		if (exists($self->fixednodes()->{$delaynode}) ||
		    ! exists($self->current_v2pmap()->{$delaynode}));
	    
	    $self->createFixedNode($delaynode,
				   $self->current_v2pmap()->{$delaynode});
	}
    }
    return 0;
}

#
# Print out some summary stats.
#
sub PrintSummaryStats($)
{
    my ($self) = @_;

    # Set estimations
    my $minimum_nodes = $self->counters()->{'physcount'} +
	$self->delaynodecount() / $self->options()->{'delay_capacity'};
    my $maximum_nodes = $self->counters()->{'physcount'} +
	$self->delaynodecount();
    $minimum_nodes = POSIX::ceil($minimum_nodes);

    # For the caller.
    $self->counters()->{'minimum_nodes'}  = $minimum_nodes;
    $self->counters()->{'maximum_nodes'}  = $maximum_nodes;

    my $virtnode_count = $self->counters()->{'virtcount'};
    my $simnode_count  = $self->counters()->{'simcount'};
    my $reserved_virtcount = $self->counters()->{'reserved_virtcount'};
    my $reserved_physcount = $self->counters()->{'reserved_physcount'};

    if (!$self->quiet()) {
	print "Minimum nodes   = $minimum_nodes\n";
	print "Maximum nodes   = $maximum_nodes\n";
	if ($virtnode_count) {
	    print "Virtual nodes     = $virtnode_count\n";
	}
	if ($simnode_count) {
	    print "Simulated nodes   = $simnode_count\n";
	}
	if ($reserved_virtcount) {
	    print "Reserved vnodes   = $reserved_virtcount\n";
	}
	if ($reserved_physcount) {
	    print "Reserved pnodes   = $reserved_physcount\n";
	}
	print "<= 1G links       = " . $self->counters()->{'Gblinks'} . "\n";
	print " > 1G links       = " . $self->counters()->{'MGblinks'} . "\n";
    }
    return 0;
}

#
# Dump the virt lans
#
sub GenVirtLans($)
{
    my ($self) = @_;
    my $experiment = $self->experiment();
    my $pid    = $experiment->pid();
    my $eid    = $experiment->eid();

    #
    # It would be nice if "tunnels" could be handled as a case in the
    # logic below, but there are too many special things about
    # tunnels, primary being that they are assumed to be connected
    # over the control interfaces of the nodes. There should really be
    # no reason why we cannot build a tunnel on top of an experimental
    # link since it is just another form of encapsulation. 
    #
    foreach my $vname (sort(keys(%{ $self->{'VLANS'} }))) {
	my $vlan = $self->vlans()->{$vname};
	
	next
	    if (!$vlan->_tunnel());
	
	my @members = $vlan->memberlist();
	$self->printdb("$vname (tunnel): " . join(" ",@members) . "\n");
	
	if (scalar(@members) != 2) {
	    tberror("Too many members in tunnel $vname\n");
	    return -1;
	}
	
	my ($member0,$member1) = @members;
	my $virtnode0 = $member0->virt_node();
	my $virtnode1 = $member1->virt_node();
	my $vname0    = $virtnode0->vname();
	my $vname1    = $virtnode1->vname();
	my $ip0       = $member0->ip();
	my $ip1       = $member1->ip();
	
	$vlan->_geninodes(1)
	    if ($virtnode0->_isgeninode() || $virtnode1->_isgeninode());
		
	my ($delay0,$bw0,$ebw0,$backfill0,$loss0,
	    $rdelay0,$rbw0,$rebw0,$rbackfill0,$rloss0) =
		@{$member0->_delayinfo()};
	my ($delay1,$bw1,$ebw1,$backfill1,$loss1,
	    $rdelay1,$rbw1,$rebw1,$rbackfill1,$rloss1) =
		@{$member1->_delayinfo()};
	
	my $bw = min($bw0,$rbw1);
	
	#
	# Tunnels go into the geni rspec, but not locally since assign
	# does not really know what to do with tunnels. Special case
	# handling below. 
	#
	if ($vlan->_geninodes()) {
	    #
	    # We eventually want to support tunnels between a local cluster node
	    # and a protogeni node.
	    #
	    # Enforce tunnel between two geni nodes. It would be nice to support
	    # this, but it requires that the cluster node go into the rspec, and
	    # that complicates things.
	    #
	    if (! ($virtnode0->_isgeninode() && $virtnode1->_isgeninode())) {
		tberror("Tunnel $vname: ".
			"Unsupported tunnel between cluster and protogeni node!\n");
		return -1;
	    }
	    $self->createLink($vname, $vname,
			      [ $virtnode0->_cmurn(),
				$virtnode1->_cmurn() ],
			      {'virtual_node_id' => $vname0,
			       'virtual_interface_id' => "$member0",
			       'tunnel_ip' => $ip0 },
			      {'virtual_node_id' => $vname1,
			       'virtual_interface_id' => "$member1",
			       'tunnel_ip' => $ip1 },
			      $bw, "tunnel", {'isgeninode' => 1});
	}
    }

    my $errors	         = 0;
    my %osdoesveth       = ();
    my %osdoesvethEN     = ();	# Encapsulated veth
    my %osdoesvethNE     = ();  # Non-Encapsulated veth
    my %osdoesvlan       = ();
    my %osdoesmlink      = ();
    my %osdoeslinkdelays = ();
    my %osdoesrembstore  = ();  # Remote blockstore support

    foreach my $vname (sort(keys(%{ $self->{'VLANS'} }))) {
	my $vlan = $self->vlans()->{$vname};

	# Tunnels are handled elsewhere.
	next
	    if ($vlan->_tunnel());

	my @members = $vlan->memberlist();
	$self->printdb("$vname: " . join(" ",@members) . "\n");

	my $simnodes     = 0;
	my $realnodes    = 0;
	my $virtnodes    = 0;
	my $nonvirtnodes = 0;
	my $sharednodes  = 0;
	my $geninodes    = 0;
	my %nodesdo      = ("alias"=>0, "veth"=>0, "vlan"=>0, "ldelay"=>0,
			    "veth-ne"=>0, "veth-en"=>0, "rem-bstore"=>0,
			    "none"=>0);
	my $trivial_ok   = 0;
	my $emulated     = $vlan->_emulated();
        my $uselinkdelay = $vlan->_uselinkdelay();
	my $mustdelay    = $vlan->_mustdelay();
	my $nobwshaping  = $vlan->_nobwshaping();
	my $nointerswitch= $vlan->_nointerswitch();
	my $protocol     = $vlan->_protocol();
	my $linkencap    = $vlan->_encapstyle();
	my $layer        = $vlan->_layer();
	my $sanlan       = $vlan->_sanlan();

	# For mixing pnodes and vnodes.
	$vlan->_mixedencap(0);

	#
	# Count the types of nodes (simulated, virtual, real, etc.) in this
	# LAN
	#
	foreach my $member (@members) {
	    my $osid;
	    my $virtnode = $member->virt_node();

	    if ($virtnode->_sharedokay()) {
		$sharednodes++;
		$vlan->_sharednodes($sharednodes);
	    }
	    if ($virtnode->_isgeninode()) {
		$geninodes++;
		$vlan->_geninodes($geninodes);
	    }

	    if ($virtnode->_issimnode()) {
		$simnodes++;

		if (defined($virtnode->_osinfo())) {
		    $osid = $virtnode->_osinfo()->osid();
		} else {
		    $osid = "<SIM>";
		}
		# XXX apparently all simnodes can do veths
		if (!exists($osdoesmlink{$osid})) {
		    $osdoesmlink{$osid} = 0;
		    $osdoesveth{$osid} = 1;
		    $osdoesvethNE{$osid} = 1;
		    $osdoesvethEN{$osid} = 1;
		    $osdoesvlan{$osid} = 0;
		    $osdoeslinkdelays{$osid} = 1;
		    $osdoesrembstore{$osid} = 0;
		}
	    }
	    else {
		my $osinfo;
		
		if ($virtnode->_isvirtnode()) {
		    $virtnodes++;

		    # For virtnodes, we have to map the osid of the vnode
		    # to the osid of the physical machine it will reside on.
		    # Doing this before assign chooses the node, is silly
		    # but no choice right now.
		    #
		    # And now, we only map in this way IF the parent_osid
		    # is not set (it gets set if the user chooses a subOS and
		    # a parent is assigned by default in the parser, or
		    # if they choose both a subOS and a specific parent OS).
		    #
		    if (defined($virtnode->_parent_osinfo())) {
			$osinfo = $virtnode->_parent_osinfo();
			$osid = $osinfo->osid();
		    }
		    elsif (defined($virtnode->_osinfo())) {
			$osinfo = $self->nodejailosinfo($virtnode);
			if (!defined($osinfo)) {
			    return -1;
			}
			$osid = $osinfo->osid();
		    }
		}
		else {
		    $nonvirtnodes++;

		    $osinfo = $virtnode->_osinfo()
			if (defined($virtnode->_osinfo()));
		}
		
		#
		# Check os feature list emulated/veth/vlan support.
		#
		if (defined($osinfo)) {
		    $osid = $osinfo->osid();
		    
		    if (!exists($osdoesmlink{$osid})) {
			$osdoesmlink{$osid} =
			    $osinfo->FeatureSupported('mlinks');
			$osdoesveth{$osid} =
			    $osinfo->FeatureSupported('veths');
			$osdoesvethNE{$osid} =
			    $osinfo->FeatureSupported('veth-ne');
			$osdoesvethEN{$osid} =
			    $osinfo->FeatureSupported('veth-en');
			$osdoesvlan{$osid} =
			    $osinfo->FeatureSupported('vlans');
			# Need this for phys nodes requesting lindelays.
			$osdoeslinkdelays{$osid} =
			    $osinfo->FeatureSupported('linkdelays');
			# remote blockstore support.
			$osdoesrembstore{$osid} =
			    $osinfo->FeatureSupported('rem-bstore');
		    }
		} else {
		    # XXX If the user doesn't explicitly set an OS on a PC.
		    # Be conservative and assume minimum features.
		    $osid = "<DEFAULT>";
 		    if (!exists($osdoesmlink{$osid})) {
			$osdoesmlink{$osid} = 0;
			$osdoesveth{$osid} = 0;
			$osdoesvethNE{$osid} = 0;
			$osdoesvethEN{$osid} = 0;
			$osdoesvlan{$osid} = 0;
			$osdoeslinkdelays{$osid} = 0;
			$osdoesrembstore{$osid} = 0;
		    }
		}
		$realnodes++;
	    }
	    # Figure out how many nodes support a feature
	    $nodesdo{"alias"}++
		# All OSs support this. 
		if (1);
	    $nodesdo{"none"}++
		# All OSs support no encap
		if (1);
	    $nodesdo{"veth"}++
		if ($osdoesveth{$osid});
	    $nodesdo{"veth-ne"}++
		if ($osdoesvethNE{$osid});
	    $nodesdo{"veth-en"}++
		if ($osdoesvethEN{$osid});
	    $nodesdo{"vlan"}++
		if ($osdoesvlan{$osid});
	    $nodesdo{"ldelay"}++
		if ($osdoeslinkdelays{$osid});
	    $nodesdo{"rem-bstore"}++
		if ($osdoesrembstore{$osid});

	    # Remember since we went to the trouble of determining the osid.
	    $member->_osdoesvethNE($osdoesvethNE{$osid});
	    $member->_osdoesvlan($osdoesvlan{$osid});
	}

	#
	# Layer 1 links cannot be any of these things right now.
	# Just a wire.
	#
	if ($layer == 1 &&
	    ($trivial_ok || $emulated || $uselinkdelay || $nointerswitch ||
	     $mustdelay || $nobwshaping || $sharednodes || $simnodes)) {
	    tberror("$vname is a layer 1 link, no options please.\n");
	    return -1;
	}

	$self->printdb("$vname: members = ".
		       scalar(@members) .
		       " real/virt/sim = ".
		       "$nonvirtnodes/$virtnodes/$simnodes ".
		       "mlink/veth-ne/veth-en/vlan/ldelay/rbstore = ".
		       $nodesdo{"alias"} . "/".
		       $nodesdo{"veth-en"} . "/".
		       $nodesdo{"veth-ne"} . "/".
		       $nodesdo{"vlan"} . "/".
		       $nodesdo{"ldelay"} . "/".
		       $nodesdo{"rem-bstore"} . "\n");

	# The OS on all nodes in a lan containing remote blockstores
	# (sanlan) must support the "rem-bstore" OS feature.
	if ($sanlan && $nodesdo{"rem-bstore"} != $realnodes) {
	    tberror("$vname: All nodes connecting to a link/lan that ".
		    "includes remote blockstores must support the ".
		    "'rem-bstore' OS feature!\n");
	    return -1;
	}

	#
	# Determine the emulation/encapsulation style for the link.
	# The goal is to come up with a compatible emulation style
	# for all members of the virt_lan.  Note that it is not stictly
	# necessary for all members of the virt_lan to emulate in the
	# same way; e.g., one node could be doing an 802.1q tagged VLAN
	# while another could just be doing IP aliasing or veths without
	# encapsulation.  In fact, it is not even necesary in some cases
	# for all vlinks on a physical link to use the same style!
	# But we don't want to go there right now, so for simplicity,
	# we require that the user specify identical values for all
	# members of a virt_lan.  
	#
	# XXX this is made hideous by having both global and per-link
	# encapsulation values that were previously used for two
	# different purposes.  The per-link value was used to
	# specify using "veth" devices for non-vnode emulated links
	# (as opposed to using IP aliases).  The global value
	# was used to specify using veth devices without encapsulation
	# for vnode emulated links.
	#
	# So the simplified semantics look like:
	#
	# global  per-link  in vnode?  meaning
	#
	# default default   no         alias; non-vnode mpx links (historic)
	# default alias     no         alias; non-vnode mpx links (historic)
	# default veth      no         veth; non-vnode mpx links (historic)
	#
	# default default   yes        veth; vnode vlinks (historic)
	# veth    default   yes        veth; vnode vlinks (historic)
	# veth-ne default   yes        veth-noencap; vnode vlinks (historic)
	#
	# default *         yes        veth
	# default *         no         alias
	# alias   *         yes        ERROR; we could support this
	# alias   *         no         alias
	# veth    *         *          veth
	# veth-ne *         *          veth-noencap
	# vlan    *         *          vlan
	#
	my $encapval;

        #
	# Notes on virtual interfaces.
	#
	# If a link is EMULATED (virtlanemulated) then it will have an
	# "encapsulation style" (virtlanencapstyle).  That value is
	# one of:
	#
	# "veth-ne"	emulation is done with "veth" devices;
	#		no encapsulation is used (uses made-up MAC addresses
	#		instead).
	#		Works on FreeBSD only and OpenVZ. 
	#
	# "vlan"	emulation is done with "vlan" devices;
	#		uses 802.1q VLAN tagging.
	#		Works on FreeBSD or Linux.
	#
	# "default"	emulation style was not explicitly set by the users;
	#		encap style depends on context ("veth-ne" for vnode)
	#
	# Note that the encapsulation style for "default" depends on
	# the node type.  For non-vnodes the default is "vlan".  For
	# vnodes the default is "veth-ne" since they must always have
	# some pseudo-device on which to hang a route table ID; i.e:
	# we cannot just do IP aliasing.
	#
        # Encapsulation can be specified per link.  The default link
        # encapsulation can also be specified by a per-experiment
        # setting. 
        #
	my $globalencap = $experiment->encap_style();

	#
	# No longer support veth or alias encap; catch it now. 
	#
	if (! ($globalencap =~ /^(default|veth-ne|vlan|alias)$/)) {
	    tberror("unknown global encapsulation style '$globalencap'\n");
	    $errors++;
	    next;
	}
	if (! ($linkencap =~ /^(default|veth-ne|vlan)$/)) {
	    tberror("$vname: unknown link encapsulation style '$linkencap'\n");
	    $errors++;
	    next;
	}
	if ($protocol eq "P2PLTE") {
	    #
	    # These links do not get any shaping or encapsulation.
	    #
	    $linkencap   = "none";
	    $nobwshaping = 1;
	    $emulated    = 0;

	    #
	    # Someone was trying to create a P2PLTE link with VMs, which we
	    # cannot do, and were silently turning that into a vlan. Lets
	    # throw an error instead and burst their bubble.
	    #
	    if ($virtnodes) {
		tberror("$vname: P2PLTE links cannot be used with VMs!\n");
		return -1;
	    }
	}
	if ($virtnodes) {
	    #
	    # At the present time, links with virtnodes require that we 
	    # multiplex (and use encapsulation). If emulated is not set,
	    # just turn it on (we can do this silently since there is no
	    # other choice for the user). 
	    #
	    $emulated = 1;
	    
	    #
	    # For virtual nodes, we prefer veth-ne cause vlans are a scarce
	    # resource, and most VM implementations should support them in
	    # some manner (eg: openvz veth device). 
	    #
	    if ($linkencap ne "default") {
		# Non default link encap overrides global encap.
		$encapval = $linkencap;
	    }
	    elsif ($globalencap eq "default") {
		$encapval = "vlan";
	    }
	    else {
		$encapval = $globalencap;
	    }
	}
	else {
	    #
	    # No virtual nodes. We allow links to use encapsulation and to
	    # be multiplexed (emulated). This allows the experimentor to
	    # have more links then just the number of physical interfaces.
	    # Encapsulation without multiplexing is okay, although useful
	    # mostly for testing purposes. If the link is multiplexed but not
	    # encapsulated, an encapsulation method must be chosen. We
	    # prefer vlan these days cause it runs everywhere. Might want
	    # to look at the nodesdo info at some point.
	    #
	    if ($emulated) {
		if ($linkencap ne "default") {
		    # Non default link encap overrides global encap.
		    $encapval = $linkencap;
		}
		elsif ($globalencap eq "default") {
		    $encapval = "vlan";
		}
		else {
		    $encapval = $globalencap;
		}
	    }
	    elsif ($linkencap ne "default") {
		# Non default link encap overrides global encap.
		$encapval = $linkencap;
	    }
	    elsif ($globalencap ne "default") {
		$encapval = $globalencap;
	    }
	    if (defined($encapval)) {
		if ($nodesdo{$encapval} != $nonvirtnodes) {
		    tberror("Not all nodes in link $vname support $encapval ".
			    "encapsulation\n");
		    $errors++;
		    next;
		}
	    }
	    else {
		$encapval = "none";
	    }
	}
	$self->printdb("$vname: global/link = ".
		       "$globalencap/$linkencap => $encapval\n");

	#
	# Update the per-link values for emulated and encapsulation style.
	# Also init the per-member flags, since this might be a mixed
	# pnode/vnode link, where the pnode links use a different setting.
	#
	$vlan->_encapstyle($encapval);
	$vlan->_emulated($emulated);
	foreach my $member (@members) {
	    $member->_encapstyle($encapval);
	    $member->_emulated($emulated);
	}

	if ($sanlan && $vlan->_encapstyle() ne "vlan") {
	    tberror("$vname: Links/LANs that host remote blockstores must ".
		    "use 'vlan' encapsulation!\n");
	    return -1;
	}

	#
	# For links involving virtnodes, we prefer to use virtual links.
	# But we can only do this if all involved nodes support a common
	# emulation style.
	#
	my $allnodes = $simnodes + $realnodes;
	if ($virtnodes > 0) {
	    $trivial_ok = $vlan->_trivial_ok();

	    #
	    # MLE Constraint: Not allowed to use a shared node on
	    # any link that is part of a vpath.
	    #
	    if (defined($vlan->_vpaths())) {
		tberror("Not allowed to use virtual/shared nodes in $vlan ".
			"since it is part of a path.\n");
		$errors++;
		next;
	    }

	    if ($sharednodes) {
		#
		# MLE Constraint: Not allowed to use a shared node on
		# any link that is implemented_by a vpath.
		#
		if (defined($vlan->_implemented_by())) {
		    tberror("Not allowed to use shared nodes in ".
			    "$vlan since is is implemented by a path.\n");
		    $errors++;
		    next;
		}
		
		#
		# All nodes must support vlan encapsulation since that is how
		# we create the links. Even if only one node in the link or
		# lan is on a shared node, they must all do vlan encap.
		# If none of the nodes land on a shared node, then use the
		# requested vlan encap. Right, this decision is actually made
		# later after assign maps the resources.
		#
		if ($nodesdo{"vlan"} != $allnodes) {
		    tberror("Shared nodes requested for $vname, ".
			    "but vlan encapsulation\n".
			    "not supported on all nodes.\n");
		    $errors++;
		}
	    }
	    #
	    # Regardless of shared nodes, there must be a common
	    # encapsulation style in case no shared nodes are used
	    # (and vlan encap is not needed).
	    #
	    if ($nodesdo{$encapval} == $allnodes) {
		#
		# All members support the encapsulation style, use it.
		#
		;
	    }
	    elsif ($nonvirtnodes && $encapval eq "veth-ne") {
		#
		# One way of mixing vnodes and pnodes is to require that all
		# nodes support the same style of encapsulation. The most
		# common is vlan encap.  But that is really inefficient
		# since it burns up scarce vlan ids. On the other hand, if
		# vnode links are veth-ne, and the user does not need/want
		# multiplexing on the pnodes, then a plain
		# non-encapsulating physical interface on the pnode is just
		# fine since all the pnode sees is ethernet frames with
		# fake mac addressess generated by the veth device on the
		# vnodes.
		#
		# At the moment, we have no NS syntax for the user to ask
		# for this, but if the pnodes do not support veth-ne, we
		# will just turn off the emulate bit for the pnode members
		# of the lan. Assign will not try to multiplex those, and
		# if the user asked for more links then interfaces, it will
		# fail to map.
		#
		$vlan->_mixedencap(1);
		
		foreach my $member (@members) {
		    my $virtnode = $member->virt_node();

		    next
			if ($virtnode->_isvirtnode());

		    if (! $member->_osdoesvethNE()) {
			tbwarn("$vname: changing $member to non-encapsulating ".
			       "since physical host does not support veth-ne\n");
			$member->_emulated(0);
			$member->_encapstyle("none");
		    }
		}
	    }
	    else {
		#
		# Not all members support the desired encapsulation. We used to
		# reset emulated and encapsulation style, but now we just throw
		# an error so that user knows the topology is not going to be
		# what was expected.
		#
		tberror("Encapsulation not supported on ".
			"$vname since at least one of the nodes in $vname ".
			"does not support '$encapval' link emulation\n");
		$errors++;
		next;
	    }
	}
	if ($protocol !~ /^ethernet/ && $protocol !~ /^P2PLTE/ ) {
	    #
	    # This arrangement is temporary. For now, if its not a
	    # regular ethernet or LTE, then create a lan attached to a fake
	    # switch. See ptopgen.  We label them differently though,
	    # since these do not get vlans.  Some other special
	    # treatment applies as well.
	    #
	    my $lanname = "fakelan/$vname";

	    $self->createNode($lanname, $mycmurn, $protocol, '1', undef, undef);
	    
	    # So we ignore it when it comes back from assign.
	    $self->lannodes()->{$lanname} = 1;
	    
	    # XXX If not ethernet, assume wireless. Need more info someplace.
	    $self->exptstats()->{'wirelesslans'} += 1;

	    my $others = {};
	    if ($emulated) {
		$others->{'emulated'}   = 1;
		# assign seems to require this, but it seems wrong.
		$others->{'trivial_ok'} = 1;
	    }
	    
	    foreach my $member (@members) {
		my $plink = "fakelan/$vname/$member";
		my $vname = $member->virt_node()->vname();
		
		my ($top_bw, $top_rbw) = $self->virtlantopbw($vlan, $member);
		$self->createLink($vname, $plink, [$mycmurn],
				  {'virtual_node_id' => $vname,
				   'virtual_interface_id' => "$member" },
				  {'virtual_node_id' => $lanname },
				  $top_bw, $protocol, $others);
		next;
	    }
	}
	elsif (defined($vlan->_portvlan())) {
	    #
	    # Special case that we use to connect a port to a vlan
	    # in another experiment. There is no delay or other stuff.
	    #
	    my $lannode  = "portlan/$vname";
	    
	    # Lan node for assign.
	    $self->createNode($lannode, $mycmurn, "lan", '1',
			      { 'real-switch' => ['' , "1.0"] },
			      { 'virtualization_type' => 'raw' });
	    
	    # So we ignore it when it comes back from assign.
	    $self->lannodes()->{$lannode} = 1;

	    my $others = {};
	    my $bw     = '*';

	    #
	    # We do not do link delays, but we do want to multiplex
	    # these links. For now, use usevirtiface() as an indicator.
	    #
	    if ($vlan->usevirtiface()) {
		$others->{'emulated'}   = 1;
		# assign seems to require this, but it seems wrong.
		$others->{'trivial_ok'} = 1;
		# This is probably not correct for all situations. 
		$bw = 1000;
	    }
	    foreach my $member (@members) {
		my $virtnode   = $member->virt_node();
		my $vnodevname = $virtnode->vname();
		my $plink      = "portlan/$vname/$member";
		my (undef,$bw0)= @{$member->_delayinfo()};
		my $wiretype   = $vlan->_wiretype();

		if ($bw0 != 0) {
		    $wiretype = $self->GetWiretype($wiretype, $bw0);
		}
		$self->createLink($vname, $plink,
				  [$virtnode->_cmurn()],
				  {'virtual_node_id' => $vnodevname,
				   'virtual_interface_id' =>"$member" },
				  {'virtual_node_id' => $lannode },
				  $bw, $wiretype, $others);
	    }
	}
	elsif (@members == 2) {
	    #
	    # We treat LANs with two members specially - they are just links
	    #
	    $self->exptstats()->{'links'} += 1;

	    my ($member0,$member1) = @members;
	    my $virtnode0 = $member0->virt_node();
	    my $virtnode1 = $member1->virt_node();
	    my $vname0    = $virtnode0->vname();
	    my $vname1    = $virtnode1->vname();

	    my ($delay0,$bw0,$ebw0,$backfill0,$loss0,
		$rdelay0,$rbw0,$rebw0,$rbackfill0,$rloss0) =
		    @{$member0->_delayinfo()};
	    my ($delay1,$bw1,$ebw1,$backfill1,$loss1,
		$rdelay1,$rbw1,$rebw1,$rbackfill1,$rloss1) =
		    @{$member1->_delayinfo()};

	    # Here the r's are going to be 1->0 and the others 0->1
	    my $delay      = $delay0+$rdelay1;
	    my $loss       = 1-(1-$loss0)*(1-$rloss1);
	    my $bw         = min($bw0,$rbw1);
 	    my $backfill   = max($backfill0,$rbackfill1);
	    my $rdelay     = $rdelay0+$delay1;
	    my $rloss      = 1-(1-$rloss0)*(1-$loss1);
	    my $rbw        = min($rbw0,$bw1);
 	    my $rbackfill  = max($rbackfill0,$backfill1);
	    my $bandwidth  = $self->getbandwidth($member0, $vlan, $bw);
	    my $rbandwidth = $self->getbandwidth($member1, $vlan, $bw);

	    # Need to know about tracing on a per queue basis, since the
	    # user can specify tracing asymmetrically.
	    my ($traced,$trace_endnode)   = @{$member0->_traceinfo()};
	    my ($rtraced,$rtrace_endnode) = @{$member1->_traceinfo()};

	    # Rob says not supported
	    if (($trivial_ok || $emulated) &&
		($bandwidth == 0 || $rbandwidth == 0)) {
		tberror("Cannot mix trivial_ok|emulated with * bw\n");
		$errors++;
	    }

	    #
	    # Lets see how many <=1Gb and >1Gb links we have. HACK!
	    #
	    if (!$emulated && ($bandwidth || $rbandwidth)) {
		# Must convert this to kbps like everything else is.
		my $OneGb = 1000 * 1000;
		
		my $maxbw = max($bw, $rbw);

		if ($maxbw <= $OneGb) {
		    $self->counters()->{'Gblinks'}++;
		}
		elsif ($maxbw > $OneGb) {
		    $self->counters()->{'MGblinks'}++;
		}
	    }

	    #
	    # See if the link is really being shaped, or if just need
	    # a delay node cause of tracing/monitoring.
	    #
	    my $shaped = 0;

	    if (((($delay >= $DELAYTHRESH) ||
		  (!$nobwshaping &&
		   ($self->requires_delay($member0, $vlan, $bw) ||
		    $self->requires_delay($member1, $vlan, $bw))) ||
		  ($loss != 0)) ||
		 (($rdelay >= $DELAYTHRESH) ||
		  (!$nobwshaping &&
		   ($self->requires_delay($member0, $vlan, $rbw) ||
		    $self->requires_delay($member1, $vlan, $rbw))) ||
		  ($rloss != 0)) ||
		 # Link must be shaped for other reasons (q_red).
		 $mustdelay ||
		 # Global force, or per-link force. 
		 $self->option('forcelinkdelays') || $uselinkdelay) &&
		# No shaping on bridged lans.
		!$vlan->_bridged() &&
		# No shaping of geni nodes.
		$vlan->_geninodes() == 0) {
		# Need a delay node and its really a shaped link.
		$shaped = 1;
		# Mark the links as shaped for later.
		$vlan->setmembershaped($member0);
		$vlan->setmembershaped($member1);
	    }

	    #
	    # MLE Constraint: Not allowed to shape a link that is
	    # implemented_by a path, unless it uses link shaping.
	    #
	    if (defined($vlan->_implemented_by()) && $shaped &&
			!$self->virtlan_use_linkdelay($vlan, $shaped)) {
		tberror("Not allowed to shape (delay nodes) $vlan since it ".
			"is implemented_by a path. Try endnode shaping.\n");
		$errors++;
		next;
	    }

	    #
	    # MLE Constraint: The links in a path cannot be shaped at all.
	    #
	    if (defined($vlan->_vpaths()) && $shaped) {
		tberror("Not allowed to shape $vlan cause its in a vpath\n");
		$errors++;
		next;
	    }
	    # And, a layer 1 link cannot be shaped no matter what right now.
	    if ($layer == 1 && $shaped) {
		tberror("Not allowed to shape $vlan cause its at layer 1\n");
		$errors++;
		next;
	    }

	    #
	    # Check to make sure that both nodes support linkdelays.  This
	    # check is only made for links comprised of physical nodes,
	    # since if the OS supports virtual nodes, it supports linkdelays.
	    #
	    if ($shaped && $virtnodes != scalar(@members)  &&
		$self->virtlan_use_linkdelay($vlan, $shaped)) {
		#
		# The user had to specify the OS.
		#
		if (! (defined($virtnode0->_osinfo()) &&
		       defined($virtnode1->_osinfo()))) {
		    tberror("You must specify the OSID for all nodes in ".
			    "lan $vlan, when using linkdelays ".
			    "(endnode traffic shaping)\n");
		    $errors++;
		}
		else {
		    #
		    # All the OS's have to support linkdelays.
		    #
		    foreach my $virtnode ($virtnode0, $virtnode1) {
			my $osinfo = $virtnode->_osinfo();

			# Always supports.
			# XXX Ignore for GEC16
			next
			    if (1 || $virtnode->_isvirtnode());
			
			if (! $osdoeslinkdelays{$osinfo->osid()}) {
			    my $osname = $osinfo->osname();
			    tberror({type => 'primary', severity => SEV_ERROR,
				     error => ['node_lacks_linkdelay_support',
					       $virtnode, $vlan]},
				    "$virtnode in link $vlan is running an OS ".
				    "($osname) that does not support linkdelays ".
				    "(endnode traffic shaping)\n");
			    $errors++;
			}
		    }
		}
	    }

	    #
	    # Get the bandwidth we're supposed to put into the top file, which
	    # may be different that what we're limiting the link to
	    #
	    my ($top_bw0, $top_rbw0) = $self->virtlantopbw($vlan, $member0);
	    my ($top_bw1, $top_rbw1) = $self->virtlantopbw($vlan, $member1);

	    my $top_bw  = max($top_bw0, $top_rbw1);
	    my $top_rbw = max($top_rbw0, $top_bw1);

	    if (($shaped ||
		 (($traced || $rtraced) &&
		  !($trace_endnode && $rtrace_endnode))) &&
		# Ignore for bridged links.
		!$vlan->_bridged() &&
		# XXX simulated nodes hack. We don't want to put delay nodes
		# between simulated nodes. If there is a link between a
		# simulated and a real node, we might need to put in delay
		# nodes.
		($realnodes != 0)) {
		$self->exptstats()->{"shapedlinks"} += 1;
		
		#
		# We use a linkdelay if the link is emulated, globally forced,
		# globally preferred if the link is shaped, or if the per-link
		# flag was set (which means to put in a link delay regardless
		# of whether the link is shaped).
		#
		if ($self->virtlan_use_linkdelay($vlan, $shaped)) {
		    my $plink = "linksimple/$vname/$member0,$member1";
		    my $others = {};
		    if ($emulated) {
			$others->{'emulated'} = 1
			    if ($member0->_emulated() && $member1->_emulated());
			$others->{'virtualization_type'} =
			    $vlan->_encapstyle();
		    }
		    if ($trivial_ok) {
			$others->{'trivial_ok'} = 1;
		    }
		    if ($nointerswitch) {
			$others->{'nointerswitch'} = 1;
		    }
		    #
		    # If the virtnode is a VM and it has been fixed to
		    # a topology node, then we have to use that node
		    # name, since the VM names do not appear in the vtop.
		    #
		    if (defined($virtnode0->_fixedvm())) {
			$vname0 = $virtnode0->_fixedvm()->vname();
		    }
		    if (defined($virtnode1->_fixedvm())) {
			$vname1 = $virtnode1->_fixedvm()->vname();
		    }
		    
		    if (defined($vlan->_implemented_by())) {
			#
			# We post pass these links. Save.
			#
			$self->vlinks()->{"$vlan"} = [$plink];
		    }
		    else {
			$self->createLink($vname, $plink, [$mycmurn],
				    {'virtual_node_id' => $vname0,
				     'virtual_interface_id' => "$member0" },
				    {'virtual_node_id' => $vname1,
				     'virtual_interface_id' => "$member1" },
				    ($top_bw == 0 ? "*" : 
				     max($top_bw, $top_rbw)),
				    ($emulated ? $vlan->_wiretype() :
				     $self->GetWiretype($vlan->_wiretype(),
						 max($top_bw, $top_rbw))),
				    $others);
		    }
		    my @delayinfo = ($delay,$bw,$backfill,$loss,
				     $rdelay,$rbw,$rbackfill,$rloss, 0);
		    
		    $self->printdb("Delay link $plink = " . 
				   join(" ", @delayinfo) . "\n");
		    
		    # Save for the post pass.
		    $self->delaylinks()->{$plink} = \@delayinfo;
		}
		else {
		    my $delayname   = $self->nextdelayname();
		    my $plink       = "linksdelaysrc/$vname/$member0,$member1";

		    my $delaydesirename = $self->delay_desire_name();
		    my $delaydesiretype = $self->delay_desire_type();
		    my $delaydesirepenalty = $self->delay_desire_penalty();
		    
		    
		    my @delayinfo = ($delay,$bw,$backfill,$loss,
				     $rdelay,$rbw,$rbackfill,$rloss,0);
		    my $desire = {};
		    if ($delaydesirename ne '') {
			$desire->{$delaydesirename} = 
			    [$delaydesiretype, $delaydesirepenalty];
		    }
		    $self->createNode($delayname, $mycmurn, "delay", '1', 
				      $desire, undef);

		    my $others = {};
		    $self->createLink($vname,
				      "linksdelaysrc/$vname/$member0,$member1",
				      [$mycmurn],
				      {'virtual_node_id' => $vname0,
				       'virtual_interface_id' => "$member0" },
				      {'virtual_node_id' => $delayname,
				       'virtual_interface_id' => "$member1" },
				      ($top_bw == 0 ? "*" : $top_bw), 
				      $self->GetWiretype($vlan->_wiretype(),
						  max($top_bw, $top_rbw)),
				      $others);
		    
		    $self->createLink($vname,
				      "linksdelaydst/$vname/$member1,$member0",
				      [$mycmurn],
				      {'virtual_node_id' => $vname1,
				       'virtual_interface_id' => "$member1" },
				      {'virtual_node_id' => $delayname,
				       'virtual_interface_id' =>"$member0" },
				      ($top_bw == 0 ? "*" : $top_rbw), 
				      $self->GetWiretype($vlan->_wiretype(),
						  max($top_bw, $top_rbw)),
				      $others);
		    
		    $self->printdb("Delay node $plink ($delayname) = " . 
				   join(" ", @delayinfo) . "\n");
		    
		    # Save for the post pass.
		    $self->delaylinks()->{$plink} = \@delayinfo;
		    $self->delaynodes()->{$delayname} = $delayname;
		}
		#
		# Ports are set to the next-fastest speed when a link gets a
		# delay node.  This can override initialization above cause we
		# could not tell earlier if the link was going to get a real
		# delay node or just a delaywithswitch.
		#
		#$self->portbw()->{$member0} =
		#    $self->getbandwidth($member0,$vlan,$bandwidth);
		#$self->portbw()->{$member1} =
		#    $self->getbandwidth($member1,$vlan,$rbandwidth);
	    }
	    else {
		my $plink = "linksimple/$vname/$member0,$member1";
		my $vtbw   = max($top_bw,$top_rbw);
		my $others = {'isgeninode' => $vlan->_geninodes()};
		my $wiretype = $vlan->_wiretype();

		if (!$emulated) {
		    # Let assign choose bw if top_bw is zero.
		    $vtbw = ($top_bw == 0 ? "*" : $vtbw);
		    $wiretype = $self->GetWiretype($wiretype,
						   max($top_bw, $top_rbw));
		}
		if ($emulated) {
		    $others->{'emulated'} = 1
			if ($member0->_emulated() && $member1->_emulated());
		    $others->{'virtualization_type'} = $vlan->_encapstyle();
		}
		if ($layer == 1) {
		    $wiretype = "wire";
		}
		
		if ($trivial_ok) {
		    $others->{'trivial_ok'} = 1;
		    #
		    # We store this info in case assign actually does turn it
		    # into a trivial link. If that happens, we have to insert
		    # a link delay if the link is between two vnodes. Why?
		    # Cause a trivial link (using loopback) would have much
		    # more bandwidth (400+ Mb) then your typical 100Mb link.
		    # Note the final member of the array, which indicates this
		    # delay should be inserted only if assign makes it a
		    # trivial link.		    
		    #
		    if (!$nobwshaping && !$vlan->_allsim()) {
			$self->delaylinks()->{$plink} = 
			    [$delay,$bw,$backfill,$loss,
			     $rdelay,$rbw,$rbackfill,$rloss,1.000000];
		    }
		}
		if ($nointerswitch) {
		    $others->{'nointerswitch'} = 1;
		}
		if (defined($vlan->_implemented_by())) {
		    #
		    # We post pass these links. Save.
		    #
		    $self->vlinks()->{"$vlan"} = [$plink];
		}
		else {
		    #
		    # If the virtnode is a VM and it has been fixed to
		    # a topology node, then we have to use that node
		    # name, since the VM names do not appear in the vtop.
		    #
		    if (defined($virtnode0->_fixedvm())) {
			$vname0 = $virtnode0->_fixedvm()->vname();
		    }
		    elsif (defined($virtnode0->_sanhostname())) {
			$vname0 = $virtnode0->_sanhostname();
		    }
		    if (defined($virtnode1->_fixedvm())) {
			$vname1 = $virtnode1->_fixedvm()->vname();
		    }
		    elsif (defined($virtnode1->_sanhostname())) {
			$vname1 = $virtnode1->_sanhostname();
		    }
		    $self->createLink($vname, $plink,
				      [$virtnode0->_cmurn(),
				       $virtnode1->_cmurn() ],
				      {'virtual_node_id' => $vname0,
				       'virtual_interface_id' =>"$member0" },
				      {'virtual_node_id' => $vname1,
				       'virtual_interface_id' =>"$member1" },
				      $vtbw, $wiretype, $others);
		}
	    }
	}
	elsif (@members != 0) {
	    my $desires = {};
	    $self->exptstats()->{"lans"} += 1;
	    my $lannode = ($vlan->_geninodes() ? "lan-$vname" : "lan/$vname");
	    my $cmurn   = ($vlan->_geninodes() ?
			   $members[0]->virt_nodes()->_cmurn() : $mycmurn);

	    #
	    # This is for mixing real nodes with pnodes in a lan. The goal 
	    # is to prevent assign from putting the lan node on a pc;
	    # always prefer a real switch. See corresponding change in
	    # ptopgen.
	    #
	    if ($virtnodes && $nonvirtnodes) {
		$desires->{"real-switch"} = ['' , "1.0"];
	    }
	    # This allows the lan node to go on a shared node.
	    if ($sharednodes) {
		$desires->{"pcshared"} = ['' , "0.0"];
	    }
			       
	    # Lan node for assign.
	    $self->createNode($lannode, $cmurn, "lan", '1', $desires,
			      { 'virtualization_type' => 'raw' ,
			        'isgeninode' => $vlan->_geninodes() });
	    
	    # So we ignore it when it comes back from assign.
	    $self->lannodes()->{$lannode} = 1;
	    
	    foreach my $member (@members) {
		my $virtnode   = $member->virt_node();
		my $vnodevname = $virtnode->vname();
		
		my ($delay,$bw,$ebw,$backfill,$loss,
		    $rdelay,$rbw,$rebw,$rbackfill,$rloss) =
			@{$member->_delayinfo()};

		# Need to know about tracing on a per queue basis, since the
		# user can specify tracing asymmetrically.
		my ($traced,$trace_endnode)  = @{$member->_traceinfo()};
		
		#
		# See if the link is really being shaped, or if the we just
		# need a delay node cause of tracing/monitoring.
		#
		my $shaped = 0;

                # XXX The expression below should be modified for
                # better bandwidth support.  Probably needs to happen
                # post assign somehow.
		if (((($delay >= $DELAYTHRESH) ||
		      (!$nobwshaping &&
		       $self->requires_delay($member, $vlan, $bw)) ||
		      ($loss != 0)) || 
		     (($rdelay >= $DELAYTHRESH) ||
		      (!$nobwshaping &&
		       $self->requires_delay($member, $vlan, $rbw)) ||
		      ($rloss != 0)) ||
		     # Link must be shaped for other reasons (q_red).
		     $mustdelay ||
		     # Global force, or per-lan force. 
		     $self->option('forcelinkdelays') || $uselinkdelay) &&
		    # No shaping on bridged lans.
		    !$vlan->_bridged() &&
		    # No shaping for geni nodes.
		    $vlan->_geninodes() == 0) {
		    $shaped = 1;
		    # Mark the link as shaped for later.
		    $vlan->setmembershaped($member);
		}

		#
		# MLE Constraint: Not allowed to shape a link that is
		# implemented_by a path, unless it uses link shaping.
		#
		if (defined($vlan->_implemented_by()) && $shaped &&
		    !$self->virtlan_use_linkdelay($vlan, $shaped)) {
		    tberror("Not allowed to shape (delay nodes) $vlan since it ".
			    "is implemented_by a path. Try endnode shaping.\n");
		    $errors++;
		    next;
		}

		#
		# MLE Constraint: The links in a path cannot be shaped at all.
		#
		if (defined($vlan->_vpaths()) && $shaped) {
		    tberror("Not allowed to shape $vlan cause its in a vpath\n");
		    $errors++;
		    next;
		}
		# And, a layer 1 link cannot be shaped no matter what right now.
		if ($layer == 1 && $shaped) {
		    tberror("Not allowed to shape $vlan cause its at layer 1\n");
		    $errors++;
		    next;
		}
		if (defined($vlan->_implemented_by())) {
		    if (!exists($self->vlinks()->{"$vlan"})) {
			$self->vlinks()->{"$vlan"} = [];
		    }
		}

		#
		# Check to make sure that this node supports linkdelays.
		# This check is only made for links comprised of physical
		# nodes, since if the OS supports virtual nodes, it
		# supports linkdelays.
		#
		if ($shaped && $virtnodes != scalar(@members) &&
		    $self->virtlan_use_linkdelay($vlan, $shaped)) {
		    #
		    # The user had to specify the OS.
		    #
		    if (! defined($virtnode->_osinfo())) {
			tberror("You must specify the OSID for all nodes in ".
				"lan $vlan, when using linkdelays ".
				"(endnode traffic shaping)\n");
			$errors++;
		    }
		    elsif (!$virtnode->_isvirtnode()) {
			#
			# All the OSes have to support linkdelays.
			#
			my $osinfo = $virtnode->_osinfo();
			
			if (!defined($osinfo)) {
			    tbreport(SEV_ERROR, 'node_lacks_linkdelay_support',
				     $virtnode, $vlan);
			}
			elsif (! $osdoeslinkdelays{$osinfo->osid()}) {
			    my $osname = $osinfo->osname();
			    tbwarn("$virtnode in lan $vlan is running an OSID".
				   " ($osname) that does not support linkdelays".
				   " (endnode traffic shaping)\n");
			    $errors++;
			}
		    }
		}
		my ($top_bw, $top_rbw) = $self->virtlantopbw($vlan, $member);
		my $bandwidth  = $self->getbandwidth($member,$vlan,$bw);
		my $rbandwidth = $self->getbandwidth($member,$vlan,$rbw);

		#
		# Lets see how many <=1Gb and >1Gb links we have. HACK!
		#
		if (!$emulated && ($bandwidth || $rbandwidth)) {
		    # Must convert this to kbps like everything else is.
		    my $OneGb = 1000 * 1000;
		    my $maxbw = max($bw, $rbw);

		    if ($maxbw <= $OneGb) {
			$self->counters()->{'Gblinks'}++;
		    }
		    elsif ($maxbw > $OneGb) {
			$self->counters()->{'MGblinks'}++;
		    }
		}
		
		if (($shaped || ($traced && !$trace_endnode)) &&
		    # Ignore for bridged links.
		    !$vlan->_bridged() &&
		    # if we have 1 real node in the LAN, we may need to create
		    # a lan
		    ($realnodes != 0)) {
		    $self->exptstats()->{"shapedlans"} += 1;
		    
		    #
		    # We use a linkdelay if the link is emulated,
		    # globally forced, globally preferred if the link
		    # is shaped, or if the per-link flag was set
		    # (which means to put in a link delay regardless
		    # of whether the link is shaped).
		    #
		    if ($self->virtlan_use_linkdelay($vlan, $shaped)) {
			my $plink = "linklan/$vname/$member";
				
			my @delayinfo = ($delay,$bw,$backfill,$loss,
					 $rdelay,$rbw,$rbackfill,$rloss,0);
			
			my $others = {};
			if ($emulated) {
			    $others->{'emulated'} = 1 if ($member->_emulated());
			    $others->{'virtualization_type'} =
				$vlan->_encapstyle();
			}
			if ($trivial_ok) {
			    $others->{'trivial_ok'} = 1;
			}
			if ($nointerswitch) {
			    $others->{'nointerswitch'} = 1;
			}
			#
			# If the virtnode is a VM and it has been fixed to
			# a topology node, then we have to use that node
			# name, since the VM names do not appear in the vtop.
			#
			if (defined($virtnode->_fixedvm())) {
			    $vnodevname = $virtnode->_fixedvm()->vname();
			}
		    
			if (defined($vlan->_implemented_by())) {
			    #
			    # We post pass these links. Save.
			    #
			    push(@{$self->vlinks()->{"$vlan"}}, $plink);
			}
			else {
			    $self->createLink($vname, $plink, [],
				      {'virtual_node_id' => $vnodevname,
				       'virtual_interface_id' =>"$member" },
				      {'virtual_node_id' => "$lannode" },
				      ($top_bw == 0 ? "*" : 
				       max($top_bw,$top_rbw)),
				      ($emulated ? $vlan->_wiretype() :
				       $self->GetWiretype($vlan->_wiretype(),
					      max($top_bw, $top_rbw))),
					      $others);
			}
			
			$self->printdb("Delay link $plink = " .
				       join(" ", @delayinfo) . "\n");
			
			# Save for the post pass.
			$self->delaylinks()->{$plink} = \@delayinfo;
		    }
		    else {
			my $delayname   = $self->nextdelayname();
			my $plink       = "linkdelaysrc/$vname/$member";
			my $delaydesirename = $self->delay_desire_name();
			my $delaydesiretype = $self->delay_desire_type();
			my $delaydesirepenalty = $self->delay_desire_penalty();
				
			my @delayinfo   = ($delay,$bw,$backfill,$loss,
					   $rdelay,$rbw,$rbackfill,$rloss,0);
			
			my $desire = {};
			if ($delaydesirename ne '') {
			    $desire->{$delaydesirename} = 
				[$delaydesiretype, $delaydesirepenalty];
			}
			$self->createNode($delayname, $mycmurn, "delay", '1',
					  $desire, undef);
			
			my $others = {};
			$self->createLink($vname,
					  "linkdelaysrc/$vname/$member",
					  [$mycmurn],
				       {'virtual_node_id' => $vnodevname,
					 'virtual_interface_id' =>"$member" },
				       {'virtual_node_id' => $delayname,
					 'virtual_interface_id' =>"$member" },
				       $top_bw == 0 ? "*" : $top_bw,
				       $self->GetWiretype($vlan->_wiretype(),
							  $top_bw),
				       $others);
				
			$self->createLink($vname,
					  "linkdelaydst/$vname/$member",
					  [$mycmurn],
					{'virtual_node_id' => "$lannode",
					 'virtual_interface_id' =>"$member" },
					{'virtual_node_id' => $delayname,
					 'virtual_interface_id' =>"$member" },
					$top_bw == 0 ? "*" : $top_bw,
				        $self->GetWiretype($vlan->_wiretype(),
							   $top_bw),
					$others);
			
			$self->printdb("Delay node $plink ($delayname) = " .
				       join(" ", @delayinfo) . "\n");
	
			# Save for the post pass.
			$self->delaylinks()->{$plink} = \@delayinfo;
			$self->delaynodes()->{$delayname} = $delayname;
			
			# XXX Mark the lan as having delayed members so that
			# we create a delayed protolan. Bogus.
			$vlan->_delayed(1);
		    }
		    #
		    # Port is set to the next-fastest speed when the link
		    # gets a delay node.  This can override initialization
		    # above cause we could not tell earlier if the link was
		    # going to get a real delay node or just a
		    # delaywithswitch.
		    #
		    #$self->portbw()->{$member} = $bandwidth;	    
		}
		else {
		    my $plink = "linklan/$vname/$member";
		    my $others = {'isgeninode' => $vlan->_geninodes()};
		    my $wiretype = $vlan->_wiretype();
		    
		    if ($emulated) {
			$others->{'emulated'} = 1 if ($member->_emulated());
			$others->{'virtualization_type'} =
			    $member->_encapstyle();
		    }
		    else {
			$wiretype = $self->GetWiretype($wiretype, $top_bw);
		    }
		    if ($trivial_ok) {
			$others->{'trivial_ok'} = 1;
		    }
		    if ($nointerswitch) {
			$others->{'nointerswitch'} = 1;
		    }
		    #
		    # If the virtnode is a VM and it has been fixed to
		    # a topology node, then we have to use that node
		    # name, since the VM names do not appear in the vtop.
		    #
		    if (defined($virtnode->_fixedvm())) {
			$vnodevname = $virtnode->_fixedvm()->vname();
		    }
		    elsif (defined($virtnode->_sanhostname())) {
			$vnodevname = $virtnode->_sanhostname();
		    }
		    
		    #
		    # We store this info in case assign actually does
		    # turn it into a trivial link. If that happens, we
		    # have to insert a link delay if the link is
		    # between two vnodes. Why?  Cause a trivial link
		    # (using loopback) would have much more bandwidth
		    # (400+ Mb) then your typical 100Mb link. Note the
		    # final member of the array, which indicates this
		    # delay should be inserted only if assign makes it
		    # a trivial link.
		    #
		    if (!$nobwshaping) {
			$self->delaylinks()->{$plink} = 
			    [$delay,$bw,$backfill,$loss,
			     $rdelay,$rbw,$rbackfill,$rloss,1.000000];
		    }
		    if (defined($vlan->_implemented_by())) {
			#
			# We post pass these links. Save.
			#
			push(@{$self->vlinks()->{"$vlan"}}, $plink);
		    }
		    else {
			$self->createLink($vname, $plink,
					  [$virtnode->_cmurn()],
					  {'virtual_node_id' => $vnodevname,
					   'virtual_interface_id' =>"$member" },
					  {'virtual_node_id' => $lannode },
					  ($top_bw == 0 ? "*" : $top_bw), 
					  $wiretype, $others);
		    }
		}
	    }
	}
    }
    return $errors;
}

#
# Print the results in plain text top file format.
#
sub PrintTop($;$)
{
    my ($self, $outfile) = @_;

#    print Dumper($self);
    my $output = "";
    my %fixedifaces = ();

    foreach my $vclass (@{$self->rspec()->{'vclass'}}) {
	$output .= 'make-vclass ' . ' ';
	$output .= $vclass->{'name'} . ' ';
	$output .= $vclass->{'weight'} . ' ';
	foreach my $nodetype (@{$vclass->{'members'}}) {
	    $output .= $nodetype . ' ';
	}
	$output .= "\n";
    }

    foreach my $node (@{$self->rspec()->{'node'}}) {
	next
	    if (exists($node->{'isgeninode'}) && $node->{'isgeninode'});
	
	$output .= 'node' . ' ';
	$output .= $node->{'virtual_id'} . ' ';
	$output .= $node->{'node_type'} . ':' . $node->{'type_slots'} . ' ';
	if (exists($node->{'disallow_trivial_mix'})) {
	    $output .= 'disallow_trivial_mix' . ' ';
	}
	if (exists($node->{'subnode'})) {
	    $output .= 'subnode_of:' . $node->{'subnode'} . ' ';
	}
	while ( my ($desire, $desireval) = each (%{$node->{'desires'}})) {
	    $output .= $desireval->[0] . $desire . 
		':' .  sprintf("%f", $desireval->[1]) . ' ';
	}
	$output .= "\n";

	#
	# In ptop format, the fixed interfaces go on the link lines,
	# so just save them up for below.
	#
	if (exists($node->{'interfaces'})) {
	    foreach my $ref (@{ $node->{'interfaces'} }) {
		my $virtid = $ref->{'virtual_id'};
		my $compid = $ref->{'component_id'};

		$fixedifaces{$virtid} = $compid
		    if (defined($compid));
	    }
	}
    }

    foreach my $link (@{$self->rspec()->{'link'}}) {
	next
	    if (exists($link->{'isgeninode'}) && $link->{'isgeninode'});

	$output .= 'link' . ' ';
	$output .= $link->{'plink'} . ' ';
	$output .= $link->{'interface_ref'}->[0]->{'virtual_node_id'} . ' ';
	$output .= $link->{'interface_ref'}->[1]->{'virtual_node_id'} . ' ';
	$output .= $link->{'capacity'} . ' ';
	$output .= $link->{'latency'} . ' ';
	$output .= $link->{'packet_loss'} . ' ';
	$output .= $link->{'link_type'} . ' ';
	if (exists ($link->{'nodelay'})) {
	    $output .= 'nodelay' . ' ';
	}
	if (exists($link->{'emulated'})) {
	    $output .= 'emulated' . ' ';
	}
	if (exists($link->{'trivial_ok'})) {
	    $output .= 'trivial_ok' . ' ';
	}
	if (exists($link->{'nointerswitch'})) {
	    $output .= 'no_interswitch' . ' ';
	}
	if (exists($link->{'interface_ref'}->[0]->{'virtual_interface_id'})) {
	    my $if1 = $link->{'interface_ref'}->[0]->{'virtual_interface_id'};
	    if (exists($fixedifaces{$if1})) {
		$output .= 'fixsrciface:' . $fixedifaces{$if1} . ' ';
	    }
	}
	if (exists($link->{'interface_ref'}->[1]->{'virtual_interface_id'})) {
	    my $if2 = $link->{'interface_ref'}->[1]->{'virtual_interface_id'};
	    if (exists($fixedifaces{$if2})) {
		$output .= 'fixdstiface:' . $fixedifaces{$if2} . ' ';
	    }
	}
	$output .= "\n";
    }

    foreach my $fixednode (@{$self->rspec()->{'fixed'}}) {
	$output .= 'fix-node' . ' ';
	$output .= $fixednode->{'vnode'} . ' ';
	$output .= $fixednode->{'pnode'};
	$output .= "\n";
    }

    $outfile = *STDOUT
	if (!defined($outfile));
    print $outfile $output;
    return 0;
}


#
# Print the rspec part of the topo. Eventually the whole thing needs
# to be in rspec. The RSPEC prints the results in v2 format
#
sub PrintRspec($;$)
{
    my ($self, $output) = @_;
    $output = *STDOUT
	if (!defined($output));
    
    my $doc = XML::LibXML::Document->new();

    # Construct the current time string 
    my $creation = time();
    my $expiration = $creation + 3600;

    my $rspecns = "http://www.protogeni.net/resources/rspec/2";
    my $rspecurl = "http://www.protogeni.net/resources/rspec/2/request.xsd";
    my $extns = "http://www.protogeni.net/resources/rspec/ext/emulab/1";
    my $exturl = "http://www.protogeni.net/resources/rspec/ext/emulab/1/vtop_extension.xsd";
    
    my $root = $doc->createElement("rspec");
    $root->setAttribute("xmlns", "$rspecns");
    $root->setAttribute("xmlns:xsi",
			"http://www.w3.org/2001/XMLSchema-instance");
    $root->setAttribute("xmlns:emulab", "$extns");

    ### XXX: Change the URL
    $root->setAttribute("xsi:schemaLocation",
			"$rspecns $rspecurl $extns $exturl"); 
    $root->setAttribute("type", "request");
    $root->setAttribute("generated", 
			POSIX::strftime("20%y-%m-%dT%H:%M:%S",
					gmtime($creation)));
    $root->setAttribute("valid_until",
			POSIX::strftime("20%y-%m-%dT%H:%M:%S",
					gmtime($expiration)));
    
    $doc->setDocumentElement($root);

    foreach my $ref (@{$self->rspec()->{'node'}}) {
    	$self->processNodeRspec($doc, $root, $ref);
    }
    foreach my $ref (@{$self->rspec()->{'link'}}) {
	$self->processLinkRspec($doc, $root, $ref);
    }
    foreach my $ref (@{$self->rspec()->{'vclass'}}) {
	$self->processVClassRspec($doc, $root, $ref);
    }
    
    print $output $doc->toString(1) . "\n";
    return 0;
}

#
# One time initialization for a vtop. 
#
sub CreateVtop($;$)
{
    my ($self, $architecture) = @_;
    my $pid = $self->experiment()->pid();

    # For forcing untyped nodes to a particular arch.
    if (defined($architecture)) {
	$self->{'FORCEARCH'} = $architecture;
    }

    #
    # This is for stats gathering. It might duplicate other stuff, but
    # thats okay.
    #
    $self->{'EXPTSTATS'} =
    {
        # pnodes include jailnodes and delaynodes.
	# We let the wrapper determine pnodes once the
	# experiment is fully swapped in so that the record
	# is not "committed" until successful swapin.
	'jailnodes'   => 0,
	'vnodes'      => 0,
	# vnodes include wanodes.
	'wanodes'     => 0,
	# wanodes includes plabnodes.
	'plabnodes'   => 0,
	'simnodes'    => 0,
	'delaynodes'  => 0,
	'linkdelays'  => 0,
	'links'       => 0,
	'walinks'     => 0,
	'lans'        => 0,
	'wirelesslans' => 0,
	'shapedlinks' => 0,
	'shapedlans'  => 0,
	'minlinks'    => undef,
	# includes emulated links. Maybe thats wrong.
	'maxlinks'    => 0,
    };

    # Initialize counters.
    $self->{'COUNTERS'}->{'nodecount'}   = 0;
    $self->{'COUNTERS'}->{'plabcount'}   = 0;
    $self->{'COUNTERS'}->{'genicount'}   = 0;
    $self->{'COUNTERS'}->{'virtcount'}   = 0;
    $self->{'COUNTERS'}->{'simcount'}    = 0;
    $self->{'COUNTERS'}->{'remotecount'} = 0;
    $self->{'COUNTERS'}->{'sharedcount'} = 0;
    $self->{'COUNTERS'}->{'bstorecount'} = 0;
    $self->{'COUNTERS'}->{'physcount'}   = 0;
    $self->{'COUNTERS'}->{'Gblinks'}     = 0;
    $self->{'COUNTERS'}->{'MGblinks'}    = 0;

    #
    # Experiment wide options.
    #
    # Set this when forcing linkdelays instead of delay nodes. NS file.
    $self->options()->{'uselinkdelays'} =
	($self->virtexperiment()->uselinkdelays() ? 1 : 0);

    # Force a link delay, even when no delay would otherwise be inserted.
    $self->options()->{'forcelinkdelays'} =
	($self->virtexperiment()->forcelinkdelays() ? 1 : 0);

    # Allow override of delay capacity.
    $self->options()->{'delay_capacity'} = ($DELAYCAPACITY || 1);
    if ($self->virtexperiment()->delay_capacity()) {
	$self->options()->{'delay_capacity'} =
	    $self->virtexperiment()->delay_capacity();
	$self->options()->{'delaycap_override'} = 1;
	# Record this in the stats only when overridden.
	$self->exptstats()->{'delay_capacity'}  =
	    $self->options()->{'delay_capacity'};
    }

    # Allow override of delay osid.
    if (defined($self->virtexperiment()->delay_osname())) {
	my $osname = $self->virtexperiment()->delay_osname();
	my $osimage;

	if ($osname =~ /^(.*)\/(.*)$/) {
	    $osimage = OSImage->Lookup($osname);
	}
	else {
	    $osimage = OSImage->Lookup($pid, $osname);
	    if (!defined($osimage)) {
		$osimage = OSImage->LookupByName($osname);
	    }
	}
	if (!defined($osimage)) {
	    tberror({cause => 'user',
		     type => 'primary', severity => SEV_ERROR,
		     error => ['invalid_os', 'delay', $osname, $pid]},
		    "Invalid OS $osname in project $pid!");
	    return -1;
	}
	my $osid = $osimage->osid();
	$self->options()->{'delay_osid'} = $osid;
	# Keep a desire string we can use to make sure that the node
	# type picked for the delay node can load the right OS.
	$self->options()->{'delay_desire_type'} = '';
	$self->options()->{'delay_desire_name'} = "OS-$osid";
	$self->options()->{'delay_desire_penalty'} = '1';
	# For ptopgen.
	$self->allimages()->{$osid} = 1;
    }
    else {
	$self->options()->{'delay_desire_type'} = '';
	$self->options()->{'delay_desire_name'} = '';
	$self->options()->{'delay_desire_penalty'} = '';
    }

    # Allow override of jail osid.
    if (defined($self->virtexperiment()->jail_osname())) {
	my $osname = $self->virtexperiment()->jail_osname();
	my $osimage= OSImage->Lookup($pid, $osname);
	if (!defined($osimage)) {
	    $osimage = OSImage->LookupByName($osname);
	    if (!defined($osimage)) {
		tberror({cause => 'user',
			 type => 'primary', severity => SEV_ERROR,
			 error => ['invalid_os', 'jail', $osname, $pid]},
			"Invalid OS $osname in project $pid!");
		return -1;
	    }
	}
	$self->options()->{'jail_osid'} = $osimage->osid();
    }

    # XXX woeful NSE hack
    my $sim_osname = "FBSD-NSE";
    if (defined($sim_osname)) {
	my $osimage = OSImage->Lookup($pid, $sim_osname);
	if (!defined($osimage)) {
	    $osimage = OSImage->LookupByName($sim_osname);
	}
	if (defined($osimage)) {
	    $self->options()->{'sim_osid'} = $osimage->osid();
	}
	elsif (exists($self->options()->{'jail_osid'})) {
	    $self->options()->{'sim_osid'} = $self->options()->{'jail_osid'};
	}
    }

    # Option to fix current resources. Command line overrides experiment.
    # This option does not make sense unless updating is also on.
    if ($self->updating() && !$self->fixcurrent() &&
	$self->virtexperiment()->allowfixnode()) {
	$self->{'FLAGS'} |= $VTOP_FLAGS_FIXNODES;
    }

    #
    # If updating, load current experiment resources. We have to be
    # careful of how this is merged in with the (new) desired
    # topology. Fixnodes might also be set independently of updating.
    #
    if ($self->updating() || $self->fixcurrent()) {
	return -1
	    if ($self->LoadCurrentResources());
    }
    
    return -1
	if ($self->LoadPhysInfo() ||
	    $self->LoadVirtNodes() ||
	    $self->LoadVirtLans());
    
    return -1
	if ($self->GenVirtTypes() ||
	    $self->GenVirtNodes() ||
	    $self->GenVirtLans() ||
	    $self->GenFixNodes() ||
	    $self->PrintSummaryStats());

    # Stats for the caller.
    $self->exptstats()->{"vnodes"}    = $self->counters()->{'virtcount'};
    $self->exptstats()->{"wanodes"}   = $self->counters()->{'remotecount'};
    $self->exptstats()->{"plabnodes"} = $self->counters()->{'plabcount'};
    $self->exptstats()->{"simnodes"}  = $self->counters()->{'simcount'};

    return 0;
}

#
# getbandwidth(bw)
# Returns the lowest ok bandwidth that is greater than or equal to
# the one passed. Takes a virtual node, from which it grabs a type - only
# considers bandwidths on the node types the virtual node can be mapped to.
# Very similar to requires_delay().
#
sub getbandwidth($$$$)
{
    my ($self, $virtlanmember, $virtlan, $targetbw) = @_;
    my $best = 10000000000;

    my $virtnode  = $virtlanmember->virt_node();
    my $node_type = $virtnode->type();
    my $protocol  = protocolbasetype($virtlan->_protocol());
    my $linkbws   = $self->{'TYPELINKBW'};

    #
    # A target bandwidth of zero indicates that we want assign to choose.
    #
    return 0
	if ($targetbw == 0);
	
    foreach my $bw (keys(%{ $linkbws->{$node_type}{$protocol} })) {
	if (($bw >= $targetbw) && ($bw < $best)) {
	    $best = $bw;
	}
    }

    if (! $virtnode->_isvtyped()) {
	my $node_class = $virtnode->_typeinfo()->class();
	
	foreach my $bw (keys(%{ $linkbws->{$node_class}{$protocol} })) {
	    if (($bw >= $targetbw) && ($bw < $best)) {
		$best = $bw;
	    }
	}
    }
    return $best;

}

# requires_delay()
# Returns 1 if the given bandwidth requires that a delay node be inserted, 0
# if it can be handled by some interface in the testbed
#
# Way bogus! We have to guess if we need to insert a delay node (assign should
# really be doing this). We need a delay node if the desired bw does not
# match the native hardware link speed. Of course, we do not know what assign
# will map the node too, but we do know generally what interface speeds are
# supported on each type/class of hardware that the user might request. If
# a 50Mb link on a "pc" is requested, we know we need a delay node cause
# pcs support just 100Mb and 1000Mb links. assign might pick either one, but
# we know we need a delay node no matter what. The problem is what happens if
# the user asks for 100Mb (no delay node), but assign maps it to a 1000Mb link?
# Well, we are screwed since we needed a delay node. We are ignoring that
# problem for now since no one has access to 1gig interfaces at the moment.
# 
sub requires_delay($$$$)
{
    my ($self, $virtlanmember, $virtlan, $targetbw) = @_;

    my $virtnode  = $virtlanmember->virt_node();
    my $node_type = $virtnode->type();
    my $protocol  = protocolbasetype($virtlan->_protocol());
    my $linkbws   = $self->{'TYPELINKBW'};
    my $node_class;

    #
    # A target bandwidth of zero indicates that we want assign to choose.
    # Therefore, no delay is needed since assign picks the native bw.
    #
    goto norequire
	if ($targetbw == 0);
	
    if (!exists($linkbws->{$node_type}{$protocol})) {    
	warn("requires_delay(): $virtnode - invalid type $node_type!\n");
	goto norequire;
    }

    if (! $virtnode->_isvtyped()) {
	$node_class = $virtnode->_typeinfo()->class();
	
	if (!exists($linkbws->{$node_class}{$protocol})) {
	    warn("requires_delay(): $virtnode - invalid class $node_class!\n");
	    goto norequire;
	}
    }

    foreach my $bw (keys(%{ $linkbws->{$node_type}{$protocol} })) {
	goto norequire
	    if ($targetbw == $bw);
    }
    if (defined($node_class)) {
	foreach my $bw (keys(%{ $linkbws->{$node_class}{$protocol} })) {
	    goto norequire
		if ($targetbw == $bw);
	}
    }
    $self->printdb("requires_delay:1 $virtnode, $virtlan, $targetbw\n");
    return 1;

  norequire:
    $self->printdb("requires_delay:0 $virtnode, $virtlan, $targetbw\n");
    return 0;
}

#
# Return the (bandwidth, rbandwidth) to put into a top file for this link -
# this is _NOT_ the hard limit on bandwidth that the user asked for us to
# set up traffic shaping for.
#
sub virtlantopbw($$$) {
    my ($self, $virtlan, $member) = @_;
    my $node = $member->virt_node()->vname();

    my ($delay,$bw,$ebw,$backfill,$loss,
	$rdelay,$rbw,$rebw,$rbackfill,$rloss) = @{$member->_delayinfo()};

    # Return the estimated bw if it was given; otherwise, return the normal
    # bandwidth, 
    my ($return_bw, $return_rbw);
    
    if (defined($ebw)) {
	$return_bw = $ebw;
    }
    else {
	#
	# If this is an emulated link, or one on which we are doing end node
        # shaping we put in only the bandwidth from the virtual topology -
	# otherwise, we put in the bandwidth of the type of physical interface
	# it is likely to get mapped to.
	#
        my $shaped = $virtlan->membershaped($member);
	
	if ($virtlan->_emulated() ||
	    $self->virtlan_use_linkdelay($virtlan, $shaped)) {
	    $return_bw = $bw;
	}
	else {
	    $return_bw = $self->getbandwidth($member, $virtlan, $bw);
	}
    }

    if (defined($rebw)) {
	$return_rbw = $rebw;
    }
    else {
	#
	# If this is an emulated link, we put in only the reported
	# bandwidth - otherwise, we put in the bandwidth of the type
	# of physical interface it is likely to get mapped to
	#
        my $shaped = $virtlan->membershaped($member);

	if ($virtlan->_emulated() ||
	    $self->virtlan_use_linkdelay($virtlan, $shaped)) {
	    $return_rbw = $rbw;
	}
	else {
	    $return_rbw = $self->getbandwidth($member, $virtlan, $bw);
	}
    }
    return ($return_bw, $return_rbw);
}

#
# Determine if a given link/lan uses linkdelays
#
sub virtlan_use_linkdelay($$$) {
    my ($self, $virtlan, $shaped) = @_;

    #print Dumper($virtlan);

    #
    # Here are the conditions for using linkdelays on each link/lan
    # Note: $forcelinkdelays and $uselinkdelays are global
    #
    if ( # linkdelays can be globally forced
         $self->option('forcelinkdelays') ||
         # We use linkdelays on emulated virtlans
         $virtlan->_emulated() ||
	 # Some of the nodes are on shared pnodes.
	 $virtlan->_sharednodes() ||
         # The user requested linkdelays, and this is a virtlan that gets
         # shaped (note - in this case, non-shaped virtlans don't get
         # linkdelays)
         ($self->option('uselinkdelays') && $shaped) ||
         # The user forced linkdelays for this specific virtlan
         $virtlan->_uselinkdelay()) {
        # Yep, use linkdelays
	#$self->printdb("Using linkdelay for $virtlan\n");
        return 1;
    } else {
        # No - either won't be delayed at all, or we'll use a delay node
        return 0;
    }
}

# We do not actually store information about the protocol heirarchy in the
# database, so we use a simple conventions for now - <basetype>[-subtype]
sub protocolbasetype($) {
    if ($_[0] =~ /^([^-]+)-/) {
        return $1;
    } else {
        return $_[0];
    }
}

#############################################################################
#
# Solution. Now we get into the code to process the solution. 
#
# Stuff for the solution and interpretation.
sub solution($)           { return $_[0]->{'SOLUTION'}; }
sub solution_p2v($)       { return $_[0]->{'SOLUTION'}->{'P2V'}; }
sub solution_v2p($)	  { return $_[0]->{'SOLUTION'}->{'V2P'}; }
sub solution_v2v($)	  { return $_[0]->{'SOLUTION'}->{'V2V'}; }
sub solution_plinks($)	  { return $_[0]->{'SOLUTION'}->{'PLINKS'}; }
sub solution_virtnodes($) { return $_[0]->{'SOLUTION'}->{'VIRTNODES'}; }
sub solution_delaynodes($){ return $_[0]->{'SOLUTION'}->{'DELAYNODES'}; }
sub solution_rtabmap($)	  { return $_[0]->{'SOLUTION'}->{'RTABMAP'}; }
sub solution_vethmap($)   { return $_[0]->{'SOLUTION'}->{'VETHMAP'}; }
sub solution_vethpatch($) { return $_[0]->{'SOLUTION'}->{'VETHPATCHES'}; }
sub solution_portmap($)   { return $_[0]->{'SOLUTION'}->{'PORTMAP'}; }
sub solution_vifacemap($) { return $_[0]->{'SOLUTION'}->{'VIFACEMAP'}; }
sub solution_ifacemap($)  { return $_[0]->{'SOLUTION'}->{'IFACEMAP'}; }
sub solution_blockstores($){ return $_[0]->{'SOLUTION'}->{'BLOCKSTORES'}; }
sub solution_sanhosts($)  { return $_[0]->{'SOLUTION'}->{'SANHOSTS'}; }

sub MapResources($)
{
    my ($self) = @_;

    if ($self->genicount()) {
	my $genirspec;
	
	$self->printdb("Mapping geni resources ...\n");
	
	if (libGeni::MapResourcesNew($self->experiment(),
				  $self->user(), $self->rspec(),
				  \$genirspec, $self->verbose())) {
	    tberror("Could not map Geni resources\n");
	    return -1;
	}
	if ($self->ReadRspecSolution($genirspec) != 0) {
	    tberror("Could not parse rspec solution! $!\n");
	    return -1;
	}
	$self->{'GENIRSPEC'} = $genirspec;
    }
    return 0;
}

sub ClearSolution($)
{
    my ($self) = @_;

    # Start with a new solution vector each time.
    $self->{'SOLUTION'} = {};
    $self->{'SOLUTION'}->{'TORESERVE'}   = {};
    $self->{'SOLUTION'}->{'V2P'}         = {};
    $self->{'SOLUTION'}->{'P2V'}         = {};
    $self->{'SOLUTION'}->{'V2V'}         = {};
    $self->{'SOLUTION'}->{'PLINKS'}      = {};
    $self->{'SOLUTION'}->{'VIRTNODES'}   = {};
    $self->{'SOLUTION'}->{'DELAYNODES'}  = {};
    $self->{'SOLUTION'}->{'RTABMAP'}     = {};
    $self->{'SOLUTION'}->{'VETHMAP'}     = {};
    $self->{'SOLUTION'}->{'VETHPATCHES'} = {};
    $self->{'SOLUTION'}->{'PORTMAP'}     = {};
    $self->{'SOLUTION'}->{'VIFACEMAP'}   = {};
    $self->{'SOLUTION'}->{'IFACEMAP'}    = {};
    $self->{'SOLUTION'}->{'BLOCKSTORES'} = {};
    $self->{'SOLUTION'}->{'SANHOSTS'}    = {};

    return 0;
}

sub AddNodeToSolution($$$)
{
    my ($self, $virtual, $physical) = @_;

    #
    # We generally ignore lannodes, but lets remember the mapping.
    #
    if (exists($self->lannodes()->{$virtual})) {
	$self->lannodes()->{$virtual} = $physical;
	return 0;
    }

    #
    # XXX Must distinguish between local and ProtoGeni resources
    # until libGeni code is updated for new rspec stuff.
    #
    # This might not exist, as for internal nodes.
    my $virtnode = $self->vnodes()->{$virtual};

    if (defined($virtnode) && $virtnode->_isgeninode()) {
	#
	# We need the local node object which is essentially a
	# proxy for the real node at the remote component manager.
	#
	my $proxynode = libGeni::LookupProxyNode($physical);
	if (!defined($proxynode)) {
	    tberror("Could not find proxynode for $physical\n");
	    return -1;
	}
	$physical = $proxynode->node_id();
    }
    elsif ($PGENISUPPORT && GeniHRN::IsValid($physical)) {
	(undef,undef,$physical) = GeniHRN::Parse($physical);
    }

    #
    # Watch for blockstore nodes; the physical nodes in the
    # ptop file are fictitious. For example, dbox1:raid1 is
    # the blockstore raid1 on physical host dbox1. The virtnode
    # is then mapped to dbox1, and the blockstore is the raid1
    # entry in the physical blockstores table. 
    #
    if ($virtnode && defined($virtnode->_blockstore())) {
	my ($bphys,$bstore) = split(":", $physical);
	my $virt_bs  = $virtnode->_blockstore();
	my $bs_name  = $virt_bs->vname();

	# Record blockstore assignment for upload later.
	$self->solution_blockstores()->{$bs_name} = $bstore;

	# Actual mapping.
	$physical = $bphys;
    }

    # All we do in this stage is store the results.
    $self->solution()->{'V2P'}->{$virtual}  = $physical;
    $self->solution()->{'P2V'}->{$physical} = []
	if (!exists($self->solution()->{'P2V'}->{$physical}));

    push(@{ $self->solution()->{'P2V'}->{$physical} }, $virtual);
    $self->printdb("  $virtual $physical\n");

    return 0;
}

sub AddLinkToSolution($$$$$$$$;$)
{
    my ($self,
	$vlink, $trivial, $direct, $nodeA, $portA, $nodeB, $portB,
	$switchpath) = @_;
	
    #
    # Map the solution back to our objects and store the results.
    #
    my ($linktag) = ($vlink =~ m|^(\w+)/|);
    my $virtlan;
    my $member0;
    my $member1;
    my ($lan,$virtA,$virtB) = undef;

    if (($lan,$virtA,$virtB) =
	($vlink =~ m|^linksdelaysrc/(.+)/(.+),(.+)$|)) {
	$virtlan = $self->vlans()->{$lan};
	$member0 = $virtlan->members()->{$virtA};
	$member1 = $virtlan->members()->{$virtB};
	$member0->_pnode($nodeA);
	$member0->_pport($portA);
	$member0->_delaynode($nodeB);
	$member0->_delayport($portB);
    }
    elsif (($lan,$virtA) =
	   ($vlink =~ m|^linkdelaysrc/([^/]+)/(.+)$|)) {
	# This is the link between the original node and the delay node.
	$virtlan = $self->vlans()->{$lan};
	$member0 = $virtlan->members()->{$virtA};
	$member0->_pnode($nodeA);
	$member0->_pport($portA);
	$member0->_delaynode($nodeB);
	$member0->_delayport($portB);
    }
    elsif (($lan,$virtA,$virtB) =
	   ($vlink =~ m|^linksimple/(.+)/(.+),(.+)$|)) {
	$virtlan = $self->vlans()->{$lan};
	$member0 = $virtlan->members()->{$virtA};
	$member1 = $virtlan->members()->{$virtB};
	if (!$trivial) {
	    $member0->_pnode($nodeA);
	    $member0->_pport($portA);
	    $member1->_pnode($nodeB);
	    $member1->_pport($portB);
	}
    }
    elsif (($lan,$virtA) =
	   ($vlink =~ m|^linklan/([^/]+)/(.+)$|)) {
	$virtlan = $self->vlans()->{$lan};
	$member0 = $virtlan->members()->{$virtA};
	if (!$trivial) {
	    $member0->_pnode($nodeA);
	    $member0->_pport($portA);
	    # For a special case, see below.
	    if (defined($nodeB)) {
		$member0->_lannode($nodeB);
		$member0->_lanport($portB);
	    }
	    else {
		$member0->_lannode("null");
		$member0->_lanport("null");
	    }
	}
    }
    elsif (($lan,$virtA) =
	   ($vlink =~ /^(?:fakelan|portlan)\/([^\/]+)\/(.+)$/)) {
	$virtlan = $self->vlans()->{$lan};
	$member0 = $virtlan->members()->{$virtA};
	$member0->_pnode($nodeA);
	$member0->_pport($portA);
    }
    elsif (($lan,$virtA) =
	   ($vlink =~ m|^linkdelaydst/([^/]+)/(.+)$|)) {
	# This is the link between the delay node and lannode.
	$virtlan = $self->vlans()->{$lan};
	# Special case since the other side is a lannode.
	$member0 = $virtlan->members()->{$virtA};
	$member0->_delayportB($portB);
	# Stash the path here. Silly, but its easier.
	$member0->_delaypath($switchpath);
    }
    elsif (($lan,$virtA,$virtB) =
	   ($vlink =~ m|^linksdelaydst/(.+)/(.+),(.+)$|)) {
	$virtlan = $self->vlans()->{$lan};
	$member0 = $virtlan->members()->{$virtA};
	$member1 = $virtlan->members()->{$virtB};
	$member0->_pnode($nodeA);
	$member0->_pport($portA);
	$member0->_delaynode($nodeB);
	$member0->_delayport($portB);
	# Stash the path here. Silly, but its easier.
	$member0->_delaypath($switchpath);
    }
    else {
	tberror("Bad vlink in solution: $vlink\n");
	return -1;
    }

    $self->solution_plinks()->{$vlink} =
	[$linktag,$virtlan,$trivial,$direct,$member0,$member1,$switchpath];
    if (!$trivial) {
	$self->printdb("  $vlink ".
		       (defined($nodeA) ? "A:$nodeA:$portA " : "") .
		       (defined($nodeB) ? "B:$nodeB:$portB " : "") .
		       ($direct ? " (direct)" : "") .
		       (defined($switchpath) ? " $switchpath" : "") .
		       "\n");
    }
    else {
	$self->printdb("  $vlink trivial\n");
    }
    return 0;
}

sub ReadTextSolution($$)
{
    my ($self, $input) = @_;

    $self->ClearSolution();

    #
    # Still using the old assign format.
    #
    my $found_nodes_section = 0;
    
    while (<$input>) {
	# find the 'BEST SCORE' line and print that out for informational
	# purposes
	if (/BEST SCORE/) {
	    chomp($_);
	    $self->solution()->{"BEST SCORE"} = $_;
	}
        if (/^Nodes:/) {
            $found_nodes_section = 1;
            last;
        }
    }
    if (!$found_nodes_section) {
        tbwarn("Unable to find Nodes section in assign output");
        return -1;
    }
    $self->printdb("Nodes:\n");
    while (<$input>) {
	chomp;
	/^End Nodes$/ && last;
	my @info = split;
	my ($virtual,$physical) = @info[0,1];

	$self->AddNodeToSolution($virtual, $physical);
    }

    # read Edges
    # By convention, in plinks, the delay node is always the second
    # entry.
    my $found_edges_section = 0;
    while (<$input>) {
        if (/^Edges:/) {
            $found_edges_section = 1;
            last;
        }
    }
    if (!$found_edges_section) {
        tbwarn("Unable to find Edges section in assign output");
        return -1;
    }

    $self->printdb("Edges:\n");
    EDGEWHILE: while (<$input>) {
	my ($vlink,$rawA,$rawB) = undef;
	my $trivial = 0;
	my $direct  = 0;
	my $swpath  = undef;

	/^End Edges$/ && last EDGEWHILE;
        my @info = split;
	my $line = $_;
	my $type = $info[1];
        SWITCH1: for ($type) {
	    /^intraswitch$/ && do {
		($vlink,$rawA,$rawB) = @info[0,3,5];
		last SWITCH1;
	    };
	    /^interswitch$/ && do {
		($vlink,$rawA,$rawB) = @info[0,3,$#info];
		#
		# We need to save the path through the switches for later.
		#	
		$swpath = getportlist(@info);
		last SWITCH1;
	    };
	    /^direct$/ && do {
		($vlink,$rawA,$rawB) = @info[0,3,5];
		$direct = 1;
		last SWITCH1;
	    };
	    /^trivial$/ && do {
		# we don't have plinks for trivial links
		$vlink   = $info[0];
		$trivial = 1;
		last SWITCH1;
	    };
	    tberror("Found garbage: $line\n");
	    return -1;
	}

	my ($nodeportA,$nodeportB) = undef;
	my ($switchportA,$switchportB) = undef;
	my ($nodeA,$portA,$nodeB,$portB) = undef;

	if (!$trivial) {
	    ($nodeportA,$switchportA) = getnodeport($rawA);

	    # TODO: Add this error checking code in once ptopgen_new
	    # becomes standard
#	    if (! defined($nodeportA) || ! defined($switchportA)) {
#		tberror("Malformed interface pair A: $rawA\n");
#		return -1;
#	    }

	    # Convert back to node:iface format.
	    if (defined($nodeportA)) {
		$nodeportA =~ s/\//:/;
		($nodeA,$portA) = split(":", $nodeportA);
	    }

	    my $isswitch = 1;
	    if (defined($switchportA)) {
		$switchportA =~ s/\//:/;
		my ($switchA, $swportA) = split(":", $switchportA);
		my $noderef = Node->Lookup($switchA);
		$isswitch = $noderef->isswitch();
	    }

	    #
	    # If the link is direct and switchA is not a switch, this is
	    # a link directly between two nodes:
	    #
	    # $rawA hold both sides of the link (switchportA is really
	    # $nodeportB).
	    if ($direct && ! $isswitch) {
		$nodeportB   = $switchportA;
		$switchportB = undef;
	    }
	    else {
		($nodeportB,$switchportB) = getnodeport($rawB);
	    }

	    # TODO: Add this error checking code in once ptopgen_new
	    # become standard
#	    if (! defined($nodeportA)) {
#		tberror("Malformed interface pair B: $rawB\n");
#		return -1;
#	    }

	    if (defined($nodeportB)) {
		# Convert back to node:iface format.
		$nodeportB =~ s/\//:/;
		($nodeB,$portB) = split(":", $nodeportB);
	    }
	    
	    if( $direct ) {
		# Ensure the mapping of direct links is in the same order
		# as the virt members...
		my ($vlinktype, $vlinkname, $vlinkmembers) = split( "/", $vlink );
		my ($vmem0, $vmem1) = split( ",", $vlinkmembers );
		my ($vmem0node, $vmem0port) = split( ":", $vmem0 );

		my $mapped0 = $self->solution_v2p()->{ $vmem0node };
		
		if( defined($mapped0) && $mapped0 eq $nodeB ) {
		    # It isn't.  Flip the order of the nodes to avoid
		    # horrible confusion later.
		    my ($nodeT, $portT);

		    $nodeT = $nodeB;
		    $portT = $portB;
		    $nodeB = $nodeA;
		    $portB = $portA;
		    $nodeA = $nodeT;
		    $portA = $portT;
		}
	    }
	    
	}
	$self->AddLinkToSolution($vlink, $trivial, $direct,
				 $nodeA, $portA, $nodeB, $portB, $swpath);
    }
    return 0;
}

sub ReadRspecSolution($$)
{
    my ($self, $rspec) = @_;
    my %ifacemap = ();
	
    $self->printdb("Processing rspec\n");
    $self->printdb("Nodes:\n");

    foreach my $ref (GeniXML::FindNodes("n:node", $rspec)->get_nodelist()) {
	my $node_urn  = GeniXML::GetNodeId($ref);
	my $virtual   = GeniXML::GetVirtualId($ref);

	#
	# We generally ignore lannodes, but lets remember the mapping.
	#
	if (exists($self->lannodes()->{$virtual})) {
	    $self->lannodes()->{$virtual} = $node_urn;
	    return 0;
	}
	$self->AddNodeToSolution($virtual, $node_urn);
	    
	$ifacemap{$virtual} = {};
	foreach my $linkref (GeniXML::FindNodes("n:interface",
						$ref)->get_nodelist()) {
	

	    my $component_id  = GeniXML::GetNodeId($linkref);
	    my $virtual_id    = GeniXML::GetVirtualId($linkref);
	    my $virtlan       = $self->memberof()->{$virtual_id};

	    # Skip tunnels until assign can handle multiple rspecs
	    next
		if ($virtlan->_tunnel());

	    if (GeniHRN::IsValid($component_id)) {
		my ($urn_authority,$urn_node,$urn_iface) =
		    GeniHRN::ParseInterface($component_id);
		$component_id = $urn_iface;
	    }
	    $ifacemap{$virtual}->{$virtual_id} = $component_id;
	}
    }
    
    $self->printdb("Links:\n");
    foreach my $ref (GeniXML::FindNodes("n:link",
					    $rspec)->get_nodelist()) {
	my $virtual_id = GeniXML::GetVirtualId($ref);
	my $virtlan    = $self->vlans()->{$virtual_id};
	
	if (!defined($virtlan)) {
	    tberror("Could not find lan $virtual_id\n");
	    return -1;
	}
	# Skip tunnels until assign can handle multiple rspecs
	next
	    if ($virtlan->_tunnel());
	
	my @ifacerefs = GeniXML::FindNodes("n:interface_ref",
					   $ref)->get_nodelist();

	if (scalar(@ifacerefs) == 2) {
	    my ($ifaceA,$ifaceB) = @ifacerefs;
	    my $trivial = 0;

	    my $virtA  = GeniXML::GetText("virtual_interface_id", $ifaceA);
	    my $virtB  = GeniXML::GetText("virtual_interface_id", $ifaceB);
	    my $vnodeA = GeniXML::GetText("virtual_node_id", $ifaceA);
	    my $vnodeB = GeniXML::GetText("virtual_node_id", $ifaceB);
	    my $nodeA  = $self->solution()->{'V2P'}->{$vnodeA};
	    my $nodeB  = $self->solution()->{'V2P'}->{$vnodeB};
	    my $portA  = $ifacemap{$vnodeA}->{$virtA};
	    my $portB  = $ifacemap{$vnodeB}->{$virtB};
	    my $vlink  = "linksimple/$virtual_id/$virtA,$virtB";

	    if ($portA eq "loopback" || $portB eq "loopback") {
		$nodeA = $nodeB = $portA = $portB = undef;
		$trivial = 1;
		$virtlan->_trivial_ok(1);
	    }
	    
	    $self->AddLinkToSolution($vlink, $trivial, 0,
				     $nodeA, $portA, $nodeB, $portB);
	}
	else {
	    foreach my $iref (@ifacerefs) {
		my $virtA  = GeniXML::GetText("virtual_interface_id", $iref);
		my $vnodeA = GeniXML::GetText("virtual_node_id", $iref);
		my $nodeA  = $self->solution()->{'V2P'}->{$vnodeA};
		my $portA  = $ifacemap{$vnodeA}->{$virtA};
	    
		my $vlink = "linklan/$virtual_id/$virtA";
	    
		$self->AddLinkToSolution($vlink, 0, 0, $nodeA, $portA);
	    }
	}
    }
    return 0;
}

#
# Interpret the results. This is really just the first stage.
#
sub InterpNodes($)
{
    my ($self) = @_;

    #
    # Pre pass; if the user fixed VMs to specific nodes, then have to
    # augment the solution.
    #
    foreach my $vname (sort(keys(%{ $self->fixednodes() }))) {
	my $vnode = $self->vnodes()->{$vname};
	my $fixed = $self->fixednodes()->{$vname};

	# Delay and internal nodes do not have an entry in vnodes().
	next
	    if (! (defined($vnode) &&
		   $vnode->_isvirtnode() && $vnode->_fixedvm()));

	$self->AddNodeToSolution($vname, $self->solution()->{'V2P'}->{$fixed})
	    if (!exists($self->solution()->{'V2P'}->{$vname}));
    }

    foreach my $virtual (keys(%{ $self->solution()->{'V2P'} })) {
	my $physical = $self->solution()->{'V2P'}->{$virtual};
	my $pnode    = $self->pnodes()->{$physical};

	# This might not exist, as for internal nodes.
	my $virtnode = $self->vnodes()->{$virtual};

	$self->printdb("$physical, $virtual" .
		       (defined($pnode) ? ", $pnode" : "") .
		       (defined($virtnode) ? ", $virtnode" : "") . "\n");

	#
	# Skip sanhosts; only there cause of the subnode relationship.
	#
	next
	    if (!defined($virtnode) && exists($self->sanhosts()->{$virtual}));

	#
	# A node already allocated to this experiment, and still wanted.
	# We also have to watch for shared nodes; we will not have the
	# pnode loaded cause it is not actually ours. Instead, have to
	# look in the current_p2v table to see if we are using it. 
	#
	if (defined($pnode) ||
	    exists($self->current_p2v()->{$physical})) {
	    #
	    # Mark pnode as being reused.
	    #
	    # Look at node being mapped to the pnode;
	    # if it not in the previous map, mark node for reboot.
	    #
	    if (defined($pnode) && $pnode->_reuse() eq "reboot") {
		# No changes once it goes into reboot.
		;
	    }
	    elsif (defined($virtnode) && $virtnode->_isvirtnode()) {
		#
		# A new virtual node on an existing physical node
		# does not force the physnode to be rebooted; we can
		# set up a new virtnode on it without a reboot. If its
		# an existing virtual on the same physnode, then mark
		# both as reused; no need to reboot either. If the 
		# virtnode has moved here from someplace else, no
		# reboot of the physnode either, but obviously the
		# vnode will be released and a new one allocated.  What
		# we cannot determine is if its just a renamed node
		# (which would require a reboot of the the virtual
		# node). 
		#
		$pnode->_reuse("reused")
		    if (defined($pnode));

		if (exists($self->current_v2p()->{$virtual}) &&
		    $self->current_v2p()->{$virtual} eq $physical) {
		    # This is the virtual pnode allocated on the real pnode.
		    my $virtpname = $self->current_v2v()->{$virtual};
		    my $virtpnode = $self->pnodes()->{$virtpname};

		    $virtpnode->_reuse("reused");
		}
	    }
	    else {
		#
		# If a new node mapped to this physnode (maybe
		# even the luser changed the name of the node), or if an
		# existing virtual node moved to this physnode, must
		# reboot the physnode. Else, the physnode is being
		# reused as is, and no need to mess with it. If the
		# user requested reboot, that will be handled outside
		# of this script.
		#
		if (!exists($self->current_v2p()->{$virtual}) ||
		    $self->current_v2p()->{$virtual} ne $physical) {
		    $pnode->_reuse("reboot");
		}
		else {
		    $pnode->_reuse("reused");
		}
	    }
	}
	else {
	    my $pnodeobj = Node->Lookup($physical);

	    #
	    # This is a new node; we have to reserve it. Note that
	    # we do not reserve a widearea physnode when a virtual node
	    # is mapped to it; they are special.
	    #
	    # If there is no virtnode, then its an internal node, like
	    # a delay.
	    #
	    $self->solution()->{'TORESERVE'}->{$physical} = 1
		if ((!defined($virtnode) ||
		     !$virtnode->_isvirtnode() ||
		     !($virtnode->_isremotenode() &&
		       !$virtnode->_isdedremote())) &&
		    # Avoid allocating local shared physical node.
		    !(defined($virtnode) && $virtnode->_isvirtnode() &&
		      defined($pnodeobj->sharing_mode())));
	}

	if (!defined($virtnode)) {
	    #
	    # Internally created node.
	    #
	    if (! ($self->isadelaynode($virtual) ||
		   $self->isasanhost($virtual))) {
		tbwarn("Unknown node $virtual on $physical\n");
		return -1;
	    }
	    if ($self->isadelaynode($virtual)) {
		if (!exists($self->solution_delaynodes()->{$physical})) {
		    $self->solution_delaynodes()->{$physical} = [];
		}
		push(@{$self->solution_delaynodes()->{$physical}}, $virtual);
	    }
	    elsif ($self->isasanhost($virtual)) {
		if (!exists($self->solution_sanhosts()->{$physical})) {
		    $self->solution_sanhosts()->{$physical} = [];
		}
		push(@{$self->solution_sanhosts()->{$physical}}, $virtual);
	    }
	}
	elsif ($virtnode->_isvirtnode()) {
	    #
	    # If mapping a virtual node, then record that, since we need
	    # to allocate the virtnodes on that physnode, later.
	    #
	    if (!exists($self->solution_virtnodes()->{$physical})) {
		$self->solution_virtnodes()->{$physical} = [];
	    }
	    push(@{$self->solution_virtnodes()->{$physical}}, $virtual);
	}
	elsif ($virtnode->_issubnode()) {
	    #
	    # Subnodes are currently not dynamically created, and there
	    # is only one subnode per physical host. That physical host
	    # needs to be allocated, if we do not already have it.
	    #
	    my $subnode_pnode = Node->Lookup($physical);
	    if (!defined($subnode_pnode)) {
		tbwarn("Could not lookup subnode host $physical\n");
		return -1;
	    }
	    my $parentname = $subnode_pnode->phys_nodeid();
	    
	    if (! exists($self->solution()->{'P2V'}->{$parentname})) {
		# Make up a name and add to the reserve list.
		my $newvname = $self->newvname($parentname, "phost");

		$self->solution()->{'TORESERVE'}->{$parentname} = 1;
		$self->solution()->{'V2P'}->{$newvname}   = $parentname;
		$self->solution()->{'P2V'}->{$parentname} = [ $newvname ];

		$self->printdb("  Adding subnode: $newvname $parentname\n");
	    }
	}
    }

    # Check nodes for shared members that require special address
    # treatment.  Perform address substitution and reservation
    # on attached lans / lan members.  Have to do this before InterpLinks
    # because node allocation results in the creation of 'vinterfaces'
    # entries prior to InterpLinks.
    $self->CheckIPAddressReservations() == 0
	or return -1;

    return 0;
}

#
# Allocate nodes.
#
sub AllocNodes($)
{
    my ($self) = @_;
    my $experiment = $self->experiment();
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();
    my $idx = $experiment->idx();
	
    if ($self->impotent()) {
	my @nodeids = keys(%{ $self->solution()->{'TORESERVE'} });

	tbinfo("Pretending to allocate @nodeids\n")
	    if (@nodeids);
	goto skip;
    }

    #
    # Move existing nodes into a holding experiment and then back.
    #
    # Why? We will avoid any UNIQUE key issues when a virt_node in the
    # topology moves from one pnode to another, or from previous to new
    # mapping.
    #
    # Another reason to do this just before nalloc of a new toreserve
    # nodes is that, we can get into name clashes. For example, lets
    # say the user called his node pc2 and it was actually mapped to
    # pc99 in the initial swapin. If this was a swapmod where the user
    # asked for another node node0 which got mapped to pc2. nalloc of
    # pc2 will result in UNIQUE key problems since there exists a
    # reserved vname pc2 (virtual name). By having this operation of
    # moving the nodes into a holding experiment and back before a new
    # nalloc, we avoid this UNIQUE key problem. Also note that simply
    # updating the vname to be the same as the node_id field also does
    # not work all the time i.e. in the example discussed above.
    #
    #
    # We need to only once during a mapping.  If it gets repeatedly
    # called coz only some pnode resources got nalloced, we do not
    # have to do the above again.
    #
    # XXX Is there a race with the shared pool deamon; the shared node
    # could get deallocated.
    # 
    my @nodeids = keys(%{ $self->oldreservednodes() });
    if (@nodeids && !$self->{'OLDRSRVCLEAN_FLAG'}) {
	system("$NFREE -o $pid $eid @nodeids");
	if ($?) {
	    tberror("Could not move nodes to old reserved holding\n");
	    return -1;
	}
	system("$NALLOC -f $pid $eid @nodeids");
	if ($?) {
	    tberror("Could not move nodes back from old reserved holding\n");
	    return -1;
	}
	$self->{'OLDRSRVCLEAN_FLAG'} = 1;
    }

    #
    # Now alloc new nodes. This might include nodes already allocated
    # in a previous iteration. That is okay; nalloc will ignore them.
    #
    @nodeids = keys(%{ $self->solution()->{'TORESERVE'} });
    $self->printdb("Trying to allocate @nodeids\n");
    system("$NALLOC -p $pid $eid @nodeids");
    my $exitval  = $? >> 8;

    #
    # If nalloc failed with a fatal error, lets give it up. No retry.
    # 
    if ($exitval < 0 || $exitval == 255) {
	tberror("Failed to reserve any nodes.\n");
	return -1; 
    }

    #
    # Okay, if nalloc got anything, we have to set the norecover bit,
    # since tbswap operates on the principle that once new nodes are
    # reserved, recovery is no longer possible. However, if we exit
    # cleanly enough that we can deallocate the new nodes, recovery
    # is still possible. In the old assign_wrapper that was handled
    # in the Fatal(). In the new version ... 
    #
    $self->{'NORECOVER'} = 1;

    #
    # Got some, perhaps not all nodes.
    #
    my @reserved  = $experiment->NodeList(0, 1);	# objects, virtual.

    #
    # All newly allocated nodes MUST go to the INIT_DIRTY allocstate
    # since the user now has control of them. If we eventually fail,
    # nodes not in RES_READY are deallocated (retry/modify).
    #
    foreach my $pnode (@reserved) {
	my $nodeid = $pnode->node_id();
	    
	if (exists($self->solution()->{'TORESERVE'}->{$nodeid})) {
	    $self->newreserved()->{$nodeid} = $nodeid;
	    $pnode->SetAllocState(TBDB_ALLOCSTATE_RES_INIT_DIRTY())
		if (!$self->impotent());

	    #
	    # Fix all of the nodes assigned to the pnode.
	    #
	    foreach my $vname (@{ $self->solution_p2v()->{$nodeid} }) {
		$self->fixednodes()->{$vname} = $nodeid;

		# And add to the results for the next vtop print.
		$self->createFixedNode($vname, $nodeid)
		    if (!$pnode->isfednode());
	    }
	}
    }
    
    if ($exitval > 0) {
	#
	# We got some but not all the nodes.
	#
	my $rcount    = scalar(@reserved);
	my $tcount    = scalar(@nodeids);
	my @justnames = map { $_->node_id() } @reserved;


	# We got only some. Need to figure out which.
	tbinfo("Reserved some nodes ($rcount) we needed, ".
	       "but not all ($exitval).\n");
	
	#
	# We check to see if we were able to reserve all the fixed
	# nodes we needed. If we could not get the fixed list, then
	# this experiment is unlikely to map in the "near" future, so
	# give up now (no retry).
	#
	my @fixed = values(%{ $self->fixednodes() });
	foreach my $fixname (@fixed) {
	    if (! grep {$_ eq $fixname} @justnames) {
		tbwarn("  Could not allocate fixed node $fixname!\n");
		return -1;
	    }
	}
	
	#
	# Must extend the fixed list with newly allocated nodes so
	# that we can recreate the top file, and try again with a new
	# set.
	#
	foreach my $pnode (@reserved) {
	    my $nodeid = $pnode->node_id();
	    
	    if (exists($self->solution()->{'TORESERVE'}->{$nodeid})) {
		#
		# Fix all of the nodes assigned to the pnode.
		#
		foreach my $vname (@{ $self->solution_p2v()->{$nodeid} }) {
		    $self->fixednodes()->{$vname} = $nodeid;

		    # And add to the results for the next vtop print.
		    $self->createFixedNode($vname, $nodeid)
			if (!$pnode->isfednode());
		}
	    }
	}

	#
	# Return indicator that we made forward progress (got some nodes).
	# Caller will decide if appropriate to keep trying. We made progress
	# if the return value of nalloc (number of nodes not allocated) does
	# not equal the number of nodes we tried to allocate.
	#
	return (($tcount == $exitval) ? 10 : 11);
    }

    #
    # Lets do a check to see if the shared nodes are still shared. This
    # check is advisory; we will not really know until CreateVnodes()
    # locks the tables, but if the node is not shared now cause the pool
    # daemon released it, we can still recover with another run. 
    #
    my $rerun = 0;
    
    foreach my $physical (sort(keys(%{ $self->solution_virtnodes() }))) {
	my $pnode = Node->Lookup($physical);
	if (!defined($pnode)) {
	    tberror("Could not get object for $physical\n");
	    return -1;
	}
	# Remote node. Not our problem.
	next
	    if ($pnode->isfednode());
	
	$pnode->FlushReserved();
	my $reservation = $pnode->Reservation();

	# We got the node we wanted. 
	next
	    if (defined($reservation) &&
		$reservation->SameExperiment($self->experiment()));
	
	if (! ($pnode->erole() eq "sharedhost" ||
	       $pnode->erole() eq "storagehost")) {
	    tbinfo("$pnode is not in shared mode.\n");
	    $rerun++;
	}
    }
    return 1
	if ($rerun);

    #
    # Set the node allocstate for unused/dirty nodes.
    #
    foreach my $pnode (values(%{ $self->oldreservednodes() })) {
	if ($pnode->_reuse() eq "unused") {
	    #
	    # Node was used in previous incarnation, but not any more.
	    # Mark it for teardown by the caller (tbswap currently).
	    #
	    $pnode->SetAllocState(TBDB_ALLOCSTATE_RES_TEARDOWN())
		if (! $self->impotent());
	}
	elsif ($pnode->_reuse() eq "reboot") {
	    #
	    # Node is being reused, but for a different purpose, so
	    # it should be rebooted.
	    #
	    # XXX Note that when we use alloconly mode, and then we
	    # "commit" the allocations, we do not want to change the
	    # allocstate cause that messes up os_setup later. This is
	    # relevant to the Geni path only.
	    #
	    $pnode->SetAllocState(TBDB_ALLOCSTATE_RES_REBOOT())
		if (! ($self->impotent() ||
		       ($self->commitmode() &&
			$pnode->allocstate() eq
			TBDB_ALLOCSTATE_RES_INIT_DIRTY())));
	}
    }
  skip:
    if ($self->AllocVirtNodes() != 0) {
	tberror("Could not allocate virtual nodes\n");
	return -1;
    }

    #
    # Allocate Geni nodes (get tickets). Eventually we want to retry
    # the assignment and replace tickets that we could not get. 
    #
    if (defined($self->genirspec()) &&
	!($self->impotent() || $self->alloconly())) {
	$self->printdb("Requesting geni tickets ...\n");

	my $progress = libGeni::GetTickets($self);
	if ($progress) {
	    tberror("Error allocating (some) Geni Tickets\n");
	    #
	    # Need to find out what geni nodes we could not get tickets for.
	    # The local proxy nodes for them need to be released, and if we
	    # made forward progress, we try again in another loop through.
	    # The rest of the solution state will get cleared before
	    # the next loop, but calling nfree is easiest here. 
	    #
	    my @tofree = ();
	    
	    foreach my $pnode (@reserved) {
		my $nodeid = $pnode->node_id();

		#
		# XXX See libGeni; it sets external_resource_index if the
		# if we get a ticket. Need a state variable instead. 
		#
		if (exists($self->solution()->{'TORESERVE'}->{$nodeid}) &&
		    !defined($pnode->external_resource_index())) {
		    push(@tofree, $nodeid);
		}
	    }
	    if (@tofree) {
		tbinfo("Releasing unticketed nodes: @tofree\n");
		system("$NFREE $pid $eid @tofree");
		if ($?) {
		    tberror("Could not free unticketed nodes\n");
		    return -1;
		}
		foreach my $nodeid (@tofree) {
		    delete($self->newreserved()->{$nodeid});
		}
	    }
	    return $progress;
	}
	tbinfo("Successfully got all geni tickets we needed.\n");
	
	#
	# Redeem the tickets.
	#
	$self->printdb("Redeeming geni tickets ...\n");
	    
	if (libGeni::RedeemTickets($self->experiment(), $self->user())) {
	    tberror("Could not redeem Geni Tickets\n");
	    #
	    # Release outstanding tickets now since we are hosed. 
	    #
	    if (libGeni::ReleaseTickets($self->experiment(), $self->user())) {
		tberror("Could not release Geni Tickets\n");
	    }
	    return -1;
	}
	tbinfo("Successfully redeemed all geni tickets.\n");
    }

    #
    # Update the pnodes() array with the newly allocated nodes.
    #
    foreach my $physical (keys(%{ $self->solution_p2v() })) {
	my @vlist = @{ $self->solution_p2v()->{$physical} };

	my $pnode = Node->Lookup($physical);
	if (!defined($pnode)) {
	    tberror("Could not get object for $physical\n");
	    return -1;
	}
	$self->pnodes()->{$physical} = $pnode;

	# Node might need the link delay kernel.
	$pnode->_needslinkdelay(0);
	# ipfw pipe numbers.
	$pnode->_pipenumber(110);
	# Routing table id for each vnode on a pnode. Do not use 0.
	$pnode->_rtabid(1);
	# For assigning dynamic ports.
	$pnode->_portarray(undef);
	$pnode->_portlow(TBDB_LOWVPORT);
	$pnode->_portnext(TBDB_LOWVPORT);
	$pnode->_porthigh(TBDB_MAXVPORT);
	# To avoid unitialized access.
	$pnode->_reuse("used");
	
	#
	# The node might not have a reservation entry if in
	# impotent mode. But if the node is shared, it *will*
	# so if there is no erole, we know the node is not shared.
	#
	$pnode->_sharedhost((defined($pnode->erole()) &&
			     $pnode->erole() eq "sharedhost") ? 1 : 0);
	
	#
	# Typically, its one-to-one, unless its a physnode hosting
	# virtnodes, in which case the mapping is one-to-many.
	#
	foreach my $virtual (@vlist) {
	    #
	    # Nodes that we create in assign_wrapper, like delays
	    # nodes (tbdelayXX) and jail hosts (vhost-XX) do not have
	    # entries in the virt_nodes table. Should we form one, so
	    # that we can refer to all nodes consistently?
	    #
	    next
		if (!exists($self->vnodes()->{$virtual}));

	    my $virtnode = $self->vnodes()->{$virtual};
	    
	    if ($virtnode->_isvirtnode()) {
		#
		# The physical node is the virtual node on the physical.
		#
		my $vpnode = Node->Lookup($self->solution_v2v()->{$virtual});
		if (!defined($vpnode)) {
		    tberror("Could not get object for $physical\n");
		    return -1;
		}
		$self->pnodes()->{$vpnode->node_id()} = $vpnode;
		$virtnode->_onsharednode($pnode->_sharedhost());
		$virtnode->_pnode($vpnode);

		#
		# Minor post processing; Whenever a shared node is
		# selected by assign, must reset the encap style of
		# the lans it is a memberof, to vlan encap.
		#
		if ($virtnode->_onsharednode()) {
		    foreach my $virtlan ($virtnode->memberlist()) {
			$virtlan->_encapstyle("vlan")
			    if (!$virtlan->_tunnel());
		    }
		}
	    }
	    else {
		# Default this for physnodes.
		$virtnode->_onsharednode(0);
		$virtnode->_pnode($pnode);
	    }
	}
    }
    $self->SetPortRange() == 0
	or return -1;
    
    #
    # Set the sshd ports. Its complicated by the fact that a single
    # experiment could have multiple jailed nodes on the same physical
    # node, and so a per-experiment wide sshd port is not going to
    # work unless there happens to be just one jail per node, but
    # thats not likely in the local area case.
    #
    foreach my $vnodename (sort(keys(%{ $self->solution_v2v() }))) {
	my $vpnodename = $self->solution_v2v()->{$vnodename};
	my $vpnode     = $self->pnodes()->{$vpnodename};
	my $virtnode   = $self->vnodes()->{$vnodename};
	
	if ($vpnode->isjailed() ||
	    $vpnode->isremotenode() || $virtnode->_onsharednode()) {
	    my $pnodename = $self->solution_v2p()->{$vnodename};
	    my $pnode     = $self->pnodes()->{$pnodename};
	    my $sshdport;

	    #
	    # XXX What an absurd DB default for this! Should be null.
	    #
	    if (exists($self->current_v2v()->{$vnodename}) &&
		$vpnode->sshdport() != 11000) {
		
		$sshdport = $vpnode->sshdport();
		$self->printdb("sshdport: Reusing $sshdport on $vpnode\n");
	    }
	    else {
		$sshdport = nextipportnum($pnode);
		return -1
		    if ($sshdport < 0);

		$self->printdb("sshdport: Using $sshdport on $vpnode\n");
	    }

	    DBQueryWarn("update nodes set sshdport=$sshdport ".
			"where node_id='$vpnodename'")
		or return -1 if (! ($self->impotent() || $self->alloconly()));
	}
    }

    #
    # Must post pass the trafgens list to make sure no ip port collisions.
    #
    foreach my $virt_trafgen ($self->virt_trafgens()->Rows()) {
	my $vnodename = $virt_trafgen->vnode();
	my $pnodename = $self->solution_v2p()->{$vnodename};
	my $pnode     = $self->pnodes()->{$pnodename};
	my $ipport    = nextipportnum($pnode);

	my $trafname         = $virt_trafgen->vname();
	my $target_vnodename = $virt_trafgen->target_vnode();
	my $target_trafname  = $virt_trafgen->target_vname();

	$self->printdb("Setting $virt_trafgen port to $ipport\n");

	if (! ($self->impotent() || $self->alloconly())) {
	    DBQueryWarn("update virt_trafgens set port=$ipport ".
			"where exptidx='$idx' and ".
			"      vnode='$vnodename' and vname='$trafname'")
		or return -1;
	
	    DBQueryWarn("update virt_trafgens set target_port=$ipport ".
			"where exptidx='$idx' and ".
			"      vnode='$target_vnodename' and ".
			"      vname='$target_trafname'")
		or return -1;
	}
    }

    #
    # Upload the v2pmap table. 
    #
    foreach my $vnodename (keys(%{ $self->solution_v2p() })) {
	#
	# If a virtual node, the pnode is the virtual node, not the
	# underlying physical node.
	#
	my $pnodename = (exists($self->solution_v2v()->{$vnodename}) ?
			 $self->solution_v2v()->{$vnodename} :
			 $self->solution_v2p()->{$vnodename});

	$self->printdb("v2pmap: $vnodename $pnodename\n");

	DBQueryWarn("insert into v2pmap set ".
		    "  pid='$pid', eid='$eid', exptidx='$idx', ".
		    "  vname='$vnodename', node_id='$pnodename'")
	    or return -1 if (!($self->impotent() || $self->alloconly()));
    }
    foreach my $vnodename (keys(%{ $self->lannodes() })) {
	my $pnodename = $self->lannodes()->{$vnodename};

	$self->printdb("v2pmap (lannode): $vnodename $pnodename\n");

	DBQueryWarn("insert into v2pmap set ".
		    "  pid='$pid', eid='$eid', exptidx='$idx', ".
		    "  vname='$vnodename', node_id='$pnodename'")
	    or return -1 if (!($self->impotent() || $self->alloconly()));
    }
    return 0;
}

# Allocate virtnodes. This is a little hokey in that the virtnodes
# just need to be allocated from the pool that is on the real node. We
# know they are free, but we should go through nalloc anyway. If
# anything fails, no point in retry.
#
sub AllocVirtNodes($)
{
    my ($self) = @_;
    my $experiment = $self->experiment();
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();

    foreach my $physical (sort(keys(%{ $self->solution_virtnodes() }))) {
	my @vlist = sort(@{ $self->solution_virtnodes()->{$physical} });
	my $numvs = @vlist;
	my @plist = ();
	my @oplist = ();
	my @ovlist = ();
	my @delvlist = ();

	$self->printdb("On pnode $physical: vnodes @vlist\n");

	#
	# If updating, need to watch for nodes that are already reserved.
	# We save that info in oplist/ovlist, and build a new vlist for
	# avail, of just the nodes we need in this run. 
	#
	if ($self->updating()) {
	    my @oldvlist = ();
	    if (exists($self->current_p2v()->{$physical})) {
		@oldvlist = @{ $self->current_p2v()->{$physical} };
	    } 
	    $self->printdb("On pnode $physical: oldvlist: @oldvlist\n");

	    # newvlist = elements in vlist but not in oldvlist
	    #            i.e. newly mapped to this pnode
	    my @newvlist = array_diff( \@vlist, \@oldvlist );
	    $self->printdb("On pnode $physical: newvlist: @newvlist\n");

	    # curvlist = elements in both vlist and oldvlist
	    #            i.e. vnodes mapped the same way from previous
	    #            to current
	    # This is the same as @vlist intersection @oldvlist
	    # since the lists have no duplicates
	    my @curvlist = array_diff( \@vlist, \@newvlist );
	    $self->printdb("On pnode $physical: curvlist: @curvlist\n");

	    foreach my $virtual (@curvlist) {
		if (exists($self->current_v2v()->{$virtual}) ) {
		    push(@oplist, $self->current_v2v()->{$virtual});
		    push(@ovlist, $virtual);
		}
	    }

	    # delvlist = elements in oldvlist not in vlist
	    #            i.e. vnodes that moved to another pnode or
	    #            went away
	    @delvlist = array_diff( \@oldvlist, \@vlist );
	    $self->printdb("On pnode $physical: delvlist: @delvlist\n");

	    while (scalar(@newvlist) && scalar(@delvlist)) {
		my $del_vnode = pop(@delvlist);
		if (exists($self->current_v2v->{$del_vnode})) {
		    my $reserved_node = $self->current_v2v()->{$del_vnode};
		    push(@oplist, $reserved_node);
		    my $new_vnode = pop(@newvlist);
		    push(@ovlist, $new_vnode);
		}
	    }
	
	    # These are the new nodes we need to allocate
	    @vlist = @newvlist;
	    $numvs = scalar(@vlist);

	    if (@oplist) {
		$self->printdb("Reusing vnodes @oplist\n"); 
	    }
	}

	#
	# Still need to allocate some virtnodes?
	#
	if ($numvs) {
	    #
	    # All vnodes on pnode are dynamic if the first one is.
	    # We also assume that we do not mix vnode types on a pnode; bad.
	    #
	    my $virtnode = $self->vnodes()->{$vlist[0]};
	    
	    if ($virtnode->_isdynamic()) {
		# Always use the base type ... node type system sucks.
		my $basetype;

		if ($virtnode->_typeinfo()->IsAuxType()) {
		    $basetype = $virtnode->_typeinfo()->BaseType()->type();
		}
		else {
		    $basetype = $virtnode->_typeinfo()->type();
		}

		#
		# We might be expecting to allocate a shared vnode on
		# a shared host. We cannot be sure until CreateVnodes
		# does the table locking, and so it might actually
		# fail (CreateVnodes will make sure).  At this time I
		# am not going to worry about rerunning the
		# assignment; we will fail with a temp resource
		# shortage and let the user try again.
		#
		my $sharedokay = $virtnode->_sharedokay();
		
		#
		# Call into library. Be sure to pass impotent mode along.
		#
		if (Node->CreateVnodes(\@plist,
				       {"pid"      => "$pid",
					"eid"      => "$eid",
					"count"    => $numvs,
					"vtype"    => $basetype,
					"nodeid"   => $physical,
					"debug"    => 0,
					"verbose"  => $self->verbose(),
					"impotent" => $self->impotent(),
					"sharedokay" => $sharedokay,
					"regression" => $self->regression(),
					"user"       => $self->user(),
					"vlist"    => \@vlist
				       })
		    < 0) {
		    tberror("Could not allocate vnodes on $physical\n");
		    return -1;
		}
	    }
	    else {
		#
		# Run avail to get the list of virtnodes on the phys node. We
		# already know there are enough, since assign knows that.
		#
		$self->printdb("Asking avail for $numvs for vnodes: ".
			       "@vlist on $physical\n");
		if (! open(AVAIL, "$AVAIL ".
			   "virtonly=$physical rand limit=$numvs|")) {
		    tberror("Could not start avail\n");
		    return -1;
		}
		while (<AVAIL>) {
		    next
			if (! /^\|/);
		    next
			if (/node_id/);

		    if ($_ =~ /^\|([-a-zA-Z0-9]+)\s*\|(\w+)\s*\|(\w+)\s*\|$/) {
			push(@plist, $1);
		    }
		    else {
			tberror("Bad line from avail: $_\n");
			return -1;
		    }
		}
		close(AVAIL);

		# Sanity check.
		if (scalar(@vlist) != scalar(@plist)) {
		    $self->printdb("avail gave " . scalar(@plist) .
				   " vnodes: @plist on $physical\n");
		    tberror("Could not map some virtual nodes on $physical\n");
		    return -1;
		}

		#
		# Try to allocate. Note, if this fails we are done
		# for. Okay for now since it is never the case that it
		# should fail!
		#
		if ($self->impotent() || $self->alloconly()) {
		    tbinfo("Selected for $physical: @plist\n");
		    tbinfo("Skipping physical reservation, as directed.\n");
		}
		else {
		    tbinfo("Reserving on $physical: @plist ...\n");
		    system("$NALLOC $pid $eid @plist");
		    if ($?) {
			tberror("Failed to reserve @plist (on $physical)\n");
			return -1;
		    }
		}
	    }
	}

	if ($self->updating()) {
	    #
	    # Append the lists we created above, so that we get all of them
	    # in the loop below.
	    #
	    @plist = (@plist, @oplist);
	    @vlist = (@vlist, @ovlist);
	}
    
	while (@plist) {
	    my $virtphys = pop(@plist);
	    my $virtual  = pop(@vlist);
	    my $pnode    = Node->Lookup($virtphys);
	    if (!defined($pnode)) {
		tberror("Could not get node object for $virtphys\n");
		return -1;
	    }

	    $self->solution_v2v()->{$virtual} = $virtphys;
	    $self->printdb("  Mapping $virtual to $virtphys on $physical\n");

	    #
	    # New virtual nodes are always clean. Old ones stay in whatever
	    # state they were in so that os_setup/vnode_setup know they
	    # need to reboot them.
	    #
	    if (! $self->impotent()) {
		if (!exists($self->current_v2v()->{$virtual})) {
		    $self->newreserved()->{$virtphys} = $virtphys;
		    $pnode->SetAllocState(TBDB_ALLOCSTATE_RES_INIT_CLEAN());
		}
		elsif ($self->current_v2v()->{$virtual} ne $virtphys) {
		    # Node has moved.
		    $pnode->SetAllocState(TBDB_ALLOCSTATE_RES_REBOOT());
		}
	    }
	    #
	    # Set the vname for the reserved node right away. Needed in
	    # the libGeni::GetTickets() to find the pnode.
	    #
	    $pnode->ModifyReservation({"vname" => $virtual}) == 0
		or return -1 if (!$self->impotent());

	    #
	    # Not sure where to put this.
	    #
	    $pnode->SetJailIPFromVnode($experiment, $virtual) == 0
		or return -1 if (!$self->impotent());
	}

	# Since we have some extra physical vnodes reserved on this pnode,
	# we will let tbswap tear them down.
	while (@delvlist) {
	    my $del_vnode = pop(@delvlist);

	    if (exists($self->current_v2v()->{$del_vnode})) {
		my $pname = $self->current_v2v()->{$del_vnode};
		my $pnode = $self->pnodes()->{$pname};

		$pnode->SetAllocState(TBDB_ALLOCSTATE_RES_TEARDOWN())
		    if (!$self->impotent() &&
			$pnode->allocstate() ne
			TBDB_ALLOCSTATE_RES_INIT_CLEAN());
	    }		
	}
    }

    return 0;
}

#
# Now interpret the plinks. This comes out of assign_wrapper, no way
# I would try to mess with it, not yet.
#
sub InterpLinks($)
{
    my ($self) = @_;
    my $experiment = $self->experiment();
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();

    $self->printdb("Interpreting link/lan results from assign\n");

    #
    # MLE: Add the links that are implemented by others.
    #
    foreach my $virtlan (values(%{ $self->vlans() })) {
	my $vpath = $virtlan->_implemented_by();

	next
	    if (!defined($vpath));

	my @vlinks = @{$self->vlinks()->{"$virtlan"}};
	if (@vlinks == 1) {
	    my ($vlink) = @vlinks;
	    my ($member0,$member1) = $virtlan->memberlist();
	    my $firstmember = $vpath->firstmember();
	    my $lastmember  = $vpath->lastmember();
	    my $direct      = $virtlan->_layer() == 3 ? 1 : 0;

	    $self->printdb("Adding link $virtlan, implemented by $vpath\n");

	    $self->AddLinkToSolution($vlink, 0, $direct,
				     $firstmember->_pnode(),
				     $firstmember->_pport(),
				     $lastmember->_pnode(),
				     $lastmember->_pport());
	}
	else {
	    $self->printdb("Adding lan $virtlan, implemented by $vpath\n");
	    foreach my $vlink (@vlinks) {
		$self->printdb("vlink: $vlink\n");
		
		my ($lan,$virtA) = ($vlink =~ m|^linklan/([^/]+)/(.+)$|);
		if (!defined($lan)) {
		    tberror("Bad vlink, not a linklan: $vlink\n");
		    return -1;
		}
		my ($vnode) = split(":", $virtA);
		# The lan we adding.
		my $virtlan = $self->vlans()->{$lan};
		# The corresponding member of the lan
		my $member  = $virtlan->members()->{$virtA};

		# Find the segment in the path that implements this lan member.
		foreach my $segment ($vpath->virtlanlist()) {
		    my ($member0,$member1) = $segment->memberlist();
		    my $pnode0 = $member0->_pnode();
		    my $pport0 = $member0->_pport();
		    my $pnode1 = $member1->_pnode();
		    my $pport1 = $member1->_pport();

		    next
			if (! ($member0->vnode() eq $vnode ||
			       $member1->vnode() eq $vnode));
		    
		    $self->printdb("$member - $member0,$pnode0,$pport0, ".
				   "$member1,$pnode1,$pport1\n");

		    # We want the node side of the segment, not the switch side.
		    if ($member0->vnode() eq $vnode) {
			$self->AddLinkToSolution($vlink, 0, 0,
						 $pnode0, $pport0, undef, undef);
			$member->_segment_member($member0);
		    }
		    else {
			$self->AddLinkToSolution($vlink, 0, 0,
						 $pnode1, $pport1, undef, undef);
			$member->_segment_member($member1)
		    }
		}
	    }
	}
    }
    return -1
	if ($self->InterpLinksAux() != 0);

    #
    # Go through and look for bridge nodes. 
    #
    foreach my $bridgename (keys(%{ $self->bridges() })) {
	my @members = values(%{ $self->bridges()->{$bridgename} });

	# Can only bridge two links.
	my ($member0,$member1) = @members;

	$self->AddBridge($bridgename, $member0, $member1);
    }

    #
    # Locally shared nodes.
    #
    # This should go elsewhere ...
    #
    my @sharedpnodes = ();

    foreach my $virtual (keys(%{ $self->solution_v2p() })) {
	my $pnode = $self->pnodes()->{$self->solution_v2p()->{$virtual}};
	my $virtnode = $self->vnodes()->{$virtual};

	# internally created node ...
	next
	    if (!defined($virtnode));
	next
	    if ($pnode->_reuse() eq "unused");
	next
	    if ($pnode->isvirtnode());

	if (defined($virtnode->sharing_mode()) &&
	    ($virtnode->sharing_mode() eq "shared_local" ||
	     $virtnode->sharing_mode() eq "storage_pool")) {
	    push(@sharedpnodes, $pnode);
	}
    }
    if (@sharedpnodes > 0) {
	my $protovlan = ProtoLan->Create($experiment, "sharedlan",
					 $self->impotent() ||
					 $self->alloconly());
					 
	$protovlan->SetRole("encapsulation");
	$protovlan->SetType("vlan");
	$protovlan->SetAttribute("link/lan", "sharedlan");
	$protovlan->SetEncapStyle("default");
	# Total hack ... see snmpit.
	$protovlan->SetAttribute("trunk_mode", "dual");

	# Well, if there are no experimental interfaces, we want to kill
	# the protovlan so that it does not confused snmpit.
	my $iface_counter = 0;
	
	foreach my $pnode (@sharedpnodes) {
	    my $pnodename = $pnode->node_id();
	    my @interfaces;
	    if ($pnode->AllInterfaces(\@interfaces)) {
		tberror("Could not get interface list for $pnode\n");
		return -1;
	    }
	    foreach my $interface (@interfaces) {
		my $iface   = $interface->iface();
		my $type    = $interface->type();
		my $wiredup = $interface->wiredup();

		next
		    if ($interface->role() ne TBDB_IFACEROLE_EXPERIMENT() ||
			!$wiredup || $interface->wire_unused());

		#
		# Gack. We need to make sure that we are connected to an
		# ethernet switch, not something like an apcon or another
		# node. Use the Port library for this.
		#
		my $port = Port->GetOtherEndByIface($pnodename, $iface);
		if (!defined($port)) {
		    tberror("Could not get Port other end for $interface\n");
		    return -1;
		}
		next
		    if (! $port->is_switch_side());
		my $switchname = $port->node_id();
		my $switch = Node->Lookup($switchname);
		if (!defined($switch)) {
		    tberror("Could not lookup node object for $switchname\n");
		    return -1;
		}
		my $forwarding_protocols;
		if ($switch->NodeTypeAttribute("forwarding_protocols",
					       \$forwarding_protocols) ||
		    !defined($forwarding_protocols) ||
		    $forwarding_protocols eq "") {
		    tberror("No forwarding_protocols set for $switch\n");
		    return -1;
		}
		next
		    if ($forwarding_protocols ne "ethernet");

		my $speed = $self->interfacespeedmbps($type, "ethernet");
		DBQueryWarn("update interfaces set " .
			    "   current_speed='$speed',trunk=1 " .
			    "where node_id='$pnodename' and iface='$iface'")
		    or return -1 if (!($self->impotent() ||
				       $self->alloconly()));

		# Use attributes in the future, instead of above query.
		my $mem =
		    $protovlan->AddMember($pnodename, $iface,
					  {"trunk_mode"    => "dual",
					   "current_speed" => $speed});
		
		#
		# Do not do this for nodes already in the shared experiment.
		# It would reset the in-use bandwidth. Bad.
		#
		if (!exists($self->current_p2v()->{$pnodename})) {
		    # Must convert this to kbps like everything else is.
		    $speed = $speed * 1000;
		
		    DBQueryWarn("update interface_state set " .
				"   remaining_bandwidth='$speed' " .
				"where node_id='$pnodename' and ".
				"      iface='$iface'")
			or return -1 if (!($self->impotent() ||
					   $self->alloconly()));
		}
		$iface_counter++;
	    }
	}
	if (!$iface_counter) {
	    $self->printdb("No interfaces in shared vlan, killing protovlan\n");
	    $protovlan->Destroy();
	}
    }

    # Write the vlans to the DB.
    $self->UploadVlans() == 0
	or return -1;
    $self->UpLoadIPAddresses() == 0
	or return -1;
    $self->UpLoadTunnels() == 0
	or return -1;
    $self->UpLoadInterfaceSettings() == 0
	or return -1;
    $self->UploadBlockstores() == 0
	or return -1;
    return 0;
}

sub InterpLinksAux($)
{
    my ($self) = @_;
    my $experiment = $self->experiment();
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();

    my $vlanid     = 0;
    my %portmap    = %{ $self->solution_portmap() };
    my %protovlans = ();

    my %plinks = %{ $self->solution_plinks() };
    my @plinks = sort(keys(%plinks));

    while (@plinks) {
	my $plink = shift(@plinks);
	
	my ($linktag,$virtlan,$trivial,$direct,$member0,$member1,$pathA) =
	    @{$plinks{$plink}};
	my $lan = $virtlan->vname();

	#
	# trivial links do not have physical links, so no delay
	# nodes. But, we *do* use trivial links for intranode links,
	# and thus there could be link delays (ie: two jailed nodes on
	# a link/lan assigned to the same phys node).
	#
	if ($trivial) {
	    $self->printdb("plink $plink - trivial\n");
	}
	else {
	    $self->printdb("plink $plink\n");
	}
	$self->printdb("  pathA - $pathA\n")
	    if (defined($pathA));

	# There is always a member0.
	my $virtA  = $member0;
	my $vnodeA = $member0->vnode();
	my $vportA = $member0->vport();
	my ($nodeA,$portA,$pnodeA) = undef;
	# But it might be trivial, so no portinfo.
	if (!$trivial) {
	    $nodeA  = $member0->_pnode();
	    $portA  = $member0->_pport();
	    $pnodeA = Node->Lookup($nodeA);
	}
	my $virtnodeA = $self->vnodes()->{$vnodeA};

	if ($linktag eq "linksdelaysrc") {
	    # trivial links do not have physical links, so no delay nodes.
	    next
		if ($trivial);

	    # The other node in the link that correspond to the topology.
	    my $virtC  = $member1;
	    my $nodeC  = $member1->_pnode();
	    my $portC  = $member1->_pport();
	    my $vnodeC = $member1->vnode();
	    my $vportC = $member1->vport();
	    # The delay node port/links
	    my $nodeB = $member0->_delaynode();
	    my $portB = $member0->_delayport();
	    my $nodeD = $member1->_delaynode();
	    my $portD = $member1->_delayport();
	    my $pathB = $member1->_delaypath();

	    $self->printdb("LINK delay: $virtA,$virtC - ".
			   "$nodeA:$portA,$nodeB:$portB,".
			   "$nodeD:$portD,$nodeC:$portC\n");
	    $self->printdb(" path - $pathB\n")
		if (defined($pathB));

	    my $protolan    = ProtoLan->Create($experiment, "$lan",
					       $self->impotent() ||
					       $self->alloconly());
	    my $protolansrc = ProtoLan->Create($experiment,
					       "$lan" . "-delaysrc",
					       $self->impotent() ||
					       $self->alloconly(),
					       $protolan);
	    my $protolandst = ProtoLan->Create($experiment,
					       "$lan" . "-delaydst",
					       $self->impotent() ||
					       $self->alloconly(),
					       $protolan);
	    $protolansrc->SetType("vlan");
	    $protolandst->SetType("vlan");
	    $protolansrc->SetRole("delay");
	    $protolandst->SetRole("delay");
	    $protolansrc->SetAttribute("link/lan", $lan);
	    $protolandst->SetAttribute("link/lan", $lan);
	    $protolansrc->SetAttribute("switchpath", "$pathA")
		if (defined($pathA));
	    $protolandst->SetAttribute("switchpath", "$pathB")
		if (defined($pathB));
	    $protolan->SetRole("link/lan");
	    $protolan->AddInterface($nodeC, $vnodeC, $vportC, $portC);
	    $protolan->AddInterface($nodeA, $vnodeA, $vportA, $portA);
	    $protolansrc->AddMember($nodeA, $portA);
	    $protolansrc->AddMember($nodeB, $portB);
	    $protolandst->AddMember($nodeC, $portC);
	    $protolandst->AddMember($nodeD, $portD);
	
	    $self->AddDelay($virtlan, $member0, $member1,
			    $nodeB,$portB,$portD,0,
			    $self->delaylinks()->{$plink});
	    
	    #
	    # Setup portmap using virt members in plink name.
	    #
	    $portmap{$virtA} = $portA;
	    $portmap{$virtC} = $portC;

	    #
	    # Set up tracing across the delay node (both directions).
	    #
	    $self->SetUpTracing($virtlan, $member0, $nodeB, $portB, $portD);
	    $self->SetUpTracing($virtlan, $member1, $nodeB, $portD, $portB);
	}
	elsif ($linktag eq "linkdelaysrc") {
	    # trivial links do not have physical links, so no delay nodes.
	    next
		if ($trivial);

	    # The delay node port/links
	    my $nodeB = $member0->_delaynode();
	    my $portB = $member0->_delayport();
	    my $pathB = $member0->_delaypath();
	    my $nodeD = $nodeB;
	    my $portD = $member0->_delayportB();

	    $self->printdb("LAN delay: $virtA - ".
			   "$nodeA:$portA,$nodeB:$portB,$nodeD:$portD\n");

	    #
	    # Construct a name for the delay link. This has to be unique
	    # since now (with virtual nodes) we can have multiple vnodes
	    # from the same lan, on the same pnode, without using veths.
	    # Multiple routing tables made this possible.
	    #
	    my $dlink = $lan . "/dlink/$vnodeA";

	    my $protolan = ProtoLan->Lookup($experiment, $lan);
	    if (!defined($protolan)) {
		$protolan = ProtoLan->Create($experiment, "$lan",
					     $self->impotent() ||
					     $self->alloconly());
		$protolan->SetRole("link/lan");
	    }
	    $protolan->AddInterface($nodeA, $vnodeA, $vportA, $portA);

	    my $protolanlan = ProtoLan->Lookup($experiment,
					       $lan . "-delaylan");
	    if (!defined($protolanlan)) {
		$protolanlan = ProtoLan->Create($experiment,
						$lan . "-delaylan",
						$self->impotent() ||
						$self->alloconly(),
						$protolan);
		$protolanlan->SetType("vlan");
		$protolanlan->SetRole("delay");
		$protolanlan->SetAttribute("link/lan", $lan);
	    }
	    $protolanlan->AddMember($nodeD, $portD);
	    if (defined($pathB)) {
		$self->printdb("  pathB - $pathB\n");
		my $path = $protolanlan->GetAttribute("switchpath");
		$protolanlan->SetAttribute("switchpath",
					   AddToSwitchPath($path, $pathB));
	    }
	    my $protolanlink = ProtoLan->Create($experiment, $dlink,
						$self->impotent(),
						$protolan);
	    $protolanlink->SetType("vlan");
	    $protolanlink->SetRole("delay");
	    $protolanlink->SetAttribute("link/lan", $lan);
	    $protolanlink->SetAttribute("switchpath", "$pathA")
		if (defined($pathA));
	    $protolanlink->AddMember($nodeA, $portA);
	    $protolanlink->AddMember($nodeB, $portB);

	    $self->AddDelay($virtlan, $member0, $member0,
			    $nodeB,$portB,$portD,1,
			    $self->delaylinks()->{$plink});
	    
	    # Setup portmap using virt members in plink name.
	    $portmap{$virtA} = $portA;

	    #
	    # Set up tracing across the delay node (one direction
	    # cause its a lan).
	    #
	    $self->SetUpTracing($virtlan, $member0, $nodeB, $portB, $portD);
	}
	elsif ($linktag eq "linksimple") {
	    # The other node in the link that correspond to the topology.
	    my $virtB  = $member1;
	    my $vnodeB = $member1->vnode();
	    my $vportB = $member1->vport();
	    my ($nodeB,$portB,$pnodeB) = undef;
	    my $protolink;
	    my $virtnodeB = $self->vnodes()->{$vnodeB};

	    #
	    # If the link is delayed, its with endpoint delays, not a
	    # delay node.
	    #
	    # trivial links do not have physical links, but could be using
	    # virtual interfaces on the same node. 
	    #
	    #
	    if (! $trivial) {
		$nodeB  = $member1->_pnode();
		$portB  = $member1->_pport();
		$pnodeB = Node->Lookup($nodeB);

		$self->printdb("LINK simple: $virtA,$virtB - ".
			       "$nodeA:$portA,$nodeB:$portB\n");

		if ($virtlan->_layer() == 1) {
		    my $attrs = undef;
		    
		    #
		    # A layer one link is a "wire" between two interfaces
		    # attached to a layer one switch; snmpit deals with
		    # wires by creating the links on the layer one switch.
		    #
		    # If both nodes are switches, then we mark it as a Trunk
		    # so that wire is marked appropriately and the ports are
		    # put into trunk mode.
		    #
		    $protolink = ProtoLan->Create($experiment, $lan,
						  $self->impotent() ||
						  $self->alloconly());
		    $protovlans{$lan} = $protolink;
		    $protolink->SetType("wire");
		    
		    if ($pnodeA->isswitch() && $pnodeB->isswitch()) {
			$protolink->SetRole("trunk");
			$attrs = {"trunk_mode" => "equal"};
		    }
		    else {
			$protolink->SetRole("link");
		    }
		    $protolink->AddInterface($nodeA, $vnodeA,
					     $vportA, $portA, undef, $attrs);
		    $protolink->AddInterface($nodeB, $vnodeB,
					     $vportB, $portB, undef, $attrs);

		    #
		    # The layer one link when it is in existence, is just like
		    # a wire between the end points. But of course the wire
		    # is dynamic, only in existence because the layer one
		    # switch hooks them up to each other. While this
		    # connection is in existence, we want to create a
		    # "logical" wire so that the link at the next layer up
		    # sees that wire (as for snmpit).
		    #
		    my $logicalwire =
			Interface::LogicalWire->Create(($self->impotent() ||
							$self->alloconly()
							? 1 : 0),
						       $nodeA, $portA,
						       $nodeB, $portB);
		    return -1
			if (!defined($logicalwire));

		    $self->printdb("Created $logicalwire for $virtlan\n");

		    #
		    # Stash this into segment so we can find it later, as when
		    # doing the link at the next layer up.
		    #
		    $virtlan->_logicalwire($logicalwire);

		    #
		    # And stash into the lan entry for snmpit later, which will
		    # need to find the wire so it can mark it as active once
		    # the layer 1 link is created.
		    #
		    $protolink->SetAttribute("logicalwireid",
					     $logicalwire->WireID());

		    # Setup portmap using virt members in plink name.
		    # For setting speeds later.
		    $portmap{$virtA} = $portA;
		    $portmap{$virtB} = $portB;
	
		    next;
		}
		elsif ($virtlan->_layer() == 2 && $virtlan->_vpaths()) {
		    #
		    # A layer two path. We know we want to put the
		    # ports into trunk mode, but we might not know the
		    # vlan(s) yet since the link(s) running over this
		    # path might not have been created.
		    #
		    # Note that the current implementation of a layer
		    # two path is a set of nodes, with each interior
		    # node in the path acting as a bridge. All of the
		    # ports along the way are added to the vlan that
		    # was created for the link. 
		    #
		    # Look at the list of all the links this path
		    # implements. If not all of them have been
		    # processed then push this back on the vlinks list
		    # to be processed later.
		    #
		    # We know there is only one.
		    #
		    my ($vpath) = @{$virtlan->_vpaths()};
		    
		    foreach my $implements (values(%{$vpath->implements()})) {
			if (!exists($protovlans{$implements->vname()})) {
			    push(@plinks, $plink);
			    goto loop;
			}
		    }
		    #
		    # Okay, all of the vlans implemented by this path
		    # (segment) have been created. Put the ports of this
		    # segment into the those vlans, and make sure the
		    # ports are marked for trunking. 
		    #
		    foreach my $implements (values(%{$vpath->implements()})) {
			my $protovlan = $protovlans{$implements->vname()};

			$protovlan->AddMember($nodeA, $portA,
					      {"trunk_mode" => "equal"})
			    if (! $protovlan->IsMember($nodeA, $portA));

			$protovlan->AddMember($nodeB, $portB,
					      {"trunk_mode" => "equal"})
			    if (! $protovlan->IsMember($nodeB, $portB));

			$self->printdb("Path Segment: $vpath:$implements\n");
		    }
		    next;
		}
		#
		# Special handing for layer two links implemented by a path.
		#
		if ($virtlan->_implemented_by()) {
		    #
		    # Make sure the underlying links have been processed.
		    # Push back on the list if not.
		    #
		    my $vpath = $virtlan->_implemented_by();
		    my @links = $vpath->virtlanlist();

		    foreach my $link (@links) {
			if (!exists($protovlans{$link->vname()})) {
			    push(@plinks, $plink);
			    goto loop;
			}
		    }
		    #
		    # Find the first and last links (the segments) of the path.
		    # The logical wires created by those segments are the wires
		    # we want to use below.
		    #
		    # XXX Not sure this makes sense if the path has more then
		    # 2 segments in it.
		    #
		    my $firstlink = shift(@links);
		    my $lastlink  = (@links ? pop(@links) : $firstlink);
		    my $firstwire = $firstlink->_logicalwire();
		    my $lastwire  = $lastlink->_logicalwire();

		    $self->printdb("$virtlan; $firstwire, $lastwire\n");

		    $portA = $firstwire->iface1();
		    $portB = $lastwire->iface1();
		}
		if ($virtlan->usevirtiface()) {
		    my $protovlan;
		    
		    #
		    # Create some new virtual devices.
		    #
		    my ($virtifaceA, $virtifaceB);

		    if ($member0->usevirtiface()) {
			$virtifaceA = $self->NewVirtIface($virtlan, $member0,
							  $nodeA, $portA);
			return -1
			    if (!defined($virtifaceA));
		    }
		    if ($member1->usevirtiface()) {
			$virtifaceB = $self->NewVirtIface($virtlan, $member1,
							  $nodeB, $portB);
			return -1
			    if (!defined($virtifaceB));
		    }

		    #
		    # We need to reserve the shared bandwidth.
		    #
		    if (exists($self->delaylinks()->{$plink}) ||
			$member0->_reservebw() || $member1->_reservebw()) {
			my ($bandwidth,$rbandwidth) = 0;
			
			if (exists($self->delaylinks()->{$plink})) {
			    (undef,$bandwidth,undef,undef,
			     undef,$rbandwidth,undef) =
				 @{$self->delaylinks()->{$plink}};
			}
			else {
			    $bandwidth  = $member0->_reservebw();
			    $rbandwidth = $member1->_reservebw();
			}

			if (($virtnodeA->_onsharednode() ||
			     $member0->_reservebw()) &&
			    $self->printdb("  Reserving shared BW: $member0,".
					   "$bandwidth,$virtifaceA\n") &&
			    !($self->impotent() || $self->alloconly()) &&
			    $virtifaceA->ReserveSharedBandwidth($bandwidth)) {
			    tbinfo("Could not reserve shared bandwidth: ".
				   "$member0,$bandwidth,$virtifaceA\n");
			    return -1;
			}
			if (($virtnodeB->_onsharednode() ||
			     $member1->_reservebw()) &&
			    $self->printdb("  Reserving shared BW: $member1,".
					   "$rbandwidth,$virtifaceB\n") &&
			    !($self->impotent() || $self->alloconly()) && 
			    $virtifaceB->ReserveSharedBandwidth($rbandwidth)) {
			    tbinfo("Could not reserve shared bandwidth: ".
				   "$member1,$rbandwidth,$virtifaceB\n");
			    return -1;
			}
		    }

		    #
		    # When using virtual interfaces we need to create a
		    # protolan for the underlying vlan, and then another link
		    # for the endpoints that run over that vlan. Note though
		    # that there might be multiple emulated links running on
		    # on this physical link. Once we have everything created
		    # there is a postpass to merge the vlans into a single
		    # supervlan since a nodeport can be in just a single vlan.
		    # Note that if the encapstype is "vlan" then the previous
		    # is obviously false, since then the ports are going to
		    # be in trunk mode, and the nodeports in multiple vlans.
		    #
		    if ($virtlan->_encapstyle() ne "vlan") {
			my $lanid = "v" . "$lan" . $vlanid++;

			$protovlan = ProtoLan->Create($experiment, $lanid,
						      $self->impotent() ||
						      $self->alloconly());
			$protovlan->SetRole("encapsulation");
			$protovlan->SetType("vlan");
			$protovlan->SetEncapStyle($virtlan->_encapstyle());
			$protovlan->SetAttribute("link/lan", $lan);
			$protovlan->SetAttribute("switchpath", "$pathA")
			    if (defined($pathA));
			$protovlans{$lan} = $protovlan;

			$protovlan->AddMember($nodeA, $portA)
			    if (!$protovlan->IsMember($nodeA, $portA));
			$protovlan->AddMember($nodeB, $portB)
			    if (!$protovlan->IsMember($nodeB, $portB));
		    }
		    $protolink = ProtoLan->Create($experiment, $lan,
						  $self->impotent() ||
						  $self->alloconly(),
						  $protovlan);
		    my $vlan_type;
		    my $vlan_role;

		    if (defined($protovlan)) {
			$vlan_type = "emulated";
			$vlan_role = "link/lan";
			$virtifaceA->_vlanname($protovlan->vname())
			    if (defined($virtifaceA));
			$virtifaceB->_vlanname($protovlan->vname())
			    if (defined($virtifaceB));
		    }
		    else {
			$vlan_type = "vlan";
			$vlan_role = "emulated";
			$protolink->SetAttribute("link/lan", $lan);
			$protolink->SetAttribute("switchpath", "$pathA")
			    if (defined($pathA));
			$virtifaceA->_vlanname($lan)
			    if (defined($virtifaceA));
			$virtifaceB->_vlanname($lan)
			    if (defined($virtifaceB));
		    }
		    $protolink->SetType($vlan_type);
		    $protolink->SetRole($vlan_role);

		    $protolink->AddInterface($nodeA, $vnodeA, $vportA,
					     (defined($virtifaceA) ?
					      $virtifaceA->viface() : $portA),
					     (defined($protovlan) ?
					      undef : $portA));
 		    $protolink->AddInterface($nodeB, $vnodeB, $vportB,
					     (defined($virtifaceB) ?
					      $virtifaceB->viface() : $portB),
					     (defined($protovlan) ?
					      undef : $portB));
		    # For portmap below
		    $portA = $virtifaceA->viface()
			if (defined($virtifaceA));
		    $portB = $virtifaceB->viface()
			if (defined($virtifaceB));
		}
		else {
		    $protolink = ProtoLan->Create($experiment, $lan,
						  $self->impotent() ||
						  $self->alloconly());
		    #
		    # At layer 2, a direct link is a wire between two
		    # interfaces. We want them setup like any layer 2
		    # link.
		    #
		    $protolink->SetType(($direct ? "direct" : "vlan"));
		    $protolink->SetRole("link/lan");
		    $protolink->SetAttribute("link/lan", $lan);
		    $protolink->SetAttribute("switchpath", "$pathA")
			if (defined($pathA));
		    $protolink->AddInterface($nodeA, $vnodeA, $vportA, $portA);
		    $protolink->AddInterface($nodeB, $vnodeB, $vportB, $portB);
		    $protovlans{$lan} = $protolink;
		}
	    }
	    else {
		# If the trivial link has all simulated members, we
		# don't want a veth interface
		if (! $virtlan->_allsim()) {
		    # No phys mapping. We create a veth, but there is
		    # no phys mapping for the port and no underlying
		    # (linked) vlan.
		    $nodeA = $self->solution_v2p()->{$vnodeA};
		    $nodeB = $self->solution_v2p()->{$vnodeB};

		    my $virtifaceA = $self->NewVirtIface($virtlan,
							 $member0, $nodeA);
		    return -1
			if (!defined($virtifaceA));
		    my $virtifaceB = $self->NewVirtIface($virtlan, $member1,
							 $nodeB);
		    return -1
			if (!defined($virtifaceB));
		    
		    $portA = $virtifaceA->viface();
		    $portB = $virtifaceB->viface();

		    $self->printdb("LINK simple (trivial): $virtA,$virtB - ".
				   "$nodeA:$portA,$nodeB:$portB\n");
		    
		    $protolink = ProtoLan->Create($experiment, $lan,
						  $self->impotent() ||
						  $self->alloconly());
		    $protolink->SetType("trivial");
		    $protolink->SetRole("link/lan");
		    $protolink->AddInterface($nodeA, $vnodeA, $vportA, $portA);
		    $protolink->AddInterface($nodeB, $vnodeB, $vportB, $portB);
		}
		else {
		    # next plink
		    next;
		}
	    }
	
	    # Setup portmap using virt members in plink name.
	    $portmap{$virtA} = $portA;
	    $portmap{$virtB} = $portB;
	
	    if (exists($self->delaylinks()->{$plink})) {
		my ($delay,$bandwidth,$backfill,$loss,
		    $rdelay,$rbandwidth,$rbackfill,$rloss,$trivial_ok) =
			@{$self->delaylinks()->{$plink}};

		if (!$trivial_ok || ($trivial_ok && $trivial)) {
		    #
		    # Two entries, one for each side of the duplex link.
		    #
		    $self->AddLinkDelay($virtlan,$member0,$nodeA,$portA,0,
					[$delay,$bandwidth,$backfill,$loss]);

		    $self->AddLinkDelay($virtlan,$member1,$nodeB,$portB,0,
				       [$rdelay,$rbandwidth,$rbackfill,$rloss]);
		}
	    }
	    #
	    # Set up tracing across the link. There is trace on each end node,
	    # on the output (after the linkdelay above).
	    #
	    $self->SetUpTracing($virtlan, $member0, $nodeA, undef, $portA);
	    $self->SetUpTracing($virtlan, $member1, $nodeB, undef, $portB);
	}
	elsif ($linktag eq "linklan") {
	    # A single node in a lan, no delay node.
	    my $protolan;

	    #
	    # trivial links do not have physical links, but could be using
	    # virtual interfaces on the same node. 
	    #
	    if (! $trivial) {
		$self->printdb("LAN node: $virtA - $nodeA:$portA\n");
		
		#
		# Special handing for layer two links implemented by a path.
		#
		if ($virtlan->_implemented_by()) {
		    #
		    # Make sure the underlying links have been processed.
		    # Push back on the list if not.
		    #
		    my $vpath = $virtlan->_implemented_by();
		    my @links = $vpath->virtlanlist();

		    foreach my $link (@links) {
			if (!exists($protovlans{$link->vname()})) {
			    push(@plinks, $plink);
			    goto loop;
			}
		    }
		    #
		    # So we have the member of the segment which gets us
		    # the logical wire. From the logical wire we can get
		    # the logical interface for the lan.
		    #
		    my $segment_member  = $virtA->_segment_member();
		    my $segment_virtlan = $segment_member->virt_lan();
		    my $segment_wire    = $segment_virtlan->_logicalwire();
		    #
		    # We have an implicit assumption that the node side of
		    # a wire is on the left and the switch on the right. We
		    # to get the node side here.
		    #
		    my $logical_iface = $segment_wire->iface1();
		    
		    $self->printdb("$virtlan; $segment_wire, $logical_iface\n");

		    $portA = $logical_iface;
		}
		if ($virtlan->usevirtiface()) {
		    #
		    # Look for the underlying protovlan for this lan. Create
		    # new one otherwise.
		    #
		    my $protovlan;
		    
		    if ($virtlan->_encapstyle() ne "vlan") {
			if (exists($protovlans{$lan})) {
			    $protovlan = $protovlans{$lan};
			}
			else {
			    my $lanid = "v" . "$lan" . $vlanid++;
			    $protovlan = ProtoLan->Create($experiment, $lanid,
							  $self->impotent() ||
							  $self->alloconly());
			    $protovlan->SetRole("encapsulation");
			    $protovlan->SetType("vlan");
			    $protovlan->SetEncapStyle($virtlan->_encapstyle());
			    $protovlan->SetAttribute("link/lan", $lan);
			    $protovlans{$lan} = $protovlan;
			}
			$protovlan->AddMember($nodeA, $portA)
			    if (!$protovlan->IsMember($nodeA, $portA));

			if (defined($pathA)) {
			    my $path = $protovlan->GetAttribute("switchpath");
			    $protovlan->SetAttribute("switchpath",
						AddToSwitchPath($path, $pathA));
			}
		    }
		
		    #
		    # Create new veth device. Watch for a mixed pnode/vnode
		    # lan where the pnode is not using encapsulation.
		    #
		    my $virtiface;
		    if ($member0->usevirtiface()) {
			$virtiface = $self->NewVirtIface($virtlan, $member0,
							 $nodeA, $portA);
			return -1
			    if (!defined($virtiface));

			$virtiface->_vlanname((defined($protovlan) ?
					       $protovlan->vname() : $lan));
		    }
		    #
		    # We need to reserve the shared bandwidth. 
		    #
		    if (exists($self->delaylinks()->{$plink}) ||
			 $member0->_reservebw()) {
			my ($bandwidth,$rbandwidth) = 0;
			
			if (exists($self->delaylinks()->{$plink})) {
			    (undef,$bandwidth,undef,undef,
			     undef,$rbandwidth,undef) =
				 @{$self->delaylinks()->{$plink}};
			}
			else {
			    $bandwidth = $rbandwidth = $member0->_reservebw();
			}
			my $maxbw = max($bandwidth, $rbandwidth);
			if (($virtnodeA->_onsharednode() ||
			     $member0->_reservebw()) &&
			    $self->printdb("  Reserving shared BW: ".
					   "$member0,$maxbw,$virtiface\n") &&
			    !($self->impotent() || $self->alloconly) && 
			    $virtiface->ReserveSharedBandwidth($maxbw)) {
			    tbinfo("Could not reserve shared bandwidth: ".
				   "$member0,$maxbw,$virtiface\n");
			    return -1;
			}
		    }

		    $protolan = ProtoLan->Lookup($experiment, $lan);
		    if (defined($protolan)) {
			#
			# Watch for a lan that mixes trivial links and
			# actual vlan encapsulated links. We might
			# have processed a trivial member first, in
			# which case we have to set its link pointer
			# to the protovlan.
			#
			if ($protolan->type() eq "trivial" &&
			    defined($protovlan)) {
			    $protolan->SetLink($protovlan);
			}
		    }
		    else {
			$protolan = ProtoLan->Create($experiment, $lan,
						     $self->impotent() ||
						     $self->alloconly(),
						     $protovlan);
		    }
		    if (defined($protovlan)) {
			$protolan->SetType("emulated");
			$protolan->SetRole("link/lan");
		    }
		    else {
			$protolan->SetType("vlan");
			$protolan->SetRole("emulated");
			$protolan->SetAttribute("link/lan", $lan);
			if (defined($pathA)) {
			    my $path = $protolan->GetAttribute("switchpath");
			    $protolan->SetAttribute("switchpath",
						AddToSwitchPath($path, $pathA));
			}
		    }
		    $protolan->AddInterface($nodeA, $vnodeA, $vportA,
					    (defined($virtiface) ?
					      $virtiface->viface() : $portA),
					    (defined($protovlan) ?
					     undef : $portA));

		    #
		    # If the "lannode" is placed on a node, and that node is
		    # different than the current node, we have to connect the
		    # two in the vlan. Typically, the lannode is placed on a
		    # switch, and this is not an issue. 
		    #
		    if (!$virtnodeA->_onsharednode() &&
			! ($member0->_lannode() ne "null" &&
			   $member0->_lanport() ne "null" &&
			   $member0->_lannode() eq $nodeA &&
			   $member0->_lanport() eq $portA)) {
			my $plan = $protovlan || $protolan;
			
			$plan->AddMember($member0->_lannode(),
					 $member0->_lanport())
			    if (!$plan->IsMember($member0->_lannode(),
						 $member0->_lanport()));
			$self->AddVirtPatch($lan,
					    $member0->_lannode(),
					    $member0->_lanport());
		    }
		    
		    # For below.
		    $portA = $virtiface->viface()
			if (defined($virtiface));
		}
		else {
		    $protolan = ProtoLan->Lookup($experiment, $lan);
		    if (!defined($protolan)) {
			#
			# XXX Watch for a lan that mixes delayed and
			# non-delayed members. We should create the
			# protolans earlier.
			#
			$protolan = ProtoLan->Create($experiment, $lan,
						     $self->impotent() ||
						     $self->alloconly());
		    
			if ($virtlan->_delayed()) {
			    my $protolanlan =
				ProtoLan->Create($experiment,
						 $lan . "-delaylan",
						 $self->impotent() ||
						 $self->alloconly(),
						 $protolan);
			    $protolanlan->SetType("vlan");
			    $protolanlan->SetRole("delay");
			    $protolanlan->SetAttribute("link/lan", $lan);
			}
			else {
			    $protolan->SetType("vlan");
			    $protolan->SetAttribute("link/lan", $lan);
			}
			$protolan->SetRole("link/lan");
		    }
		    $protolan->AddInterface($nodeA, $vnodeA, $vportA, $portA);
		    if ($virtlan->_delayed()) {
			my $protolanlan =
			    ProtoLan->Lookup($experiment,
					     $lan . "-delaylan");
			$protolanlan->AddMember($nodeA, $portA);
			if (defined($pathA)) {
			    my $path = $protolanlan->GetAttribute("switchpath");
			    $protolanlan->SetAttribute("switchpath",
					       AddToSwitchPath($path, $pathA));
			}
		    }
		    else {
			if (defined($pathA)) {
			    my $path = $protolan->GetAttribute("switchpath");
			    $protolan->SetAttribute("switchpath",
					    AddToSwitchPath($path, $pathA));
			}
		    }
		}
	    }
	    else {
		# If the trivial lan has all simulated members, we
		# don't want a veth interface
		if (! $virtlan->_allsim()) {
		    # No phys mapping. We create a veth, but there is
		    # no phys port.
		    $nodeA = $self->solution_v2p()->{$vnodeA};
		    my $virtiface = $self->NewVirtIface($virtlan, $member0,
							$nodeA);
		    return -1
			if (!defined($virtiface));
		    
		    $portA = $virtiface->viface();

		    $self->printdb("LAN node (trivial): ".
				   "$virtA - $nodeA:$portA\n");

		    $protolan = ProtoLan->Lookup($experiment, $lan);
		    if (!defined($protolan)) {
			$protolan = ProtoLan->Create($experiment, $lan,
						     $self->impotent() ||
						     $self->alloconly());
			$protolan->SetType("trivial");
			$protolan->SetRole("link/lan");
		    }
		    #
		    # A lan can be a mix of real and trivial members, say if
		    # its a lan of multiple members that spans two physical
		    # nodes with multiple members on each node. In this case,
		    # we have to mark these interfaces in the lans table to
		    # make it easy for snmpit to ignore them when setting up
		    # the physical part of the lan, and just use the physical
		    # interfaces that were added above. 
		    #
		    $protolan->AddInterface($nodeA, $vnodeA, $vportA, $portA,
					    undef, {"trivial" => "yes"});
		}
		else {
		    # next plink
		    next;
		}
	    }
	    # Setup portmap using virt members in plink name.
	    $portmap{$virtA} = $portA;
	
	    if (exists($self->delaylinks()->{$plink})) {
		my ($delay,$bandwidth,$backfill,$loss,
		    $rdelay,$rbandwidth,$rbackfill,$rloss,$trivonly) =
			@{$self->delaylinks()->{$plink}};

		if (!$trivonly || $trivonly && $trivial) {
		    #
		    # One entry, comprising each side of the link to lan.
		    #
		    $self->AddLinkDelay($virtlan,$member0,$nodeA,$portA,1,
					$self->delaylinks()->{$plink});
		}
	    }
	    #
	    # Set up tracing on the end node (one direction cause its a lan).
	    #
	    $self->SetUpTracing($virtlan, $member0, $nodeA, undef, $portA);
	}
	elsif ($linktag eq "fakelan") {
	    #
	    # No trivial links, delays, or vlans.
	    #
	    $self->printdb("FakeLan - $virtA - $nodeA:$portA\n");
	    
	    my $protolan = ProtoLan->Lookup($experiment, $lan);
	    $protolan = ProtoLan->Create($experiment, $lan,
				 $self->impotent() || $self->alloconly())
		if (!defined($protolan));
	    $protolan->SetType("fakelan");
	    $protolan->SetRole("link/lan");
	
	    if ($member0->usevirtiface()) {
		$protolan->AddMember($nodeA, $portA);
		
		my $virtiface = $self->NewVirtIface($virtlan, $member0,
						    $nodeA, $portA);
		return -1
		    if (!defined($virtiface));

		$portA = $virtiface->viface();
	    }
	    else {
		$protolan->AddInterface($nodeA, $vnodeA, $vportA, $portA);
	    }
	    $portmap{$virtA} = $portA;

	    #
	    # Set up tracing on the end node (one direction cause its a lan).
	    #
	    $self->SetUpTracing($virtlan, $member0, $nodeA, undef, $portA);
	}
	elsif ($linktag eq "portlan") {
	    my $portvlan = $virtlan->_portvlan();
	    
	    #
	    # No trivial links, delays, vlans. 
	    # This is a port in an existing lan in another experiment.
	    #
	    $self->printdb("PortLan - $virtA - $nodeA:$portA\n");
	    
	    my $protolan = ProtoLan->Lookup($experiment, $lan);
	    $protolan = ProtoLan->Create($experiment, $lan,
				 $self->impotent() || $self->alloconly())
		if (!defined($protolan));
	    $protolan->SetType("portlan");
	    $protolan->SetRole("port/lan");
	    $protolan->SetAttribute("link/lan", $lan);
	    $protolan->SetAttribute("target_lanid", $portvlan->lanid());

	    if ($member0->usevirtiface()) {
		$protolan->AddMember($nodeA, $portA);
		
		my $virtiface = $self->NewVirtIface($virtlan, $member0,
						    $nodeA, $portA);
		return -1
		    if (!defined($virtiface));

		$portA = $virtiface->viface();

		#
		# The vinterface needs to link to the underlying lan
		# so that tmcd can find the vlan tag. Do this here
		# since we have what we need in hand. 
		#
		$virtiface->Update({"vlanid" => $portvlan->lanid()});
	    }
	    else {
		$protolan->AddInterface($nodeA, $vnodeA, $vportA, $portA);
	    }
	    $portmap{$virtA} = $portA;
	}
	elsif ($plink =~ m|^linkdelaydst/([^/]+)/(.+)$| ||
	       $plink =~ m|^linksdelaydst/(.+)/(.+),(.+)$|) {
	    next;
	}
	else {
	    warn("Bad plink: $plink\n");
	}
      loop:
    }
    $self->{'SOLUTION'}->{'PORTMAP'} = \%portmap;

    return 0;
}

#
# Initialize the nodes.
#
sub InitializePhysNodes($)
{
    my ($self) = @_;
    
    #
    # Init each pnode.
    #
    foreach my $pnodename (keys(%{ $self->solution_p2v() })) {
	my $pnode = $self->pnodes()->{$pnodename};
	
	$pnode->FlushReserved();
	my $reservation = $pnode->Reservation();

	print STDERR "$pnodename\n";

	#
	# We should never try to initialize a node that is not
	# allocated to the experiment. 
	#
	# This case covers shared nodes as well since the phys node
	# is in a holding experiment.
	#
	if ((!defined($reservation) || 
	     !$self->experiment()->SameExperiment($reservation))) {
	    if (defined($pnode->sharing_mode())) {
		$self->printdb("InitPnode: Skipping shared host $pnodename\n");
		next;
	    }
	    elsif (defined($pnode->erole()) &&
		   $pnode->erole() eq TBDB_RSRVROLE_STORAGEHOST()) {
		tbinfo("InitPnode: Skipping $pnodename; storage host\n");
		next;
	    }
	    elsif (! ($self->impotent() && 
		      exists($self->solution()->{'TORESERVE'}->{$pnodename}))){
		tbinfo("InitPnode: Skipping $pnodename; reserved elsewhere\n");
		next;
	    }
	}
	
	#
	# Physical nodes can be plain nodes in the topo, delay nodes,
	# internal nodes hosting other things (like virtual nodes),
	# etc. Determine the role the node is going to play, and
	# initialize it based on that role. Note that I am ignoring
	# the simulation code these days since it no longer works and
	# no one understands it.
	#
	# XXX A node cannot play multiple roles. This is unfortunate. 
	#
	my @vnodelist = @{ $self->solution_p2v()->{$pnodename} };
    	my $vnodename;
	my $role      = TBDB_RSRVROLE_NODE;

	if (exists($self->solution_delaynodes()->{$pnodename})) {
	    $role = TBDB_RSRVROLE_DELAYNODE;
	    # Need only one of the virtnodes to complete the initialization
	    $vnodename = $vnodelist[0];
	}
	elsif (exists($self->solution_sanhosts()->{$pnodename})) {
	    $role = TBDB_RSRVROLE_STORAGEHOST;
	    # Need only one of the virtnodes to complete the initialization
	    $vnodename = $vnodelist[0];
	}
	elsif (exists($self->solution_virtnodes()->{$pnodename})) {
	    $role = TBDB_RSRVROLE_VIRTHOST;
	    #
	    # Since we allow a VM to be "fixed" to a node in the topology, it
	    # is possible that a physnode has two roles; its normal node role
	    # and its role as a virthost. We want to initialize the pnode
	    # for the VIRTHOST role, but using the normal node virtnode, not
	    # one of the VM virtnodes. The only reason for using the VM
	    # virtnode, is when we have to use the VM to figure out what
	    # OS to run on the internally created pnode.
	    #
	    foreach my $vname (@vnodelist) {
		my $virtnode = $self->vnodes()->{$vname};

		# Find the one real node. Icky.
		if (!$virtnode->_isvirtnode()) {
		    $vnodename = $vname;
		    last;
		}
	    }
	    $vnodename = $vnodelist[0]
		if (!defined($vnodename));
	}
	else {
	    $vnodename = $vnodelist[0];
	}
	$self->InitializePhysNode($pnodename, $role, $vnodename) == 0
	    or return -1;
    }

    #
    # Now do each of the virtual physical nodes (pcvmxxx-yyy). These
    # are naturally plain nodes and always one-to-one.
    #
    foreach my $vnodename (keys(%{ $self->solution_v2v() })) {
	my $vpnodename = $self->solution_v2v()->{$vnodename};

	$self->InitializePhysNode($vpnodename, 
				  TBDB_RSRVROLE_NODE, $vnodename) == 0
	    or return -1;
    }
    
    #
    # XXX This is here cause vnames were not set until now. Need to move.
    #
    if (defined($self->genirspec()) &&
	!($self->impotent() || $self->alloconly())){
	if (libGeni::MapNodes($self->experiment(), $self->verbose())) {
	    tberror("Could not map geni nodes to local nodes.\n");
	    return -1;
	}
    }

    #
    # XXX Similarly, all of the vnames need to be setup before this
    # config step for UE nodes can run since we allow vnames to be used
    # as the adb target.  This probably isn't the greatest place for
    # this, but I'm not sure where is better.  This task has to happen
    # inside the mapper run so that the result is picked up when the
    # GENI manifest is created.
    #
    if (!($self->impotent() || $self->alloconly())) {
	foreach my $pnodename (keys(%{ $self->solution_p2v() })) {
	    my $pnode = $self->pnodes()->{$pnodename};
	    # Do some limited early setup for UE class nodes to get necessary
	    # information into the PG manifest.
	    if ($pnode->class eq "ue") {
		$pnode->UEConfig() == 0
		    or return -1;
	    }
	}
    }

    return 0;
}

#
# Initialize a physical (or virtual physical) node. A lot of magic
# in this function
#
sub InitializePhysNode($$$)
{
    my ($self, $pnodename, $role, $vnodename) = @_;
    my $pnode = $self->pnodes()->{$pnodename};

    $self->printdb("InitPnode: $pnodename,$role,$vnodename\n");

    # If this is a node in the topology (in the vnodes() array) then
    # there must be a virtual physical node (which might be the same
    # as the pnode if its a plain node, not a VM or subnode).
    my $virtnode;
    my $vpnode;
    if (exists($self->vnodes()->{$vnodename})) {
	$virtnode = $self->vnodes()->{$vnodename};
	$vpnode   = $virtnode->_pnode();
	if (!defined($vpnode)) {
	    tberror("No virtual physical node for $vnodename on $pnodename\n");
	    return -1;
	}
    }
    
    my %nodesets     = ();
    my %rsrvsets     = ();
    my $cmdline_role = "default";
    my $cmdline      = "";
    my $vname;
    my ($osinfo, $osid);
    my $routertype;

    if ($role eq TBDB_RSRVROLE_DELAYNODE() ||
	$role eq TBDB_RSRVROLE_STORAGEHOST() ||
	($role eq TBDB_RSRVROLE_VIRTHOST() && $virtnode->_isvirtnode())) {
	#
	# One of our internally created nodes. 
	#
	if ($role eq TBDB_RSRVROLE_STORAGEHOST()) {
	    #
	    # A storage host.
	    #
	}
	elsif ($role eq TBDB_RSRVROLE_DELAYNODE()) {
	    #
	    # A delay node.
	    #
	    $osid = ($self->option("delay_osid") || $pnode->delay_osid());
	    $vname        = $vnodename;
	    $routertype   = TBDB_ROUTERTYPE_NONE;
	    $cmdline_role = "delay";

	    $self->exptstats()->{"delaynodes"} += 1;
	}
	else {
	    #
	    # An internal node hosting VMs.
	    #
	    if (defined($virtnode->_parent_osinfo())) {
		# Do not want to lose version info, so use osinfo when we
		# have it.
		$osinfo = $virtnode->_parent_osinfo();
	    }
	    elsif ($self->option("jail_osid")) {
		$osinfo = OSImage->Lookup($self->option("jail_osid"));
	    }
	    else {
		$osinfo = $self->nodejailosinfo($virtnode)
	    }
	    $vname        = $self->newvname($pnodename, "vhost");
	    $routertype   = TBDB_ROUTERTYPE_MANUAL;
	    $cmdline_role = "vnodehost";

	    $self->exptstats()->{"jailnodes"} += 1;
	}
	$osid = $osinfo->osid()
	    if (defined($osinfo));
	if (!defined($osid)) {
	    tberror("No OSID is defined for internal node $vname!\n");
	    return -1;
	}
	$cmdline = $self->osidbootcmd($osid, $cmdline_role, $cmdline);
	if (!defined($cmdline)) {
	    tberror("Error determining boot command line for $pnode\n");
	    return -1;
	}
	%nodesets = ("def_boot_cmd_line" => $cmdline,
		     "startstatus"       => 0,
		     "bootstatus"        => 'unknown',
		     # This is no longer used for anything.
		     "deltas"            => '', 
		     "ready"             => 0,
		     "routertype"        => $routertype);

	%rsrvsets = ("vname"             => $vname,
		     "erole"             => $role);

	if (!$self->impotent() && !$self->alloconly() &&
	    $self->experiment()->AddInternalProgramAgent($vname)) {
	    tberror("Error determining boot command line for $pnode\n");
	    return -1;
	}
    }
    else {
	#
	# A normal user node (physical or virtual).
	#
	my ($cmdline,$rpms,$startupcmd,$tarfiles,$loadlist,
	    $failureaction,$routertype) = @{ $virtnode->_settings() };

	if ($virtnode->_isbridge()) {
	    # Allow user to override defaults on a per-node basis.
	    if (! defined($virtnode->_osinfo())) {
		$osid = ($self->option("delay_osid") ||
			 $pnode->delay_osid());
		undef($osinfo);
	    }
	}
	
	# Do not want to lose version info, so use osinfo when we have it.
	if (defined($virtnode->_osinfo())) {
	    $osinfo = $virtnode->_osinfo();
	    $osid   = $osinfo->osid();
	}
	else {
	    $osid   = $pnode->default_osid();
	    $osinfo = OSImage->Lookup($osid);
	    if (!defined($osinfo)) {
		tberror("Could not map $osid to OSimage object\n");
		return -1;
	    }
	}
	if ($osinfo->isImageAlias()) {
	    #
	    # Map the alias to the type specific image.
	    #
	    $osinfo = $osinfo->MapToImage($pnode->type());
	    $osid = $osinfo->osid();
	}
	
	my $vname           = $vnodename;
	my $inner_elab_role = $virtnode->inner_elab_role();
	my $plab_role       = $virtnode->plab_role();
	my $sharing_mode;

	if (!$pnode->isvirtnode() &&
	    (!defined($cmdline) || $cmdline eq "")) {
	    # If the user has not overridden the command line, try to
	    # find a default for this OSID. Only test real physical node.
	    if ($role eq TBDB_RSRVROLE_VIRTHOST) {
		$cmdline = $self->osidbootcmd($osid, "vnodehost", "");
	    }
	    elsif ($pnode->_needslinkdelay()) {
		$cmdline = $self->osidbootcmd($osid, "linkdelay", "");
	    }
	    elsif ($virtnode->_isbridge()) {
		# Allow user to override defaults on a per-node basis.
		if (! defined($virtnode->_osinfo())) {
		    $osid = ($self->option("delay_osid") ||
			     $pnode->delay_osid());
		    undef($osinfo);
		}
		$cmdline = $self->osidbootcmd($osid, "delay", "");
		$role = TBDB_RSRVROLE_DELAYNODE();
		$routertype = TBDB_ROUTERTYPE_NONE;
	    }
	    elsif (defined($inner_elab_role) && $inner_elab_role =~ /boss/) {
		$cmdline = $self->osidbootcmd($osid, "linkdelay", "");
	    }
	    if (!defined($cmdline)) {
		tberror("Error determining boot command line for $pnode\n");
		return -1;
	    }
	}
	elsif ($pnode->isvirtnode() || defined($virtnode->sharing_mode())) {
	    # in some situations we don't allow a user-specified command line
	    $cmdline = "";
	}
	if (!$pnode->isvirtnode() &&
	    defined($virtnode->sharing_mode()) &&
	    $virtnode->sharing_mode() eq "shared_local") {
	    $role = "sharedhost";
	    $sharing_mode = "shared_local";
	    $cmdline = $self->osidbootcmd($osid, "vnodehost", "")
		if (!defined($cmdline) || $cmdline eq "");
	}
	#
	# NOTE: We no longer include tarballs and RPMs in this update,
	# because they are now handled by tarfiles_setup
	#
	%nodesets = ("def_boot_cmd_line" => $cmdline,
		     "bootstatus"        => 'unknown',
		     # This is no longer used for anything.
		     "deltas"            => '', 
		     "ready"             => 0,
		     "startupcmd"        => $startupcmd || '',
		     "loadlist"          => $loadlist || '',
		     "failureaction"     => $failureaction,
		     "routertype"        => $routertype);
	# They never report status, need to set them.
	if (defined($virtnode->_blockstore())) {
	    $nodesets{"startstatus"} = 0;
	}
	elsif (!exists($self->oldreservednodes()->{$pnodename})) {
	    $nodesets{"startstatus"} = 'none';
	}
		
	%rsrvsets = ("vname"             => $vnodename,
		     "erole"             => $role,
		     "plab_role"         => $plab_role);
	$rsrvsets{"inner_elab_role"} = $inner_elab_role
	    if (defined($inner_elab_role));
	$rsrvsets{"sharing_mode"} = $sharing_mode
	    if (defined($sharing_mode));


    }
    $self->printdb("InitPnode: Storing info for $pnodename,$vnodename\n");

    # Do this in regression mode to avoid timestamp diffs
    if ($self->regression()) {
	$rsrvsets{"rsrv_time"} = 0;
    }
    if ($self->verbose()) {
	my $setstr = join(",",
			  map("$_='" . $nodesets{$_} . "'", keys(%nodesets)));
	$self->printdb("  $setstr\n");
    }
    $pnode->Update(\%nodesets) == 0
	or return -1 if (! ($self->impotent() || $self->alloconly()));

    if ($self->verbose()) {
	my $setstr =
	    join(",", map("$_='" . $rsrvsets{$_} . "'", keys(%rsrvsets)));
	$self->printdb("  $setstr\n");
    }
    $pnode->ModifyReservation(\%rsrvsets) == 0
	or return -1 if (! ($self->impotent() || $self->alloconly()));
    
    #
    # Now call os_select.
    #
    if (defined($osid) && (!$pnode->isremotenode()
			   || $pnode->isdedicatedremote())) {
	# osselect wants an osinfo/osimage object, but we do not always have
	# that. See above.
	if (!defined($osinfo)) {
	    $osinfo = OSImage->Lookup($osid);
	    if (!defined($osinfo)) {
		tberror("Could not map $osid to OSimage object\n");
		return -1;
	    }
	}
	#
	# Map generic OSID to the specific one.
	#
	if ($osinfo->IsGeneric()) {
	    my $tmp = $osinfo->ResolveNextOSID($self->experiment());
	    if (!defined($tmp)) {
		tberror("Could not resolve specific osid for $osinfo on $pnode!\n");
		return -1;
	    }
	    $osinfo = $tmp;
	}
	elsif ($osinfo->isImageAlias()) {
	    #
	    # Map the alias to the type specific image.
	    #
	    $osinfo = $osinfo->MapToImage($pnode->type());
	}
	#
	# If the node is in RES_READY (already in the experiment, this
	# is a swapmod), check to see if the node is running an older
	# version of the same OS. If it is, we do not want to change it,
	# since then it will get reloaded. Consider, if a system image
	# is updated and released (version number changes), any nodes
	# running the previously released image in an experiment, will
	# get reloaded during a swapmod, and 99.9 percent of the time,
	# that is not what users expect or want.
	#
	if ($pnode->allocstate() eq TBDB_ALLOCSTATE_RES_READY()) {
	    my ($curosinfo) = $pnode->RunningOsImage();
	    if (defined($curosinfo) &&
		$curosinfo->osid() == $osinfo->osid() &&
		$curosinfo->vers() != $osinfo->vers()) {
		$self->printdb("  Not changing to different version ".
			       "of $curosinfo\n");
		$osinfo = $curosinfo;
	    }
	}
	
	if ($self->impotent() || $self->alloconly()) {
	    $self->printdb("  pretending to os_select $osinfo\n");
	}
	else {
	    $self->printdb("  os_select $osinfo\n");

	    if ($pnode->OSSelect($osinfo, "def_boot_osid", $self->verbose())) {
		tberror("OSSelect($pnode,$osinfo) failed\n");
		return -1;
	    }
	}
    }
    # Clear this after os_select.
    if ($self->regression()) {
	DBQueryFatal("update nodes set state_timestamp=0, ".
		     "    op_mode_timestamp=0,allocstate_timestamp=0 ".
		     "where node_id='$pnodename'");
    }
    return 0;
}

#
# This is special. Look at the osid of the virtnodes on this pnode and
# map to a suitable osid.
#
sub nodejailosinfo($$)
{
    my ($self, $virtnode) = @_;

    #
    # We know at this point that all vnodes on this pnode want the same
    # osid (at least, the same vhost osid :-)) cause of assign (osid 
    # features/desires). 
    #
    my $osinfo    = $virtnode->_osinfo();

    $self->printdb("nodejailosid: $virtnode, $osinfo\n");

    #
    # The old method was to use nextosid, but the new method uses
    # the subos stuff.
    #
    my $nextosinfo = $osinfo->DefaultParent();
    if (defined($nextosinfo)) {
	$self->printdb("Mapping VM osinfo $osinfo to ".
		       "$nextosinfo on $virtnode\n");
    }
    else {
	tbwarn("nodejailosid: Could not map $osinfo on $virtnode\n");
    }
    return $nextosinfo;
}

sub osidbootcmd($$$$)
{
    my ($self, $osid, $role, $default) = @_;

    my $osimage = OSImage->Lookup($osid);
    if (!defined($osimage)) {
	tbwarn("No such OSID $osid\n");
	return undef;
    }
    if (defined($osimage->nextosid())) {
	$osimage = $osimage->ResolveNextOSID($self->experiment());
	return undef
	    if (!defined($osimage));
    }
    return undef
	if ($osimage->OSBootCmd($role, \$default) != 0);
    return $default;
}

#
# Takes vnode, pnode as arguments
# and determines the correct routing table id
#
sub getrtabid($$$)
{
    my ($self, $pnode, $member) = @_;
    my $rtabid;
    my $vnodename = $member->vnode();
    my $numvnodesonpnode =
	scalar(@{ $self->solution_p2v()->{$pnode->node_id()} });

    if ($numvnodesonpnode > 1 || $pnode->_sharedhost()) {
	if (! exists($self->solution_rtabmap()->{$vnodename})) {
	    if ($pnode->_sharedhost() &&
		!($self->impotent() || $self->alloconly())) {
		$rtabid = $pnode->Nextrtabid();
	    }
	    else {
		$rtabid = $pnode->_rtabid();
		$pnode->_rtabid($rtabid + 1);
	    }
	    $self->solution_rtabmap()->{$vnodename} = $rtabid;
	}
	else {
	    $rtabid = $self->solution_rtabmap()->{$vnodename};
	}
    }
    else {
	$rtabid = $self->solution_rtabmap()->{$vnodename} = 0;
    }
    return $rtabid;
}


sub NewVirtIface($$$$;$)
{
    my ($self, $virtlan, $member, $pnodename, $pport) = @_;

    my $lan       = $virtlan->vname();
    my $pnode     = $self->pnodes()->{$pnodename};
    my $vnodename = $member->vnode();
    my $ip        = $member->ip();
    my $mask      = $member->mask();
    my $encap     = $virtlan->_encapstyle();
    my $isveth    = (($encap eq "veth" || $encap eq "veth-ne") ? 1 : 0);
    my $vllidx    = $virtlan->idx();
    my $rtabid    = $self->getrtabid($pnode, $member);
    my $exptidx   = $self->experiment()->idx();
    my $isvnode   = exists($self->solution_v2v()->{$vnodename});
    my $vvnode;
    my $isvdev;
    my $type;

    #
    # Special actions for virtnodes (as opposed to just emulated links).
    #
    if ($isvnode) {
	#
	# XXX type should be either veth or vlan
	#
	$type = $encap;
	if (!$isveth && $type ne "vlan") {
	    tbwarn("whacked encap type '$type' for vnode, ".
		   "setting to 'veth' instead\n");
	    $type = "veth";
	    $isveth = 1;
	}
	$isvdev = 1;

	# to the nodes table entry for the virtnode. 
	$vvnode = $self->solution_v2v()->{$vnodename};
    }
    else {
	#
	# For multiplexed links, the default is no encapsulation,
	# aka "alias".
	#
	$type = $encap;
	if ($type eq "default" || $type eq "alias") {
	    $type = "alias";
	    $isvdev = 0;
	}
	else {
	    $isvdev = 1;
	}
    }

    #
    # Create new virtiface in the DB.
    #
    my %argref = ("mac"    => "genfake",
		  "IP"     => $ip,
		  "mask"   => $mask,
		  "type"   => $type,
		  "rtabid" => $rtabid,
		  "exptidx" => $exptidx,
		  "virtlanidx" => $vllidx,
	      );
    $argref{"iface"} = $pport
	if (defined($pport));
    $argref{"vnode_id"} = $vvnode
	if (defined($vvnode));

    my $virtiface = ($self->impotent() || $self->alloconly() ?
		     Interface::VInterface->MakeFake($pnodename, \%argref) :
		     Interface::VInterface->Create($pnodename, \%argref));
    if (!defined($virtiface)) {
	return undef;
    }
    $self->printdb("$virtiface: $member, ".
		   "isvdev:$isvdev, isveth:$isveth" .
		   (defined($pport) ? ", pport:$pport" : "") . "\n");
    
    my $newid = $virtiface->unit();

    # Record this vinterface mapping.
    # XXX This should be a list since there are multiple virtifaces per
    # physical member. 
    $self->solution_vifacemap()->{$member} = $virtiface;
    $member->_virtiface($virtiface);
    $virtiface->_member($member);
    $virtiface->_trunk(undef);
    $virtiface->_speed(undef);
    
    #
    # For veth and vlan interfaces, we need to set the characteristics
    # of the underlying physical interface, but only if we actually own
    # the node; it might be on a shared physical node.
    #
    # If the pnode is a shared host, we do not want to do this; the physical
    # interfaces are all set up the right way, do not mess it up. 
    #
    if (defined($pport) && $isvdev &&
	(!$pnode->_sharedhost() || $member->_needtrunk())) {

	# If vlan encap, turn on trunking.
	$virtiface->_trunk(($type eq "vlan") ? 1 : 0);

	# Also set the speed, although if this is a control interface,
	# it will utlimately be ignore.
	$virtiface->_speed(
	    $self->interfacespeedmbps(physinterfacetype($pnode,$pport),
				      "ethernet"));
    }

    #
    # This is to assist with patching up virts. See AddVirtPatch().
    # A LAN of vnodes split across multiple physical machines may
    # not have the correct physical LAN info coming out of assign
    # and may need to be patched up later.
    #
    if (!defined($pport) && $isvnode) {
	$self->solution_vethmap()->{$lan} = {}
	  if (!exists($self->solution_vethmap()->{$lan}));
	$self->solution_vethmap()->{$lan}->{$pnodename} = []
	  if (!exists($self->solution_vethmap()->{$lan}->{$pnodename}));
	
	push(@{ $self->solution_vethmap()->{$lan}->{$pnodename} }, $virtiface);
    }
    return $virtiface;
}

sub AddVirtPatch($$$$)
{
    my ($self, $lan, $pnodename, $pport) = @_;

    $self->printdb("Adding Virt Patch: $lan, $pnodename, $pport\n");

    $self->solution_vethpatch()->{$lan} = {}
        if (!exists($self->solution_vethpatch()->{$lan}));
    
    $self->solution_vethpatch()->{$lan}->{$pnodename} = $pport;
}

#
# Add a delay node entry.
#
sub AddDelay($$$$$$$$$)
{
    my ($self, $virtlan, $member0, $member1, $pnodename,
	$iface0, $iface1, $islan, $params) = @_;

    # Delay Info. 
    my ($delay,$bandwidth,$backfill,$lossrate,
	$rdelay,$rbandwidth,$rbackfill,$rlossrate) = @{$params};

    my $pnode =  $self->pnodes()->{$pnodename};

    # ipfw pipe numbers so we can control it remotely.
    my $pipe0 = $pnode->_pipenumber();
    my $pipe1 = $pipe0 + 10;
    $pnode->_pipenumber($pipe1 + 10);

    my $vnodename0 = $member0->vnode();
    my $vnodename1 = $member1->vnode();
    my $experiment = $self->experiment();
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();
    my $idx = $experiment->idx();
    my $lan = $virtlan->vname();
    my $nobwshaping = $virtlan->_nobwshaping();

    #
    # We allow users to oversubscribe by letting them turn off the
    # bandwidth shaping. If however, if the link was shaped for some
    # other reason (like a delay), then turn off just the bw shaping
    # part by setting them to 0.  This is special; means no limits in
    # ipfw.
    #
    if ($nobwshaping) {
	$bandwidth = $rbandwidth = 0;
    }

    $self->printdb("  Delay: \[$iface0:$pnodename:$iface1 ".
		   "pipes:$pipe0+$pipe1,".
		   "$delay,$bandwidth,$backfill,$lossrate,".
		   "$rdelay,$rbandwidth,$rbackfill,$rlossrate]\n");
    
    #
    # We need to find the queue info. If its a member of a lan, there
    # is just one queue, towards the lan. A duplex link has two queues,
    # one for each member (outgoing side).
    #
    if (!$islan) {
	my ($q0_limit,$q0_maxthresh,$q0_minthresh,$q0_weight,$q0_linterm,
	    $q0_qinbytes,$q0_bytes,$q0_meanpsize,$q0_wait,$q0_setbit,
	    $q0_droptail,$q0_red,$q0_gentle) = @{ $member0->_queueinfo() };

	my ($q1_limit,$q1_maxthresh,$q1_minthresh,$q1_weight,$q1_linterm,
	    $q1_qinbytes,$q1_bytes,$q1_meanpsize,$q1_wait,$q1_setbit,
	    $q1_droptail,$q1_red,$q1_gentle) = @{ $member1->_queueinfo() };

	#
	# See if this delaynode was inserted strictly for tracing/monitoring.
	#
	my $noshaping = (($virtlan->membershaped($member0) ||
			  $virtlan->membershaped($member1)) ? 0 : 1);
    
	DBQueryWarn("insert into delays " .
	     " (pid,eid,exptidx,node_id,vname,noshaping,iface0,iface1" .
	     ",vlan0,vlan1".
	     ",vnode0,pipe0,delay0,bandwidth0,backfill0,lossrate0" .
	     ",vnode1,pipe1,delay1,bandwidth1,backfill1,lossrate1" .
	     ",q0_limit,q0_maxthresh,q0_minthresh,q0_weight,q0_linterm" .
	     ",q0_qinbytes,q0_bytes,q0_meanpsize,q0_wait,q0_setbit" .
	     ",q0_droptail,q0_red,q0_gentle" .
	     ",q1_limit,q1_maxthresh,q1_minthresh,q1_weight,q1_linterm" .
	     ",q1_qinbytes,q1_bytes,q1_meanpsize,q1_wait,q1_setbit" .
	     ",q1_droptail,q1_red,q1_gentle)" .
	     " values ('$pid','$eid','$idx','$pnodename','$lan' ".
	     ",$noshaping,'$iface0','$iface1','$lan','$lan'".
	     ",'$vnodename0',$pipe0,$delay,$bandwidth,$backfill,$lossrate".
	     ",'$vnodename1',$pipe1,$rdelay,$rbandwidth,$rbackfill,$rlossrate".
	     ",$q0_limit,$q0_maxthresh,$q0_minthresh,$q0_weight,$q0_linterm".
	     ",$q0_qinbytes,$q0_bytes,$q0_meanpsize,$q0_wait,$q0_setbit".
	     ",$q0_droptail,$q0_red,$q0_gentle".
  	     ",$q1_limit,$q1_maxthresh,$q1_minthresh,$q1_weight,$q1_linterm".
	     ",$q1_qinbytes,$q1_bytes,$q1_meanpsize,$q1_wait,$q1_setbit".
	     ",$q1_droptail,$q1_red,$q1_gentle)")
	    or return -1 if (! ($self->impotent() || $self->alloconly()));
    }
    else {
	my ($q0_limit,$q0_maxthresh,$q0_minthresh,$q0_weight,$q0_linterm,
	    $q0_qinbytes,$q0_bytes,$q0_meanpsize,$q0_wait,$q0_setbit,
	    $q0_droptail,$q0_red,$q0_gentle) = @{ $member0->_queueinfo() };

	#
	# See if this delaynode was inserted strictly for tracing/monitoring.
	#
	my $noshaping = ($virtlan->membershaped($member0) ? 0 : 1);
    
	#
	# Obviously, its implied that the q0 params are towards the lan,
	# For the reverse side, force the queue to 2 slots (should be 1
	# but dummynet not quite precise enough) to avoid excess queuing
	# delay since the traffic should already be at the proper bandwidth
	# when it gets to the node.
	#
	DBQueryWarn("insert into delays" .
	     " (pid,eid,exptidx,node_id,vname,noshaping,iface0,iface1," .
	     "  vlan0,vlan1,".
	     "  vnode0,pipe0,delay0,bandwidth0,backfill0,lossrate0," .
	     "  vnode1,pipe1,delay1,bandwidth1,backfill1,lossrate1," .
	     "  q0_limit,q0_maxthresh,q0_minthresh,q0_weight,q0_linterm," .
	     "  q0_qinbytes,q0_bytes,q0_meanpsize,q0_wait,q0_setbit," .
	     "  q0_droptail,q0_red,q0_gentle,q1_limit,q1_qinbytes) " .
	     " values ('$pid','$eid','$idx','$pnodename','$lan', ".
	     "  $noshaping,'$iface0','$iface1','$lan','$lan',".
	     "  '$vnodename0',$pipe0,$delay,$bandwidth,$backfill,$lossrate,".
	     "  '$vnodename1',$pipe1,$rdelay,$rbandwidth,$rbackfill,$rlossrate,".
	     "  $q0_limit,$q0_maxthresh,$q0_minthresh,$q0_weight,$q0_linterm,".
	     "  $q0_qinbytes,$q0_bytes,$q0_meanpsize,$q0_wait,$q0_setbit,".
	     "  $q0_droptail,$q0_red,$q0_gentle,2,0)")
	    or return -1 if (! ($self->impotent() || $self->alloconly()));
    }

    #
    # XXX - Whenever a delay node is inserted, port speeds are set to
    #       their maximum speed on the delay node ports. This is to ensure that
    #       they get a valid number instead of something left over, but
    #       also because this is a simplification.
    #       At some point we might want to force all the
    #       ports along the way to 10Mbs, and have the delay node worry
    #       about delay only, and not bandwidth. That will be harder to
    #       to do in this mess. See companion XXX above where portbw hash
    #       is set.
    #
    my $speed0 =
	$self->interfacespeedmbps(physinterfacetype($pnode, $iface0),
				  "ethernet");
    my $speed1 =
	$self->interfacespeedmbps(physinterfacetype($pnode, $iface1),
				  "ethernet");

    $self->printdb("  Setting port speeds on $pnodename: ".
		   "$iface0:$speed0 $iface1:$speed1\n");

    DBQueryWarn("update interfaces set " .
		"current_speed='$speed0' " .
		"where node_id='$pnodename' and ".
		"iface='$iface0'")
	or return -1 if (!($self->impotent() || $self->alloconly()));

    DBQueryWarn("update interfaces set " .
		"current_speed='$speed1' " .
		"where node_id='$pnodename' and ".
		"iface='$iface1'")
	or return -1 if (!($self->impotent() || $self->alloconly()));

    return 0;
}

#
# Link delays. These are done differently than delays. A link delay is
# a delay that is established at the endpoints of the link, instead of
# on a delay node. So, in a duplex link, there would be a traffic
# shaping rule on each output side of the link. On a lan, there are
# two rules, one for traffic to the switch, and one for traffic from
# the switch. Like above, there are also queues associated with output
# side (to the switch) of a link.
#
sub AddLinkDelay($$$$$$)
{
    my ($self, $virtlan, $member, $pnodename, $iface, $islan, $params) = @_;

    # backfill unsupported for linkdelays so ignore its entry in params.
    my ($delay,$bandwidth,$backfill,$lossrate,
	$rdelay,$rbandwidth,$rbackfill,$rlossrate) = @{$params};

    #
    # We need to find the queue info. If its a member of a lan, there
    # is just one queue, *towards* the lan. A duplex link has two queues,
    # one for each member (outgoing side).
    #
    my ($q_limit,$q_maxthresh,$q_minthresh,$q_weight,$q_linterm,
	$q_qinbytes,$q_bytes,$q_meanpsize,$q_wait,$q_setbit,
	$q_droptail,$q_red,$q_gentle) = @{ $member->_queueinfo() };

    my $pnode =  $self->pnodes()->{$pnodename};

    # Mark pnode for alternate kernel.
    $pnode->_needslinkdelay(1);
    # Stats.
    $self->exptstats()->{"linkdelays"} += 1;

    # ipfw pipe numbers so we can control it remotely.
    my $pipe  = $pnode->_pipenumber();
    my $rpipe = $pipe + 10;
    $pnode->_pipenumber($rpipe + 10);

    my $vnodename  = $member->vnode();
    my $mask       = $member->mask();
    my $ip         = $member->ip();
    my $experiment = $self->experiment();
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();
    my $idx = $experiment->idx();
    my $lan = $virtlan->vname();
    my $nobwshaping = $virtlan->_nobwshaping();

    #
    # We allow users to oversubscribe by letting them turn off the
    # bandwidth shaping. If however, if the link was shaped for some
    # other reason (like a delay), then turn off just the bw shaping
    # part by setting them to 0.  This is special; means no limits in
    # ipfw.
    #
    if ($nobwshaping) {
	$bandwidth = $rbandwidth = 0;
    }

    $self->printdb("  LinkDelay: \[$pipe,$rpipe," .
		   "$virtlan,$delay,$bandwidth,$backfill,$lossrate".
		   ($islan ? "$rdelay,$rbandwidth,$rbackfill,$rlossrate" : "").
		   "\]\n");

    return 0
	if ($self->impotent() || $self->alloconly());

    DBQueryWarn("insert into linkdelays " .
		" (node_id,iface,type,ip,netmask,exptidx,pid,eid,vlan, ".
		"  vnode,pipe,delay,bandwidth,lossrate, ".
		"  q_limit,q_maxthresh,q_minthresh,q_weight, ".
		"  q_linterm,q_qinbytes,q_bytes,q_meanpsize, ".
		"  q_wait,q_setbit,q_droptail,q_red,q_gentle) ".
		" values " .
		" ('$pnodename','$iface','simplex','$ip','$mask', ".
		"  '$idx', '$pid','$eid', ".
		"  '$lan','$vnodename',$pipe,$delay,$bandwidth,$lossrate, ".
		"  $q_limit,$q_maxthresh,$q_minthresh,$q_weight, ".
		"  $q_linterm,$q_qinbytes,$q_bytes,$q_meanpsize, ".
		"  $q_wait,$q_setbit,$q_droptail,$q_red,$q_gentle)")
	or return -1;
    
    #
    # If its a lan, add the from-switch stuff. On the node, the ipfw
    # pipe that is built for this will need to specify a queue size of 1.
    #
    if ($islan) {
	DBQueryWarn("update linkdelays set ".
		    " rpipe=$rpipe,rdelay=$rdelay,rbandwidth=$rbandwidth, ".
		    " rlossrate=$rlossrate,type='duplex' ".
		    "where node_id='$pnodename' and ".
		    "      vlan='$lan' and vnode='$vnodename'")
	    or return -1;
    }
    return 0;
}

#
# Add a bridge. At the moment, bridges are just delay nodes. 
#
sub AddBridge($$$$)
{
    my ($self, $bridgename, $member0, $member1) = @_;
    my $iface0 = $member0->_pport();
    my $iface1 = $member1->_pport();
    my $pnodename = $member0->_pnode();
    my $pnode =  $self->pnodes()->{$pnodename};
    my $lan0  = $member0->virt_lan()->vname();
    my $lan1  = $member1->virt_lan()->vname();

    # Bridge index, multiple rows in the table under the same index.
    my $bridgeidx = $pnode->_pipenumber();
    $pnode->_pipenumber($bridgeidx + 1);

    # ipfw pipe numbers.
    my $pipe0 = $pnode->_pipenumber();
    my $pipe1 = $pipe0 + 10;
    $pnode->_pipenumber($pipe1 + 10);

    my $vnodename0 = $member0->vnode();
    my $vnodename1 = $member1->vnode();
    my $experiment = $self->experiment();
    my $pid   = $experiment->pid();
    my $eid   = $experiment->eid();
    my $idx   = $experiment->idx();

    # The name of the bridge (as for the delay agent).
    my $vname = $bridgename;

    $self->printdb("  Bridge:$bridgeidx $iface0:$pnodename:$iface1\n");

    # Grab the queue info.
    my ($q0_limit,$q0_maxthresh,$q0_minthresh,$q0_weight,$q0_linterm,
	$q0_qinbytes,$q0_bytes,$q0_meanpsize,$q0_wait,$q0_setbit,
	$q0_droptail,$q0_red,$q0_gentle) = @{ $member0->_queueinfo() };

    my ($q1_limit,$q1_maxthresh,$q1_minthresh,$q1_weight,$q1_linterm,
	$q1_qinbytes,$q1_bytes,$q1_meanpsize,$q1_wait,$q1_setbit,
	$q1_droptail,$q1_red,$q1_gentle) = @{ $member1->_queueinfo() };

    #
    # And the shaping params. Since this bridge mimics the delay for
    # a duplex link, we only use the "forward" params from each
    # member.
    #
    my ($delay,$bandwidth,undef,$backfill,$lossrate)      =
	@{ $member0->_delayinfo() };
    my ($rdelay,$rbandwidth,undef,$rbackfill,$rlossrate)  =
	@{ $member1->_delayinfo() };

    # See if the user wants the bw shaping to be disabled.
    $bandwidth = 0
	if ($member0->nobwshaping());
    $rbandwidth = 0
	if ($member1->nobwshaping());

    # We now allow bridges to work with vinterfaces (vlan encap).
    my $viface_unit0 = "null";
    my $viface_unit1 = "null";
    if (defined($member0->_virtiface())) {
	$viface_unit0 = $member0->_virtiface()->unit();
    }
    if (defined($member1->_virtiface())) {
	$viface_unit1 = $member1->_virtiface()->unit();
    }

    #
    # We are inserting the bridge, but it might not be for shaping.
    # Maybe for tracing. We use the estimated bandwidth field to
    # signal this, but need a better approach.
    #
    my $noshaping = (defined($member0->est_bandwidth()) ||
		     defined($member1->est_bandwidth()) ? 0 : 1);

    $self->printdb("  Shaping: $lan0: $pipe0,$delay,$bandwidth,$lossrate\n".
		   "           $lan1: $pipe1,$rdelay,$rbandwidth,$rlossrate\n")
	if (!$noshaping);
    
    DBQueryWarn("insert into delays " .
		" (pid,eid,exptidx,node_id,vname,noshaping,iface0,iface1" .
		",vlan0,vlan1,isbridge,viface_unit0,viface_unit1".
		",vnode0,pipe0,delay0,bandwidth0,backfill0,lossrate0" .
		",vnode1,pipe1,delay1,bandwidth1,backfill1,lossrate1" .
		",q0_limit,q0_maxthresh,q0_minthresh,q0_weight,q0_linterm" .
		",q0_qinbytes,q0_bytes,q0_meanpsize,q0_wait,q0_setbit" .
		",q0_droptail,q0_red,q0_gentle" .
		",q1_limit,q1_maxthresh,q1_minthresh,q1_weight,q1_linterm" .
		",q1_qinbytes,q1_bytes,q1_meanpsize,q1_wait,q1_setbit" .
		",q1_droptail,q1_red,q1_gentle)" .
		" values ('$pid','$eid','$idx','$pnodename','$vname' ".
		",$noshaping,'$iface0','$iface1','$lan0','$lan1',1".
		",$viface_unit0,$viface_unit1".
		",'$vnodename0',$pipe0,$delay,$bandwidth,$backfill,$lossrate".
		",'$vnodename1',$pipe1,$rdelay,$rbandwidth,$rbackfill".
		",$rlossrate".
		",$q0_limit,$q0_maxthresh,$q0_minthresh,$q0_weight,$q0_linterm".
		",$q0_qinbytes,$q0_bytes,$q0_meanpsize,$q0_wait,$q0_setbit".
		",$q0_droptail,$q0_red,$q0_gentle".
		",$q1_limit,$q1_maxthresh,$q1_minthresh,$q1_weight,$q1_linterm".
		",$q1_qinbytes,$q1_bytes,$q1_meanpsize,$q1_wait,$q1_setbit".
		",$q1_droptail,$q1_red,$q1_gentle)")
	or return -1 if (! ($self->impotent() || $self->alloconly()));

    #
    # Check for tracing.
    #
    my ($traced0, $endnode0, $trace_type0, $trace_expr0,
	$trace_snaplen0, $trace_db0) = @{ $member0->_traceinfo() };

    if ($traced0) {
	#
	# Must find the other end of the link, since a trace works by
	# capturing packets *leaving* the other side. 
	#
	my $omember = ($member0->virt_lan()->member(0) eq "$member0" ?
		       $member0->virt_lan()->member(1) :
		       $member0->virt_lan()->member(0));
	
	$self->printdb("  Trace: $member0: $omember,$pnodename,$iface0,$iface1\n");
	my $vname = $member0->virt_lan()->vname();
	my $vnode = $omember->virt_node()->vname();

	DBQueryWarn("insert into traces ".
		    " (node_id, idx, iface0, iface1, pid, eid, exptidx, ".
		    "  linkvname, vnode, trace_type, trace_expr, ".
		    "  trace_snaplen, trace_db) ".
		    "values ".
		    "  ('$pnodename', 0, '$iface0', '$iface1','$pid','$eid', ".
		    "   '$idx', '$vname', '$vnode', ".
		    "   '$trace_type0', '$trace_expr0', $trace_snaplen0, ".
		    "   '$trace_db0')")
	    or return -1 if (! ($self->impotent() || $self->alloconly()));
    }
    
    my ($traced1, $endnode1, $trace_type1, $trace_expr1,
	$trace_snaplen1, $trace_db1) = @{ $member1->_traceinfo() };

    if ($traced1) {
	#
	# Must find the other end of the link, since a trace works by
	# capturing packets *leaving* the other side. 
	#
	my $omember = ($member1->virt_lan()->member(0) eq "$member1" ?
		       $member1->virt_lan()->member(1) :
		       $member1->virt_lan()->member(0));
	
	$self->printdb("  Trace: $member1: $omember,$pnodename,$iface1,$iface0\n");
	my $vname = $member1->virt_lan()->vname();
	my $vnode = $omember->virt_node()->vname();

	DBQueryWarn("insert into traces ".
		    " (node_id, idx, iface0, iface1, pid, eid, exptidx, ".
		    "  linkvname, vnode, trace_type, trace_expr, ".
		    "  trace_snaplen, trace_db) ".
		    "values ".
		    "  ('$pnodename', 0, '$iface1', '$iface0','$pid','$eid', ".
		    "   '$idx', '$vname', '$vnode', ".
		    "   '$trace_type1', '$trace_expr1', $trace_snaplen1, ".
		    "   '$trace_db1')")
	    or return -1 if (! ($self->impotent() || $self->alloconly()));
    }
    
    #
    # XXX - Whenever a bridge node is inserted, port speeds are set to
    #       their maximum speed on the ports. This is to ensure that
    #       they get a valid number instead of something left over, but
    #       also because this is a simplification.
    my $speed0 =
	$self->interfacespeedmbps(physinterfacetype($pnode, $iface0),
				  "ethernet");
    my $speed1 =
	$self->interfacespeedmbps(physinterfacetype($pnode, $iface1),
				  "ethernet");

    $self->portbw()->{$member0} = $speed0 * 1000;
    $self->portbw()->{$member1} = $speed1 * 1000;

    $self->printdb("  Setting port speeds on $pnodename: ".
		   "$iface0:$speed0 $iface1:$speed1\n");

    DBQueryWarn("update interfaces set " .
		"current_speed='$speed0' " .
		"where node_id='$pnodename' and ".
		"iface='$iface0'")
	or return -1 if (!($self->impotent() || $self->alloconly()));

    DBQueryWarn("update interfaces set " .
		"current_speed='$speed1' " .
		"where node_id='$pnodename' and ".
		"iface='$iface1'")
	or return -1 if (!($self->impotent() || $self->alloconly()));

    return 0;
}

#
# Setup tracing on a link.
#
sub SetUpTracing($$$$$)
{
    my ($self, $virtlan, $member, $pnodename, $iface0, $iface1) = @_;
    my $vnodename = $member->vnode();

    # Bridged links handled elsewhere.
    return 0
	if ($virtlan->_bridged());

    #
    # Handle virtual nodes - in some cases (ie. PlanetLab), we have to
    # look in v2vmap to find out which node we got placed on.
    #
    if (exists($self->solution_v2v()->{$vnodename})) {
        $pnodename = $self->solution_v2v()->{$vnodename};
    }

    #
    # First see if this member of the lan wanted tracing. 
    #
    my ($traced, $endnode, $trace_type, $trace_expr,
	$trace_snaplen, $trace_db) = @{ $member->_traceinfo() };

    return 0
	if (!$traced);

    # This means its on an end node.
    $iface0 = ""
	if (!defined($iface0));

    $self->printdb("Trace: $virtlan, $member, ".
		   "$endnode, $pnodename, $iface0, $iface1\n");

    return 0
	if ($self->impotent() || $self->alloconly());

    my $experiment = $self->experiment();
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();
    my $idx = $experiment->idx();
    my $lan = $virtlan->vname();

    DBQueryWarn("insert into traces ".
		 " (node_id, idx, iface0, iface1, pid, eid, exptidx, ".
		 "  linkvname, vnode, trace_type, trace_expr, trace_snaplen, ".
		 "  trace_db) ".
		 "values ".
		 "  ('$pnodename', 0, '$iface0', '$iface1', '$pid', '$eid', ".
		 "   '$idx', '$lan', '$vnodename', ".
		 "   '$trace_type', '$trace_expr', $trace_snaplen, ".
		 "   '$trace_db')")
	or return -1;
    
    return 0;
}

#
# Look for shared entities that require special IP address treatment.
# This usually means getting a new mutually exclusive address range,
# reserving it for this experiment in the database.  Substitute
# addresses on co-located link/lan members to accomodate.  This
# reservation purposely does _NOT_ persist across swapins.
#
sub CheckIPAddressReservations($) {
    my ($self) = @_;

    # For stashing lans we need to take a closer look at.
    my @sharedlans = ();

    $self->printdb("Checking IP Address Reservations.\n");

    # Round 1, peel off lans that contain members that need special
    # address treatment.  These lans could probably be marked when
    # such a node is added to them, but doing it here keeps this
    # procedure self-contained.
  virtlans:
    foreach my $virtlan (values(%{ $self->vlans() })) {
	next
	    if ($virtlan->_layer() != 2);  # foo from the beyond.

	foreach my $member ($virtlan->memberlist()) {
	    my $vnodename = $member->vnode();
	    my $virtnode  = $member->virt_node();
	    my $vtype     = $virtnode->type();
	    # XXX: This isn't quite right.  Need to figure out how to
	    # check to see if the current lan member is attached to a
	    # 'sanhost', but I can't figure out the right path through
	    # the libvtop objects...
	    if ($vtype eq "blockstore") {
		push @sharedlans, $virtlan;
		next virtlans;
	    }
	}
    }

    # Round 2: re-assign addresses using the IP buddy allocator, via
    # its testbed wrapper.  Note that this amends the addresses assigned
    # in the virt_lans table as well.
    if (@sharedlans) {
	$self->printdb("Modifying address allocations for: ".
		       join(", ", map { $_->vname() } @sharedlans) .
		       "\n");
	require Socket;
	# Don't pull this module in until now to avoid unnecessary
	# dependencies.  If we find ourselves using it in other places,
	# then move this up to package scope.
	require IPBuddyWrapper;
	# Tie this buddy allocator to the "storage_pool" global address range.
	my $buddy = IPBuddyWrapper->new("storage_pool");
	return -1 
	    unless defined($buddy);
	# Grab the reserved addresses buddy allocator lock.
	$buddy->lock() 
	    or return -1;
	# Now preload the reservations in the DB, including those associated
	# with this experiment.  The buddy allocator will allocate around
	# these.
	if ($buddy->loadReservedRanges($self->experiment())) {
	    $buddy->unlock();
	    return -1;
	}

	foreach my $virtlan (@sharedlans) {
	    my $vlanname    = $virtlan->vname();
	    my @members     = $virtlan->memberlist();
	    my $hbits       = 1;

	    # Figure out how many host bits this lan actually needs.
	    # XXX: This is only compatible with IPv4
	    while (scalar(@members)+2 > 2**$hbits) {
		$hbits++;
	    }
	    if ($hbits > 24) {
		tberror("Lan $vlanname has too many members!\n");
		$buddy->unlock();
		return -1;
	    }
	    my $prefix = 32 - $hbits;
	    my $newmask = Socket::inet_ntoa(pack("B32", "1" x $prefix));
	    $virtlan->_mask($newmask);
	    
	    my $range       = $buddy->requestAddressRange($self->experiment(),
							  $prefix);
	    if (!defined($range)) {
		$buddy->unlock();
		return -1;
	    }
	    $self->printdb("Reserved shared address range for ".
			   "$vlanname: $range\n");

	    # Got a new reserved range, so re-IP members of this lan.
	    foreach my $member (@members) {
		# Grab some info/objects for the current lan member.
		my $vmember   = $member->virt_member();
		my $ip        = $vmember->ip();
		my $vnodename = $vmember->vnode();

		# re-IP this member.  Push back into the virt_lans
		# table; otherwise, things that expect the IP set
		# there to match what is set in the
		# interfaces/vinterfaces table will go wonky.
		my $new_ip = $buddy->getNextAddress($range);
		if (!defined($new_ip)) {
		    tberror("Could not get an address in range: $range\n");
		    $buddy->unlock();
		    return -1;
		}
		$self->printdb("$vnodename: $ip -> $new_ip\n");
		$vmember->ip($new_ip);
		$vmember->mask($newmask);
		# Replace the virt_lans row.  It already exists, so an insert
		# would fail.
		my $sflags = $VirtExperiment::STORE_FLAGS_REPLACE;
		$sflags |= $self->verbose() ? 
		    $VirtExperiment::STORE_FLAGS_DEBUG :
		    0;
		$sflags |= $self->impotent() ?
		    $VirtExperiment::STORE_FLAGS_IMPOTENT :
		    0;
		if ($vmember->Store($sflags) != 0 && !$self->impotent()) {
		    tberror("Could not store updated virt_lans row!\n");
		    $buddy->unlock();
		    return -1;
		}
	    }
	}

	# All done with reservations, so commit and unlock.
	$buddy->commitReservations()
	    unless $self->impotent();
	$buddy->unlock();
    }

    return 0;
}

#
# Write the vlans table to the DB.
#
sub UploadVlans($)
{
    my ($self) = @_;
    my $experiment = $self->experiment();
    my $exptidx = $experiment->idx();
    
    #
    # Post process; mark vlans on federated nodes with a different type
    # so that we do not try to create them locally.
    #
    foreach my $protolanA (ProtoLan->ProtoLanList()) {
	next
	    if ($protolanA->type() ne "vlan");

	foreach my $member ($protolanA->MemberList()) {
	    my $node = $protolanA->MemberNode($member);
	    if ($node->isfednode()) {
		$protolanA->SetType("geni-vlan");
		last;
	    }
	}
	foreach my $member ($protolanA->IfaceList()) {
	    my $node = $protolanA->IfaceNode($member);
	    if ($node->isfednode()) {
		$protolanA->SetType("geni-vlan");
		last;
	    }
	}
    }

    #
    # MLE:
    #
    # 1. Set the dependencies on lans so that the underlying segments
    #    are handled by snmpit first.
    # 2. Set the switch path. The user specified the path, so we want to
    #    use that insted of letting snmpit calculate one on the fly. 
    #
    $self->printdb("Setting dependencies for MLE virtlans...\n");
    foreach my $virtlan (values(%{ $self->vlans() })) {
	next
	    if (!$virtlan->_implemented_by());
    
	my $vpath = $virtlan->_implemented_by();
	my @links = $vpath->virtlanlist();

	my $protolink = ProtoLan->Lookup($self->experiment(),
					 $virtlan->vname());
 	
	# If the proto link has an underlying proto vlan, that is 
	# the actual dependency.
	my $protodep = $protolink->link() || $protolink;

	foreach my $link (@links) {
	    my $protolink = ProtoLan->Lookup($self->experiment(), $link->vname());
	    $protolink->SetLink($protodep);
	}

	#
	# Now do the path
	#
	my @switchpath = ();
	
	foreach my $link (@links) {
	    my $logicalwire = $link->_logicalwire();
	    my $pnodeA      = Node->Lookup($logicalwire->node_id1());
	    my $pnodeB      = Node->Lookup($logicalwire->node_id2());
	    if ($pnodeA->isswitch() && $pnodeB->isswitch()) {
		push(@switchpath, $pnodeA->node_id() .":". $pnodeB->node_id());
	    }
	}
	if (@switchpath) {
	    $self->printdb("Switch path for $virtlan: @switchpath\n");
	    $protolink->SetAttribute("switchpath", "@switchpath");
	}
    }

    #
    # Emulated vlans will result in node:port pairs being in more than
    # one vlan since that link is shared for several lans. For hardware
    # implemented 802.1q tagged vlans (type "vlan"), this is ok. But for
    # "veth" implemented vlans, we have to merge the overlapping vlans
    # into "supervlans". Must be done iteratively of course.
    #
    $self->printdb("Dumping protolans before merging.\n");
    ProtoLan->DumpAll()
	if ($self->verbose());
    
    $self->printdb("Merging vlans ...\n");
  again:
    foreach my $protolanA (ProtoLan->ProtoLanList()) {
	my @membersA = $protolanA->MemberList();
	my $keyA     = $protolanA->vname();

	next
	    if (! ($protolanA->type() eq "vlan" &&
		   $protolanA->role() eq "encapsulation" &&
		   $protolanA->encapstyle() ne "vlan"));

	foreach my $protolanB (ProtoLan->ProtoLanList()) {
	    my @membersB = $protolanB->MemberList();
	    my $keyB     = $protolanB->vname();

	    next
		if (! ($protolanB->type() eq "vlan" &&
		       $protolanB->role() eq "encapsulation" &&
		       $protolanB->encapstyle() ne "vlan"));
	    
	    if ($keyA ne $keyB) {
		foreach my $memberA (@membersA) {
		    if (grep {$_ eq $memberA} $protolanB->MemberList()) {
			foreach my $memberB (@membersB) {
			    if (! grep {$_ eq $memberB}
				$protolanA->MemberList()) {
				$protolanA->AddMember(split(":", $memberB));
			    }
			}
			# Must reset the links before killing the old one.
			foreach my $protolan (ProtoLan->ProtoLanList()) {
			    if (defined($protolan->link()) &&
				$protolan->link()->vname()
				   eq $protolanB->vname()) {
				$protolan->SetLink($protolanA);
			    }
			}
			$self->printdb("Merged $protolanB into $protolanA\n");
			if (defined($protolanA->GetAttribute("switchpath")) ||
			    defined($protolanB->GetAttribute("switchpath"))) {
			    $protolanA->SetAttribute("switchpath",
			     AddToSwitchPath($protolanA->GetAttribute("switchpath"),
					     $protolanB->GetAttribute("switchpath")));
			}
			$protolanB->Destroy();
			goto again;
		    }
		}
	    }
	}
    }

    #
    # Compute spanning tree for lan switch paths.
    #
    foreach my $protolan (ProtoLan->ProtoLanList()) {
	my $swpath = $protolan->GetAttribute("switchpath");
	if (defined($swpath) && $swpath ne "") {
	    my @edges  = ();
	    # Convert from string to [[], []]
	    foreach my $edge (split(" ", $swpath)) {
		my ($a,$b) = split(":", $edge);
		push(@edges, [$a, $b]);
	    }
	    @edges  = SpanningTree(\@edges);
	    # Convert back to string.
	    my @swpath = ();
	    foreach my $edge (@edges) {
		my ($a, $b) = @$edge;
		push(@swpath, "$a:$b");
	    }
	    $swpath = join(" ", @swpath);
	    
	    if ($self->verbose()) {
		print STDERR "$protolan Spanning Tree: @swpath\n";
	    }
	    $protolan->SetAttribute("switchpath", $swpath);
	}
    }
    
    if (!($self->impotent() || $self->alloconly())) {
	$self->printdb("Uploading protolans table.\n");
	ProtoLan->DumpAll()
	    if ($self->verbose());
	if (ProtoLan->InstantiateAll($self->regression()) != 0) {
	    tberror("Could not instantiate protolans!\n");
	    return -1;
	}

	my @lans;
	if (Lan->ExperimentLans($experiment, \@lans) != 0) {
	    tberror("Could not get list of all lans for $experiment\n");
	    return -1;
	}
	#
	# Once the lans are instantiated we have to go back and update the
	# vinterfaces table. Eventually I want to roll vinterface creation
	# into lan instantiation.
	#
	foreach my $lan (@lans) {
	    # Only care about encapsulated links.
	    next
		if (! ($lan->type() eq "emulated" ||
		       $lan->GetRole() eq "emulated"));

	    my $virtlan     = $self->vlans()->{$lan->vname()};
	    if (!defined($virtlan)) {
		tberror("Could not find lan $lan in local lan list!\n");
		return -1;
	    }
	    my $virtlanidx  = $virtlan->idx();
	    my $linkedlanid = $lan->lanid();

	    #
	    # An encapsulated lan is linked to the real lan.
	    # A vlan encapsulated link does not have a linked lan;
	    # there is no need for it.
	    #
	    if ($lan->type() eq "emulated") {
		my $linkedlan = $lan->GetLinkedLan();
		if (!defined($linkedlan)) {
		    tberror("Emulated lan $lan does not have a linked vlan!\n");
		    return -1;
		}
		$linkedlanid = $linkedlan->lanid();
		#
		# XXX This is a fix for emulated vlans; We need to insert the
		# openflow attributes that exist for the emulated vlan,
		# into the linked vlan. At some point we need to fix the
		# interp code above, to not create an encapsulation vlan
		# when the encap style is vlan (which is how links are done
		# already).
		#
		if ($linkedlan->type() eq "vlan" && $virtlan->_ofenabled()) {
		    $linkedlan->SetAttribute("ofenabled", "1");
		    $linkedlan->SetAttribute("ofcontroller",
					     $virtlan->_ofcontroller());
		    $linkedlan->SetAttribute("oflistener", "");
		}
	    }
	    DBQueryWarn("update vinterfaces set vlanid='$linkedlanid' ".
			"where virtlanidx='$virtlanidx' and ".
			"      exptidx='$exptidx'")
		or return -1;
	}

	#
	# Set the trunk/speed for any physical ports so marked.
	#
	foreach my $lan (@lans) {
	    next
		if ($lan->type() ne "vlan");

	    # Set the failureaction on the vlan according to the link/lan.
	    my $lanname;
	    $lan->GetAttribute("link/lan", \$lanname);
	    my $virtlan = $self->vlans()->{$lanname};
	    if (defined($virtlan)) {
		$lan->SetAttribute("failureaction", $virtlan->failureaction());
	    }
	    
	    my @members;
	    if ($lan->MemberList(\@members) != 0) {
		tberror("Could not get member list for $lan\n");
		return -1;
	    }
	    foreach my $member (@members) {
		my $current_speed;
		my $trunk_mode;
		$member->GetAttribute("trunk_mode", \$trunk_mode);
		$member->GetAttribute("current_speed", \$current_speed);

		next
		    if (! (defined($trunk_mode) || defined($current_speed)));
		
		my $interface = $member->GetInterface();
		if (!defined($interface)) {
		    tberror("No interface for $member\n");
		    return -1;
		}
		my $args = {};
		$args->{'current_speed'} = $current_speed
		    if (defined($current_speed));
		if (defined($trunk_mode)) {
		    $args->{'trunk'} = 1;
		    $args->{'trunk_mode'} = $trunk_mode;
		}
		$interface->Update($args) == 0
		    or return -1;
	    }
	}
    }
    else {
	$self->printdb("Dumping final protolans table.\n");
	ProtoLan->DumpAll()
	    if ($self->verbose());
    }

    #
    # Patch up virts.
    #
    foreach my $vname (keys(%{ $self->vlans() })) {
	next
	    if (!exists($self->solution_vethpatch()->{$vname}));

	foreach my $pname (keys(%{ $self->solution_vethmap()->{$vname} })) {
	    next
		if (!exists($self->solution_vethpatch()->{$vname}->{$pname}));

	    my $pport = $self->solution_vethpatch()->{$vname}->{$pname};
	    my $pnode = $self->pnodes()->{$pname};

	    foreach my $viface (@{$self->solution_vethmap()->{$vname}->{$pname}}) {
		#
		# For veth and vlan interfaces, we need to set the
		# characteristics of the underlying physical
		# interface.
		#
		my $speed =
		    $self->interfacespeedmbps(physinterfacetype($pnode, $pport),
					      "ethernet");
		    
		$self->printdb("Virt Patch: ".
			       "$vname $pname $viface $pport $speed\n");

		my $member = $viface->_member();
		$viface->_speed($speed);
		$viface->_trunk(($viface->type() eq "vlan") ? 1 : 0);
		# This is a fake data structure in impotent mode.
		$viface->Update({"iface" => $pport})
		    if (! $self->alloconly());
	    }
	}
    }

    #
    # Upload the port bw to the interfaces table for each iface.
    #
    foreach my $virtlan (values(%{ $self->vlans() })) {
	my $vlanname = $virtlan->vname();

	foreach my $member ($virtlan->memberlist()) {
	    # Will this happen?
	    next
		if (!exists($self->solution_portmap()->{$member}));

	    # XXX NSE checks I do not understand.
	    next
		if (! (exists($self->portbw()->{$member}) &&
		       exists($self->solution_v2p()->{$member->vnode()})));

	    my $iface;
	    my $pnodename;
	    my $interface;
	    my $speed;
	    my $trunk;
	    my $trunk_vlan;
	    my $args = {};

	    if (exists($self->solution_vifacemap()->{$member})) {
		#
		# Need to set the underlying physical interface, but
		# that info is not in portbw cause the member is not a
		# physical interface. 
		#
		my $virtiface = $self->solution_vifacemap()->{$member};
		$iface     = $virtiface->iface();
		$pnodename = $virtiface->node_id();
		$speed     = $virtiface->_speed();
		$trunk     = $virtiface->_trunk();

		# Skip loopback interfaces.
		next
		    if (!defined($iface));

		$interface = Interface->LookupByIface($pnodename, $iface);
		if (!defined($interface)) {
		    tberror("No such interface $pnodename:$iface\n");
		    return -1;
		}

		#
		# Another wrinkle; if this was a trunked vlan on the control
		# network, we have to mark the vlan as dual mode and say
		# what the native vlan is. This is how snmpit knows what to
		# do.
		#
		if ($trunk && $interface->role() eq TBDB_IFACEROLE_CONTROL()) {
		    $trunk_vlan = VLan->LookupInternal("Control");
		    if (!defined($trunk_vlan)) {
			tberror("Could not lookup control vlan\n");
			return -1;
		    }
		    if (!$self->impotent()) {
			my $vlan = VLan->Lookup($self->experiment(),
						$virtiface->_vlanname());
			if (!defined($vlan)) {
			    tberror("Could not lookup vlan for $virtiface\n");
			    return -1;
			}
			$vlan->SetAttribute("trunk_mode", "dual");
			$vlan->SetAttribute("trunk_vlan", $trunk_vlan->lanid());
		    }
		}
		#
		# Do not mess with control interface speeds. 
		#
		if ($interface->role() eq TBDB_IFACEROLE_CONTROL()) {
		    $speed = 0;
		}
	    }
	    else {
		$iface     = $self->solution_portmap()->{$member};
		$pnodename = $self->solution_v2p()->{$member->vnode()};
		$speed     = $self->portbw()->{$member};
		$trunk     = 0;

		$interface = Interface->LookupByIface($pnodename, $iface);
		if (!defined($interface)) {
		    tberror("No such interface $pnodename:$iface\n");
		    return -1;
		}

		my $interface = Interface->LookupByIface($pnodename, $iface);
		if (!defined($interface)) {
		    tberror("No such interface $pnodename:$iface\n");
		    return -1;
		}
		
		#
		# This happens when the user asks assign to give it the
		# default speed ("*" bw in the NS file). Need to assign it
		# from the interface info.
		#
		if (! $speed) {
		    $speed = $self->interfacespeedmbps($interface->type(),
						       $interface->type() eq
						       "P2PLTE" ? "P2PLTE" :
						       "ethernet");
		}
		else {
		    # XXX - the following converts from bps to Mbps
		    # since portbw() is in bps.
		    $speed = $speed / 1000;
		}
	    }
	    my $ifacetype = $interface->type();
	    my $dbgline = "Interface: $pnodename:$iface type:$ifacetype";
	    my $max_speed;

	    my $itype_result =
		DBQueryWarn("select max_speed / 1000 from interface_types ".
			    "where type='$ifacetype'");
	    if ($itype_result && $itype_result->numrows) {
		($max_speed) = int($itype_result->fetchrow_array());
		$dbgline .= " max:$max_speed";
	    }

	    if ($speed) {
		if (defined($max_speed) && $speed > $max_speed) {
		    tbwarn("Illegal interface speed for $pnodename:$iface\n");
		}
		$dbgline .= " speed:$speed";
		$args->{'current_speed'} = $speed;
	    }
	    if ($trunk) {
		$dbgline .= " trunk:$trunk";
		$args->{'trunk'} = 1;
		if (defined($trunk_vlan)) {
		    $args->{'trunk_mode'} = "dual";
		    $dbgline .= ":dual(" . $trunk_vlan->lanid() . ")";
		}
	    }
	    $dbgline .= "\n";

	    if (keys(%{$args})) {
		$self->printdb($dbgline);
		$interface->Update($args) == 0
		    or return -1 if (!($self->impotent() ||
				       $self->alloconly()));
	    }
	}
    }
    return 0;
}

#
# Upload the IP addresses to the interfaces table.
#
sub UpLoadIPAddresses($)
{
    my ($self) = @_;

    # For recording IPs we have seen already.
    my %IPs = ();

    foreach my $virtlan (values(%{ $self->vlans() })) {
	my $vlanname = $virtlan->vname();
	my $mask     = $virtlan->_mask();

	next
	    if (!($virtlan->_layer() == 2 || $virtlan->_layer() == 3 ||
		  ($virtlan->_layer() == 1 && $self->experiment()->geniflags)));

	foreach my $member ($virtlan->memberlist()) {
	    # Will this happen?
	    next
		if (!exists($self->solution_portmap()->{$member}));

	    my $iface = $self->solution_portmap()->{$member};
	    my $vnodename = $member->vnode();

	    if ($member->usevirtiface()) {
		#
		# Emulated links on local virtual nodes use the new
		# veth device.
		#
		# See NewVirtIface() calls. Everything was set up then.
		#
		my $pnodename = $self->solution_v2p()->{$vnodename};
		my $ip        = $member->ip();

		$self->printdb("IP(v): $member - ".
			       "$pnodename:$vnodename:$iface $ip\n");
	    }
	    else {
		#
		# Use IPs above to catch if we have inserted an entry
		# for this pnode/iface yet. If not, insert a normal
		# entry. If so, we want to add a new ipalias for the
		# interface. That is cause assign can cause an interface
		# to be shared between multiple links, and so we need
		# ipaliases on the client side.
		#
		my $pnodename  = $self->solution_v2p()->{$vnodename};
		my $pnode      = $self->pnodes()->{$pnodename};
		my $ip         = $member->ip();
		my $rtabid     = $self->getrtabid($pnode, $member);
		my $pvnodename = undef;

		# Mark as being a jail interface by establishing a connection
		# to the nodes table entry for the virtnode.
		if (exists($self->solution_v2v()->{$vnodename})) {
		    my $pvnode =
			$self->pnodes()->{$self->solution_v2v()->{$vnodename}};

		    if ($pvnode->isjailed()) {
			$pvnodename = $self->solution_v2v()->{$vnodename};
		    }
		}

		if (! exists($IPs{"$pnodename:$iface"})) {
		    $self->printdb("IP: $member - ".
				   (defined($pvnodename) ? "$pvnodename:" : "").
				   "$pnodename:$iface $ip\n");
		    
		    #
		    # Never update control net interfaces. This is so
		    # that we can consider them for mapping purposes
		    # (ie. PlanetLab), but don't have to worry about
		    # their IPs getting changed, since that's
		    # important persistent state!
		    #
		    if (physinterfacerole($pnode,$iface) eq
			TBDB_IFACEROLE_CONTROL) {
			$self->printdb("Not setting IP for control interface: ".
				       "$pnode:$iface\n");
		    }
		    else {
			my $vnode_id = (defined($pvnodename) ?
					"'$pvnodename'" : "NULL");
			
			DBQueryWarn("update interfaces set ".
				    "   IP='$ip',IPaliases=NULL,mask='$mask',".
				    "   vnode_id=$vnode_id,rtabid='$rtabid' ".
				    "where node_id='$pnodename' and ".
				    "      iface='$iface'")
			    or return -1 if (!($self->impotent() ||
					       $self->alloconly()));
			    
			$IPs{"$pnodename:$iface"} = 1;
		    }
		}
		else {
		    #
		    # Rather then an IP aliases like we used to do,
		    # tie a virtual interface to it.
		    #
		    my $viface =
			$self->NewVirtIface($virtlan, $member,
					    $pnodename, $iface);

		    $self->printdb("IP: $member - ".
				   "$pnodename:$iface $ip ($viface)\n");
		}
	    }

	    #
	    # Spit out any IP aliases as vinterface table entries.
	    # Note that this is different from the classic use of IP
	    # aliases as a multiplexing mechanism. Here we are setting
	    # up IP aliases that have been explicitly requested by the
	    # user for this node on this lan. IP aliases in this context
	    # can be validly requested and assigned to both physical
	    # and virtual nodes.
	    #
	    # Note well that the MAC addresses used for these IP alias
	    # entries purposely match those of the interfaces on which
	    # they are to be setup on the client-side. This is how the
	    # client-side knows which interface to apply them to.
	    #
	    if ($member->ip_aliases()) {
		my %argref = (
		    mask       => $mask,
		    type       => "alias",
		    iface      => $iface,
		    exptidx    => $self->experiment->idx(),
		    virtlanidx => $virtlan->idx(),
		   );

		my $pnodename  = $self->solution_v2p()->{$vnodename};

		# Grab VM info, if this is a VM that is. 
		if (exists($self->solution_v2v()->{$vnodename})) {
		    $argref{vnode_id} = $self->solution_v2v()->{$vnodename};
		}

		# Is the node connecting via virtual interface? The
		# target inteface for tha alias should have already
		# been created in the vinterfaces table by this time.
		if ($member->usevirtiface()) {
		    my $vif = Interface::VInterface->LookupByVirtLan(
			$self->experiment(), $virtlan->vname(), $vnodename);
		    $argref{mac} = $vif->mac();
		} else {
		    my $pnode    = $self->pnodes()->{$pnodename};
		    my $pif      = Interface->LookupByIface($pnode, $iface);
		    $argref{mac} = $pif->mac();
		}

		my @ip_aliases = split(/,/, $member->ip_aliases());
		foreach my $ipa (@ip_aliases) {
		    $argref{IP} = $ipa;
		    my $aiface = 
			($self->impotent() || $self->alloconly() ?
			 Interface::VInterface->MakeFake($pnodename, \%argref) :
			 Interface::VInterface->Create($pnodename, \%argref));

		    $self->printdb("IP Alias: $member - " .
				   (exists($argref{vnode_id}) ? 
				   $argref{vnode_id} : $pnodename) .
				   ":$argref{mac} $ipa ($aiface)\n");
		}
	    }
	}
    }
    return 0;
}

#
# Upload the tunnels table. These are built for remote node links.
#
sub UpLoadTunnels($)
{
    my ($self) = @_;

    #
    # First need to assign ports to the servers. To do that need to
    # figure out who is a server! We put the server on a real emulab
    # node if possible, and otherwise one of the virtual nodes. Also,
    # we want to share the server amongst more than one link, if
    # possible, since a server can handle more than one tunnel. So,
    # make sure that only one port is assigned per server node.
    #
    my %lantotunnelserver = ();
    my %rnodetotunnelport = ();
    my $secretkey;

    foreach my $virtlan (values(%{ $self->vlans() })) {
	my $server;
	
	next
	    if (! $virtlan->_tunnel());
	next
	    if ($virtlan->_geninodes());

	my @members = $virtlan->memberlist();
	if (@members != 2) {
	    tberror("Too many members for a tunnel!\n");
	    return -1;
	}

	#
	# Pick one of the members to be the server.
	# 
	foreach my $member (@members) {
	    my $virtnode = $member->virt_node();

	    # Start with the first node, but overwrite if better choice.
	    $server = $virtnode
		if (!defined($server) ||
		    (! $virtnode->_isremotenode() &&
		     ! exists($lantotunnelserver{$virtlan})));
	}
	$lantotunnelserver{$virtlan} = $server;

	# Assign a port, but only the first time chosen.
	if (! $rnodetotunnelport{$server}) {
	    my $pnodename = $self->solution_v2p()->{$server->vname()};
	    my $pnode = $self->pnodes()->{$pnodename};
	
	    $rnodetotunnelport{$server} = nextipportnum($pnode);
	}
    }
    foreach my $virtlan (values(%{ $self->vlans() })) {
	next
	    if (! $virtlan->_tunnel());
	next
	    if ($virtlan->_geninodes());

	my $server    = $lantotunnelserver{$virtlan};
	my $ipport    = $rnodetotunnelport{$server};
	my $mask      = $virtlan->_mask();
	my $secretkey = TBGenSecretKey();

	my ($member0,$member1) = $virtlan->memberlist();
	my $virtnode0 = $member0->virt_node();
	my $virtnode1 = $member1->virt_node();
	my $ip0       = $member0->ip();
	my $ip1       = $member1->ip();
	
	
	my $pnodename0 = ($virtnode0->_isvirtnode() ?
			  $self->solution_v2v()->{$virtnode0->vname()} :
			  $self->solution_v2p()->{$virtnode0->vname()});
	my $pnodename1 = ($virtnode1->_isvirtnode() ?
			  $self->solution_v2v()->{$virtnode1->vname()} :
			  $self->solution_v2p()->{$virtnode1->vname()});
	my $pnode0 = $self->pnodes()->{$pnodename0};
	my $pnode1 = $self->pnodes()->{$pnodename1};

	#
	# Need to map the server to the control net interface of the
	# physical node.
	#
	my $peerip0 = ($virtnode0->_isvirtnode() ?
		       Interface->LookupControl($pnode0->phys_nodeid()) :
		       Interface->LookupControl($pnode0));
	my $peerip1 = ($virtnode1->_isvirtnode() ?
		       Interface->LookupControl($pnode1->phys_nodeid()) :
		       Interface->LookupControl($pnode1));
	
	if (!defined($peerip0)) {
	    tberror("No Control Network IP for $pnodename0!\n");
	    return -1;
	}
	if (!defined($peerip1)) {
	    tberror("No Control Network IP for $pnodename1!\n");
	    return -1;
	}
	$peerip0 = $peerip0->IP();
	$peerip1 = $peerip1->IP();

	$self->printdb("Tunnel: $member0 <-> $member1, ".
		       "$ip0 <-> $ip1, $peerip0 <-> $peerip1\n");

	next
	    if ($self->impotent() || $self->alloconly());

	my $tunnel = Tunnel->Create($self->experiment(),
				    $virtlan->vname(), $secretkey,
				    $virtlan->_encapstyle(), $mask, $ipport);
	if (!defined($tunnel)) {
	    tberror("Could not create tunnel for $virtlan\n");
	    return -1;
	}
	my $iface0 = $tunnel->AddInterface($pnodename0,
					   $member0->vnode(),
					   $member0->vport());
	if (!defined($iface0)) {
	    tberror("Could not add $member0 to $tunnel\n");
	    return -1;
	}
	my $iface1 = $tunnel->AddInterface($pnodename1,
					   $member1->vnode(),
					   $member1->vport());
	if (!defined($iface1)) {
	    tberror("Could not add $member1 to $tunnel\n");
	    return -1;
	}
	my $tunnel_tag = `echo '$secretkey' | /usr/bin/cksum`;
	if ($tunnel_tag =~ /^(\d+)/) {
	    $tunnel_tag = $1;
	}
	my $iface0_mac = GenFakeMac();
	my $iface1_mac = GenFakeMac();

	# Need to set a bunch of attributes later returned by tmcd.
	if ($iface0->SetAttribute("tunnel_ip", $ip0) ||
	    $iface0->SetAttribute("tunnel_peerip", $ip1) ||
	    $iface0->SetAttribute("tunnel_srcip", $peerip0) ||
	    $iface0->SetAttribute("tunnel_dstip", $peerip1) ||
	    $iface0->SetAttribute("tunnel_isserver",
			  ($server->vname() eq $virtnode0->vname() ? 1 : 0)) ||
	    $iface0->SetAttribute("tunnel_secretkey", $secretkey) ||
	    $iface0->SetAttribute("tunnel_ipmask", $mask) ||
	    $iface0->SetAttribute("tunnel_serverport", $ipport) ||
	    $iface0->SetAttribute("tunnel_lan", $virtlan->vname()) ||
	    $iface0->SetAttribute("tunnel_unit", $member0->vport() + 1) ||
	    $iface0->SetAttribute("tunnel_tag", $tunnel_tag) ||
	    $iface0->SetAttribute("tunnel_mac", $iface0_mac) ||
	    $iface0->SetAttribute("tunnel_style", $virtlan->_encapstyle())) {
	    tberror("Could not set attributes for $iface0 in $tunnel\n");
	    return -1;
	}
	if ($iface1->SetAttribute("tunnel_ip", $ip1) ||
	    $iface1->SetAttribute("tunnel_peerip", $ip0) ||
	    $iface1->SetAttribute("tunnel_srcip", $peerip1) ||
	    $iface1->SetAttribute("tunnel_dstip", $peerip0) ||
	    $iface1->SetAttribute("tunnel_isserver",
			  ($server->vname() eq $virtnode1->vname() ? 1 : 0)) ||
	    $iface1->SetAttribute("tunnel_secretkey", $secretkey) ||
	    $iface1->SetAttribute("tunnel_ipmask", $mask) ||
	    $iface1->SetAttribute("tunnel_serverport", $ipport) ||
	    $iface1->SetAttribute("tunnel_lan", $virtlan->vname()) ||
	    $iface1->SetAttribute("tunnel_unit", $member1->vport() + 1) ||
	    $iface1->SetAttribute("tunnel_tag", $tunnel_tag) ||
	    $iface1->SetAttribute("tunnel_mac", $iface1_mac) ||
	    $iface1->SetAttribute("tunnel_style", $virtlan->_encapstyle())) {
	    tberror("Could not set attributes for $iface1 in $tunnel\n");
	    return -1;
	}
    }
    return 0;
}

#
# Upload interface settings.
#
sub UpLoadInterfaceSettings($)
{
    my ($self) = @_;

    my $experiment = $self->experiment();
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();
    my $idx = $experiment->idx();

    foreach my $virtlan (values(%{ $self->vlans() })) {
	my $protocol = $virtlan->_protocol();
	my $vlanname = $virtlan->vname();

	next
	    if (! (($protocol =~ /^(80211|flex900|xcvr2450)/)));
	
	my @members  = $virtlan->memberlist();
	my $ssid     = "${vlanname}_${idx}";
	my $apmac;

	if (defined($virtlan->_accesspoint())) {
	    my $member    = $virtlan->_accesspoint();
	    my $vnodename = $member->vnode();
	    my $pnodename = $self->solution_v2p()->{$vnodename};
	    my $iface     = $self->solution_portmap()->{$member};
	    my $pnode     = $self->pnodes()->{$pnodename};
	    my $interface;

	    if ($pnode->GetInterface($iface, \$interface) != 0) {
		tberror("Could not find interface $pnodename:$iface\n");
		return -1;
	    }
	    $apmac = $interface->mac();
	}

	foreach my $member (@members) {
	    my $vnodename = $member->vnode();
	    my $pnodename = $self->solution_v2p()->{$vnodename};
	    my $iface     = $self->solution_portmap()->{$member};

	    #
	    # First copy over the lan settings.
	    #
	    foreach my $lan_setting ($self->virt_lan_settings()->Rows()) {
		my $capkey = DBQuoteSpecial($lan_setting->capkey());
		my $capval = DBQuoteSpecial($lan_setting->capval());
		my $vname  = $lan_setting->vname();

		next
		    if ($vname ne $vlanname);

		$self->printdb("interface_setting: $vname: ".
			       "$pnodename $iface $capkey $capval\n");
	    
		DBQueryWarn("insert into interface_settings ".
			    "       (node_id, iface, capkey, capval) ".
			    "values ('$pnodename', '$iface', ".
			    "        $capkey, $capval)")
		    or return -1 if (!($self->impotent() ||
				       $self->alloconly()));
	    }

	    #
	    # Next do the per-member settings, which override lan settings.
	    #
	    foreach my $setting ($self->virt_lan_member_settings()->Rows()) {
		next
		    if ("$member" ne $setting->member());

		my $capkey = DBQuoteSpecial($setting->capkey());
		my $capval = DBQuoteSpecial($setting->capval());

		$self->printdb("interface_setting (member): ".
			       "$pnodename $iface $capkey $capval\n");
	    
		DBQueryWarn("replace into interface_settings ".
			    "       (node_id, iface, capkey, capval) ".
			    "values ('$pnodename', '$iface', ".
			    "        $capkey, $capval)")
		    or return -1 if (! ($self->impotent() ||
					$self->alloconly()));
	    }

	    #
	    # And lastly, these override anything the user says to do.
	    # 
	    DBQueryWarn("replace into interface_settings ".
			 "       (node_id, iface, capkey, capval) ".
			 "values ('$pnodename', '$iface', ".
			 "        'protocol', '$protocol')")
		or return -1 if (! ($self->impotent() ||
				    $self->alloconly()));
		
	    $self->printdb("interface_setting: ".
			   "$pnodename $iface protocol $protocol\n");

	    if ($protocol =~ /^(80211|flex900|xcvr2450)/) {
		DBQueryWarn("replace into interface_settings ".
			    "       (node_id, iface, capkey, capval) ".
			    "values ('$pnodename', '$iface', 'ssid', '$ssid')")
		    or return -1 if (! ($self->impotent() ||
					$self->alloconly()));
	
		$self->printdb("interface_setting: ".
			       "$pnodename $iface ssid $ssid\n");

		if (defined($apmac)) {
		    DBQueryWarn("replace into interface_settings ".
				"       (node_id, iface, capkey, capval) ".
				"values ('$pnodename', '$iface', ".
				"        'accesspoint', '$apmac')")
			or return -1 if (! ($self->impotent() ||
					    $self->alloconly()));
		    
		    $self->printdb("interface_setting: ".
				   "$pnodename $iface accesspoint $apmac\n");
		}
	    }
	}
    }
    return 0;
}

sub UploadBlockstores($)
{
    my ($self) = @_;
    my $experiment = $self->experiment();
    my $exptidx = $experiment->idx();
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();

    #
    # vname   = "blockstore-d1"
    # bs_name = "d1"
    # bstore  = "raid1"
    # vvnode  = "dboxvm1-1"
    # pnode   = "dbox1"
    #
    foreach my $bs_name (keys(%{ $self->blockstores() })) {
	my $virtnode = $self->blockstores()->{$bs_name};
	my $bstore   = $self->solution_blockstores()->{$bs_name};
	my $vname    = $virtnode->vname();
	my $vvnode   = $self->solution_v2v()->{$vname};
	my $vpnode   = $virtnode->_pnode();
	my $pnode    = $vpnode->phys_nodeid();

	#
	# If this is a blockstore clone, then bstore will be the storage
	# pool that the clone is allocating space from. We need this to
	# charge resources to. However, what we record in the DB is the
	# blockstore that we are cloning since that is what is needed later
	# in tmcd for passing to the storage server.
	#
	my $pool = $bstore;
	if ($virtnode->_bsperms() ne "RW") {
	    my $bsattr = $virtnode->_blockstore_attributes();
	    if ($bsattr && exists($bsattr->{'clone'})) {
		$bstore = "lease-" . $bsattr->{'clone'};
	    }
	}
	my $size = $virtnode->_bsallocsize();

	$self->printdb("BlockStore: ".
		       "$vname, $bstore ($pool), $size, $vvnode, $vpnode, $pnode\n");

	my $blockstore = Blockstore->Lookup($pnode, $bstore);
	if (!defined($blockstore)) {
	    tberror("Could not lookup blockstore $pnode:$bstore\n");
	    return -1;
	}
	if (! ($self->impotent() || $self->alloconly())) {
	    if ($blockstore->Reserve($experiment, $vvnode, $bs_name, $size)) {
		tberror("Could not lookup reserve $pnode:$bstore $size\n");
		return -1;
	    }
	}
    }
    return 0;
}

# getnodeport(s)
# Takes a ports result from assign (mac0,mac1) and converts null strings to undef.
sub getnodeport($)
{
    my $macstring=$_[0];
    my ($A,$B) = ($macstring =~ /^\(([^,]+),([^,]+)\)$/);

    $A = undef
	if ($A eq "(null)");
    $B = undef
	if ($B eq "(null)");

    return ($A, $B);
}

# getportlist
# Takes the list of arguments on an edges line and returns the set of
# ports spanned by that vlan.
sub getportlist(@)
{
    my @info   = @_;
    my @result = ();
    # The beginning and end of the list are ignored for the path
    # since we care only about the Trunk links.
    @info = splice(@info, 2, $#info);

    #
    # The first thing might actually be a path member, as for a
    # fake lan node. According to Rob, the path is path from the
    # source to destination and when the lannode is on a switch,
    # the first item is that switch, and that is part of the path.
    # When it is a node, we do not need/want that in the path and
    # so we skip it.
    #
    # The problem is how to properly distinguish between them. This
    # is the best I came up with.
    #
    if ($info[0] =~ /^link\-([-\w]*):([-\w]*):/) {
	shift(@info);
	shift(@info);
    }

    while (@info) {
	#
	# Traverse two at a time. We can deduce the switch pair
	# from the first string, but thats a kludge.  The
	# second string is supposed to be real interface info,
	# but ignore that for now, until new ptopgen actually
	# sets it.
	#
	my $field1 = shift(@info);
	my $field2 = shift(@info);

	if ($field1 =~ /^link\-/ &&
	    $field2 eq "((null),(null))") {
	    $field1 =~ s/^link\-//;
	    push(@result, $field1);
	}
	elsif ($field1 =~ /^link\-([-\w]*):([-\w]*)/) {
	    my $sw1 = $1;
	    my $sw2 = $2;
	    
	    if ($field2 eq "($sw1/$sw2,$sw2/$sw1)" ||
		$field2 eq "($sw2/$sw1,$sw1/$sw2)") {
		push(@result, "$sw1:$sw2");
	    }
	}
    }
    return join(" ", @result);
}

# Get the type for an interface.
sub physinterfacetype($$)
{
    my ($pnode, $iface) = @_;

    my $interface;
    if ($pnode->GetInterface($iface, \$interface) != 0) {
	tberror("Could not get interface: $pnode:$iface\n");
	return -1;
    }
    return $interface->type();
}
# Get the role for an interface.
sub physinterfacerole($$)
{
    my ($pnode, $iface) = @_;

    my $interface;
    if ($pnode->GetInterface($iface, \$interface) != 0) {
	tberror("Could not get interface: $pnode:$iface\n");
	return -1;
    }
    return $interface->role();
}

#
# Give me a new vname for an internally allocated node. We have to
# watch for names that were made up previously (say, if this is an
# update).  Not allowed to reuse names of course. We do not mark nodes
# as hosting, so have to infer this from reserved_pnodes. I'm sure
# there is a better way to do this.
#
sub newvname($$$)
{
    my ($self, $pnodename, $prefix) = @_;

    #
    # First check to see if this pnode was already allocated (update)
    #
    my @vnames = keys(%{ $self->current_v2p() });
	
    foreach my $vname (@vnames) {
	# Skip the v mappings.
	next
	    if (exists($self->current_v2v->{$vname}));

	if ($pnodename eq $self->current_v2p->{$vname}) {
	    return $vname
		if ($pnodename ne $vname);
	    last;
	}
    }
    
    while (1) {
	my $newname = $prefix . "-" . $self->nextphostnumber();

	return $newname
	    if (!exists($self->current_v2p->{$newname}));
    }
}

sub array_diff($$)
{
    my ($a, $b) = @_;

    my %seen; # lookup table
    my @aonly;# answer
    
    # build lookup table
    @seen{@$b} = ();

    foreach my $item (@$a) {
	push(@aonly, $item) unless exists $seen{$item};
    }
    return @aonly;
}

#
# If there are no virtual nodes, then there is no port sharing, and it
# makes no difference, as long as there are no collisions on a
# node. If there are virtual nodes, then assign a port range for the
# experiment, and all port allocations need to be shared within that
# range on each phys node. That is, if there are 2 virtual nodes on
# physical node, then must allocated from the one range.  There is
# never any overlap between experiements of course.
# 
sub SetPortRange($)
{
    my ($self) = @_;

    #
    # No virtual nodes, fall back to simple approach.
    #
    return 0
	if (! scalar(keys(%{ $self->solution_v2v() })));

    #
    # Use existing port range when updating, or else find a free slot.
    #
    my ($newlow,$newhigh) = $self->experiment()->GetPortRange();
    if (!defined($newlow)) {
	#
	# We allocate a port range but do not save it. This is
	# okay since we do not store the per-node assignments.
	#
	($newlow,$newhigh) =
	    $self->experiment()->SetPortRange($self->impotent());
    }
    if (!defined($newlow)) {
	tberror("Could not set the portrange!\n");
	return -1;
    }
    $self->printdb("SetPortRange: $newlow,$newhigh\n");

    #
    # Now set the port range for those nodes hosting virtual nodes.
    # This prevents overlap with other vnodes from other experiments
    # on that nodes. Since you cannot share a node unless you are using
    # virtual nodes, there is no need to worry about phys nodes that
    # are dedicated. That might change of course. 
    #
    foreach my $vnodename (keys(%{ $self->solution_v2v() })) {
	my $vpnodename = $self->solution_v2v()->{$vnodename};
	my $vpnode     = $self->pnodes()->{$vpnodename};
	my $pnodename  = $self->solution_v2p()->{$vnodename};
	my $pnode      = $self->pnodes()->{$pnodename};

	$vpnode->_portlow($newlow);
	$vpnode->_porthigh($newhigh);
	$pnode->_portlow($newlow);
	$pnode->_porthigh($newhigh);

	my $portarray1 = [];
	my $portarray2 = [];

	#
	# XXX This attempts to keep the sshd port the same across
	# swapmod. We need a better (more general) way to do this.
	#
	my $sshdport;
	if (exists($self->current_v2v()->{$vnodename}) &&
		$vpnode->sshdport() != 11000) {

	    $sshdport = $vpnode->sshdport();
	    #$self->printdb("reserving sshdport $sshdport on $vpnode\n");
	}
	
	for (my $i = 0, my $port = $pnode->_portlow();
	     $i < $pnode->_porthigh() - $pnode->_portlow(); $i++,$port++) {
	    
	    $portarray1->[$i] = ($i < 10 ? $port : 0 - $port);
	    $portarray2->[$i] = ($i < 10 ? $port : 0 - $port);

	    if (defined($sshdport) && $port == $sshdport) {
		$portarray1->[$i] = $sshdport;
		$portarray2->[$i] = $sshdport;
	    }
	}
	$pnode->_portarray($portarray1);
	$vpnode->_portarray($portarray2);

	# We only set the vpnodes. tmcd sends that to the client.
	DBQueryWarn("update nodes set ipport_low=$newlow, ".
		    " ipport_next=ipport_low+1, ipport_high=$newhigh ".
		    "where node_id='$vpnodename'")
	    or return -1 if (!($self->impotent() || $self->alloconly()));
    }
    return 0;
}

#
# Bump and return the IP port number for a node. This is
# required for multiplexing virtual nodes on a physical node. 
#
sub nextipportnum($)
{
    my ($pnode, $default)  = @_;
    my $portarray = $pnode->_portarray();
    my $port = 0;

    if (!defined($portarray)) {
	#
	# Fall back to simple approach; no shared nodes.
	#
	$port = $pnode->_portnext();
	$pnode->_portnext($port + 2);
	return $port;
    }

    for (my $i = 0; $i < $pnode->_porthigh() - $pnode->_portlow(); $i++) {
	if ($portarray->[$i] < 0) {
	    $port = 0 - $portarray->[$i];
	    $portarray->[$i] = $port;
	    last;
	}
    }
    if (!$port) {
	tberror("No more dynamic ports available for $pnode!\n");
	return -1;
    }
    return $port;
}

#############################################################################
# XML support that will move elsewhere. Note that this code is entirely
# derived from the code that Tarun wrote to convert top files in XML.
# It is currently operating in the same fashion; parsing the text lines
# that are created above. This is silly extra work, but I do not want to
# diverge too far from the original code yet.
#

#
# Creates a child node with name "nodeName" whose parent is "parent"
# in the XML document "document"
#
sub addNodeRspec ($$$)
{
    my ($doc, $root, $name) = @_;
    my $newnode = $doc->createElement($name);
    $root->appendChild($newnode);
    return $newnode;
}

#
# Process a node and emits RSPEC v2
#
sub processNodeRspec ($$$$)
{
    my ($self, $doc, $root, $node) = @_;
    
    # Check if the node has been fixed
    my $fixedto = '';
    foreach my $fixednode (@{$self->rspec()->{'fixed'}}) {
	if ($fixednode->{'vnode'} eq $node->{'virtual_id'}) {
	    $fixedto = $fixednode->{'pnode'};
	    last;
	}
    }

    my $rspecnode = addNodeRspec ($doc, $root, 'node');
    $rspecnode->setAttribute('client_id', $node->{'virtual_id'});
    $rspecnode->setAttribute('component_manager_id', $node->{'manager_urn'});
    if ($fixedto ne '') {
	my ($authority,undef,undef) = GeniHRN::Parse($node->{'manager_urn'});
	$rspecnode->setAttribute('component_id',
			 GeniHRN::Generate($authority, "node", $fixedto));
    }

    my $isnodestatic = $node->{'node_static'};
    my $nodetypename = $node->{'node_type'};
    my $nodetypeslots = $node->{'type_slots'};
    
    # Determine hardware type and sliver type from nodetype
    # The formula for this is to check for the substring "vm" in the type name
    # If the substring is found, the rest of the string becomes the hardware 
    # type and the sliver type is "openvz". If the substring "vm" is not found,
    # the sliver type is "raw-pc" and the type name is the hardware type
    # eg: typename = pcvm600 =>{ hardwaretype = "pc600", slivertype = "openvz"}
    # eg: typename = pc600 => { hardwaretype = "pc600", slivertype = "raw-pc"}
    my $slivertype = "raw-pc";
    my $hardwaretype = $nodetypename;
    my $vmloc = index($nodetypename, "vm");
    if ($vmloc != -1) {
	$slivertype = "openvz";
	$hardwaretype = substr($nodetypename, 0, $vmloc) 
	                 . substr($nodetypename, $vmloc+2); 
    }

    # Create hardware node with Emulab extensions
    my $hardwarenode = addNodeRspec($doc, $rspecnode, 'hardware_type');
    $hardwarenode->setAttribute('name', $hardwaretype);
    my $typecount = addNodeRspec($doc, $hardwarenode, 'emulab:node_type');
    $typecount->setAttribute('type_slots', $nodetypeslots);
    if ($isnodestatic == 1) {
	$typecount->setAttribute('static', 'true');
    }

    # Create sliver type
    my $slivernode = addNodeRspec($doc, $rspecnode, 'sliver_type');
    $slivernode->setAttribute('name', $slivertype);
    my $diskimagenode = addNodeRspec($doc, $slivernode, 'disk_image');

# XXX: This is NOT correct at all. The disk image name should be a URN
# composed of the project name, and the name of the disk image obtained from
# the osinfo structure. It should NOT be the osid. This has been done merely 
# as a placeholder to ensure that the vtop still validates.
    $diskimagenode->setAttribute('name', 'diskimageurn');

    # Deal with the disallow_trivial_mix flag
    if (exists($node->{'disallow_trivial_mix'})) {
	addNodeRspec($doc, $rspecnode, 'emulab:disallow_trivial_mix');
    }

    # Deal with the subnode_of flag
    if (exists($node->{'subnode'})) {
	my $relation = addNodeRspec($doc, $rspecnode, 'relation');
	$relation->setAttribute('type', 'subnode');
	my $subnode = addNodeRspec($doc, $relation, 'emulab:subnode_of');
	$subnode->SetAttribute('parent', $node->{'subnode'});
    }

    # Add interfaces to the node
    foreach my $interface (@{$node->{'interfaces'}}) {
	my $iface = $interface->{'virtual_id'};
	my $fixed = $interface->{'component_id'};
	
	my $interfacedecl = addNodeRspec($doc, $rspecnode, 'interface');
	$interfacedecl->setAttribute('client_id', $iface);
	if (defined($fixed)) {
	    my $fixediface = addNodeRspec($doc, $interfacedecl, 
					  'emulab:fixedinterface');
	    $fixediface->setAttribute('name', $fixed);
	}
    }

    # Add all the desires as extensions
    while ( my ($desire, $desireval) = each (%{$node->{'desires'}})) {
	my $desirenode = addNodeRspec($doc, $rspecnode, 'emulab:fd');
	my $operator = $desireval->[0];
	$desirenode->setAttribute('name', $desire);
	$desirenode->setAttribute('weight', $desireval->[1]);
	if ($desireval->[1] >= 1.000000) {
	    $desirenode->setAttribute('violatable', 'true');
	}
	if ($operator eq "?+") {
	    $desirenode->setAttribute('local_operator', '+');
	}
	elsif ($operator eq "*&") {
	    $desirenode->setAttribute('global_operator', 'FirstFree');
	}
	elsif ($operator eq '*!') {
	    $desirenode->setAttribute('global_operator', 'OnceOnly');
	}
    }
}

sub processLinkRspec ($$$$)
{
# TODO: Deal with fixed interfaces correctly
    my ($self, $doc, $root, $link) = @_;
	
    my $rspeclink = addNodeRspec($doc, $root, 'link');
    $rspeclink->setAttribute('client_id', $link->{'plink'});
    
    my $cmnode = addNodeRspec($doc, $rspeclink, 'component_manager');
    $cmnode->setAttribute('name', $link->{'manager_urn'});

    my $linktype = addNodeRspec($doc, $rspeclink, 'link_type');
    $linktype->setAttribute('name', $link->{'link_type'});

    if (exists ($link->{'nodelay'})) {
	addNodeRspec($doc, $rspeclink, 'emulab:nodelay');
    }
    if (exists($link->{'emulated'})) {
	addNodeRspec($doc, $rspeclink, 'emulab:multiplex_ok');
    }
    if (exists($link->{'trivial_ok'})) {
	addNodeRspec($doc, $rspeclink, 'emulab:trivial_ok');
    }

    # Add the interface refs
    my $interface_ref = addNodeRspec($doc, $rspeclink, 'interface_ref');
    $interface_ref->setAttribute('client_id', $link->{'interface_ref'}->[0]);

    $interface_ref = addNodeRspec($doc, $rspeclink, 'interface_ref');
    $interface_ref->setAttribute('client_id', $link->{'interface_ref'}->[1]);

    # The forward link
    my $property = addNodeRspec($doc, $rspeclink, 'property');
    $property->setAttribute('source_id', $link->{'interface_ref'}->[0]);
    $property->setAttribute('dest_id', $link->{'interface_ref'}->[1]);
    $property->setAttribute('capacity', $link->{'capacity'});
    $property->setAttribute('latency', $link->{'latency'});
    $property->setAttribute('packet_loss', $link->{'packet_loss'});

    # The reverse link
    $property = addNodeRspec($doc, $rspeclink, 'property');
    $property->setAttribute('source_id', $link->{'interface_ref'}->[1]);
    $property->setAttribute('dest_id', $link->{'interface_ref'}->[0]);
    $property->setAttribute('capacity', $link->{'capacity'});
    $property->setAttribute('latency', $link->{'latency'});
    $property->setAttribute('packet_loss', $link->{'packet_loss'});
}

sub processVClassRspec($$$$)
{
    my ($self, $doc, $root, $vclass) = @_;
    my $vclassNode = addNodeRspec($doc, $root, 'emulab:vclass');

    my $name = $vclass->{'name'};
    my $weight = $vclass->{'weight'};

    # XXX: We don't have hard vclass support yet     
    $vclassNode->setAttribute('name', $name);
    $vclassNode->setAttribute('weight', $weight);

    foreach my $physType (@{$vclass->{'members'}}) {
	my $physNode = addNodeRspec($doc, $vclassNode, 'emulab:physical_type');
	$physNode->setAttribute('name', $physType);
    }
}

###############################################################################
# Print the solution as an rspec. 
#
sub addNode($$$)
{
    my ($document, $parent, $nodeName) = @_;
    
    my $newNode = $document->createElement($nodeName);
    $parent->appendChild($newNode);
    return $newNode;
}

sub PrintSolution($$)
{
    my ($self, $output) = @_;
    $output = *STDOUT
	if (!defined($output));

    my $pid = $self->experiment()->pid();
    my $eid = $self->experiment()->eid();

    my $doc = XML::LibXML::Document->new();

    my $root = $doc->createElement("rspec");
    $root->setAttribute("pid", "$pid");
    $root->setAttribute("eid", "$eid");
    $root->setAttribute("xmlns:rspec",
			"http://www.protogeni.net/resources/rspec/0.1");
    $doc->setDocumentElement($root);

    foreach my $pnodename (keys(%{ $self->solution_p2v() })) {
	my @vnodenames = @{ $self->solution_p2v()->{$pnodename} };
	my $pnode = $self->pnodes()->{$pnodename};

	foreach my $vnodename (@vnodenames) {
	    my $vnode   = $self->vnodes()->{$vnodename};
	    my $newNode = addNode($doc, $root, "node");
	    my $type;

	    if (defined($vnode) && $vnode->_isvirtnode()) {
		$pnode = $vnode->_pnode();
	    }
	    
	    $newNode->setAttribute("virtual_id", $vnodename);
	    $newNode->setAttribute("component_uuid", $pnode->uuid());

	    if (defined($vnode)) {
		$type = $vnode->type();
	    }
	    elsif (exists($self->sanhosts()->{$vnodename})) {
		$type = "pcsanhost";
	    }
	    else {
		$type = $pnode->type();
	    }
	    $newNode->setAttribute("sliver_type", $type);

	    if (defined($vnode) && defined($vnode->_sanhostname())) {
		$newNode->setAttribute("subnode_of", $vnode->_sanhostname());
	    }
	}
    }
    foreach my $virtlan (values(%{ $self->vlans() })) {
	my $vlanname = $virtlan->vname();

	my $newLink = addNode($doc, $root, "link");
	$newLink->setAttribute("virtual_id", $vlanname);
	    
	foreach my $member ($virtlan->memberlist()) {
	    # Will this happen?
	    next
		if (!exists($self->solution_portmap()->{$member}));
		
	    my $vnode  = $member->vnode();
	    my $vport  = $member->vport();
	    my $pport  = $member->_pport();

	    my $newMember = addNode($doc, $newLink, "interface_ref");
	    $newMember->setAttribute("virtual_node_id", $vnode);
	    $newMember->setAttribute("virtual_port_id", $vport);
	    #
	    # XXX Ignore for now. Need to fix.
	    #
	    $newMember->setAttribute("component_id", $pport)
		if (defined($pport));
	}
    }
    print $output $doc->toString(1) . "\n";

    return 0;
}

#
# Little helper routine to map a vname to the physnode. See libGeni.
#
sub VnameToNode($$)
{
    my ($self, $vname) = @_;
    my $nodeid;

    if (exists($self->solution_v2v()->{$vname})) {
	$nodeid = $self->solution_v2v()->{$vname};
    }
    elsif (exists($self->solution_v2p()->{$vname})) {
	$nodeid = $self->solution_v2p()->{$vname};
    }
    return undef
	if (!defined($nodeid));

    return Node->Lookup($nodeid);
}

#
# A switchpath is "SW1:SW2 SW2:SW3 ..." This function takes an
# existing path, and adds new ones from the list, while watching for
# duplicates.  We assume the new path is already unique since it came
# right out of assign. Note that assign might spit out either SW1:SW2
# or SW2:SW1, so have to watch for that too.
#
sub AddToSwitchPath($$)
{
    my ($cur, $new) = @_;

    return $new
	if (!defined($cur));
    return $cur
	if (!defined($new));

    my @cur = split(" ", $cur);
    my @new = split(" ", $new);
    foreach my $n (@new) {
	my ($s1,$s2) = split(":", $n);

	push(@cur, $n)
	    if (! ((grep {$_ eq $n} @cur) ||
		   (grep {$_ eq "$s2:$s1"} @cur)));
    }
    my $rval = join(" ", @cur);
    return $rval;
}

#
# Wiretypes.
#
sub GetWiretype($$$)
{
    my ($self, $wiretype, $bandwidth) = @_;

    return $wiretype
	if (!$MAINSITE);

    return $wiretype
	if ($wiretype =~ /^ethernet-/ || $wiretype !~ /^ethernet/);

    if ($bandwidth == 0) {
	$wiretype = "ethernet";
    }
    elsif ($bandwidth <= 100000) {
	# 100 Mbit
	$wiretype = "ethernet-100000";
    }
    elsif ($bandwidth <= 1000000) {
	# 1 Gbit
	$wiretype = "ethernet-1000000";
    }
    elsif ($bandwidth <= 10000000) {
	# 10 Gbit
	$wiretype = "ethernet-10000000";
    }
    elsif ($bandwidth <= 25000000) {
	# 25 Gbit
	$wiretype = "ethernet-25000000";
    }
    elsif ($bandwidth <= 40000000) {
	# 40 Gbit
	$wiretype = "ethernet-40000000";
    }
    else {
	# 100 Gbit
	$wiretype = "ethernet-100000000";
    }
    return $wiretype;
}

#
# Are all nodes explicitly typed.
#
sub AllNodesTyped($)
{
    my ($self) = @_;
    my $nodecount = $self->nodecount();
    my $typecount = 0;

    foreach my $type (keys(%{ $self->types() })) {
	$typecount += $self->types()->{$type};
    }
    return 1
	if ($nodecount == $typecount);
    return 0;
}


1;
