#!/usr/bin/perl -wT
#
# Copyright (c) 2008-2021 University of Utah and the Flux Group.
# 
# {{{GENIPUBLIC-LICENSE
# 
# GENI Public License
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and/or hardware specification (the "Work") to
# deal in the Work without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Work, and to permit persons to whom the Work
# is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Work.
# 
# THE WORK IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS
# IN THE WORK.
# 
# }}}
#
package GeniCMV2;

#
# The server side of the CM interface on remote sites. Also communicates
# with the GMC interface at Geni Central as a client.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = qw(Exporter);
@EXPORT = qw();

# Must come after package declaration!
use GeniDB;
use GeniResponse;
use GeniTicket;
use GeniCredential;
use GeniCertificate;
use GeniComponent;
use GeniSlice;
use GeniAggregate;
use GeniSliver;
use GeniUtil;
use GeniCM;
use GeniHRN;
use GeniXML;
use GeniStitch;
use GeniStd;
use emutil;
use libEmulab;
use English;
use EmulabConstants;
use libtestbed;
use Data::Dumper;
use XML::Simple;
use Date::Parse;
use POSIX qw(strftime);
use POSIX qw(setsid :sys_wait_h);
use Time::Local;
use Compress::Zlib;
use File::Temp qw(tempfile);
use MIME::Base64;
use Errno qw(:POSIX);
use List::Util qw(shuffle);

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBLOGS         = "@TBLOGSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $MAINSITE       = @TBMAINSITE@;
my $BOSSNODE       = "@BOSSNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";
my $PGENIDOMAIN    = "@PROTOGENI_DOMAIN@";
my $ELABINELAB     = "@ELABINELAB@";
my $TBBASE         = "@TBBASE@";
my $TBDOCBASE      = "@TBDOCBASE@";
my $CLUSTER_PORTAL = "@CLUSTER_PORTAL@";
my $CREATEEXPT     = "$TB/bin/batchexp";
my $ENDEXPT        = "$TB/bin/endexp";
my $NALLOC	   = "$TB/bin/nalloc";
my $NFREE	   = "$TB/bin/nfree";
my $TEVC	   = "$TB/bin/tevc";
my $AVAIL	   = "$TB/sbin/avail";
my $PTOPGEN	   = "$TB/libexec/ptopgen";
my $TBSWAP	   = "$TB/bin/tbswap";
my $SWAPEXP	   = "$TB/bin/swapexp";
my $PLABSLICE	   = "$TB/sbin/plabslicewrapper";
my $NAMEDSETUP     = "$TB/sbin/named_setup";
my $VNODESETUP     = "$TB/sbin/vnode_setup";
my $GENTOPOFILE    = "$TB/libexec/gentopofile";
my $TARFILES_SETUP = "$TB/bin/tarfiles_setup";
my $MAPPER         = "$TB/bin/mapper";
my $VTOPGEN        = "$TB/bin/vtopgen";
my $SNMPIT         = "$TB/bin/snmpit";
my $CLONEIMAGE     = "$TB/sbin/clone_image";
my $FLASHNODE      = "$TB/sbin/flashnode";
my $CREATEIMAGE    = "$TB/bin/create_image";
my $DELETEIMAGE    = "$TB/sbin/delete_image";
my $CREATEDATASET  = "$TB/bin/createdataset";
my $DELETEDATASET  = "$TB/bin/deletelease";
my $EXTENDDATASET  = "$TB/bin/extendlease";
my $GRANTDATASET   = "$TB/bin/grantlease";
my $APPROVEDATASET = "$TB/bin/approvelease";
my $GRANTIMAGE     = "$TB/sbin/grantimage";
my $WAP            = "$TB/sbin/withadminprivs";
my $SHAREVLAN      = "$TB/sbin/sharevlan";
my $PANIC          = "$TB/sbin/panic";
my $CHECKQUOTA     = "$TB/sbin/checkquota";
my $LINKTEST       = "$TB/sbin/linktest_control";
my $NODEADMIN      = "$TB/bin/node_admin";
my $XMLLINT	   = "/usr/local/bin/xmllint";
my $IMAGEINFO      = "$TB/sbin/imageinfo";
my $PRERENDER      = "$TB/libexec/vis/prerender";
my $IMPORTER       = "$TB/sbin/image_import";
my $POSTIMAGEDATA  = "$TB/sbin/protogeni/postimagedata";
my $EMULAB_PEMFILE = "@prefix@/etc/genicm.pem";
# Just one of these, at Utah.
my $GENICH_PEMFILE = "@prefix@/etc/genich.pem";
my $WITHPROVENANCE = @IMAGEPROVENANCE@;
my $PROTOGENI_LOCALUSER = @PROTOGENI_LOCALUSER@;
my $API_VERSION    = 2;

#
# Tell the client what API revision we support.  The correspondence
# between revision numbers and API features is to be specified elsewhere.
# No credentials are required.
#
sub GetVersion()
{
    my @input_rspec_versions = ( "0.1", "0.2", "2", "3", "PG 0.1", "PG 0.2", "PG 2" );
    my @ad_rspec_versions = ( "0.1", "0.2", "2", "3", "PG 0.1", "PG 0.2", "PG 2" );
    my $blob = {
	"api" => $API_VERSION,
	"level" => 1,
	"input_rspec" => \@input_rspec_versions,
	"output_rspec" => "2",
	"ad_rspec" => \@ad_rspec_versions
    };
    #POSIX::_exit(1);
    #sleep(30);
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
}

#
# Respond to a Resolve request. 
#
sub Resolve($)
{
    my ($argref) = @_;
    my $credentials = $argref->{'credentials'};
    my $urn         = $argref->{'urn'};
    my $admin       = 0;
    my $isauth	    = 0;

    if (! (defined($credentials) && defined($urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! GeniHRN::IsValid($urn)) {
	return GeniResponse->MalformedArgsResponse("Invalid URN");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    my ($object, $type) = LookupURN($urn);
    return $object
	if (GeniResponse::IsResponse($object));

    #
    # This is a convenience for testing. If a local user and that
    # user is an admin person, then do whatever it says. This is
    # easier then trying to do this with credential privs. But,
    # watch for credentials from authorities instead of users.
    #
    my (undef,$callertype,$callerid) = GeniHRN::Parse($credential->owner_urn());
    if ($callertype eq "user") {
	my $user = GeniCM::CreateUserFromCertificate($credential);
	if (!GeniResponse::IsResponse($user) &&
	    $user->IsLocal() && $user->admin()) {
	    $admin = 1;
	}
    }
    elsif ($callertype eq "authority" &&
	   ($callerid eq "cm" || $callerid eq "sa")) {
	$isauth = 1;
    }
    
    if ($type eq "node") {
	my $node  = $object;
	# Not sure about this, but I do know that Resolving a virtnode
	# is not useful right now. 
	if ($node->isvirtnode()) {
	    $node = Node->Lookup($node->phys_nodeid());
	}
	my $rspec = GeniCM::GetAdvertisement(0, $node->node_id(), "0.1", undef);
	if (! defined($rspec)) {
	    print STDERR "Could not get advertisement for $node!\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Error getting advertisement");
	}
	my $me = GeniAuthority->Lookup($ENV{'MYURN'});
	if (!defined($me)) {
	    print STDERR
		"Could not find local authority object for $ENV{'MYURN'}\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Error getting advertisement");
	}
	my $myurn = GeniHRN::Generate($OURDOMAIN, "node", $node->node_id());
	my $myhrn = "${PGENIDOMAIN}." . $node->node_id();

	#
	# See if the component object exists; if not create it.
	#
	my $component = GeniComponent->Lookup($node->uuid());
	if (!defined($component)) {
	    my $certificate = GeniCertificate->Lookup($node->uuid());
	    if (!defined($certificate)) {
		$certificate =
		    GeniCertificate->Create({'urn'  => $myurn,
					     'hrn'  => $myhrn,
					     'email'=> $TBOPS,
					     'uuid' => $node->uuid(),
					     'url'  => $me->url()});
		if (!defined($certificate)) {
		    print STDERR "Could not generate certificate for $node\n";
		    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					    "Error getting advertisement");
		}
	    }
	    $component = GeniComponent->Create($certificate, $me);
	    if (!defined($component)) {
		print STDERR "Could not create component for $node\n";
		return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					    "Error getting advertisement");
	    }
	}
	# Return a blob.
	my $blob = { "hrn"          => $myhrn,
		     "uuid"         => $node->uuid(),
		     "role"	    => $node->role(),
		     "hostname"     =>
			 GeniUtil::FindHostname($node->node_id()),
		     "physctrl"     => 
			 Interface->LookupControl($node->phys_nodeid())->IP(),
		     "urn"          => $myurn,
		     "rspec"        => $rspec,
		     "url"          => $me->url(),
		     "gid"          => $component->cert(),
		   };

	return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
    }
    if ($type eq "slice") {
	my $slice = $object;

	#
	# In this implementation, the caller must hold a valid slice
	# credential for the slice being looked up. 
	#
	if (! ($isauth || $admin ||
	       $slice->urn() eq $credential->target_urn())) {
	    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
					"No permission to resolve $slice\n");
	}
	# Return a blob.
	my $blob = { "urn" => $urn };

	#
	# We stored an error after a wrapperfork; return that error now.
	#
	if ($slice->async_code()) {
	    $blob->{"async_code"}   = $slice->async_code();
	    $blob->{"async_output"} = $slice->async_output();
	    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
	}

	my $aggregate = GeniAggregate->SliceAggregate($slice);
	if (defined($aggregate)) {
	    $blob->{'sliver_urn'} = $aggregate->urn();
	    my $manifest = $aggregate->GetManifest(1);
	    if (defined($manifest)) {
		$blob->{'manifest'}   = $manifest;
	    }
	    # For key bindings.
	    my $slice_experiment = $slice->GetExperiment();
	    if (!defined($slice_experiment)) {
		print STDERR "*** No Experiment for $slice\n";
	    }
	    else {
		my $bindings;
		if ($slice_experiment->NonLocalUsers(\$bindings)) {
		    print STDERR "*** No bindings for $slice_experiment\n";
		}
		elsif (@{ $bindings }) {
		    $blob->{'users'} = $bindings;
		}
	    }
	    $blob->{'public_url'} =
		"$TBDOCBASE/showslicepub.php?publicid=" . $slice->publicid()
		if (defined($slice->publicid()));
	}
	my $ticket = GeniTicket->SliceTicket($slice);
	if (defined($ticket)) {
	    $blob->{'ticket_urn'} = $ticket->urn();
	}
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
    }
    if ($type eq "sliver") {
	my $sliver = $object;
	my $slice  = $sliver->GetSlice();
	return GeniResponse->Create(GENIRESPONSE_ERROR)
	    if (!defined($slice));

	#
	# In this implementation, the caller must hold a valid slice
	# or sliver credential for the slice being looked up. 
	#
	if (! ($admin || $isauth ||
	       $sliver->urn() eq $credential->target_urn() ||
	       $slice->urn() eq $credential->target_urn())) {
	    print STDERR $sliver->urn() . "\n";
	    print STDERR $slice->urn() . "\n";
	    print STDERR $credential->target_urn() . "\n";
	    print STDERR $ENV{'MYURN'} . "\n";
	    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN);
	}
	my $manifest = $sliver->GetManifest(1);
	if (!defined($manifest)) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	# Return a blob.
	my $blob = { "urn"          => $urn,
		     "manifest"     => $manifest,
		 };
	$blob->{'public_url'} =
	    "$TBDOCBASE/showslicepub.php?publicid=" . $slice->publicid()
	    if (defined($slice->publicid()));
	
	# For key bindings.
	my $slice_experiment = $slice->GetExperiment();
	if (!defined($slice_experiment)) {
	    print STDERR "*** No Experiment for $slice\n";
	}
	else {
	    my $bindings;
	    if ($slice_experiment->NonLocalUsers(\$bindings)) {
		print STDERR "*** No bindings for $slice_experiment\n";
	    }
	    elsif (@{ $bindings }) {
		$blob->{'users'} = $bindings;
	    }
	}
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
    }
    if ($type eq "ticket") {
	my $ticket = $object;

	#
	# In this implementation, the caller must hold a valid slice
	# or sliver credential to get the ticket.
	#
	my $slice = GeniSlice->Lookup($ticket->slice_urn());
	if (!defined($slice)) {
	    print STDERR "Could not find slice for $ticket\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	if (! ($admin || $slice->urn() eq $credential->target_urn())) {
	    #
	    # See if its the sliver credential. 
	    #
	    my $aggregate = GeniAggregate->SliceAggregate($slice);
	    if (!defined($aggregate) ||
		$aggregate->urn() ne $credential->target_urn()) {
		return GeniResponse->Create(GENIRESPONSE_FORBIDDEN());
	    }
	}
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, $ticket->asString());
    }
    return GeniResponse->Create(GENIRESPONSE_UNSUPPORTED, undef,
				"Cannot resolve $type at this authority");
}

#
# Discover resources on this component, returning a resource availablity spec
#
sub DiscoverResources($)
{
    my ($argref) = @_;
    my $credentials = $argref->{'credentials'};
    my $available   = $argref->{'available'} || 0;
    my $compress    = $argref->{'compress'} || 0;
    my $version     = $argref->{'rspec_version'} || undef;

    if (! (defined($credentials))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my ($credential,$speaksfor,@morecreds) =
	GeniStd::CheckCredentials($credentials);
    return GeniResponse->MalformedArgsResponse("Missing arguments")
	if (!defined($credential));
    return $credential
	if (GeniResponse::IsResponse($credential));

    return GeniCM::DiscoverResourcesAux($available, $compress,
        $version, [$credential, @morecreds]);
}

#
# Create a Sliver.
#
sub CreateSliver($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $rspecstr     = $argref->{'rspec'};
    my $credentials  = $argref->{'credentials'};
    my $keys         = $argref->{'keys'};
    my $impotent     = $argref->{'impotent'} || 0;
    my $usetracker   = $argref->{'usetracker'} || 0;
    my $async        = $argref->{'asyncmode'} || 0;
    my $mypid        = $PID;
    my $cachedebug   = 0;
    my $rspec;
    my $response;
    my $retval;
    require Node;
    require Experiment;
    require libtestbed;
    require libaudit;

    # For now, I am not worrying about the slice_urn argument.
    if (! (defined($credentials) &&
	   defined($slice_urn) && defined($rspecstr))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! ($rspecstr =~ /^[\040-\176\012\015\011]+$/)) {
	return GeniResponse->MalformedArgsResponse("Bad characters in rspec");
    }
    if (! GeniHRN::IsValid($slice_urn)) {
	return GeniResponse->MalformedArgsResponse("Bad characters in URN");
    }
    my ($credential,$speaksfor,@morecreds) =
	GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    main::AddLogfileMetaData("slice_urn", $slice_urn);

    my $user = GeniCM::CreateUserFromCertificate($credential);
    if (GeniResponse::IsResponse($user)) {
	print STDERR "Could not create geni user for $credential\n";
	return $user;
    }
    
    #
    # In this implementation, the user must provide a slice credential,
    # so we ignore the slice_urn. For CreateSliver(), the slice must not
    # be instantiated.
    #
    my ($slice,$aggregate) = Credential2SliceAggregate($credential);
    if (defined($slice)) {
	return $slice
	    if (GeniResponse::IsResponse($slice));

	if ($slice_urn ne $slice->urn()) {
	    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
					"Credential does not match the URN");
	}
	main::AddLogfileMetaDataFromSlice($slice);
	
	#
	# Watch for a placeholder slice and update it.
	#
	if ($slice->isplaceholder()) {
	    if ($slice->Lock() != 0) {
		return GeniResponse->BusyResponse();
	    }
	    #
	    # Confirm that the slice certificate is the same.
	    #
	    if ($slice->cert() ne $credential->target_cert()->cert()) {
		$slice->UnLock();
		return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
					    "Slice certificate mismatch");
	    }
	    if ($slice->ConvertPlaceholder($user) != 0) {
		$slice->UnLock();
		return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					    "Could not convert placeholder");
	    }
	    $slice->UnLock();
	}
	if (defined($aggregate)) {
	    return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
					"Must delete existing slice first");
	}
	#
	# Clear the async return info, in case caller is retrying a
	# failed slice that never created (read: the portal and buses).
	#
	$slice->ClearAsyncError();
    }
    else {
	#
	# Create the slice here so we can lock it for the duration.
	#
	$slice = GeniCM::CreateSliceFromCertificate($credential, $user);
	return $slice
	    if (GeniResponse::IsResponse($slice));
    }
    main::AddLogfileMetaDataFromSlice($slice);
    
    #
    # Just in case a SliceStatus() snuck in ...
    #
    if ($slice->WaitForLock(10) != 0) {
	print STDERR "CreateSliver: Could not lock $slice\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Internal Error locking slice");
    }
    eval {$rspec = GeniCM::GetTicketAux({"credential" => $credential,
					 "rspecstr"   => $rspecstr,
					 "isupdate"   => 0,
					 "impotent"   => $impotent,
					 "v2"         => 1,
					 "level"      => 0,
					 "usetracker" => $usetracker,
					 "ticket"     => undef,
					 "speaksfor"  => $speaksfor,
					 "morecreds"  => \@morecreds,
					 "async"      => $async,
					 "slice"      => $slice}); };
    if ($@) {
	# Cons up a response for the check below.
	$rspec = GeniResponse->Create(GENIRESPONSE_SERVERERROR, undef,
				      "Internal Error: $@");
	if ($async) {
	    $slice->SetAsyncError($rspec);
	}
    }

    #
    # Slice is returned locked, but if we got an error and are going to
    # give up, then be sure to unlock it so we can kill it.
    #
    if ($async) {
	if ($PID == $mypid) {
	    # Did not fork or we are the parent, so we just return the response.
	    if (GeniResponse::IsResponse($rspec)) {
		$slice->UnLock();
		return $rspec;
	    }
	}
	else {
	    # Forked, return status code only for failure, otherwise
	    # we keep on going.
	    if (GeniResponse::IsError($rspec)) {
		$slice->UnLock();
		return $rspec->{'code'};
	    }
	}
    }
    else {
	if (GeniResponse::IsResponse($rspec)) {
	    #
	    # Depending on how this failed, we might not have a slice
	    # any more. But okay to call UnLock() on it, harmless.
	    #
	    $slice->UnLock();
	    return $rspec;
	}
    }

    #
    # If we got a cert/key, record them for the slice. This is a
    # generic openssl key/cert that is stored on the nodes (and from
    # which an ssh key pair can be derived).
    #
    if (exists($argref->{'certificate'}) && exists($argref->{'key'})) {
	$slice->AddGenericCert((exists($argref->{'certificate'}) ?
				$argref->{'certificate'} : undef),
			       (exists($argref->{'key'}) ?
				$argref->{'key'} : undef));
	
	#
	# Okay, change of plans. Take key/cert pair we got and use that
	# to generate the root ssh key that will get pushed to all nodes
	# if the user requests it. Turns out, its easier to tell users
	# how to do this, then how to use the key/cert to extract thier
	# own ssh key pair.
	#
	if (length($argref->{'key'}) > 4096) {
	    print STDERR "SSL key too long\n";
	}
	else {
	    my $slice_experiment = $slice->GetExperiment();
	    if (defined($slice_experiment)) {
		if ($slice_experiment->GenerateKeys($argref->{'key'})) {
		    print STDERR "Could not add private key to experiment\n";
		}
	    }
	    else {
		print STDERR "Cannot get slice experiment. Odd\n";
	    }
	}
    }

    # Make sure that the next phase sees all changes.
    Experiment->FlushAll();
    Node->FlushAll();
    if ($cachedebug) {
	GeniUtil::DumpCaches();
	emutil::DumpCaches();
    }

    eval { $response =
	       GeniCM::SliverWorkAux({"credential"  => $credential,
				      "object"      => $rspec,
				      "keys"        => $keys,
				      "isupdate"    => 0,
				      "impotent"    => $impotent,
				      "v2"          => 1,
				      "level"       => 0,
				      "speaksfor"   => $speaksfor,
				      # Currently locked, leave it locked.
				      "nolock"      => 1}); };
    if ($@) {
	# Cons up a response for the check below.
	$response = GeniResponse->Create(GENIRESPONSE_SERVERERROR, undef,
					 "Internal Error: $@");
    }

    if (GeniResponse::IsError($response)) {
	#
	# We have to make sure there is nothing left over since there
	# is no actual ticket, so the resources will not get cleaned
	# up by the daemon. This is mostly cause I am reaching into
	# the V1 code, and its messy.
	#
	my $tmp = GeniSlice->Lookup($credential->target_urn());
	if (defined($tmp)) {
	    #
	    # If SliverWork() killed the slice, nothing more to do.
	    # Otherwise, it is still locked.
	    #
	    # In async mode store off error info.
	    if ($async) {
		$slice->SetAsyncError($response);
	    }
	    # In async mode we are going to leave the slice record around
	    # so the client can pickup the error info.
	    GeniCM::CleanupDeadSlice($slice, !$async);
	    # And unlock since it still exists.
	    if ($async) {
		$slice->UnLock();
	    }
	}
	return $response;
    }
    #
    # Slice is still locked.
    #
    my ($sliver_credential) = @{ $response->{'value'} };

    # This should never happen
    $aggregate = GeniAggregate->SliceAggregate($slice);
    if (!defined($aggregate)) {
	print STDERR "CreateSliver: Could not find aggregate for $slice\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Internal Error, no aggregate for slice");
    }
    # We get the manifest from the aggregate object, so that the
    # expiration goes in.
    my $sliver_manifest = $aggregate->GetManifest(1);

    # Free this possibly massive XML structure, we do not need it anymore.
    undef $rspec;
    # Purge all the XML objects from the slivers, we do not need them again.
    GeniSliver->PurgeRspecs();

    #
    # At this point we want to return and let the startsliver proceed
    # in the background. Parent never returns, just the child.
    #
    # But in async mode, GetTicketAux has already forked, so do not do
    # it again here. 
    #
    if (!$async) {
	$mypid = main::WrapperFork();
	if ($mypid) {
	    return GeniResponse->Create(GENIRESPONSE_SUCCESS,
				    [$sliver_credential, $sliver_manifest]);
	}
    }

    # Make sure that the next phase sees all changes.
    Experiment->FlushAll();
    Node->FlushAll();
    if ($cachedebug) {
	GeniUtil::DumpCaches();
	emutil::DumpCaches();
    }

    #
    # The callee might also do a wrapper fork, so remember our PID
    # to make sure we unlock properly in only the parent side of the
    # fork. Child runs with slice unlocked for now. 
    #
    $mypid = $PID;

    eval { $retval = $aggregate->Start($API_VERSION); };
    if ($@) {
	#
	# This will cause the slice status to be failure.
	#
	$aggregate->SetBootFailure(GENIRESPONSE_SERVERERROR);
	$aggregate->SetErrorLog("Internal Error: $@");
	$retval = -1;
    }
    if ($retval) {
	print STDERR "Could not start sliver.\n";
	
	# Only parent unlocks.
	if ($PID == $mypid) {
	    $slice->UnLock();
	}
	if ($cachedebug) {
	    GeniUtil::DumpCaches();
	    emutil::DumpCaches();
	}
	return -1;
    }
    # Only parent unlocks.
    if ($PID == $mypid) {
	$slice->UnLock();
    }
    if ($cachedebug) {
	GeniUtil::DumpCaches();
	emutil::DumpCaches();
    }
    return 0;
}

#
# Prestage Images needed by a slice.
#
sub PrestageImages($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $credentials  = $argref->{'credentials'};
    my $imagelist    = $argref->{'imagelist'};
    my $operation    = $argref->{'operation'};
    my $mypid        = $PID;
    my $response;
    my $retval;
    require Experiment;
    require libtestbed;
    require WebTask;
    require Image;

    # For now, I am not worrying about the slice_urn argument.
    if (! (defined($credentials) && defined($operation) &&
	   defined($slice_urn) && defined($imagelist))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! GeniHRN::IsValid($slice_urn)) {
	return GeniResponse->MalformedArgsResponse("Bad characters in URN");
    }
    if (ref($imagelist) ne "ARRAY") {
	return GeniResponse->MalformedArgsResponse("Imagelist is not an array");
    }
    my ($credential,$speaksfor,@morecreds) =
	GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    main::AddLogfileMetaData("slice_urn", $slice_urn);

    my $user = GeniCM::CreateUserFromCertificate($credential);
    if (GeniResponse::IsResponse($user)) {
	print STDERR "Could not create geni user for $credential\n";
	return $user;
    }

    my %map      = ();
    my %prestage = ();
    my $blob = {
	"status" => {},
    };

    # Get the project and group.
    my $group = GeniUtil::GetHoldingProject($slice_urn, $user);
    if (GeniResponse::IsResponse($group)) {
	$response = $group;
	goto bad;
    }

    #
    # Go through image list and do the same MapToLocalImage() that we
    # do when actually starting an experiment. 
    #
    foreach my $urn (@{ $imagelist }) {
	my $image;
	
	my $hrn = GeniHRN->new($urn);
	if (!defined($hrn)) {
	    $response =
		GeniResponse->MalformedArgsResponse("Not a valid URN: $urn");
	    goto bad;
	}
	if ($hrn->IsImage()) {
	    if (! (defined($hrn->ospid()) && defined($hrn->osname()))) {
		$response =
		    GeniResponse->MalformedArgsResponse(
			"Malformed image URN: $urn");
		goto bad;
	    }
	    $image = GeniImage::MapToLocalImage($urn, undef,
						$group->pid(),
						# Assumes image tracking.
						1, @morecreds);
	    if (GeniResponse::IsError($image)) {
		$response = $image;
		goto bad;
	    }
	}
	elsif ($hrn->IsIMDataset()) {
	    $response =
		GeniResponse->MalformedArgsResponse("Do not know how to ".
						    "prestage : $urn");
	    goto bad;
	}
	else {
	    $response =
		GeniResponse->MalformedArgsResponse("Do not know how to ".
						    "prestage : $urn");
	    goto bad;
	}
	my $status = {
	    "status"   => "ready"
	};
	if ($image->isImage()) {
	    $status->{"versname"} = $image->versname();
	    $status->{"urn"} = $urn;
	    # What the user is waiting for. 
	    $status->{"size"} = $image->size() ? int($image->size() / 1024) : 0;
	}
	
	#
	# If any of these are true, then we do not have to worry about
	# prestaging
	#
	if (! ($image->isImageAlias() || !$image->isImage() ||
	       $image->IsLocal() || $image->IsSystemImage())) {
	    if (! $image->ready()) {
		$status->{"status"} = "notready";
		# Start the image prestaging if requested.
		$prestage{$urn} = $image
		    if ($operation eq "prestage");
		# Lets try to figure out the current size of the import file.
		$status->{"progress"} = $image->ImportImageFileSize();
	    }
	    else {
		$status->{"progress"} = $status->{"size"};
	    }
	}
	$blob->{"status"}->{$urn} = $status;
    }
    print STDERR Dumper($blob);

    #
    # We want to fire off imports for the images we need to get, but
    # we do this in the background and have the caller poll for status.
    # Only one at a time, since the reason we do prestage is because
    # we have poor connectivity to this aggregate.
    #
    if ($operation eq "prestage" && keys(%prestage)) {
	my @todo = keys(%prestage);
	while (@todo) {
	    my $urn   = shift(@todo);
	    my $image = $prestage{$urn};

	    if ($image->Lock()) {
		print STDERR "$image is currently locked. Waiting ...\n";

		if ($image->WaitLock(30)) {
		    print STDERR "Still locked, moving on to another.\n";
		    push(@todo, $urn);
		    next;
		}
	    }
	    print STDERR "Got the lock on $image.\n";

	    #
	    # Make sure image is still not ready, maybe someone else
	    # got in and was working on it.
	    #
	    $image->Refresh();
	    if ($image->ready()) {
		print STDERR "$image is ready after locking. Moving on\n";
		$image->Unlock();
		next;
	    }

	    #
	    # Enter a pending entry so the daemon can pick things up.
	    # In general, we prestage cause connectivity and/or bandwidth
	    # is very limited, so serializing is probably the better
	    # approach. Revisit later if needed. Note that we can receive
	    # multiple prestage requests for the same image, say from two
	    # different experiments wanting to start. Both are going to
	    # have to wait on the same pending entry to finish up.
	    #
	    my $pending = Image::PendingImport->Lookup($image->imageid());
	    if (defined($pending)) {
		# Already working on it elsewhere.
		print STDERR "Pending already exists, moving on.\n";
		$image->Unlock();
		next;
	    }
	    $pending = Image::PendingImport->Lookup($image->metadata_url());
	    if (defined($pending)) {

	    }
	    $pending = Image::PendingImport->Create({
		"uid"          => $image->creator(),
		"uid_idx"      => $image->creator_idx(),
		"pid"          => $image->pid(),
		"pid_idx"      => $image->pid_idx(),
		"type"         => "import",
		"imagename"    => $image->imagename(),
		"imageid"      => $image->imageid(),
		"metadata_url" => $image->metadata_url(),
	    });
	    if (!defined($pending)) {
		print STDERR "Could not pending import object\n";
		$image->Unlock();
		$response =
		    GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				 "Could not create pending import object");
		goto bad;
	    }
	    $image->Unlock();
	    $map{$urn} = $pending;
	}
	if (keys(%map)) {
	    # debugging
	    if (0) {
		print STDERR "Not importing images yet\n";
	    }
	    else {
		#
		# Fire off the imports in the background. Hopefully
		# these work first time and the daemon will not have
		# to ever deal with them.
		#
		$mypid = main::WrapperFork();
		if ($mypid) {
		    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
		}
		my @todo = keys(%map);
		while (@todo) {
		    my $urn     = shift(@todo);
		    my $pending = $map{$urn};
		    my $image   = $prestage{$urn};

		    #
		    # Use a webtask, we want better reporting from the importer
		    # so we can report back. Network issues need to be treated
		    # as a retryable error. 
		    #
		    my $webtask = WebTask->CreateAnonymous();
		    if (!defined($webtask)) {
			print STDERR "Could not create web task.\n";
			next;
		    }
		    my $command = "$IMPORTER -d -t ". $webtask->task_id() .
			" -g -P " . $pending->idx();

		    print STDERR "Running: '$command'\n";
		    GeniUtil::ExecuteAsGeniUser("$command");
		    $webtask->Refresh();
		    if ($?) {
			my $code = $? >> 8;
			if (!$webtask->HasExited() || $webtask->exitcode() < 0){
			    $pending->Failed($webtask->HasExited() ?
					     $webtask->output() :
					     "Internal error importing image");
			}
		    }
		    $webtask->Delete();
		}
		return 0;
	    }
	}
    }
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);

  bad:
    return -1
      if ($mypid != $PID);
    return $response;
}

#
# Delete a Sliver.
#
sub DeleteSliver($)
{
    my ($argref) = @_;
    my $sliver_urn   = $argref->{'sliver_urn'};
    my $credentials  = $argref->{'credentials'};
    my $impotent     = $argref->{'impotent'} || 0;

    if (! (defined($credentials) && defined($sliver_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! GeniHRN::IsValid($sliver_urn)) {
	return GeniResponse->MalformedArgsResponse("Bad characters in URN");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    #
    # In this implementation, the user must provide a slice or sliver
    # credential
    #
    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));
    
    if (! (defined($slice) && defined($aggregate))) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Sliver does not exist");
    }
    if ($sliver_urn ne $aggregate->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    # Terminated slices get nothing.
    if ($slice->termination_pending()) {
	return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
				    "Slice is marked for termination");
    }
    if ($slice->Lock() != 0) {
	return GeniResponse->BusyResponse();
    }
    $aggregate->Refresh();
    
    if ($aggregate->Busy() ||
	$aggregate->Imaging()) {
	$slice->UnLock();
	return GeniResponse->BusyResponse();
    }
    main::AddLogfileMetaData("sliver_urn", $sliver_urn);
    main::AddLogfileMetaDataFromSlice($slice);
    
    #
    # We need this below to sign the ticket.
    #
    my $authority = GeniCertificate->LoadFromFile($EMULAB_PEMFILE);
    if (!defined($authority)) {
	print STDERR " Could not load $EMULAB_PEMFILE\n";
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_ERROR);
	
    }
    #
    # We need the user to sign the new ticket to. 
    #
    my $user = GeniCM::CreateUserFromCertificate($credential);
    if (GeniResponse::IsResponse($user)) {
	$slice->UnLock();
	return $user;
    }
    
    my $response = GeniCM::DeleteSliverAux($credential, $impotent, 1);
    if (GeniResponse::IsResponse($response)) {
	$slice->UnLock();
	return $response;
    }

    #
    # In the v2 API, return a new ticket for the resources
    # (which were not released). As with all tickets, it will
    # expire very quickly. 
    #
    #
    # Create a new ticket from the manifest.
    #
    my $manifest = $aggregate->GetManifest(0);
    if (!defined($manifest)) {
	print STDERR "No manifest found for $aggregate\n";
	$response = GeniResponse->Create(GENIRESPONSE_ERROR);
	goto bad;
    }
    my $ticket = GeniTicket->Create($authority, $user,
				    GeniXML::Serialize($manifest));
    if (!defined($ticket)) {
	print STDERR "Could not create new ticket for $slice\n";
	$response = GeniResponse->Create(GENIRESPONSE_ERROR);
	goto bad;
    }
    $ticket->SetSlice($slice);
    $ticket->SetSpeaksFor($speaksfor)
	if (defined($speaksfor));
    
    if ($ticket->Sign()) {
	$ticket->Delete();
	print STDERR "Could not sign new ticket $ticket\n";
	$response = GeniResponse->Create(GENIRESPONSE_ERROR);
	goto bad;
    }
    if ($ticket->Store()) {
	$ticket->Delete();
	print STDERR "Could not store new ticket $ticket\n";
	$response = GeniResponse->Create(GENIRESPONSE_ERROR);
	goto bad;
    }
    my $slice_uuid = $slice->uuid();
    DBQueryWarn("delete from geni_manifests ".
		"where slice_uuid='$slice_uuid'");
    $slice->UnLock();
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $ticket->asString());

  bad:
    if (GeniCM::CleanupDeadSlice($slice) != 0) {
	print STDERR "Could not cleanup slice\n";
    }
    return $response;
}

#
# Delete a Slice
#
sub DeleteSlice($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $credentials  = $argref->{'credentials'};
    my $impotent     = $argref->{'impotent'} || 0;
    my $cancel       = 0;
    my $blocking     = 0;

    if (! (defined($credentials) && defined($slice_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! GeniHRN::IsValid($slice_urn)) {
	return GeniResponse->MalformedArgsResponse("Bad characters in URN");
    }
    if (exists($argref->{'blocking'}) && $argref->{'blocking'}) {
	$blocking = 1;
    }
    if (exists($argref->{'cancel'}) && $argref->{'cancel'}) {
	$cancel = 1;
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    #
    # In this implementation, the user must provide a slice credential.
    #
    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! defined($slice)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "No such slice here");
    }
    main::AddLogfileMetaDataFromSlice($slice);
    
    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    if ($slice->lockdown()) {
	return GeniResponse->Create(GENIRESPONSE_REFUSED(), undef,
				    "Slice is locked down");
    }
    if ($slice->termination_pending()) {
	return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
		    "Slice is already marked for termination, be patient");
    }
    if ($slice->WaitForLock(5) != 0) {
	return GeniResponse->BusyResponse();
    }
    if (!defined($aggregate)) {
	# Easy. Force blocking off and cleanup.
	$blocking = 1;
	goto cleanit;
    }
    $aggregate->Refresh();
    my $slice_experiment = $slice->GetExperiment();
    
    #
    # Do not allow a paniced slice to be terminated until the panic
    # is cleared.
    #
    if (defined($slice_experiment) && 
	($slice_experiment->state() eq EXPTSTATE_PANICED() ||
	 $slice_experiment->paniced())) {
	#
	# We are going to let the slice's SA clear the panic so it
	# can terminate. We know that it is in level 1 or 3, so we
	# can just clear it without rebooting, the nodes are going to
	# go into reloading anyway.
	#
	my $caller = GeniHRN->new($credential->owner_urn());
	if (! ($caller->IsSA() && 
	       $caller->domain() eq $slice->urn()->domain())) {
	    print STDERR "Refusing to terminate a paniced experiment\n";
	    $slice->UnLock();
	    return GeniResponse->Create(GENIRESPONSE_REFUSED(), undef,
				"Refusing to terminate a paniced experiment");
	}
	if (! ($slice_experiment->paniced() == 1 ||
	       $slice_experiment->paniced() == 3)) {
	    return GeniResponse->Create(GENIRESPONSE_REFUSED(), undef,
				"Paniced experiment is not at correct level");
	}
	#
	# This operation has to be done as an admin person. 
	#
	my $pid = $slice_experiment->pid();
	my $eid = $slice_experiment->eid();
	my $command = "$WAP $PANIC -c $pid $eid";
	print STDERR "Clearing panic before termination\n";
	GeniUtil::FlipToElabMan();
	system($command);
	if ($?) {
	    $slice->UnLock();
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				"Could not clear panic before termination");
	}
	$slice->ClearShutdown();
	GeniUtil::FlipToGeniUser();	
    }

    #
    # If the aggregate is busy, then we are in the midst of a long running
    # operation (start/restart/reload/reboot). In general we need to wait
    # for that to finish before we can actually do the delete. This might
    # mean that the user will not be able to delete the slice for a long
    # time, but we are having problems with users canceling slices before
    # they finish setting up, and the XEN client side is not handling this
    # very well. Note that the cleanupslice script calls
    # GeniCM::CleanupDeadSlice() directly, which *does* kill the monitor,
    # so admin cleanup is not affected.
    #
    # If additional cancel option is provided, we mark the slice for
    # termination after it is not busy anymore. We also set the cancel flag
    # which will stop experiment setup early (well, a little early).  We
    # have the slice locked, so we can hang out waiting, but we mark the
    # slice in case we timeout (or just plain die) here, the daemon can
    # pick it up the baton later. 
    #
    if ($aggregate->Busy()) {
	if (!$cancel) {
	    $slice->UnLock();
	    return GeniResponse->BusyResponse();
	}
    }
    # If any slivers are imaging, then we are busy as well.
    elsif ($aggregate->Imaging()) {
	$slice->UnLock();
	return GeniResponse->BusyResponse();
    }

    #
    # Proceed in the background. No reason to make the caller wait,
    # it takes too long.
    #
    if (!$blocking) {
	my $mypid = main::WrapperFork();
	if ($mypid) {
	    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
	}
    }

    #
    # OK, we want to wait for the aggregate to stop being Busy, so that
    # we can proceed with the termination. We will set the flag in the
    # slice record in case we die here, so that the daemon can pick it up
    # later and finish.
    #
    # We also set the slice experiment cancelation flag, which will stop
    # a new experiment setup early.
    #
    if ($aggregate->Busy()) {
	my $slice_uuid = $slice->uuid();
	print STDERR "aggregate is busy, marking for cancelation\n";
	$slice->MarkForTermination();
	$slice_experiment->SetCancelFlag(1);

	if (0) {
	    $slice->UnLock();
	    return 0
		if (!$blocking);
	    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
	}

	#
	# Now we wait. Release the lock in case we die, the daemon
	# will be watching as well, but it will not do anything unless
	# it gets the lock and the aggregate is no longer busy. We are
	# doing the same thing here. Of course, need to watch for the
	# slice disappearing (if the daemon beats us to it).
	#
	$slice->UnLock();
	$slice->Flush();
	while (1) {
	    sleep(10);
	    $slice = GeniSlice->Lookup($slice_uuid);
	    if (!defined($slice)) {
		print STDERR "Slice is gone, quiting ...\n";
		goto done;
	    }
	    # If it is locked, go around again, maybe the daemon has it.
	    next
		if ($slice->Lock());

	    $aggregate->Flush();
	    $aggregate = GeniAggregate->SliceAggregate($slice);
	    # This would be unusual, so call it quits.
	    if (!defined($aggregate)) {
		print STDERR "No aggregate for slice, giving up\n";
		$slice->UnLock();
		goto done;
	    }
	    last
		if (!$aggregate->Busy());
	    
	    $slice->UnLock();
	    $slice->Flush();
	}
	# Make sure the cancel flag is cleared (checked in endexp).
	$slice_experiment->SetCancelFlag(0);
    }
  cleanit:
    my $retval = GeniCM::CleanupDeadSlice($slice, 1);
    if ($retval) {
	# Must unlock so we can try again.
        $slice->UnLock();
	return -1
	    if (!$blocking);
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
  done:
    return 0
	if (!$blocking);
    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
}

#
# Get a Sliver (credential)
#
sub GetSliver($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $credentials  = $argref->{'credentials'};

    if (! (defined($credentials) && defined($slice_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! GeniHRN::IsValid($slice_urn)) {
	return GeniResponse->MalformedArgsResponse("Bad characters in URN");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    #
    # In this implementation, the user must provide a slice credential.
    #
    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! (defined($slice) && defined($aggregate))) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "No slice or aggregate here");
    }
    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    return GeniCM::GetSliverAux($credential);
}

#
# Start a sliver (not sure what this means yet, so reboot for now).
#
sub StartSliver($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $sliver_urns  = $argref->{'sliver_urns'} || $argref->{'component_urns'};
    my $credentials  = $argref->{'credentials'};
    my $manifest     = $argref->{'manifest'};
    
    return SliverAction("start",
			$slice_urn, $sliver_urns, $credentials, $manifest, 0);
}

sub StopSliver($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $sliver_urns  = $argref->{'sliver_urns'} || $argref->{'component_urns'};
    my $credentials  = $argref->{'credentials'};

    return SliverAction("stop",
			$slice_urn, $sliver_urns, $credentials, undef, 0);
}

sub RestartSliver($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $sliver_urns  = $argref->{'sliver_urns'} || $argref->{'component_urns'};
    my $credentials  = $argref->{'credentials'};
    my $manifest     = $argref->{'manifest'};
    my $asyncmode    = (exists($argref->{'asyncmode'}) ?
			$argref->{'asyncmode'} : 0);

    return SliverAction("restart",
			$slice_urn, $sliver_urns, $credentials, $manifest,
			$asyncmode);
}

sub ReloadSliver($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $sliver_urns  = $argref->{'sliver_urns'} || $argref->{'component_urns'};
    my $credentials  = $argref->{'credentials'};
    my $asyncmode    = (exists($argref->{'asyncmode'}) ?
			$argref->{'asyncmode'} : 0);

    return SliverAction("reload",
			$slice_urn, $sliver_urns, $credentials, undef,
			$asyncmode);
}

sub PowerCycleSliver($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $sliver_urns  = $argref->{'sliver_urns'} || $argref->{'component_urns'};
    my $credentials  = $argref->{'credentials'};
    my $asyncmode    = (exists($argref->{'asyncmode'}) ?
			$argref->{'asyncmode'} : 0);

    return SliverAction("powercycle",
			$slice_urn, $sliver_urns, $credentials, undef,
			$asyncmode);
}

sub SliverAction($$$$$$)
{
    my ($action, $slice_urn, $sliver_urns, $credentials,
	$manifest, $asyncmode) = @_;
    my $response;
    my $isasync = 0;

    if (! (defined($credentials) &&
	   (defined($slice_urn) || defined($sliver_urns)))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    $credential->HasPrivilege( "pi" ) or
	$credential->HasPrivilege( "info" ) or
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
				    "Insufficient privilege");

    if (defined($manifest)) {
	$manifest = GeniXML::Parse($manifest);
	if (!defined($manifest)) {
	    print STDERR "Error reading manifest\n";
	    return GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
					"Bad manifest");
	}
    }
    
    #
    # For now, only allow top level aggregate or the slice
    #
    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    #
    # I think this allows the CM to perform an action without
    # the slice credential?
    #
    if ( (!defined($slice)) && 
          ($credential->target_urn() =~ /\+authority\+cm$/)) {
          # administrative credentials are presented.
          my $cm_urn = GeniHRN::Generate($OURDOMAIN, "authority", "cm");
          if ($cm_urn != $credential->target_urn()) {
            return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
                      "Credential target does not match CM URN");
          }

      if (!defined($slice_urn)) {
          return GeniResponse->MalformedArgsResponse("Missing arguments");
      }       
      $slice = GeniSlice->Lookup($slice_urn);
      return GeniResponse->Create(GENIRESPONSE_ERROR, undef, 
                "No Slice with urn $slice_urn here")
          if (!defined($slice));
      $aggregate = GeniAggregate->SliceAggregate($slice);
      return GeniResponse->Create(GENIRESPONSE_ERROR, undef, 
                      "No Aggregate here")
          if (!defined($aggregate));
    } 

    if (! (defined($slice) && defined($aggregate))) {
	return GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
				    "No slice or aggregate here");
    }
    main::AddLogfileMetaDataFromSlice($slice);

    if (defined($slice_urn)) {
	if (! GeniHRN::IsValid($slice_urn)) {
	    return
		GeniResponse->MalformedArgsResponse("Bad characters in URN");
	}
	if ($slice_urn ne $slice->urn()) {
	    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
					"Credential does not match the URN");
	}
    }
    if ($slice->termination_pending()) {
	return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
				    "Slice is marked for termination");
    }
    # Shutdown slices get nothing.
    if ($slice->shutdown()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
				    "Slice has been shutdown");
    }
    if ($slice->Lock() != 0) {
	return GeniResponse->BusyResponse();
    }
    $aggregate->Refresh();
    
    if ($aggregate->Busy() ||
	$aggregate->Imaging()) {
	$slice->UnLock();
	return GeniResponse->BusyResponse();
    }
    if ($aggregate->ComputeState()) {
	$slice->UnLock();
	print STDERR "Could not determine current state\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    my $CheckState = sub {
	my ($object, $action) = @_;

	if ($action eq "start") {
	    if ($object->state() !~ /^(stopped|new|mixed|interrupted)$/) {
		return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
					    "Sliver is not stopped (yet)");
	    }
	}
	elsif ($action eq "stop") {
	    if ($object->state() ne "started" && $object->state() ne "mixed") {
		return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
					    "Sliver is not started (yet)");
	    }
	}
	elsif ($action eq "restart") {
	    if ($object->state() ne "started" && $object->state() ne "mixed") {
		return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
					    "Sliver is not started (yet)");
	    }
	}
	elsif ($action eq "powercycle") {
	    if ($object->state() ne "started" && $object->state() ne "mixed") {
		return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
					    "Sliver is not started (yet)");
	    }
	}
	elsif ($action eq "reload") {
	    # We want to make this check before the fork, which makes it messy
	    if (ref($object) eq "GeniSliver::Node" ||
		ref($object) eq "Aggregate") {
		if ($object->InRecovery()) {
		    return
			GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				 "Must clear recovery mode before reload");
		}
	    }
	    if ($object->state() ne "started" && $object->state() ne "stopped"){
		return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				    "Sliver is not started or stopped (yet)");
	    }
	}
	return 0;
    };
    my $PerformAction = sub {
	my ($object, $action, @slivers) = @_;

	my $exitval = 0;

	if ($action eq "start") {
	    $exitval = $object->Start($API_VERSION);
	}
	elsif ($action eq "stop") {
	    $exitval = $object->Stop($API_VERSION);
	}
	elsif ($action eq "restart") {
	    if (@slivers) {
		$exitval = $object->BatchAction("restart", @slivers);
	    }
	    else {
		$exitval = $object->Restart($API_VERSION);
	    }
	}
	elsif ($action eq "powercycle") {
	    if (@slivers) {
		$exitval = $object->BatchAction("powercycle", @slivers);
	    }
	    else {
		$exitval = $object->PowerCycle($API_VERSION);
	    }
	}
	elsif ($action eq "reload") {
	    if (@slivers) {
		$exitval = $object->BatchAction("reload", @slivers);
	    }
	    else {
		$exitval = $object->Reload($API_VERSION);
	    }
	}
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Could not $action sliver")
	    if ($exitval);
	
	return 0;
    };

    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));

    my $realuser = GeniCM::FlipToUser($slice, $user);
    if (! (defined($realuser) && $realuser)) {
	print STDERR "Error flipping to real user\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "FlipToUser Error");
    }

    if (defined($slice_urn)) {
	#
	# If the user is trying to restart an interrupted slice, then
	# switch to "start" since that makes more sense.
	#
	if ($action eq "restart" && $aggregate->state() eq "interrupted") {
	    $action = "start";
	}
	
	$response = &$CheckState($aggregate, $action);
	goto bad
	    if (GeniResponse::IsResponse($response));
	    
	if ($action eq "start" || $action eq "restart" || $action eq "reload"){
	    if (defined($manifest) &&
		$aggregate->ProcessManifest($manifest)) {
		$response = GeniResponse->Create(GENIRESPONSE_ERROR,
						 undef,
						 "Error processing manifest");
		goto bad;
	    }
	    #
	    # At this point we want to return and let the startsliver proceed
	    # in the background
	    #
	    my $mypid = main::WrapperFork();
	    if ($mypid) {
		return GeniResponse->Create(GENIRESPONSE_SUCCESS);
	    }
	    #
	    # The callee might also do a wrapper fork, so remember our PID
	    # to make sure we unlock properly in only the parent side of the
	    # fork. That child would run with the slice unlocked, Might not
	    # be a safe thing to do needs more thought. 
	    #
	    $isasync = $PID;
	}
	$response = &$PerformAction($aggregate, $action);
	goto bad
	    if (GeniResponse::IsResponse($response));

	if (!$isasync || $isasync == $PID) {
	    $slice->UnLock();
	}
	return ($isasync ? GENIRESPONSE_SUCCESS :
		GeniResponse->Create(GENIRESPONSE_SUCCESS));
    }
    else {
	my @slivers = ();

	#
	# Sanity check all arguments before doing anything.
	#
	foreach my $urn (@{ $sliver_urns }) {
	    my $sliver = GeniSliver->Lookup($urn);
	    if (!defined($sliver)) {
		$response = GeniResponse->Create(GENIRESPONSE_SEARCHFAILED,
						 undef,
						 "Nothing here by that name");
		goto bad;
	    }
	    
	    $response = &$CheckState($sliver, $action);
	    goto bad
		if (GeniResponse::IsResponse($response));

	    push(@slivers, $sliver);
	}
	foreach my $sliver (@slivers) {
	    if ($action eq "start" && defined($manifest)) {
		if ($sliver->ProcessManifest($manifest)) {
		    $response = GeniResponse->Create(GENIRESPONSE_ERROR,
				     undef,
				     "Error processing manifest for $sliver");
		    goto bad;
		}
	    }
	}
	if ($asyncmode && $action =~ /^(restart|reload)$/) {
	    #
	    # At this point we want to return and let the startsliver proceed
	    # in the background
	    #
	    my $mypid = main::WrapperFork();
	    if ($mypid) {
		return GeniResponse->Create(GENIRESPONSE_SUCCESS);
	    }
	    # Remember our pid in case callee forks again.
	    $isasync = $PID;

	    $response = &$PerformAction($aggregate, $action, @slivers);
	    goto bad
		if (GeniResponse::IsResponse($response));

	    #
	    # The callee might also do a wrapper fork, so remember our PID
	    # to make sure we unlock properly in only the parent side of the
	    # fork. That child would run with the slice unlocked, Might not
	    # be a safe thing to do needs more thought. 
	    #
	    if ($isasync == $PID) {
		$slice->UnLock();
	    }
	}
	else {
	    foreach my $sliver (@slivers) {
		$response = &$PerformAction($sliver, $action);
		goto bad
		    if (GeniResponse::IsResponse($response));
	    }
	    $slice->UnLock();
	}
	return ($isasync ? GENIRESPONSE_SUCCESS :
		GeniResponse->Create(GENIRESPONSE_SUCCESS));
    }
  bad:
    $slice->UnLock();
    return ($isasync ? $response->{'code'} : $response);
}

#
# Get sliver status
#
sub SliverStatus($)
{
    my ($argref)     = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $credentials  = $argref->{'credentials'};
    my $status;
    require Node;

    if (! (defined($credentials) && defined($slice_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! GeniHRN::IsValid($slice_urn)) {
	return GeniResponse->MalformedArgsResponse("Bad characters in URN");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    $credential->HasPrivilege( "pi" ) or
	$credential->HasPrivilege( "info" ) or
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
				    "Insufficient privilege");

    #
    # For now, only allow top level aggregate or the slice
    #
    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! (defined($slice) && defined($aggregate))) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "No slice or aggregate here");
    }
    main::AddLogfileMetaDataFromSlice($slice);
    
    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    if ($slice->Lock() != 0) {
	return GeniResponse->BusyResponse();
    }
    $aggregate->Refresh();
    my $slice_experiment = $slice->GetExperiment();

    #
    # Do not call ComputeState() while in the "working" state, since the
    # action workers in GeniAggregate() are typically running without
    # locking, and changing things here causes a race. 
    #
    # Convert to "changing" for the caller, since "working" is an internal
    # status for the newer start/restart code.
    #
    if ($aggregate->Busy()) {
	$status = "changing";
    }
    else {
	if ($aggregate->ComputeState()) {
	    print STDERR "SliverStatus: Could not compute state for $aggregate\n";
	    $slice->UnLock();
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	$status = $aggregate->status();
    }

    #
    # Grab all the slivers for this slice, and then
    # look for just the nodes.
    #
    my @slivers    = ();
    if ($aggregate->SliverList(\@slivers) != 0) {
	print STDERR "SliverStatus: Could not get slivers for $aggregate\n";
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }

    my $blob = {"state"   => $aggregate->state(),
		"status"  => $status,
		"utc"     => time(),
		"details" => {},
		"boot_failure" => $aggregate->boot_failure(),
		"error"   => $aggregate->ErrorLog() || "",
		"shutdown"=> $slice->isshutdown(),
		"paniced" => $slice_experiment->paniced(),
	       };
    $blob->{'public_url'} =
	"$TBBASE/showslicepub.php?publicid=" .	$slice->publicid()
	if (defined($slice->publicid()));
    
    #
    # If running async mode and we have an error, add this too.
    #
    if ($slice->async_code()) {
	$blob->{"async_code"}   = $slice->async_code();
	$blob->{"async_output"} = $slice->async_output();
    }
    
    foreach my $sliver (@slivers) {
	if ($sliver->isa("GeniAggregate")) {
	    next
		if (! (ref($sliver) eq "GeniAggregate::Link" ||
		       ref($sliver) eq "GeniAggregate::Tunnel"));
	}
	elsif ($sliver->resource_type() ne "Node" &&
	       $sliver->resource_type() ne "Vhost") {
	    next;
	}
	my $sliver_urn = $sliver->sliver_urn();
	my $details = $sliver->GenerateStatusBlob();
	next
	    if (!defined($details));
	
	if ($details->{'status'} eq "failed") {
	    $details->{'error'} = $sliver->ErrorLog();
	}
	$blob->{'details'}->{$sliver_urn} = $details;
    }
    $slice->UnLock();
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
}

#
# Shutdown sliver
#
sub Shutdown($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $clear        = $argref->{'clear'} || 0;
    my $credentials  = $argref->{'credentials'};
    require libtestbed;

    if (! (defined($credentials) && defined($slice_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    $credential->HasPrivilege( "pi" ) or
	$credential->HasPrivilege( "instantiate" ) or
	$credential->HasPrivilege( "control" ) or
	return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				     "Insufficient privilege" );

    #
    # The clearinghouse generates a different credential to do this.
    #
    if ($slice_urn ne $credential->target_urn()) {
	my $certificate = GeniCertificate->LoadFromFile($GENICH_PEMFILE);
	if (!defined($certificate)) {
	    print STDERR "Could not load certificate from $GENICH_PEMFILE\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}

	# The caller has to match the clearinghouse.
	if ($credential->owner_urn() ne $certificate->urn()) {
	    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
					"Insufficient privilege");
	}
    }

    #
    # No slice here? Done.
    #
    my $slice = GeniSlice->Lookup($slice_urn);
    if (!defined($slice)) {
	return GeniResponse->Create(GENIRESPONSE_SUCCESS);
    }
    main::AddLogfileMetaDataFromSlice($slice);

    # No point in shutting down a slice marked for termination.
    if ($slice->termination_pending()) {
	return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
				    "Slice is marked for termination");
    }
    
    #
    # Do not worry about locking when setting the shutdown time.
    # This can lead to race though, if a clear shutdown comes in first.
    # Seems unlikely though. 
    #
    if (!$clear) {
	# Do not overwrite original shutdown time
	$slice->SetShutdown(1)
	    if (!defined($slice->shutdown()) || $slice->shutdown() eq "");
    }
    else {
	$slice->SetShutdown(0);
    }
    # Always make sure the slice is shutdown.
    if ($slice->shutdown()) {
	# The expire daemon is going to look for this, so it will get
	# taken care of shortly.
	if ($slice->Lock() != 0) {
	    return GeniResponse->BusyResponse();
	}
	if (GeniCM::CleanupDeadSlice($slice, 0) != 0) {
	    libtestbed::SENDMAIL($TBOPS, "Emergency Shutdown failed",
				 "Emergency shutdown failed on $slice\n");
	    print STDERR "Could not shutdown $slice!\n";
	    # Lets call this a non-error since the local admin person
	    # is going to have to deal with it anyway. 
	}
	$slice->UnLock();
    }
    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
}

#
# Renew a slice
#
sub RenewSlice($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $valid_until  = $argref->{'valid_until'} || $argref->{'expiration'};
    my $credentials  = $argref->{'credentials'};
    my $alap         = 0;
    my $force        = 0;
    # extend as long as possible.
    $alap = $argref->{'alap'} if (exists($argref->{'alap'}));
    # reservation system override
    $force = $argref->{'force'} if (exists($argref->{'force'}));

    if (! (defined($credentials) && defined($slice_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! GeniHRN::IsValid($slice_urn)) {
	return GeniResponse->MalformedArgsResponse("Bad characters in URN");
    }
    my ($credential,$speaksfor,@morecreds) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    #
    # In this implementation, the user must provide a slice credential.
    #
    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! defined($slice)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED(), undef,
				    "No such slice here");
    }
    main::AddLogfileMetaDataFromSlice($slice);
    
    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    return GeniCM::RenewSliverAux([$credential, @morecreds],
				  $valid_until, $alap, $force);
}

#
# Get a Ticket.
#
sub GetTicket($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $rspecstr     = $argref->{'rspec'};
    my $credentials  = $argref->{'credentials'};
    my $impotent     = $argref->{'impotent'} || 0;
    my $usetracker   = $argref->{'usetracker'} || 0;

    if (! (defined($credentials) &&
	   defined($slice_urn) && defined($rspecstr))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! ($rspecstr =~ /^[\040-\176\012\015\011]+$/)) {
	return GeniResponse->MalformedArgsResponse("Bad characters in rspec");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    main::AddLogfileMetaData("slice_urn", $slice_urn);
    
    #
    # This implementation requires a slice credential, and it must
    # match the slice_urn.
    #
    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    if (defined($slice)) {
	return $slice
	    if (GeniResponse::IsResponse($slice));
	
	main::AddLogfileMetaDataFromSlice($slice);
    
	if ($slice_urn ne $slice->urn()) {
	    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
					"Credential does not match the URN");
	}
	# Terminated slices get nothing.
	if ($slice->termination_pending()) {
	    return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
					"Slice is marked for termination");
	}
	if (defined($aggregate) && $aggregate->Busy()) {
	    return GeniResponse->BusyResponse();
	}
	
	#
	# Watch for a placeholder slice and update it.
	#
	if ($slice->isplaceholder()) {
	    if ($slice->Lock() != 0) {
		return GeniResponse->BusyResponse();
	    }
	    #
	    # Confirm that the slice certificate is the same.
	    #
	    if ($slice->cert() ne $credential->target_cert()->cert()) {
		$slice->UnLock();
		return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
					    "Slice certificate mismatch");
	    }
	    my $user =
		GeniCM::CreateUserFromCertificate($credential);
	    if (GeniResponse::IsResponse($user)) {
		$slice->UnLock();
		return $user;
	    }
	    if ($slice->ConvertPlaceholder($user) != 0) {
		$slice->UnLock();
		return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					    "Could not convert placeholder");
	    }
	    $slice->UnLock();
	}

	#
	# GetTicket applies only to slices that are not active. Must
	# use UpdateSliver() for an active sliver.
	#
	if (defined($aggregate)) {
	    return GeniResponse->Create(GENIRESPONSE_REFUSED(), undef,
				"Cannot get a ticket for active sliver");
	}
	#
	# It is an error if there is an outstanding ticket. That ticket
	# must be released first.
	#
	my $ticket = GeniTicket->SliceTicket($slice);
	if (defined($ticket)) {
	    return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				    "Must release unredeemed ticket first");
	}
	if ($slice->IsExpired()) {
	    return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
					"Slice has expired");
	}
    }
    else {
	# Slice does not exist yet. 
    }
    return GeniCM::GetTicketAux({"credential" => $credential,
				 "rspecstr"   => $rspecstr,
				 "isupdate"   => 0,
				 "impotent"   => $impotent,
				 "v2"         => 1,
				 "level"      => 1,
				 "usetracker" => $usetracker,
				 "ticket"     => undef,
				 "speaksfor"  => $speaksfor,
				 "morecreds"  => [],
				 "async"      => 0,
				 "slice"      => undef});
}    
	
#
# Update a ticket, returning a new ticket. 
#
sub UpdateTicket($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $ticketstr    = $argref->{'ticket'};
    my $rspecstr     = $argref->{'rspec'};
    my $credentials  = $argref->{'credentials'};
    my $impotent     = $argref->{'impotent'} || 0;
    my $usetracker   = $argref->{'usetracker'} || 0;

    if (! (defined($credentials) && defined($ticketstr) &&
	   defined($slice_urn) && defined($rspecstr))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! ($rspecstr =~ /^[\040-\176\012\015\011]+$/)) {
	return GeniResponse->MalformedArgsResponse("Bad characters in rspec");
    }
    my ($credential,$speaksfor,@morecreds) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    main::AddLogfileMetaData("slice_urn", $slice_urn);
    
    defined($credential) &&
	($credential->HasPrivilege( "pi" ) or
	 $credential->HasPrivilege( "instantiate" ) or
	 $credential->HasPrivilege( "bind" ) or
	 return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				      "Insufficient privilege" ));

    #
    # This implementation requires a slice credential, and it must
    # match the slice_urn.
    #
    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    if (defined($slice)) {
	return $slice
	    if (GeniResponse::IsResponse($slice));

	if ($slice_urn ne $slice->urn()) {
	    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
					"Credential does not match the URN");
	}
    }
    else {
	# Slice should exist at this point.
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED(), undef,
				    "Slice does not exist here");
    }
    main::AddLogfileMetaDataFromSlice($slice);

    # Terminated slices get nothing.
    if ($slice->termination_pending()) {
	return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
				    "Slice is marked for termination");
    }
    if ($slice->IsExpired()) {
	return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				    "Slice has expired");
    }
    #
    # UpdateTicket applies only to slices that are not active. Must
    # use UpdateSliver() for an active sliver.
    #
    if (defined($aggregate)) {
	return GeniResponse->Create(GENIRESPONSE_REFUSED(), undef,
			    "Cannot update a ticket for active sliver");
    }

    my $ticket = GeniTicket->CreateFromSignedTicket($ticketstr);
    if (!defined($ticket)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    $GeniTicket::CreateFromSignedError);
    }

    #
    # We need the user to sign the new ticket. 
    #
    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));
    
    #
    # Make sure the ticket was issued to the caller.
    #
    if ($ticket->owner_urn() ne $user->urn()) {
	print STDERR $ticket->owner_urn() . "\n";
	print STDERR $user->urn() . "\n";
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
				    "This is not your ticket");
    }
    if (!$ticket->stored()) {
	return GeniResponse->Create(GENIRESPONSE_REFUSED(), undef,
				    "Not an active ticket");
    }
    if ($ticket->slice_urn() ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "This ticket is for another slice");
    }
    
    return GeniCM::GetTicketAuxAux({"slice"      => $slice,
				    "user"       => $user,
				    "rspecstr"   => $rspecstr,
				    "isupdate"   => 1,
				    "impotent"   => $impotent,
				    "v2"         => 1,
				    "level"      => 1,
				    "usetracker" => $usetracker,
				    "ticket"     => $ticket,
				    "credentials"=> [$credential, @morecreds],
				    "speaksfor"  => $speaksfor,
				    "async"      => 0});
}

#
# Update a sliver, returning a new ticket. 
#
sub UpdateSliver($)
{
    my ($argref) = @_;
    my $sliver_urn   = $argref->{'sliver_urn'};
    my $rspecstr     = $argref->{'rspec'};
    my $credentials  = $argref->{'credentials'};
    my $impotent     = $argref->{'impotent'} || 0;
    my $usetracker   = $argref->{'usetracker'} || 0;

    if (! (defined($credentials) &&
	   defined($sliver_urn) && defined($rspecstr))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! ($rspecstr =~ /^[\040-\176\012\015\011]+$/)) {
	return GeniResponse->MalformedArgsResponse("Bad characters in rspec");
    }
    my ($credential,$speaksfor,@morecreds) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    main::AddLogfileMetaData("sliver_urn", $sliver_urn);
    
    defined($credential) &&
	($credential->HasPrivilege( "pi" ) or
	 $credential->HasPrivilege( "instantiate" ) or
	 $credential->HasPrivilege( "bind" ) or
	 return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				      "Insufficient privilege" ));

    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! (defined($slice) && defined($aggregate))) {
	return GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
				    "No slice or aggregate here");
    }
    main::AddLogfileMetaDataFromSlice($slice);

    # Terminated slices get nothing.
    if ($slice->termination_pending()) {
	return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
				    "Slice is marked for termination");
    }
    # Must be an aggregate (top level sliver).
    if (ref($aggregate) ne "GeniAggregate") {
	return GeniResponse->MalformedArgsResponse("Must supply aggregate");
    }
    if ($sliver_urn ne $aggregate->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    if ($aggregate->Busy()) {
	return GeniResponse->BusyResponse();
    }
    if ($slice->IsExpired()) {
	return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				    "Slice has expired");
    }

    #
    # It is an error if there is an outstanding ticket. That ticket
    # must be released first.
    #
    my $ticket = GeniTicket->SliceTicket($slice);
    if (defined($ticket)) {
	return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				    "Must release unredeemed ticket first");
    }

    #
    # Any user can update the sliver. The ticket is signed to that user.
    #
    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));
    
    return GeniCM::GetTicketAuxAux({"slice"      => $slice,
				    "user"       => $user,
				    "rspecstr"   => $rspecstr,
				    "isupdate"   => 1,
				    "impotent"   => $impotent,
				    "v2"         => 1,
				    "level"      => 1,
				    "usetracker" => $usetracker,
				    "ticket"     => undef,
				    "credentials"=> [$credential, @morecreds],
				    "speaksfor"  => $speaksfor,
				    "async"      => 0});
}

#
# These next couple are special hacks.
#
sub AddNodes($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $credentials  = $argref->{'credentials'};
    my $nodelist     = $argref->{'nodes'};
    my $response;

    if (! (defined($credentials) &&
	   defined($slice_urn) && defined($nodelist))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    # It was agreed that nodes is a hash of:
    #
    #  {"node45" : {"diskimage" : "urn...",
    #               "startup"   : "/bin/echo",
    #               "tarballs"  : ["tarball1", "tarball2", ...],
    #               "lans"      : ["lan1", "lan2", ...],
    #               "hardware_type" : "type",
    #               "node"      : "pc189"}}
    #
    # "tarballs" may also be a list of ["tarball","installpath"] tuples.
    # "lans" may also be a a list of hashes, where each hash looks like
    # {'name':'lan-1','address':'10.0.0.1','netmask':'255.0.0.0','type':'ipv4'}
    # or similar.
    #
    if (ref($nodelist) ne "HASH") {
	return GeniResponse->MalformedArgsResponse("nodes is not a hash");
    }
    my ($credential,$speaksfor,@morecreds) =
	GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    $credential->HasPrivilege( "pi" ) or
	$credential->HasPrivilege( "instantiate" ) or
	$credential->HasPrivilege( "bind" ) or
	return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				     "Insufficient privilege" );

    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! (defined($slice))) {
	return GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
				    "No slice here");
    }
    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    my $manifest = $aggregate->GetManifest(0);
    return GeniResponse->Create(GENIRESPONSE_ERROR(), undef,
				"Could not get manifest for slice")
	if (!defined($manifest));

    # Terminated slices get nothing.
    if ($slice->termination_pending()) {
	return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
				    "Slice is marked for termination");
    }
    if ($aggregate->Busy()) {
	return GeniResponse->BusyResponse();
    }
    #
    # Make sure no duplicates.
    #
    foreach my $noderef (GeniXML::FindNodes("n:node",
					    $manifest)->get_nodelist()) {
	my $id = GeniXML::GetVirtualId($noderef);
	if (!defined($id)) {
	    print STDERR "No virtual node for $noderef\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR());
	}
	if (exists($nodelist->{$id})) {
	    return GeniResponse->Create(GENIRESPONSE_BADARGS(), undef,
					"Already have $id in the topology!");
	}
    }
    # Keep track of which nodes have to be added to which lans.
    my %ifacestoaddtolans = ();
    
    foreach my $nodeid (keys(%{$nodelist})) {
	my $blob = $nodelist->{$nodeid};

	#
	# If the user specifies a physical node, lets make sure that
	# node is not already reserved.
	#
	if (exists($blob->{'node'})) {
	    require Node;

	    my $pnodeid = $blob->{'node'};
	    my $pnode   = Node->Lookup($pnodeid);
	    if (!defined($pnode)) {
		return GeniResponse->Create(GENIRESPONSE_BADARGS(), undef,
				"Physical node $pnodeid does not exist");
	    }
	    if ($pnode->IsReserved()) {
		return GeniResponse->Create(GENIRESPONSE_BADARGS(), undef,
				"Physical node $pnodeid is not available");
	    }
	}
	next
	    if (!exists($blob->{"lans"}));

	if (ref($blob->{'lans'}) ne "ARRAY") {
	    return GeniResponse->MalformedArgsResponse("lans for $nodeid ".
						       "is not a list");
	}
	foreach my $lan (@{ $blob->{'lans'} }) {
	    if (ref($lan) eq 'HASH') {
		my $lanname = $lan->{'name'};
		if (!exists($ifacestoaddtolans{$lanname})) {
		    $ifacestoaddtolans{$lanname} = [];
		}
		push(@{ $ifacestoaddtolans{$lanname} }, "$nodeid:$lanname");
	    }
	    else {
		if (!exists($ifacestoaddtolans{$lan})) {
		    $ifacestoaddtolans{$lan} = [];
		}
		push(@{ $ifacestoaddtolans{$lan} }, "$nodeid:$lan");
	    }
	}
    }
    # But make sure all these lans exist.
    if (keys(%ifacestoaddtolans)) {
	my %tmp = ();
	
	foreach my $linkref (GeniXML::FindNodes("n:link",
						$manifest)->get_nodelist()) {
	    my $id = GeniXML::GetVirtualId($linkref);
	    if (!defined($id)) {
		print STDERR "No client id for $linkref\n";
		return GeniResponse->Create(GENIRESPONSE_ERROR());
	    }
	    $tmp{$id} = $id;
	}
	foreach my $lan (keys(%ifacestoaddtolans)) {
	    if (!exists($tmp{$lan})) {
		return GeniResponse->MalformedArgsResponse("No such $lan");
	    }
	}
    }
    main::AddLogfileMetaDataFromSlice($slice);

    #
    # Add new nodes.
    #
    foreach my $nodeid (keys(%{$nodelist})) {
	my $blob = $nodelist->{$nodeid};
	my $component_id = "";
 	my $xml  = "";

	if (ref($blob) ne "HASH") {
	    return GeniResponse->MalformedArgsResponse("$nodeid is not a hash");
	}
	if (exists($blob->{'node'})) {
	    my $pnodeid = $blob->{'node'};
	    my $urn = GeniHRN::Generate($OURDOMAIN, "node", $pnodeid);
	    $component_id = "component_id='$urn'";
	}
	
	$xml .= "<node client_id='$nodeid' $component_id>\n";
	$xml .= "  <sliver_type name='raw'>\n";
	if (exists($blob->{'diskimage'})) {
	    my $urn = $blob->{'diskimage'};
	    $xml .= "    <disk_image name='$urn'/>\n";
	}
	$xml .= "  </sliver_type>\n";
	if (exists($blob->{'hardware_type'})) {
	    my $hwtype = $blob->{'hardware_type'};
	    $xml .= "  <hardware_type name='$hwtype'/>\n";
	}
	if (exists($blob->{'tarballs'}) || exists($blob->{'startup'})) {
	    $xml .= "  <services>\n";

	    if (exists($blob->{'tarballs'}) &&
		ref($blob->{'tarballs'}) ne "ARRAY") {
		return GeniResponse->MalformedArgsResponse("tarballs for $nodeid ".
							   "is not a list");
	    }
	    foreach my $tarball (@{ $blob->{'tarballs'} }) {
		if (ref($tarball) eq "ARRAY") {
		    if (@$tarball == 2) {
			$xml .= "      <install url='".@{$tarball}[0]."'".
			    " install_path='".@{$tarball}[1]."' />\n";
		    }
		    else {
			my $resp = "tarballs (for $nodeid) malformed; tarballs".
			    " is a list of tarballs, or a list of [ tarball,".
			    " install-path ] tuples!";
			return GeniResponse->MalformedArgsResponse($resp);
		    }
		}
		else {
		    $xml .= "      <install url='$tarball' install_path='/' />\n";
		}
	    }
	    if (exists($blob->{'startup'})) {
		my $command = $blob->{'startup'};
		
		if (ref($command) eq "ARRAY") {
		    if (@$command == 2) {
			$xml .= "      <execute shell='".@{$command}[1]."'".
			    " command='".@{$command}[0]."' />\n";
		    }
		    else {
			my $resp = "startup commands (for $nodeid) malformed;".
			    " startup commands is a list of startup commands,".
			    " or a list of [ command, shell ] tuples!";
			return GeniResponse->MalformedArgsResponse($resp);
		    }
		}
		else {
		    $xml .= "      <execute shell='/bin/bash' ".
			"command='$command' />\n";
		}
	    }
	    $xml .= "  </services>\n";
	}
	if (exists($blob->{'lans'})) {
	    foreach my $lan (@{ $blob->{'lans'} }) {
		if (ref($lan) eq 'HASH') {
		    my $lanname = $lan->{'name'};
		    $xml .= "    <interface client_id='$nodeid:$lanname'>";
		    if (exists($lan->{'address'}) || exists($lan->{'netmask'})
			|| exists($lan->{'type'})) {
			$xml .= "<ip ";
			if (exists($lan->{'address'})) {
			    $xml .= " address='" . $lan->{'address'} . "'";
			}
			if (exists($lan->{'netmask'})) {
			    $xml .= " netmask='" . $lan->{'netmask'} . "'";
			}
			if (exists($lan->{'type'})) {
			    $xml .= " type='" . $lan->{'type'} . "'";
			}
			else {
			    $xml .= " type='ipv4'";
			}
			$xml .= " />";
		    }
		    $xml .= "</interface>\n";
		}
		else {
		    $xml .= "    <interface client_id='$nodeid:$lan' />\n";
		}
	    }
	}
	$xml .= "</node>";

	my $child = GeniXML::Parse($xml);
	if (!defined($child)) {
	    print STDERR "Could not parse XML for $nodeid: $xml\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Could not parse XML for $nodeid: $xml");
	}
	$manifest->appendChild($child);
    }
    #
    # Find each lan that has new nodes, and add to the interface list.
    #
    if (keys(%ifacestoaddtolans)) {
	foreach my $linkref (GeniXML::FindNodes("n:link",
						$manifest)->get_nodelist()) {
	    my $id = GeniXML::GetVirtualId($linkref);

	    next
		if (!exists($ifacestoaddtolans{$id}));

	    foreach my $iface (@{ $ifacestoaddtolans{$id} }) {
		my $ifaceref =
		    GeniXML::Parse("<interface_ref client_id='$iface'/>");
		$linkref->appendChild($ifaceref);
	    }
	}
    }
    my $rspecstr = GeniXML::Serialize($manifest);
    print STDERR "$rspecstr\n";

    #
    # Any user can update the sliver. 
    #
    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));

    my $rspec = GeniCM::GetTicketAuxAux({"slice"      => $slice,
					 "user"       => $user,
					 "rspecstr"   => $rspecstr,
					 "isupdate"   => 1,
					 "impotent"   => 0,
					 "v2"         => 1,
					 "level"      => -1,
					 "usetracker" => 0,
					 "ticket"     => undef,
					 "credentials"=> [$credential,
							  @morecreds],
					 "speaksfor"  => $speaksfor,
					 "async"      => 0});
    return $rspec
	if (GeniResponse::IsResponse($rspec));

    # Make sure that the next phase sees all changes.
    Experiment->FlushAll();
    Node->FlushAll();

    $response = GeniCM::SliverWorkAux({"credential"  => $credential,
				       "object"      => $rspec,
				       "keys"        => undef,
				       "isupdate"    => 1,
				       "impotent"    => 0,
				       "v2"          => 1,
				       "level"       => 1,
				       "speaksfor"   => $speaksfor,
				       "nolock"      => 0});

    if (GeniResponse::IsError($response)) {
	print STDERR "Redeem failed\n";
	# Not sure what to do here.
	my $ticket = GeniTicket->SliceTicket($slice);
	if (defined($ticket)) {
	    if ($ticket->Lock() != 0) {
		print STDERR "Could not lock $ticket\n";
	    }
	    elsif ($ticket->Release(TICKET_PURGED)) {
		print STDERR "Could not release $ticket\n";
	    }
	}
	return $response;
    }
    if ($slice->WaitForLock(30) != 0) {
	print STDERR "AddNodes: Could not lock $slice before start\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Internal Error");
    }
    $aggregate->Refresh();
    
    # We get the manifest from the aggregate object, so that the
    # expiration goes in.
    my $sliver_manifest = $aggregate->GetManifest(1);

    #
    # At this point we want to return and let the startsliver proceed
    # in the background. Parent never returns, just the child.
    #
    my $mypid = main::WrapperFork();
    if ($mypid) {
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, $sliver_manifest);
    }

    # Make sure that the next phase sees all changes.
    Experiment->FlushAll();
    Node->FlushAll();

    #
    # The callee might also do a wrapper fork, so remember our PID
    # to make sure we unlock properly in only the parent side of the
    # fork. Child runs with slice unlocked for now. 
    #
    $mypid = $PID;
    
    if ($aggregate->Start($API_VERSION,
			  $GeniAggregate::ACTION_FLAGS_SYNCVLANS|
			  $GeniAggregate::ACTION_FLAGS_NOEVENTSTART) != 0) {
	if ($PID == $mypid) {
	    $slice->UnLock();
	    print STDERR "Could not start sliver.\n";
	}
	else {
	    print STDERR "Error waiting for nodes.\n";
	}
	return -1;
    }
    if ($PID == $mypid) {
	$slice->UnLock();
    }
    return 0;
}

sub DeleteNodes($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $credentials  = $argref->{'credentials'};
    my $nodelist     = $argref->{'nodes'};
    my %nodelist     = ();
    my $response;

    if (! (defined($credentials) &&
	   defined($slice_urn) && defined($nodelist))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    # It was agreed that nodes is a list of client ids.
    if (ref($nodelist) ne "ARRAY") {
	return GeniResponse->MalformedArgsResponse("nodes is not a list");
    }
    foreach my $nodeid (@{$nodelist}) {
	$nodelist{$nodeid} = $nodeid;
    }
    my ($credential,$speaksfor,@morecreds) =
	GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    $credential->HasPrivilege( "pi" ) or
	$credential->HasPrivilege( "instantiate" ) or
	$credential->HasPrivilege( "bind" ) or
	return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				     "Insufficient privilege" );

    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! (defined($slice))) {
	return GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
				    "No slice here");
    }
    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    # Terminated slices get nothing.
    if ($slice->termination_pending()) {
	return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
				    "Slice is marked for termination");
    }
    if ($aggregate->Busy()) {
	return GeniResponse->BusyResponse();
    }
    my $manifest = $aggregate->GetManifest(0);
    return GeniResponse->Create(GENIRESPONSE_ERROR(), undef,
				"Could not get manifest for slice")
	if (!defined($manifest));

    #
    # Make sure all nodes listed are in the experiment.
    #
    my %allnodes = ();
    foreach my $noderef (GeniXML::FindNodes("n:node",
					    $manifest)->get_nodelist()) {
	# Ignore nodes on other CMs.
	next
	    if (! GeniXML::IsLocalNode($noderef));

	my $id = GeniXML::GetVirtualId($noderef);
	if (!defined($id)) {
	    print STDERR "No virtual node for $noderef\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR());
	}
	my $vnode_id = GeniXML::GetVnodeId($noderef);
	my $pnode = GeniUtil::LookupNode($vnode_id);
	if (!defined($pnode)) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Bad resource $vnode_id in manifest");
	}
	$allnodes{$id} = $pnode;
    }
    foreach my $nodeid (keys(%nodelist)) {
	if (!exists($allnodes{$nodeid})) {
	    return GeniResponse->Create(GENIRESPONSE_BADARGS(), undef,
				"No such node $nodeid in the topology!");
	}
	my $pnode = $allnodes{$nodeid};
	if ($pnode->isswitch()) {
	    return GeniResponse->Create(GENIRESPONSE_BADARGS(), undef,
			"Not allowed to delete switches from topology!");
	}
    }
    main::AddLogfileMetaDataFromSlice($slice);

    #
    # Suck out nodes. Also figure out what nodes have to be removed
    # from which lans, and which ifaces from which nodes.
    #
    my %ifacestoremovefromlans  = ();
    my %ifacestoremovefromnodes = ();
    
    foreach my $noderef (GeniXML::FindNodes("n:node",
					    $manifest)->get_nodelist()) {
	my $id = GeniXML::GetVirtualId($noderef);
	next
	    if (!exists($nodelist{$id}));

	# Remember all ifaces to purge from lans.
	foreach my $iref (GeniXML::FindNodes("n:interface",
					     $noderef)->get_nodelist()) {
	    my $client_id = GeniXML::GetInterfaceId($iref);
	    $ifacestoremovefromlans{$client_id} = $client_id;
	}
	$manifest->removeChild($noderef);
	delete $allnodes{$id};
    }
    if (!keys(%allnodes)) {
	return GeniResponse->Create(GENIRESPONSE_BADARGS(), undef,
		    "Not allowed to delete all nodes from the topology!");
    }
    # Purge the ifaces from lans.
    if (keys(%ifacestoremovefromlans)) {
	foreach my $linkref (GeniXML::FindNodes("n:link",
						$manifest)->get_nodelist()) {
	    my $link_id = GeniXML::GetVirtualId($linkref);
	    
	    foreach my $iref (GeniXML::FindNodes("n:interface_ref",
						 $linkref)->get_nodelist()) {
		my $client_id = GeniXML::GetInterfaceId($iref);
		next
		    if (!exists($ifacestoremovefromlans{$client_id}));

		$linkref->removeChild($iref);
	    }
	}
    }
    # Purge links if we reduced the number of interfaces to <= 1.
    foreach my $linkref (GeniXML::FindNodes("n:link",
					    $manifest)->get_nodelist()) {
	my @ifaces = GeniXML::FindNodes("n:interface_ref",
					$linkref)->get_nodelist();
	if (@ifaces <= 1) {
	    # Need to find this last iface in the node and delete it
	    # since otherwise the rspec would be malformed.
	    foreach my $iref (@ifaces) {
		my $client_id = GeniXML::GetInterfaceId($iref);
		$ifacestoremovefromnodes{$client_id} = $client_id;
	    }
	    $manifest->removeChild($linkref);
	}
    }
    # Purge the ifaces from nodes for links left with just one iface.
    if (keys(%ifacestoremovefromnodes)) {
	foreach my $noderef (GeniXML::FindNodes("n:node",
						$manifest)->get_nodelist()) {
	    foreach my $iref (GeniXML::FindNodes("n:interface",
						 $noderef)->get_nodelist()) {
		my $client_id = GeniXML::GetInterfaceId($iref);
		if (exists($ifacestoremovefromnodes{$client_id})) {
		    $noderef->removeChild($iref);
		}
	    }
	}
    }
    
    my $rspecstr = GeniXML::Serialize($manifest);
    print STDERR "$rspecstr\n";

    #
    # Any user can update the sliver. 
    #
    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));

    my $rspec = GeniCM::GetTicketAuxAux({"slice"      => $slice,
					 "user"       => $user,
					 "rspecstr"   => $rspecstr,
					 "isupdate"   => 1,
					 "impotent"   => 0,
					 "v2"         => 1,
					 "level"      => -1,
					 "usetracker" => 0,
					 "ticket"     => undef,
					 "credentials"=> [$credential,
							  @morecreds],
					 "speaksfor"  => $speaksfor,
					 "async"      => 0});
    return $rspec
	if (GeniResponse::IsResponse($rspec));

    # Make sure that the next phase sees all changes.
    Experiment->FlushAll();
    Node->FlushAll();

    $response = GeniCM::SliverWorkAux({"credential"  => $credential,
				       "object"      => $rspec,
				       "keys"        => undef,
				       "isupdate"    => 1,
				       "impotent"    => 0,
				       "v2"          => 1,
				       "level"       => 1,
				       "speaksfor"   => $speaksfor,
				       "nolock"      => 0});

    if (GeniResponse::IsError($response)) {
	print STDERR "Redeem failed\n";
	# Not sure what to do here.
	my $ticket = GeniTicket->SliceTicket($slice);
	if (defined($ticket)) {
	    if ($ticket->Lock() != 0) {
		print STDERR "Could not lock $ticket\n";
	    }
	    elsif ($ticket->Release(TICKET_PURGED)) {
		print STDERR "Could not release $ticket\n";
	    }
	}
	return $response;
    }
    if ($slice->WaitForLock(30) != 0) {
	print STDERR "DeleteNodes: Could not lock $slice before start\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Internal Error");
    }
    $aggregate->Refresh();
    
    # We get the manifest from the aggregate object, so that the
    # expiration goes in.
    my $sliver_manifest = $aggregate->GetManifest(1);

    #
    # At this point we want to return and let the startsliver proceed
    # in the background. Parent never returns, just the child.
    #
    my $mypid = main::WrapperFork();
    if ($mypid) {
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, $sliver_manifest);
    }

    # Make sure that the next phase sees all changes.
    Experiment->FlushAll();
    Node->FlushAll();

    #
    # The callee might also do a wrapper fork, so remember our PID
    # to make sure we unlock properly in only the parent side of the
    # fork. Child runs with slice unlocked for now. 
    #
    $mypid = $PID;
    
    if ($aggregate->Start($API_VERSION,
			  $GeniAggregate::ACTION_FLAGS_SYNCVLANS|
			  $GeniAggregate::ACTION_FLAGS_NOEVENTSTART) != 0) {
	if ($PID == $mypid) {
	    $slice->UnLock();
	    print STDERR "Could not start sliver.\n";
	}
	else {
	    print STDERR "Error waiting for nodes.\n";
	}
	return -1;
    }
    if ($PID == $mypid) {
	$slice->UnLock();
    }
    return 0;
}

#
# Redeem a ticket
#
sub RedeemTicket($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $ticketstr    = $argref->{'ticket'};
    my $credentials  = $argref->{'credentials'};
    my $keys         = $argref->{'keys'};
    my $impotent     = $argref->{'impotent'} || 0;
    
    if (! (defined($credentials) &&
	   defined($slice_urn) && defined($ticketstr))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    my $ticket = GeniTicket->CreateFromSignedTicket($ticketstr);
    if (!defined($ticket)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    $GeniTicket::CreateFromSignedError);
    }
    #
    # We need the user to sign the new ticket. 
    #
    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));
    
    #
    # Make sure the ticket was issued to the caller. 
    #
    if ($ticket->owner_urn() ne $user->urn()) {
	print STDERR $ticket->owner_urn() . "\n";
	print STDERR $user->urn() . "\n";
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
				    "This is not your ticket");
    }
    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! (defined($slice))) {
	return GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
				    "No slice here");
    }
    main::AddLogfileMetaDataFromSlice($slice);
    # Terminated slices get nothing.
    if ($slice->termination_pending()) {
	return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
				    "Slice is marked for termination");
    }
    if (defined($aggregate) && $aggregate->Busy()) {
	return GeniResponse->BusyResponse();
    }

    my $open_ticket = GeniTicket->SliceTicket($slice);
    if (! defined($open_ticket) || $open_ticket->idx() ne $ticket->idx()) {
	return GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
				    "This ticket is stale");
    }
    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    #
    # If we got a cert/key, record them for the slice. This is a
    # generic openssl key/cert that is stored on the nodes (and from
    # which an ssh key pair can be derived).
    #
    if (exists($argref->{'certificate'}) || exists($argref->{'key'})) {
	$slice->AddGenericCert((exists($argref->{'certificate'}) ?
				$argref->{'certificate'} : undef),
			       (exists($argref->{'key'}) ?
				$argref->{'key'} : undef));
    }
    my $isupdate = defined($aggregate);

    return GeniCM::SliverWorkAux({"credential"  => $credential,
				  "object"      => $open_ticket,
				  "keys"        => $keys,
				  "isupdate"    => $isupdate,
				  "impotent"    => $impotent,
				  "v2"          => 1,
				  "level"       => 1,
				  "speaksfor"   => $speaksfor,
				  "nolock"      => 0});
}

#
# Bind a user to a sliver. 
#
sub BindToSlice($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $credentials  = $argref->{'credentials'};
    my $keys         = $argref->{'keys'};
    my $amapi	     = (exists($argref->{'amapiv3'}) ? 1 : 0);
    
    if (! (defined($credentials) &&
	   defined($slice_urn) && defined($keys))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    $credential->HasPrivilege( "pi" ) or
	$credential->HasPrivilege( "bind" ) or
	return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				     "Insufficient privilege" );

    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! (defined($slice))) {
	return GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
				    "No slice here");
    }
    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    my $creator = GeniUser->Lookup($slice->creator_uuid(), 1);
    if (!defined($creator)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR(), undef,
				    "Could not lookup slice creator");
    }
    # Terminated slices get nothing.
    if ($slice->termination_pending()) {
	return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
				    "Slice is marked for termination");
    }
    if ($slice->Lock() != 0) {
	return GeniResponse->BusyResponse();
    }
    if (defined($keys)) {
	my $response = GeniCM::AddKeys($slice, $creator, $keys);
	if (GeniResponse::IsResponse($response)) {
	    $slice->UnLock();
	    return $response;
	}
    }
    # Need experiment for this.
    if (defined($aggregate)) {
	$aggregate->Refresh();
	if ($amapi) {
	    if ($aggregate->ComputeState()) {
		print STDERR "Could not compute state for $aggregate\n";
		$slice->UnLock();
		return GeniResponse->Create(GENIRESPONSE_ERROR);
	    }
	    if ($aggregate->state() ne "started") {
		$slice->UnLock();
		return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
					    "Slice is not in the proper state");
	    }
	}
	if ($aggregate->UpdateAccounts($amapi)) {
	    $slice->UnLock();
	    return GeniResponse->Create(GENIRESPONSE_ERROR());
	}
	#
	# Update the manifest. 
	#
	my $manifest = $aggregate->GetManifest(0);
	foreach my $ref (GeniXML::FindNodes("n:node",
					    $manifest)->get_nodelist()) {
	    my $virt_id   = GeniXML::GetVirtualId($ref);
	    my $sliver_id = GeniXML::GetSliverId($ref);
	    next
		if (!defined($sliver_id));
	    my $sliver    = GeniSliver->Lookup($sliver_id);
	    next
		if (!defined($sliver));

	    my $node_manifest = $sliver->AnnotateManifest();
	    if (defined($node_manifest)) {
		# And store into the new manifest.
		my $oldnode = GeniXML::GetNodeByVirtualId($virt_id, $manifest);
		GeniXML::ReplaceNode($oldnode, $node_manifest);
	    }
	}
	$aggregate->UpdateManifest($manifest);
    }
    $slice->UnLock();
    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
}

#
# Release a ticket.
#
sub ReleaseTicket($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $ticketstr    = $argref->{'ticket'};
    my $credentials  = $argref->{'credentials'};
    
    if (! (defined($credentials) &&
	   defined($slice_urn) && defined($ticketstr))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    $credential->HasPrivilege( "pi" ) or
	$credential->HasPrivilege( "bind" ) or
	return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				     "Insufficient privilege" );

    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! (defined($slice))) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "No slice here");
    }
    main::AddLogfileMetaDataFromSlice($slice);
    
    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    my $ticket = GeniTicket->CreateFromSignedTicket($ticketstr);
    if (!defined($ticket)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    $GeniTicket::CreateFromSignedError);
    }
    #
    # If the ticket is not stored, it is not a ticket that needs
    # to be released. It is a copy or a reissue. Needs more thought.
    #
    if (! $ticket->stored()) {
	return GeniResponse->Create(GENIRESPONSE_SUCCESS);
    }
    #
    # And of course, the ticket has to be for the slice indicated
    # by the provided credential.
    #
    if ($ticket->slice_urn() ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "This ticket is for another slice");
    }
    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));

    my $realuser = GeniCM::FlipToUser($slice, $user);
    if (! (defined($realuser) && $realuser)) {
	print STDERR "Error flipping to real user\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "FlipToUser Error");
    }
    #
    # XXX Need to do a restore backup state operation if this ticket
    # was the result of an update.
    #
    if ($ticket->Lock() != 0) {
	return GeniResponse->BusyResponse("ticket");
    }
    if ($ticket->Release(TICKET_RELEASED) != 0) {
	print STDERR "ReleaseTicket: Error releasing $ticket\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
}

sub ListUsage($)
{
    my ($argref)    = @_;
    my $credentials = $argref->{'credentials'};
    
    if (! (defined($credentials))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my @credentials = @{ $credentials };
    return GeniCM::ListUsage({"credential" => $credentials[0]});
}

sub ListHistory($)
{
    my ($argref)    = @_;
    my $credentials = $argref->{'credentials'};
    my $type        = $argref->{'type'};

    if (! (defined($credentials) && defined($type))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my @credentials = @{ $credentials };
    return GeniCM::ListHistory({"credential" => $credentials[0],
				"type"       => $type});
}

sub ReserveVlanTags($)
{
    my ($argref)    = @_;
    my $credentials = $argref->{'credentials'};
    my $slice_urn   = $argref->{'slice_urn'};
    my $slice_cert  = $argref->{'slice_cert'};
    my $rspecstr    = $argref->{'rspec'};
    my $linkname    = $argref->{'linkname'};
    my $taglist     = $argref->{'taglist'};
    my $response;
    my $actualtag;
    # List of vlans to delete after getting the tags.
    my @delete      = ();
    my %linkmap     = ();

    require Lan;

    my $me = GeniAuthority->Lookup($ENV{'MYURN'});
    if (!defined($me)) {
	print STDERR
	    "Could not find local authority object for $ENV{'MYURN'}\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    if (! (defined($credentials) && defined($slice_cert) &&
	   defined($taglist) &&
	   defined($linkname) && defined($slice_urn) && defined($rspecstr))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! ($linkname =~ /^[-\w]*$/)) {
	return GeniResponse->MalformedArgsResponse("Bad linkname");
    }
    foreach my $tag (@{ $taglist }) {
	if (! ($tag =~ /^\d*$/)) {
	    return GeniResponse->MalformedArgsResponse("Bad tag in list");
	}
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    $credential->HasPrivilege( "pi" ) or
	$credential->HasPrivilege( "bind" ) or
	return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				     "Insufficient privilege" );

    my (undef,$callertype,$callerid) = GeniHRN::Parse($credential->owner_urn());
    if (! ($callertype eq "authority" && $callerid eq "cm")) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef, "Not a CM");
    }
    my $slice_certificate = GeniCertificate->LoadFromString($slice_cert);
    if (!defined($slice_certificate)) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
				    "Bad slice certificate");
    }
    if ($slice_urn ne $slice_certificate->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
				    "Slice URN mismatch");
    }
    my $slice = GeniSlice->Lookup($slice_urn);
    if (defined($slice)) {
	#
	# Already exists locally. 
	#
        if ($slice->StitchLock() != 0) {
	    return GeniResponse->BusyResponse();
	}
    }
    else {
	#
	# Create a placeholder slice. Have to watch for a concurrent
	# slice creation through the normal path, in which case the code
	# needs to see if the slice was first created on this path.
	#
	my $authority =
	    GeniCM::CreateAuthorityFromRegistry($slice_certificate);
	if (GeniResponse::IsResponse($authority)) {
	    print STDERR "Could not create authority from registry\n";
	    $response = $authority;
	    goto done;
	}
	$slice = GeniSlice->Create($slice_certificate, undef, $authority);
	if (!defined($slice)) {
	    $response = GeniResponse->Create(GENIRESPONSE_ERROR);
	    goto done;
	}
	$slice->SetPublicID();
	#
	# Concurrency requires that we try for the lock after we create
	# it, since in fact it might not be us that created it. 
	#
        if ($slice->StitchLock() != 0) {
	    return GeniResponse->BusyResponse();
	}
    }
    main::AddLogfileMetaDataFromSlice($slice);
    
    #
    # Confirm that the certificate is the same.
    #
    if ($slice->cert() ne $slice_cert) {
	$response = GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
					 "Slice certificate mismatch");
	goto done;
    }
    
    my $slice_experiment = GeniCM::GeniExperiment($slice);
    if (GeniResponse::IsResponse($slice_experiment)) {
	print STDERR "Could not create new Geni slice experiment!\n";
	$response = $slice_experiment;
	goto done;
    }
    my $pid = $slice_experiment->pid();
    my $eid = $slice_experiment->eid();
    
    #
    # Run xmllint on the rspec to catch format errors.
    #
    my ($fh, $filename) = tempfile(UNLINK => 0);
    if (!defined($fh)) {
	print STDERR "Could not create temp file for rspec\n";
	$response = GeniResponse->Create(GENIRESPONSE_ERROR);
	goto done;
    }
    print $fh $rspecstr;
    close($fh);
    my $xmlerrors = `$XMLLINT --noout $filename 2>&1`;
    unlink($filename);
    if ($?) {
	$response = GeniResponse->Create(GENIRESPONSE_BADARGS,
					 $xmlerrors,
					 "rspec is not well formed");
	goto done;
    }
    my $rspec = GeniXML::Parse($rspecstr);
    if (! defined($rspec)) {
	$response = GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
					 "Error Parsing rspec XML");
	goto done;
    }

    my $rspecVersion = GeniXML::GetXmlVersion($rspec);
    if (! defined($rspecVersion)) {
	$response = GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
					 "Unknown RSpec Version");
	goto done;
    }

    #
    # Find the linkref for the one link we care about. 
    #
    my $linkref;
    
    foreach my $ref (GeniXML::FindNodes("n:link", $rspec)->get_nodelist()){
	my $vname  = GeniXML::GetVirtualId($ref);

	if ($vname eq $linkname) {
	    $linkref = $ref;
	    last;
	}
    }
    if (!defined($linkref)) {
	$response = GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
					 "Could not find link in rspec");
	goto done;
    }

    my $stitchpath = GeniStitch->Lookup($linkname, $rspec);
    if (defined($stitchpath->error())) {
	$response = $stitchpath->error();
	goto done;
    }
    if (!defined($stitchpath)) {
	$response = GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
					 "Could not find stitchpath in rspec");
    }

    #
    # Special case; if the lan has a tag reserved already, the tag we
    # got must be an exact match. This can happen if the ticket is
    # being updated before redeem, at the other side.
    #
    if (my $t = VLan::GetReservedVlanTag($slice_experiment, $linkname)) {
	if ((grep {$_ == $t} @{ $taglist })) {
	    $actualtag = $t;
	    goto gottag;
	}
	$response = GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
					 "Already have a tag reserved");
	goto done;
    }
    
    my $vlan = VLan->Lookup($slice_experiment, $linkname);
    if (!defined($vlan)) {
	#
	# The point of this is to create the VLan object, just
	# long enough to get a lanid and a tag assigned. 
	#
	$vlan = VLan->Create($slice_experiment, $linkname);
	if (!defined($vlan)) {
	    print STDERR "Could not create vlan for $linkname\n";
	    $response = GeniResponse->Create(GENIRESPONSE_ERROR);
	    goto done;
	}
	push(@delete, $vlan);
    }

    #
    # If there is already a reservation, it better be one of the
    # tags we got.
    #
    my $tag = $vlan->GetReservedVlanTag();
    if ($tag) {
	print STDERR "$vlan already had tag $tag.\n";
	if (! (grep {$_ == $tag} @{ $taglist })) {
	    print STDERR "  but the tag is not in the list we got.\n";
	    #
	    # Tell the caller about the tag; it is the only choice.
	    #
	    my @okaytags = ($tag);
	    $response = GeniResponse->Create(GENIRESPONSE_SEARCHFAILED,
					     \@okaytags,
					     "Could not find a suitable tag");
	    goto done;
	}
	$actualtag = $tag;
    }
    else {
	#
	# Check to see what tags are valid for us. 
	#
	my @tags = ();
	foreach my $tag (@{ $taglist }) {
	    push(@tags, $tag)
		if ($stitchpath->vlan_ok($tag));
	}
	if (!@tags) {
	    #
	    # Return a list of okay tags. 
	    #
	    my @okaytags = $stitchpath->vlan_list();
	    $response = GeniResponse->Create(GENIRESPONSE_SEARCHFAILED,
					     \@okaytags,
					     "Could not find a suitable tag");
	    goto done;
	}
	
	#
	# This is a debugging hack; Inside an elabinelab, it might be
	# an other local elabinelab or the outer boss. In this case,
	# there is no need to ask the outer boss to reserve a vlan, since
	# we already know that will fail (already reserved by the other).
	# In this case, we can just stipulate that one of the tags is good.
	#
	if ($ELABINELAB) {
	    my ($hisauth,undef,undef) = GeniHRN::Parse($slice_urn);

	    my @tmp = split('\.', $OURDOMAIN);
	    # Get the last two tokens. Not always the right thing to do. 
	    my $dom = join('.', splice(@tmp, -2, 2));

	    if ($me->domain() =~ /$dom$/ && $hisauth =~ /$dom$/) {
		print STDERR "ElabInElab clause is true\n";

		my $tag = pop(@tags);
		if ($vlan->ReserveVlanTag($tag)) {
		    $actualtag = $tag;
		    goto gottag;
		}
		print STDERR "But could not allocate tag $tag\n";
		$response =
		    GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
					 "Could not find a suitable tag");
		goto done;
	    }
	}
	
	#
	# Find a tag that we think is free. Snmpit will be the one to
	# say for sure, since it will also check the switches.
	#
	my $vlanid = $vlan->lanid();
	my $tag = undef;
	my @tmp = shuffle(@tags);
	while (@tmp) {
	    $tag = pop(@tmp);
	    if ($vlan->ReserveVlanTag($tag, 1)) {
		#
		# Have snmpit do actual reservation.
		#
		system("$SNMPIT -A $pid $eid $vlanid,$tag");
		if ($?) {
		    print STDERR "Could not reserve $vlanid,$tag\n";
		    next;
		}
		$actualtag = $vlan->GetReservedVlanTag();
		if (! $actualtag || $actualtag != $tag) {
		    print STDERR "No tag reserved for $vlan\n";
		    $response = GeniResponse->Create(GENIRESPONSE_ERROR);
		    goto done;
		}
		$actualtag = $tag;
		last;
	    }
	}
    }
    if (!defined($actualtag)) {
	$response = GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
					 "Could not find a suitable tag");
	goto done;
    }
  gottag:
    print STDERR "Agreed on tag $actualtag\n";
    GeniXML::SetText("vlantag", $linkref, $actualtag);
    $response = GeniResponse->Create(GENIRESPONSE_SUCCESS, 
				     GeniXML::Serialize($rspec));
  done:
    foreach my $vlan (@delete) {
	$vlan->ClearReservedVlanTag()
	    if (GeniResponse::IsError($response));

	$vlan->Destroy();
    }
    $slice->StitchUnLock()
	if (defined($slice));
    return $response;
}

#
# Convert a URN to the local object.
#
sub LookupURN($)
{
    my ($urn) = @_;
    my $object = undef;
    
    if (! GeniHRN::IsValid($urn)) {
	return GeniResponse->MalformedArgsResponse("Invalid URN");
    }
    # The URN encodes the type.
    my ($auth,$type,$id) = GeniHRN::Parse($urn);
    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				"Authority mismatch")
	if ($type ne "slice" && $auth ne $OURDOMAIN);
    $type = lc($type);

    if ($type eq "node") {
	$object = GeniUtil::LookupNode($urn);
    }
    elsif ($type eq "slice") {
	$object = GeniSlice->Lookup($urn);
    }
    elsif ($type eq "ticket") {
	$object = GeniTicket->Lookup($urn);
    }
    elsif ($type eq "sliver") {
	$object = GeniAggregate->Lookup($urn) || GeniSliver->Lookup($urn);
    }
    if (!defined($object)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED,
				    undef, "Nothing here by that name");
    }
    return ($object, $type);
}

#
# Map a slice/sliver credential to slice/aggregate
#
sub Credential2SliceAggregate($)
{
    my ($credential) = @_;
    my $target_cert  = $credential->target_cert();
    my $target_urn   = $credential->target_urn();
    my $target_uuid  = $credential->target_uuid();
    my $slice;
    my $aggregate;
    
    # First try the target urn, then fall back to the uuid
    $slice = GeniSlice->Lookup($target_urn);
    if (! defined($slice)) {
        # Could not find it by urn, trying uuid
        $slice = GeniSlice->Lookup($target_uuid);
    }
    if (defined($slice)) {
	$aggregate = GeniAggregate->SliceAggregate($slice);
    }
    else {
	$aggregate = GeniAggregate->Lookup($target_uuid);
	if (defined($aggregate)) {
	    if ($aggregate->type() ne "Aggregate") {
		$aggregate = undef;
	    }
	    else {
		$slice = GeniSlice->Lookup($aggregate->slice_uuid());
		if (!defined($slice)) {
		    $aggregate = undef;
		}
	    }
	}
    }
    my (undef, $certtype, undef) = GeniHRN::Parse($target_cert->urn());

    #
    # Make sure the certificate has not changed. If it has, we have to
    # check the UUID, since we need to support regen of the
    # certificate, which will change the version number.  Which means
    # a straight comparison will fail. So look to see if the UUID is
    # the same. If so, we store the new certificate.
    #
    if (defined($slice) && $certtype eq "slice" &&
	!$target_cert->SameCert($slice)) {
	if ($target_cert->uuid() eq $slice->uuid()) {
	    print STDERR "Updating certificate for $slice to $target_cert\n";
	    $slice->GetCertificate()->Delete();
	    $slice->Flush();
	    $target_cert->Store();
	    $slice = GeniSlice->Lookup($target_cert->urn());
	    if (!defined($slice)) {
		return (GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				     "Problem updating slice certificate"));
	    }
	}
	else {
	    return (GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
				 "Duplicate slice URN already exists here"));
	}
    }
    return ($slice, $aggregate);
}

#
# Emulab specific function to inject events into the experiment event scheduler.
#
sub InjectEvent($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $credentials  = $argref->{'credentials'};
    my $time         = $argref->{'time'};
    my $name         = $argref->{'name'};
    my $event	     = $argref->{'event'};
    my $args         = "";
    my $waitmode     = 0;
    
    if (! (defined($credentials) && defined($slice_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! (defined($time) && defined($name) && defined($event))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! ($time eq "now" || $time =~ /^\+\d*$/)) {
	return GeniResponse->MalformedArgsResponse("Improper time argument");
    }
    if (! ($name =~ /^[-\w]*$/)) {
	return GeniResponse->MalformedArgsResponse("Improper name argument");
    }
    if (! ($event =~ /^[-\w]*$/)) {
	return GeniResponse->MalformedArgsResponse("Improper event argument");
    }
    if (exists($argref->{'args'})) {
	if (ref($argref->{'args'}) ne "ARRAY") {
	    return
		GeniResponse->MalformedArgsResponse("Improper args argument");
	}
	my @args = @{ $argref->{'args'} };
	# Sanitize for shell.
	foreach my $arg (@args) {
	    $arg =~ s/(')/'\\''/g;
	    $args .= "'$arg' ";
	}
    }
    $waitmode = 1
	if (exists($argref->{'waitmode'}) && $argref->{'waitmode'});
    
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! (defined($slice) && defined($aggregate))) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Sliver does not exist");
    }
    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));

    main::AddLogfileMetaDataFromSlice($slice);

    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    if (!defined(GeniCM::FlipToUser($slice, $user))) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "FlipToUser failed");
    }
    my $experiment = $slice->GetExperiment();
    if (!defined($experiment)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "No local experiment for slice");
    }
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();
    my $opt = ($waitmode ? "-w" : "");

    my $output =
	GeniUtil::ExecQuiet("$TEVC $opt -e $pid/$eid $time $name $event $args");
    if ($?) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef, $output);
    }
    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
}

#
# Emulab specific function to create an image from a node.
#
sub CreateImage($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $credentials  = $argref->{'credentials'};
    my $imagename    = $argref->{'imagename'};
    my $sliver_urn   = $argref->{'sliver_urn'};
    my $no_versions  = 0;
    my $wholedisk    = 0;
    my $nosnapshot   = 0;
    my $mustnotexist = 0;
    my $purgeimage   = 0;
    my $update_prepare = 0;
    my ($bsname,$blockstore);
    my $copyback_uuid;
    my $description;
    my $relocate_urn;
    my $relocate_timeout = 0;
    my $response;

    require EmulabConstants;
    require Logfile;
    require OSImage;
    require WebTask;
    require GeniEvent;
    require GeniImage;
    
    if (! (defined($credentials) && defined($imagename) &&
	   defined($slice_urn) && defined($sliver_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! ($imagename =~ /^[-\w\.\+]*$/)) {
	return GeniResponse->MalformedArgsResponse("Improper name argument");
    }
    $no_versions = 1
	if (exists($argref->{'no_versions'}) && $argref->{'no_versions'});
    $wholedisk = 1
	if (exists($argref->{'wholedisk'}) && $argref->{'wholedisk'});
    $update_prepare = 1
	if (exists($argref->{'update_prepare'}) && $argref->{'update_prepare'});
    $nosnapshot = 1
	if (exists($argref->{'nosnapshot'}) && $argref->{'nosnapshot'});
    $mustnotexist = 1
	if (exists($argref->{'mustnotexist'}) && $argref->{'mustnotexist'});
    # Optional blockstore name.
    if (exists($argref->{'bsname'})) {
	$bsname = $argref->{'bsname'};
	return GeniResponse->MalformedArgsResponse("Improper bsname argument")
	    if ($bsname !~ /^[-\w\.\+]*$/);
    }
    # Optional copyback directive.
    if (exists($argref->{'copyback_uuid'})) {
	$copyback_uuid = $argref->{'copyback_uuid'};
	return GeniResponse->MalformedArgsResponse("Improper copyback argument")
	    if ($copyback_uuid !~ /^[-\w\.\+]*$/);
    }
    # Optional description.
    if (exists($argref->{'description'})) {
	$description = $argref->{'description'};
	return GeniResponse->MalformedArgsResponse("Improper description")
	    if (!TBcheck_dbslot($description, "images", "description",
			       TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR));
    }
    # Optional relocate directive.
    if (exists($argref->{'relocate_urn'})) {
	$relocate_urn = $argref->{'relocate_urn'};
	return GeniResponse->MalformedArgsResponse("Improper relocate argument")
	    if (!GeniHRN::IsValid($relocate_urn));
    }
    if ($relocate_urn && $copyback_uuid) {
	return GeniResponse->MalformedArgsResponse("Not allowed to say both".
						   "copyback and relocate");
    }
    
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));
    
    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! (defined($slice) && defined($aggregate))) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Slice does not exist");
    }
    main::AddLogfileMetaDataFromSlice($slice);

    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    # Terminated slices get nothing.
    if ($slice->termination_pending()) {
	return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
				    "Slice is marked for termination");
    }
    if ($aggregate->Busy() ||
	$aggregate->Imaging()) {
	return GeniResponse->BusyResponse();
    }
    
    my $sliver = GeniSliver->Lookup($sliver_urn);
    if (!defined($sliver)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Sliver does not exist");
    }
    if ($sliver->slice_uuid() ne $slice->uuid()) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Sliver is not in slice");
    }
    my $status;
    if ($sliver->ComputeStatus(\$status)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Could not compute status for sliver");
    }
    if ($status ne "ready") {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
				    "sliver is not ready");
    }
    my $node_id = $sliver->resource_id();
    my $node = Node->Lookup($node_id);
    if (!defined($node)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "No node for sliver urn");
    }
    if ($node->IsTainted()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
				    "node is tainted - image creation denied");
    }
    
    my $experiment = $slice->GetExperiment();
    if (!defined($experiment)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "No local experiment for slice");
    }
    my $pid = $experiment->pid();
    if (! $experiment->SameExperiment($node->Reservation())) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Node is not in the proper experiment");
    }
    if (defined($bsname)) {
	my @blockstores = $experiment->LookupBlockstoresForNode($node->vname());
	if (!@blockstores) {
	    return GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
					"No such blockstore on node");
	}
	foreach my $bs (@blockstores) {
	    if ($bs->vname() eq $bsname) {
		$blockstore = $bs;
		last;
	    }
	}
	if (!defined($blockstore)) {
	    return GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
					"No such blockstore on node");
	}
    }

    #
    # On this path, we do not allow system images to be shadowed by mere
    # users. We define system images as those in the emulab-ops project.
    # Note the admin test; this just says they are an administrator, not
    # that they are operating in withadminprivs context. Need a credential
    # to provide that, maybe later.
    #
    if ($experiment->pid() ne EmulabConstants::TBOPSPID() &&
	OSImage->LookupByName($imagename)) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
				    "Not allowed to shadow system images; ".
				    "use a different name for your image");
    }

    # See if it already exists and check ownership permission.
    my $image = OSImage->Lookup($experiment->pid(), $imagename);
    if (defined($image)) {
	if ($mustnotexist) {
	    return GeniResponse->Create(GENIRESPONSE_ALREADYEXISTS, undef,
					"Image name already in use");
	}
	if (!((defined($image->creator_urn()) &&
	       ($image->creator_urn() eq $user->urn() ||
		$image->creator_urn() eq $ENV{'REALGENIURN'})) ||
	      ($user->IsLocal() &&
	       $image->AccessCheck($user->emulab_user(),
				   EmulabConstants::TB_IMAGEID_ACCESS())))) {
	    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
					"This is not your image to overwrite");
	}
	if (defined($bsname) && !$image->isdataset()) {
	    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
					"This image is not a dataset");
	}
	if (!defined($bsname) && $image->isdataset()) {
	    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
			"This image is a dataset, maybe a name clash");
	}
	if (defined($image->relocate_urn())) {
	    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
					"This image is waiting to be ".
					"relocated back to ".
					$image->relocate_urn());
	}
    }
    elsif (defined($bsname)) {
	#
	# For datasets, the image must always exist first, via CreateDataset.
	# If we do not find it, it might be an imported dataset, which means
	# we are taking a snapshot to overwrite that imported dataset
	# All datasets are imported into the GeniSlices project, so we have to
	# find it. But there is a complication; the imported dataset might have
	# a different name cause of name collisions (between projects). So
	# lets find it via the blockstore on the node we are taking the snapshot
	# from. 
	#
	if (!exists($blockstore->{'attributes'}->{'dataset'})) {
	    return GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
				"No dataset associated with $bsname on $node");
	}
	$image = OSImage->Lookup($blockstore->{'attributes'}->{'dataset'});
	if (!defined($image)) {
	    return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				"Dataset for $bsname does not exist");
	}
	#
	# For simplicity and consistency with how existing image snapshot
	# works, lets create a new dataset in the current project so that
	# we can just travel the imaging path as it exists, and take a
	# snapshot to that new image descriptor. Ditto copyback to origin.
	#
	if (!defined(GeniCM::FlipToUser($slice, $user))) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"FlipToUser failed");
	}
	my $output =
	    GeniUtil::ExecQuiet("$CREATEDATASET -t imdataset $pid/$imagename");
	# Not a typical op, so always print debugging info;
	print STDERR $output;
	if ($?) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				"Could not create new dataset descriptor");
	}
	my $clone = OSImage->Lookup("$pid/$imagename");
	if (!defined($clone)) {
	    print STDERR "Could not look up clone: $pid/$imagename\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				"Could not look up clone $pid/$imagename");
	}
	# Need this for copyback. 
	$clone->Update({"origin_urn" => $image->origin_urn()});
	$image = $clone;
	$purgeimage = 1;
    }
    if (defined($bsname)) {
	#
	# These always go into the current project.
	#
	if ($image->pid() ne $pid) {
	    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
					"Dataset not in same project as node");
	}
    }
    my $realuser = GeniCM::FlipToUser($slice, $user);
    if (!defined($realuser)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "FlipToUser failed");
    }
    #
    # Before doing anything else, check for overquota. 
    #
    my $copt;
    if (defined($image)) {
	$copt = ($image->pid() eq $image->gid() ?    
		 "-p " . $image->pid() :
		 "-g " . $image->pid() . "/" . $image->pid());
    }
    else {
	$copt = ($experiment->pid() eq $experiment->gid() ?    
		 "-p " . $experiment->pid() :
		 "-g " . $experiment->pid() . "/" . $experiment->pid());
    }
    system("$CHECKQUOTA $copt -m 3GB " . $realuser->uid());
    if ($?) {
	return GeniResponse->Create(GENIRESPONSE_NOSPACE, undef,
				    "You are over (or close to) disk quota, ".
				    "please delete images you no longer need ".
				    "so you can proceed");
    }
    
    #
    # Lock the slice; we do not the user to mess with things.
    #
    if ($slice->Lock() != 0) {
	return GeniResponse->BusyResponse();
    }
    $aggregate->Refresh();

    #
    # Create a web task for this.
    #
    my $webtask = WebTask->CreateAnonymous();
    if (!defined($webtask)) {
	print STDERR "Could not create web task\n";
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    my $opt = " -t " . $webtask->task_id();
    if (defined($image) && $image->isdataset()) {
	$opt .= " -b $bsname ";
    }
    else {
	$opt .= " -e" if ($wholedisk);
	$opt .= " -B $copyback_uuid" if (defined($copyback_uuid));
    }

    #
    # Let user override global setting.
    #
    if (exists($argref->{'global'})) {
	$opt .= " -g " . ($argref->{'global'} ? "1" : "0");
    }
    print STDERR "CM: '$CLONEIMAGE $opt -s $imagename $node_id'\n";

    my $output = GeniUtil::ExecQuiet("$CLONEIMAGE $opt -s $imagename $node_id");
    # Not a typical op, so always print debugging info;
    print STDERR $output;
    if ($?) {
	$slice->UnLock();
	$webtask->Refresh();
	$webtask->Delete();
	if (!$webtask->HasExited()) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef, $output);
	}
	my $error = $webtask->output();
	if ($webtask->exitcode() < 0) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef, $error);
	}
	return GeniResponse->Create(GENIRESPONSE_REFUSED, undef, $error);
    }
    
    #
    # Make sure we can get the image descriptor.
    #
    if (!defined($image)) {
	$image = OSImage->Lookup($experiment->pid(), $imagename);
	if (!defined($image)) {
	    $slice->UnLock();
	    $webtask->Delete();
	    print STDERR "Cannot lookup descriptor for $imagename\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	$image->Update({"creator_urn" =>
			    (defined($speaksfor) ?
			     $speaksfor->target_urn() : $ENV{'GENIURN'})});

	# This will only happen on initial snapshot.
	if (defined($relocate_urn)) {
	    $image->SetImageRelocateURN($relocate_urn) == 0 or
		print STDERR "Could not set relocate_urn to $relocate_urn\n";
	}
	# Since this is a new image, be sure to set the shared flag
	# if we did not get a global directive above, and the image
	# is not global by inheritance. 
	if (!$image->global()) {
	    $image->Update({"shared" => 1});
	}
	$purgeimage = 1;
    }
    else {
	# Cause of image versioning.
	$image = $image->LookupMostRecent();

	$image->Update({"updater_urn" =>
			    (defined($speaksfor) ?
			     $speaksfor->target_urn() : $ENV{'GENIURN'})});
    }
    #
    # Optional descriptive text. 
    #
    if (defined($description)) {
	$image->SetDescription($description);
    }
    
    #
    # Form an image URN so the user knows how to request the new image.
    #
    my $image_urn = GeniHRN::Generate($OURDOMAIN, "image",
				      $pid . "//" . $imagename);
    my $version_urn = $image_urn . ":" . $image->version();
    my $image_url = "$TBBASE/image_metadata.php?uuid=" .
	$image->image_uuid();
    my $version_url = "$TBBASE/image_metadata.php?uuid=" .
	$image->uuid();
    # This goes back to the caller.
    my $retval = [$image_urn, $image_url, $version_urn, $version_url];

    # We just create the descriptor and return info.
    if ($nosnapshot) {
	$webtask->Delete();
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, $retval);
    }

    #
    # Reset and pass the webtask id to create image so that we do not change
    # the image descriptor until it is locked.
    #
    $webtask->Reset();
    $webtask->status("preparing");
    $webtask->imagesize(0);
    $webtask->Store();

    # Mark the sliver for sliver status calls. We can also unlock
    # since the state will prevent anything from being done.
    $sliver->SetState("imaging");

    #
    # Do the snapshot.
    #
    $opt  = " -t " . $webtask->task_id();
    $opt .= " -C " if ($purgeimage);
    $opt .= " -b $bsname" if (defined($bsname));
    $opt .= " -B $copyback_uuid" if (defined($copyback_uuid));
    $opt .= " -U " if ($update_prepare);

    # After clone_image, we can determine the new image name. Versioning
    # was handled in clone_image.
    $imagename = $image->imagename() . ":" . $image->version();

    print STDERR "CreateImage(): '$CREATEIMAGE -F -e $opt -q ".
	"-p $pid $imagename $node_id'\n";

    $output = GeniUtil::ExecQuiet("$CREATEIMAGE -F -e $opt -q ".
				  "   -p $pid $imagename $node_id");
    # Not a typical op, so always print debugging info;
    print STDERR $output;
    if ($?) {
	$slice->UnLock();
	if ($? >> 8 == ENOSPC) {
	    $response = GeniResponse->Create(GENIRESPONSE_NOSPACE,
					     undef, $output);
	}
	else {
	    $response = GeniResponse->Create(GENIRESPONSE_ERROR,
					     undef, $output);
	}
	goto bad;
    }
    #
    # The imaging operation is running in the background. We can return
    # the blob and wait for it to finish.
    # 
    my $mypid = main::WrapperFork();
    if ($mypid) {
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, $retval);
    }
    $slice->UnLock();

    #
    # We want to read the output file and splat it into this log file. 
    #
    my $logfile = $image->GetLogFile();
    if (!defined($logfile)) {
	print STDERR "Cannot find logfile $image\n";
    }
    elsif ($logfile->OpenFile()) {
	$logfile = undef;
    }

    #
    # Now wait and watch the web task for exit and for size changes
    # and generate Geni style events.
    #
    my $lastsize = 0;
    my $laststatus = "";

    while (!$webtask->HasExited()) {
	#
	# Watch for writes to the logfile, spew to STDERR.
	#
	if (defined($logfile)) {
	    my $buf;
	    my $cc = $logfile->ReadFile(\$buf);
	    if (defined($cc) && $cc && defined($buf)) {
		print STDERR $buf;
		$output .= $buf;
	    }
	    elsif (!defined($cc)) {
		# The file was closed, nothing else to do.
		$logfile = undef;
	    }
	}
	if ($webtask->imagesize() != $lastsize ||
	    $webtask->status() ne $laststatus) {
	    GeniEvent->SendEvent({"type"    => "IMAGESTATUS",
				  "slice"   => $slice->urn(),
				  "urn"     => $image_urn,
				  "details" =>
				          { "utc"    => time(),
					    "size"   => $webtask->imagesize(),
					    "status" => $webtask->status()}});
	    $lastsize   = $webtask->imagesize();
	    $laststatus = $webtask->status();
	}
	sleep(1);
	if ($webtask->Refresh()) {
	    print STDERR "$webtask was deleted, not supposed to happen\n";
	    $webtask = undef;
	    last;
	}
    }
    # Return to normal state even if it failed.
    $sliver->SetState("started");

    # If we still have the logfile opened read the rest.
    if (defined($logfile)) {
	while (1) {
	    my $buf;
	    my $cc = $logfile->ReadFile(\$buf);
	    if (!defined($cc) || $cc == 0) {
		last;
	    }
	    if (defined($buf)) {
		print STDERR $buf;
		$output .= $buf;
	    }
	}
	$logfile->CloseFile();
    }
    if (defined($webtask) && defined($webtask->consumed())) {
	print STDERR "$webtask has been consumed\n";
    }
    if (!defined($webtask) || $webtask->exitcode()) {
	print STDERR "Failed to take the snapshot of $node_id\n";
	goto bad;
    }
    if ($user->email()) {
	libtestbed::SENDMAIL($user->email(),
			     ($image->isdataset() ?
			      "Finished taking snapshot of dataset" :
			      "Finished cloning image"),
			     (! (defined($copyback_uuid) ||
				 defined($relocate_urn)) ?
			      "Image URN: $image_urn\n".
			      "Image URL: $image_url\n" :
			      "We have finished ".
			      ($image->isdataset() ?
			       "taking a snapshot of your dataset." :
			       "cloning your image.") . "\n" .
			      "Your image is now being transfered, you will ".
			      "receive another message\n".
			      "when that is complete.\n") .
			     "\n".
			     "-----------------------------------------\n".
			     "$output\n",
			     $user->email(),
			     "Bcc: $TBLOGS");
    }
    if ($relocate_urn) {
	#
	# We are waiting for the Mothership to pick up the image.
	#
	# If the relocation does not happen in a reasonable amount of
	# time, we can give up cause the expire daemon is also looking
	# for this and will take care of it. 
	#
	if ($image->WaitLock(90)) {
	    print STDERR "Could not get image lock for relocation wait\n";
	}
	else {
	    my $waitfor = 1200;
	    
	    print STDERR "Waiting for relocation: $relocate_urn\n";
	    while ($waitfor >= 0) {
		if (GeniImage::ConvertToImported($image, $relocate_urn) == 0) {
		    $image->SchedIMSDeletion(1);
		    $image->SetImageRelocateURN(undef);
		    print STDERR "Relocation complete\n";
		    last;
		}
		sleep(15);
		$waitfor -= 15;
	    }
	    if ($waitfor < 0) {
		print STDERR "Giving up on relocation, for now\n";
	    }
	    $image->Unlock();
	}
    }
    return 0;
  bad:
    # Return to normal state even if it failed.
    $sliver->SetState("started");
    
    print STDERR "Failed to take the snapshot of $node_id\n";
    if ($user->email()) {
	libtestbed::SENDMAIL($user->email(),
			     ($image->isdataset() ?
			      "Failed to snapshot dataset" :
			      "Failed to clone image"),
			     "$output\n",
			     $user->email(),
			     "Bcc: $TBOPS");
    }
    return (defined($response) ? $response : -1);
}

#
# Delete image created above.
#
sub DeleteImage($)
{
    my ($argref) = @_;
    my $image_urn    = $argref->{'image_urn'};
    my $credentials  = $argref->{'credentials'};
    my $impotent     = $argref->{'impotent'};
    my $overide_urn  = (exists($argref->{'creator_urn'}) ?
			$argref->{'creator_urn'} : undef);
    my ($imagename,$imagepid,$imagevers);

    require OSImage;
    
    if (! (defined($credentials) && defined($image_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! GeniHRN::IsValid($image_urn)) {
	return GeniResponse->MalformedArgsResponse("Invalid URN");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    main::AddLogfileMetaData("image_urn", $image_urn);

    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));

    my $authority = GeniCM::CreateAuthorityFromCertificate($credential);
    return $authority
	if (GeniResponse::IsResponse($authority));

    my ($auth, $ospid, $os, $vers) = GeniHRN::ParseImage($image_urn);
    return GeniResponse->MalformedArgsResponse("Malformed URN: $image_urn")
	if (!defined($os));
    
    $imagepid  = $ospid;
    $imagename = $os;
    $imagevers = $vers;

    #
    # Make sure we can get the image descriptor.
    #
    my $image = OSImage->Lookup($imagepid, $imagename, $imagevers);
    if (!defined($image)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "No such image: $image_urn");
    }
    if (defined($image->deleted())) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Already deleted: $image_urn");
    }
    my $imageid     = $image->imageid();
    my $creator_urn = $image->creator_urn();

    #
    # Need the project to compare the manager urn against the user SA.
    #
    my $project = $image->GetProject();
    if (!defined($project)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "No project for image");
    }

    #
    # Check to make sure image is not in use by a node, it is bad to the
    # image a node is running.
    #
    if ($image->InUse()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
				    "Image is currently in use");
    }

    if (! ((defined($creator_urn) &&
	    ($creator_urn eq $user->urn() ||
	     $creator_urn eq $ENV{'REALGENIURN'})) ||
	   GeniHRN::SameDomain($project->nonlocalurn(), $authority->urn()))) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
		    "Not enough permission to delete image; wrong SA or user");
    }
    my $fliptouser = $user;

    #
    # New approach is a project credential which the Portal will grant
    # to the project leader/managers. We leave the old checks in place.
    #
    if ($credential->target_urn()->IsProject()) {
	if ($credential->target_urn()->authority() ne
	    $project->nonlocalurn()->authority()) {
	    return GeniResponse->BadArgsResponse(
		    "Project credential does not match image domain/project");
	}
	#
	# If not the creator, operate as project leader. This can result
	# in the email not providing the actual person doing the deletion
	# unless we move the email here instead of in delete_image.
	#
	if (! (defined($creator_urn) &&
	       ($creator_urn eq $user->urn() ||
		$creator_urn eq $ENV{'REALGENIURN'}))) {
	    # fliptouser will flip to image project creator.
	    $fliptouser = undef;
	}
    }
    #
    # If not the creator, then require override to prevent
    # accidental removal of images not belonging to current user.
    # Note that not all images have the creator_urn set (yet).
    #
    elsif (!((defined($creator_urn) &&
	      !($creator_urn eq $user->urn() ||
		$creator_urn eq $ENV{'REALGENIURN'})) ||
	     ($user->IsLocal() &&
	      $image->AccessCheck($user->emulab_user(),
			       EmulabConstants::TB_IMAGEID_DESTROY())))) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
		    "Not your image; please specify original creator urn")
	    if (!defined($overide_urn) || $overide_urn ne $creator_urn);
    }
    if (!defined(GeniCM::FlipToUser($image, $fliptouser))) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "FlipToUser failed");
    }
    
    # Delete only the version if directed to.
    my $opt = (defined($imagevers) ? "-V" : "");
    $opt   .= (defined($impotent) && $impotent ? " -n" : "");
    $opt   .= " -F"
	if (($user->IsLocal() && $user->emulab_user()->admin() &&
	     $image->AccessCheck($user->emulab_user(),
				 EmulabConstants::TB_IMAGEID_DESTROY())));
    $opt   .= " $imageid";
    $opt   .= (defined($imagevers) ? ":$imagevers" : "");
    my $output = GeniUtil::ExecQuiet("$DELETEIMAGE -p $opt");
    print STDERR $output;
    if ($?) {
	print STDERR $output;
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef, $output);
    }
    # Print to get into the email log
    print STDERR "Image $image deleted by $user\n";
    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
}

#
# Image status call, mostly while creating a new image.
#
sub ImageInfo($)
{
    my ($argref) = @_;
    my $image_urn    = $argref->{'image_urn'};
    my $credentials  = $argref->{'credentials'};
    my ($imagename,$imagepid);

    require OSImage;
    require File::stat;
    require WebTask;
    
    if (! (defined($credentials) && defined($image_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! GeniHRN::IsValid($image_urn)) {
	return GeniResponse->MalformedArgsResponse("Invalid URN");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    main::AddLogfileMetaData("image_urn", $image_urn);

    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));

    my $authority = GeniCM::CreateAuthorityFromCertificate($credential);
    return $authority
	if (GeniResponse::IsResponse($authority));

    my ($auth,undef,$id) = GeniHRN::Parse($image_urn);
    return GeniResponse->MalformedArgsResponse("Malformed URN")
	if (!defined($id));
    
    if ($id =~ m{(.*)//(.*)}) {
	$imagepid  = $1;
	$imagename = $2;
    }
    else {
	return GeniResponse->MalformedArgsResponse("Could not parse $id");
    }

    #
    # Make sure we can get the image descriptor.
    #
    my $image = OSImage->Lookup($imagepid, $imagename);
    if (!defined($image)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "No such image");
    }
    my $imageid     = $image->imageid();
    my $creator_urn = $image->creator_urn();

    #
    # Need the project to compare the manager urn against the user SA.
    #
    my $project = $image->GetProject();
    if (!defined($project)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "No project for image");
    }

    if (! ($image->global() ||
	   (defined($creator_urn) &&
	    ($creator_urn eq $user->urn() ||
	     $creator_urn eq $ENV{'REALGENIURN'})) ||
	   GeniHRN::SameDomain($project->nonlocal_id(), $authority->urn()) ||
	   ($user->IsLocal() &&
	    $image->AccessCheck($user->emulab_user(),
				EmulabConstants::TB_IMAGEID_ACCESS())))) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
		    "Not enough permission to access image");
    }
    my $blob = { "size" => 0, "status" => "ready", "utc" => time() };
    
    #
    # Is there an active webtask, then we are taking a snapshot, so
    # report that info. Otherwise the current file.
    #
    my $webtask = $image->webtask();
    if (defined($webtask) && !defined($webtask->consumed())) {
	my $logfile;
	
	if ($webtask->HasExited()) {
	    if ($webtask->logfileid()) {
		$logfile = Logfile->Lookup($webtask->logfileid());
	    }
	    
	    #
	    # Try to lock the image so we can mark the webtask as consumed.
	    # Since the image lock is released after create_image is
	    # done, there is a chance a new image was requested and the
	    # webtask is a different one. Small chance, but it can happen.
	    #
	    if ($image->WaitLock(5) == 0) {
		$image->Refresh();
		if ($image->webtask_id() &&
		    $image->webtask_id() eq $webtask->task_id()) {
		    # User has the final imaging status, do not show it again.
		    # Deleted later, CreateImage() above is still watching it.
		    $webtask->consumed(1);
		    $webtask->Store();
		}
		$image->Unlock();
	    }
	}
	# Webtask is still okay to reference,
	if (!$webtask->HasExited() || $webtask->exitcode() != 0) {
	    $blob->{'status'} = $webtask->status();
	    
	    if (!$webtask->HasExited()) {
		#
		# Imaging still in progress.
		#
		$blob->{'size'} = $webtask->imagesize() . "KB";
	    }
	    else {
		#
		# Error.
		#
		if ($logfile) {
		    my $tmp;
		    $logfile->DumpFile(\$tmp);

		    if (defined($tmp) && $tmp ne "") {
			$blob->{'log'} = $tmp;
		    }
		    # Lets look for this special case. Not a good place to
		    # to do this.
		    if ($image->isdataset() && $tmp &&
			$tmp =~ /^umount: (.*): .* busy/m) {	
			$blob->{'output'} =
			    "Unable to unmount $1; you need to make ".
			    "sure you are not running any processes from ".
			    "$1 and that you do not have any active ".
			    "shells in a directory on $1";
		    }
		    elsif (defined($webtask->output())) {
			$blob->{'output'} = $webtask->output();
		    }
		}
	    }
	    print STDERR Dumper($blob);
	    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
	}
	# Fall through to looking at the file.
    }
    #
    # Get the file size on disk.
    #
    if ($image->size()) {
	$blob->{"size"} = int($image->size() / 1024) . "KB";
    }
    else {
	my $iname = $image->versname();
	my $isize = `$IMAGEINFO -s -U k $iname`;
	if (!$?) {
	    chomp($isize);
	    $blob->{"size"} = "${isize}KB";
	}
    }
    if ($image->hash()) {
	$blob->{"hash"} = $image->hash();
    }
    print STDERR Dumper($blob);
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
}

#
# Trigger an image update; we are the origin for the image, we
# need to go ask the remote cluster for a new version of an
# image created at the remote cluster.
#
sub TriggerImageUpdate($)
{
    my ($argref) = @_;
    my $blob         = $argref->{'info'};
    my $credentials  = $argref->{'credentials'};
    require OSImage;
    require Image;
    require emdb;

    if (! (defined($credentials) && defined($blob))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    #
    # The best we can do is make sure the caller is a CM in the federation.
    #
    my $caller_authority =
	GeniAuthority->CreateFromRegistry("cm", $ENV{'GENIURN'});
    if (!defined($caller_authority)) {
	return GeniResponse->Create(GENIRESPONSE_REFUSED,
				    undef, "Who are You?");
    }

    # Force debugging log.
    #print STDERR Dumper($blob);

    # Must have all these:
    foreach my $key ("origin_uuid", "imagename", "metadata_url",
		     "updater_urn") {
	if (! (exists($blob->{$key}) &&
	       defined($blob->{$key}) && $blob->{$key} ne "")) {
	    return GeniResponse->MalformedArgsResponse("Missing $key");
	}
    }
    return GeniResponse->Create(GENIRESPONSE_BADARGS, undef,
				"invalid updater urn")
	if (! GeniHRN::IsValid($blob->{'updater_urn'}));
    
    my $localimage = OSImage->Lookup($blob->{'origin_uuid'});
    return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED)
	if (!defined($localimage));

    # Need the most recent version of the image.
    my $currentimage = OSImage->Lookup($localimage->image_uuid());
    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				"Internal error getting most current image")
	if (!defined($currentimage));

    #
    # The snapshot might not be of the most recent version of the image,
    # but at the moment we are not worry about the parent/child relationships,
    # as we do for provenance. Need to at some point cause of deltas
    #
    my $imageid = $localimage->imageid();

    #
    # Are we still in an update? If so, return an error to the caller.
    #
    if ($localimage->Lock()) {
	return GeniResponse->Create(GENIRESPONSE_BUSY, undef,
				    "image is locked");
    }
    #
    # If we already have a conflicting entry in the pending imports table,
    # that is bad.
    #
    my $pending = Image::PendingImport->Lookup($blob->{'metadata_url'});
    if (defined($pending)) {
	if ($pending->imageid() == $imageid) {
	    $localimage->Unlock();
	    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
	}
	$localimage->Unlock();
	return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				    "Conflicting image update is pending");
    }
    my $args = {
	"uid_urn"      => $blob->{'updater_urn'},
	"pid"          => $localimage->pid(),
	"pid_idx"      => $localimage->pid_idx(),
	"gid"          => $localimage->gid(),
	"gid_idx"      => $localimage->gid_idx(),
	"type"         => "copyback",
	"imagename"    => $localimage->imagename(),
	"imageid"      => $localimage->imageid(),
	"remote_urn"   => $blob->{'remote_urn'},
	"metadata_url" => $blob->{'metadata_url'},
    };
    #
    # We might know the updater or we might not. If we do that is nice,
    # cause then we can set the updater fields in the new image version
    # accordingly. If not a local user record, then at least we can set
    # updater URN, but do the actual import update in the context of the
    # image creator (image_import decides this).
    #
    # Ick, setgroups skips nonlocal users, so local use does not have
    # permission to do this on ops, so have to fall back to the creator.
    #
    my $update_user = GeniUser->Lookup($blob->{'updater_urn'}, 1);
    if (defined($update_user)
	&& $update_user->IsLocal() && $update_user->emulab_user()->IsLocal()) {
	$args->{"uid"}     = $update_user->uid();
	$args->{"uid_idx"} = $update_user->uid_idx();
    }
    else {
	$args->{"uid"}     = $localimage->creator();
	$args->{"uid_idx"} = $localimage->creator_idx();
    }
    # We need the credential for secure download.
    if (exists($blob->{"credential"})) {
	$args->{"credential_string"} = $blob->{"credential"};
    }
    $pending = Image::PendingImport->Create($args);
    if (!defined($pending)) {
	$localimage->Unlock();
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Internal error creating pending import")
    }
    $localimage->Unlock();
    
    #
    # At this point, we can just return to the caller. It is now up to
    # us to pull the new image in, and if we fail we send email and hope
    # someone fixes something. 
    #
    my $mypid = main::WrapperFork();
    if ($mypid) {
	return GeniResponse->Create(GENIRESPONSE_SUCCESS);
    }

    # Try to import right away, if it fails the daemon will catch it later.
    system("$IMPORTER -d -g -P " . $pending->idx());
    return 0;
}

#
# List images for a user. If no user supplied, when for the caller.
# If user is supplied, then it must be the caller of from the same
# SA. 
#
sub ListImages($)
{
    my ($argref) = @_;
    my $user_urn     = $argref->{'user_urn'};
    my $project_urn  = $argref->{'project_urn'};
    my $credentials  = $argref->{'credentials'};
    my @images       = ();
    require OSImage;
    
    if (! defined($credentials)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (defined($user_urn) && !GeniHRN::IsValid($user_urn)) {
	return GeniResponse->MalformedArgsResponse("Invalid User URN");
    }
    if (defined($project_urn) && !GeniHRN::IsValid($project_urn)) {
	return GeniResponse->MalformedArgsResponse("Invalid Project URN");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));

    my $authority = GeniCM::CreateAuthorityFromCertificate($credential);
    return $authority
	if (GeniResponse::IsResponse($authority));

    #
    # This is a convenience for testing. If a local user and that
    # user is an admin person, then do whatever it says. This is
    # easier then trying to do this with credential privs.
    #
    my $isadmin = ($user->IsLocal() && $user->admin() ? 1 : 0);

    if (defined($user_urn) && $user->urn() ne $user_urn) {
	my $hrn = GeniHRN->new($user_urn);

	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
				    "No permission to list images")
	    if ($hrn->authority() ne
		$authority->urn()->authority() && !$isadmin);

	@images = OSImage->ListForURN($user_urn);
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, [])
	    if (!@images);
    }
    elsif (defined($project_urn)) {
	my $hrn = GeniHRN->new($project_urn);
	#
	# Must have a project credential granting permission to get the list.
	#
	if (!$credential->target_urn()->IsProject()) {
	    return GeniResponse->BadArgsResponse("Not a project credential");
	}
	if ($project_urn ne $credential->target_urn()) {
	    return GeniResponse->BadArgsResponse("Credential does not match ".
						 "project URN");
	}
	my $project;
	
	if ($hrn->IsOurDomain()) {
	    $project = Project->Lookup($hrn->id());
	    if (!defined($project)) {
		return GeniResponse->SearchFailedResponse(
		    "No local project for $project_urn");
	    }
	}
	else  {
	    my $temp = GeniHRN::Generate($hrn->authority(), "authority", "sa");
	    
	    $project = Project->LookupNonLocal($temp);
	    #
	    # No project means we have never seen anything that would cause
	    # the local shadow to be created. Treat that as no images found.
	    #
	    if (!defined($project)) {
		return GeniResponse->Create(GENIRESPONSE_SUCCESS, []);
	    }
	}
	@images = OSImage->ListForGroup($project->GetProjectGroup());
	if (!@images) {
	    return GeniResponse->Create(GENIRESPONSE_SUCCESS, [])
	}
    }
    else {
	$user_urn = $user->urn();
	@images = OSImage->ListForURN($user_urn);
	if (!@images) {
	    $user_urn = $credential->owner_urn();
	    @images = OSImage->ListForURN($user_urn);
	    return GeniResponse->Create(GENIRESPONSE_SUCCESS, [])
		if (!@images);
	}
    }
    my @result = ();
    foreach my $image (@images) {
	# Do not include imported images in this list, user cannot delete them.
	# Need to think about this.
	next
	    if (!$image->IsLocal());
	
	my $image_urn = GeniHRN::Generate($OURDOMAIN, "image",
				  $image->pid() . "//" . $image->imagename());
	my $image_url = "$TBBASE/image_metadata.php?uuid=" . $image->uuid();

	my $blob = {"urn"     => $image_urn . ":" . $image->version(),
		    "url"     => $image_url,
		    "uuid"    => $image->uuid(),
		    "created" => emutil::TBDateStringGMT($image->created()),
		    "updated" => emutil::TBDateStringGMT($image->updated()),
		    "format"  => $image->format(),
		    "description" => $image->description(),
	};
	if (defined($project_urn)) {
	    print STDERR "$image\n";
	    
	    $blob->{"creator_urn"} =
		($image->creator_urn() ? $image->creator_urn() :
		 $image->GetCreator()->nonlocalurn());
	    if (defined($image->updater())) {
		$blob->{"updater_urn"} =
		    ($image->updater_urn() ? $image->updater_urn() :
		     $image->GetUpdater()->nonlocalurn());
	    }
	}
	#
	# Get the file size on disk.
	#
	if ($image->size()) {
	    $blob->{"filesize"} = $image->size() / (1024 * 1024) . "MB";
	}
	else {
	    my $iname = $image->versname();
	    my $isize = `$IMAGEINFO -s -U m $iname`;
	    if (!$?) {
		chomp($isize);
		$blob->{"filesize"} = "${isize}MB";
	    }
	}
	
	#
	# Add the project URN, that the caller can map to a local project.
	#
	my $project = $image->GetProject();
	if (defined($project)) {
	    $blob->{'project_urn'} = $project->nonlocalurn();
	}
	push(@result, $blob);
    }
    print STDERR Dumper(\@result);
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, \@result);
}

#
# Active slivers.
#
sub ListActiveSlivers($)
{
    my ($argref) = @_;
    my $credentials  = $argref->{'credentials'};

    if (! (defined($credentials))) {
	return GeniResponse->MalformedArgsResponse("credential");
    }

    my $authority = GeniAuthority->Lookup($ENV{'MYURN'});
    if (!defined($authority)) {
	print STDERR "Could not find local authority object\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    $credential->HasPrivilege("readhistory") or
	return GeniResponse->Create( GENIRESPONSE_FORBIDDEN, undef,
				     "Insufficient privilege" );

    my $certificate = GeniRegistry::ClearingHouse->GetCertificate();
    if (!defined($certificate)) {
	print STDERR "Could not load clearinghouse certificate\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }

    #
    # The target has to match the clearinghouse or the local CM.
    # Might be (usually is) a delegated credential.
    #
    if ($credential->target_urn() ne $certificate->urn() &&
	$credential->target_urn() ne $authority->urn()) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Only the CH or local CM can do this!");
    }
    my $query_result =
	DBQueryWarn("select a.idx,m.manifest from geni_aggregates as a ".
		    "left join geni_manifests as m on ".
		    "     m.slice_uuid=a.slice_uuid ".
		    "where a.type='Aggregate'");

    return GeniResponse->Create(GENIRESPONSE_ERROR)
	if (!$query_result);
    
    return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				"Mo matching records")
	if (! $query_result->numrows);

    my @results = ();

    while (my ($idx,$manifest) = $query_result->fetchrow_array()) {
	my $aggregate = GeniAggregate->Lookup($idx);
	next
	    if (!defined($aggregate));

	my $slice = $aggregate->GetSlice();
	next
	    if (!defined($slice));

	my %blob = ();
	$blob{'sliver_uuid'}  = $aggregate->uuid();
	$blob{'sliver_urn'}   = $aggregate->urn();
	$blob{'slice_urn'}    = $slice->urn();
	$blob{'slice_uuid'}   = $slice->uuid();
	$blob{'creator_urn'}  = $slice->creator_urn();
	$blob{'creator_uuid'} = $slice->creator_uuid();
	$blob{'created'}      = $aggregate->created();
	$blob{'expires'}      = $aggregate->expires();
	$blob{'status'}       = $aggregate->status();
	$blob{'state'}        = $aggregate->state();
	if (defined($manifest)) {
	    $blob{'manifest'} = $manifest;
	}
	else {
	    $blob{'manifest'} = "";
	}
	push(@results, \%blob);
    }
    # Slow down the GMOC queries. 
    sleep(5);
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, \@results);
}

#
# Emulab specific function to share and unshare vlans. 
#
sub ShareLan($)
{
    my ($argref) = @_;
    
    return ShareLanAux($argref, 0);
}
sub UnShareLan($)
{
    my ($argref) = @_;
    
    return ShareLanAux($argref, 1);
}

sub ShareLanAux($$)
{
    my ($argref, $revoke) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $credentials  = $argref->{'credentials'};
    my $linkname     = $argref->{'lanname'};
    my $token        = $argref->{'token'};
    my $restricted   = (exists($argref->{'restricted'}) &&
			$argref->{'restricted'} ? 1 : 0);

    require Lan;
    
    if (! (defined($credentials) && 
	   defined($slice_urn) && defined($linkname))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! ($linkname =~ /^[-\w]*$/)) {
	return GeniResponse->MalformedArgsResponse("Improper lanname argument");
    }
    if (!$revoke) {
	if (!defined($token)) {
	    return GeniResponse->MalformedArgsResponse("Missing token");
	}
	if (! ($token =~ /^[-\w]*$/)) {
	    return GeniResponse->MalformedArgsResponse("Improper token");
	}
    }
    
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));
    
    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! (defined($slice) && defined($aggregate))) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Slice does not exist");
    }
    main::AddLogfileMetaDataFromSlice($slice);

    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    # Terminated slices get nothing.
    if ($slice->termination_pending()) {
	return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
				    "Slice is marked for termination");
    }
    #
    # Lock the slice; we do not let the user to mess with things.
    #
    if ($slice->Lock() != 0) {
	return GeniResponse->BusyResponse();
    }
    $aggregate->Refresh();
    # Check again after lock.
    if ($aggregate->Busy() ||
	$aggregate->Imaging()) {
	$slice->UnLock();
	return GeniResponse->BusyResponse();
    }    
    my $experiment = $slice->GetExperiment();
    if (!defined($experiment)) {
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "No local experiment for slice");
    }
    my $pid  = $experiment->pid();
    my $eid  = $experiment->eid();
    my $vlan = VLan->Lookup($experiment, $linkname);
    if (!defined($vlan)) {
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "No such lan in sliver");
    }
    if ($vlan->IsShared() && !$revoke) {
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_SUCCESS, undef,
				    "Lan is already shared");
    }
    if (!$revoke) {
	my ($lan_cert, $lan_cred);
	
	#
	# If the sharing is restricted, we need to mint a credential for
	# the user that they can delegate. 
	#
	if ($restricted) {
	    my $lan_urn = GeniHRN::Generate($OURDOMAIN, "vlan", $vlan->lanid());
	    my $lan_hrn = "${PGENIDOMAIN}.vlan" . "." . $vlan->lanid();
	    $lan_cert=
		GeniCertificate->Create({"urn"   => $lan_urn,
					 "hrn"   => $lan_hrn,
					 'email' => $TBOPS});
	    if (!defined($lan_cert)) {
		$slice->UnLock();
		return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					    "Could not create certificate");
	    }
	    $lan_cred = 
		GeniCredential->CreateSigned($lan_cert, $user,
					     $GeniCredential::LOCALCM_FLAG);
	    if (!defined($lan_cred)) {
		$lan_cert->Delete();
		$slice->UnLock();
		return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					    "Could not create credential");
	    }
	}
	
	#
	# This operation has to be done as an admin person. 
	#
	my $opt = ($restricted ? "" : "-o");
	
	GeniUtil::FlipToElabMan();
	my $output = GeniUtil::ExecQuiet("$WAP $SHAREVLAN $opt $pid,$eid ".
					 "  $linkname $token");
	my $ecode  = $?;
	GeniUtil::FlipToGeniUser();
	if ($ecode) {
	    print STDERR "Failed to share vlan:\n";
	    print STDERR $output;
	    $slice->UnLock();
	    $lan_cert->Delete()
		if (defined($lan_cert));
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef, $output);
	}
	libtestbed::SENDMAIL($TBOPS, "$linkname has been shared",
			     "$linkname in $slice_urn has been\n".
			     "shared by $user\n\n". 
			     "Slice: $slice\n".
			     "Experiment: $experiment\n",
			     $TBOPS);
	
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_SUCCESS,
				    defined($lan_cred) ?
				    [{"geni_credential" =>
					  $lan_cred->asString()}] :
				    undef);
    }
    #
    # Revoking is a litte trickier since we have to worry about the
    # experiments that are actually using the shared vlan. But the
    # backend program is going to revoke access from all the experiments
    # using those ports. Oh well.
    #
    # Delete certificate (in case it was restricted, see above)
    #
    my $lan_urn  = GeniHRN::Generate($OURDOMAIN, "vlan", $vlan->lanid());
    my $lan_cert = GeniCertificate->Lookup($lan_urn);
    if (defined($lan_cert)) {
	$lan_cert->Delete();
    }
    
    # This operation has to be done as an admin person. 
    #
    GeniUtil::FlipToElabMan();
    my $output = GeniUtil::ExecQuiet("$WAP $SHAREVLAN -r -f $pid,$eid ".
				     "  $linkname ");
    my $ecode  = $?;
    GeniUtil::FlipToGeniUser();
    if ($ecode) {
	print STDERR "Failed to unshare vlan:\n";
	print STDERR $output;
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    libtestbed::SENDMAIL($TBOPS, "$linkname has been unshared",
			 "$linkname in $slice_urn has been\n".
			 "unshared by $user\n\n". 
			 "Slice: $slice\n".
			 "Experiment: $experiment\n",
			 $TBOPS);

    $slice->UnLock();
    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
}

#
# Emulab specific function to ask for a URL to access the console.
#
sub ConsoleURL($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $credentials  = $argref->{'credentials'};
    my $sliver_urn   = $argref->{'sliver_urn'};

    if (! (defined($credentials) &&
	   defined($slice_urn) && defined($sliver_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));
    
    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! (defined($slice) && defined($aggregate))) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Slice does not exist");
    }
    main::AddLogfileMetaDataFromSlice($slice);

    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    # Terminated slices get nothing.
    if ($slice->termination_pending()) {
	return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
				    "Slice is marked for termination");
    }
    my $sliver = GeniSliver->Lookup($sliver_urn);
    if (!defined($sliver)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Sliver does not exist");
    }
    if ($sliver->slice_uuid() ne $slice->uuid()) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Sliver is not in slice");
    }
    my $node_id = $sliver->resource_id();
    my $node = Node->Lookup($node_id);
    if (!defined($node)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "No node for sliver urn");
    }
    if ($node->IsTainted()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
				    "node is tainted - console access denied");
    }
    my $experiment = $slice->GetExperiment();
    if (!defined($experiment)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "No local experiment for slice");
    }
    my $pid = $experiment->pid();
    if (! $experiment->SameExperiment($node->Reservation())) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Node is not in the proper experiment");
    }
    #
    # Not all nodes have a tipline.
    #
    my $tipserver;
    if ($node->TipServer(\$tipserver)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Internal error getting console server");
    }
    if (!defined($tipserver)) {
	return GeniResponse->Create(GENIRESPONSE_UNAVAILABLE, undef,
				    "No console server for node");
    }
    my $url = $node->GenTipAclUrl();
    if (!defined($url)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Internal error generating URL");
    }
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $url);
}

#
# Emulab specific function to ask for both URL and password.
#
sub ConsoleInfo($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $credentials  = $argref->{'credentials'};
    my $sliver_urn   = $argref->{'sliver_urn'};

    if (! (defined($credentials) &&
	   defined($slice_urn) && defined($sliver_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));
    
    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! (defined($slice) && defined($aggregate))) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Slice does not exist");
    }
    main::AddLogfileMetaDataFromSlice($slice);

    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    # Terminated slices get nothing.
    if ($slice->termination_pending()) {
	return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
				    "Slice is marked for termination");
    }
    if ($user->urn() ne $slice->creator_urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Only slice creator can do this");
    }
    my $sliver = GeniSliver->Lookup($sliver_urn);
    if (!defined($sliver)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Sliver does not exist");
    }
    if ($sliver->slice_uuid() ne $slice->uuid()) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Sliver is not in slice");
    }
    my $node_id = $sliver->resource_id();
    my $node = Node->Lookup($node_id);
    if (!defined($node)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "No node for sliver urn");
    }
    if ($node->IsTainted()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
				    "node is tainted - console access denied");
    }
    my $experiment = $slice->GetExperiment();
    if (!defined($experiment)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "No local experiment for slice");
    }
    my $pid = $experiment->pid();
    if (! $experiment->SameExperiment($node->Reservation())) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Node is not in the proper experiment");
    }
    #
    # Not all nodes have a tipline.
    #
    my $tipserver;
    if ($node->TipServer(\$tipserver)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Internal error getting console server");
    }
    if (!defined($tipserver)) {
	return GeniResponse->Create(GENIRESPONSE_UNAVAILABLE, undef,
				    "No console server for node");
    }
    my $url = $node->GenTipAclUrl();
    if (!defined($url)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Internal error generating URL");
    }
    my $pswd = $node->root_password();
    my $blob = {"url" => $url};
    if (defined($pswd)) {
	$blob->{"password"} = $pswd;
    }
    # Another URL for the console log, but only phys nodes.
    $url =~ s/nodetipacl/spewconlog/;
    $blob->{"logurl"} = $url;

    #
    # Generate and return the authentication blob when we are using
    # shellinabox consoles, so that the caller can route directly to
    # console instead of through a second iframe layer.
    #
    my $auth = $node->ConsoleAuthObject("geniuser");
    if ($auth) {
	$blob->{"authobject"} = $auth;
    }

    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
}

#
# Blockstore support.
#
sub CreateDataset($)
{
    my ($argref) = @_;
    my $credentials  = $argref->{'credentials'};
    my $dataset_urn  = $argref->{'dataset_urn'};
    my $POLICY_FAIL  = 2;
    my $needapproval = 0;
    my $unapproved_reason;
    require WebTask;
    require Lease;
    require Image;
    require EmulabConstants;
    require GeniImage;

    if (! (defined($credentials) && defined($dataset_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (!GeniHRN::IsValid($dataset_urn)) {
	return GeniResponse->MalformedArgsResponse("Invalid dataset urn");
    }
    $dataset_urn = GeniHRN->new($dataset_urn);
    if ($dataset_urn->type() !~ /^(im|lt|st)?dataset$/) {
	return GeniResponse->MalformedArgsResponse("Bad dataset type");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    #
    # The supplied dataset_urn must either match the credential target
    # (say, coming from the portal with a minted credential), or the
    # authority of the dataset_urn must match credential target to ensure
    # that the project/group match (say, a user talking directly to the
    # CM). This implies that the user has a project scoped self credential
    # (which of course, Protogeni can issue). 
    #
    return GeniResponse->MalformedArgsResponse("Credential does not match urn")
	if (! ($dataset_urn->urn() eq $credential->target_urn() ||
	       $dataset_urn->authority() eq
	       $credential->target_urn()->authority()));

    #
    # Check for project scoping. We know the credential matches cause
    # of the previous check.
    #
    return GeniResponse->MalformedArgsResponse("No project specified")
	if (!defined($dataset_urn->project()));
    
    #
    # So we want to mark the dataset with urn of the dataset, as for the
    # portal. This is how we can map from the urn at the portal to the
    # local object. This allows the portal to get a credential from us to
    # operate on the dataset. Sorta like a slice credential; whoever holds
    # the minted credential has permission to operate on or use it.
    #
    # Otherwise, only real local users can create datasets, cause we have
    # no way to verify their project membership without a minted credential
    # from someone we trust (something like the slice credential). Anyway,
    # normal users can still get a local credential since they own the
    # dataset, and then can delegate that credential as needed. The
    # difference though, is that the minted credential is usable just here
    # (create) and in GetDatasetCredential() below, to get that local
    # credential.
    #
    # Note also, that there are legacy datasets, and we want them to be
    # usable by the portal. The minted credential allows that too.
    #
    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));
    
    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN)
	if (! ((defined($user) && $user->IsLocal()) ||
	       # minted credential
	       $dataset_urn->urn() eq $credential->target_urn()));

    my $authority = GeniCM::CreateAuthorityFromCertificate($credential);
    return $authority
	if (GeniResponse::IsResponse($authority));

    # Get the project and group. This needs more thought. 
    my $group = GeniUtil::GetHoldingProject($credential->target_urn(), $user);
    return $group
	if (GeniResponse::IsResponse($group));

    my $image = Image->Lookup($group->pid(), $dataset_urn->id());
    if (defined($image)) {
	return GeniResponse->Create(GENIRESPONSE_ALREADYEXISTS, undef,
		    "A dataset or OS image with this name already exists");
    }
    my $lease = Lease->Lookup($group->pid(), $dataset_urn->id());
    if (defined($lease)) {
	return GeniResponse->Create(GENIRESPONSE_ALREADYEXISTS, undef,
		    "A long/short term dataset with this name already exists");
    }
    my $opts = "-b ";
    my $cmd  = "$CREATEDATASET ";
    if ($PROTOGENI_LOCALUSER) {
	$opts .= "-o ". $user->uid() . " ";
	$cmd   = "$WAP $cmd ";
	#
	# We do this as admin so that we create dataset owned by this
	# user and in the target project. 
	#
	GeniUtil::FlipToElabMan();
    }
    if (exists($argref->{'size'})) {
	my $size = $argref->{'size'};
	return GeniResponse->MalformedArgsResponse("Bad size, use MiBs")
	    if ($size !~ /^\d+$/);
	$opts .= " -s $size ";
    }
    if (exists($argref->{'type'})) {
	my $type = $argref->{'type'};
	return GeniResponse->MalformedArgsResponse("Bad type")
	    if ($type !~ /^[-\w]+$/);
	return GeniResponse->MalformedArgsResponse("Mismatching type")
	    if ($type ne $credential->target_urn()->type());
	$opts .= " -t $type ";
    }
    if (exists($argref->{'fstype'})) {
	my $fstype = $argref->{'fstype'};
	return GeniResponse->MalformedArgsResponse("Bad FS type")
	    if ($fstype !~ /^[-\w]+$/);
	$opts .= " -f $fstype ";
    }
    if (exists($argref->{'read_access'})) {
	my $read_access = $argref->{'read_access'};
	return GeniResponse->MalformedArgsResponse("Bad read access")
	    if (! ($read_access eq "project" || $read_access eq "global"));
	$opts .= " -R $read_access ";
	
    }
    if (exists($argref->{'write_access'})) {
	my $write_access = $argref->{'write_access'};
	return GeniResponse->MalformedArgsResponse("Bad write access")
	    if (! ($write_access eq "project" || $write_access eq "creator"));
	$opts .= " -W $write_access ";
	
    }
    if (exists($argref->{'expires'})) {
	my $expiration = $argref->{'expires'};
	
	# Gack, why does Frontier do this. It is stupid.
	if (ref($expiration) eq 'Frontier::RPC2::DateTime::ISO8601') {
	    $expiration = $expiration->value;
	}
	my $when = str2time($expiration);
	if (!$when) {
	    return GeniResponse->MalformedArgsResponse("Bad expiration");
	}
	$opts .= " -e '$when' ";
    }
    $opts .= $group->pid() . "/" . $group->gid() . "/" . $dataset_urn->id();

    #
    # Use a webtask to get back policy failure information, when a lease
    # is created but no approved. Not currently used for imdatasets.
    #
    my $webtask = WebTask->CreateAnonymous();
    if (!defined($webtask)) {
	print STDERR "Could not create web task\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    $opts = " -C -T ". $webtask->task_id() . " $opts";
	
    my $output = GeniUtil::ExecQuiet("$cmd $opts");
    # Not a typical op, so always print debugging info;
    print STDERR $output;
    if ($?) {
	$webtask->Delete();
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef, $output);
    }
    GeniUtil::FlipToGeniUser()
	if ($PROTOGENI_LOCALUSER);

    $webtask->Refresh();
    if ($webtask->needapproval()) {
	$needapproval = 1;
	$unapproved_reason = $webtask->unapproved_reason();
    }
    $webtask->Delete();

    # Stuff to put in the return blob.
    my ($state,$uuid,$busy,$msg,$urn,$url,$cred);

    #
    # Grab the lease or image to see if its been created/approved, we want
    # to tell the user something.
    #
    if (exists($argref->{'type'}) && $argref->{'type'} eq "imdataset") {
	my $image = Image->Lookup($group->pid(), $dataset_urn->id());
	if (!defined($image)) {
	    print STDERR "Could not lookup image after createdataset\n";
	    GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				 "Could not lookup image after createdataset");
				 
	}
	$image->Update({"creator_urn" => $user->urn()});
	$image->Update({"authority_urn" => $dataset_urn});
	$uuid  = $image->image_uuid();
	$state = "new";
	$busy  = 0;
	$urn   = $image->urn();
	$url   = $image->LocalURL();
	$cred  = GeniImage::CreateDatasetCredential($image, $user);
    }
    else {
	my $lease = Lease->Lookup($group->pid(),
				  $group->gid(), $dataset_urn->id());
	if (!defined($lease)) {
	    print STDERR "Could not lookup lease after createdataset\n";
	    GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				 "Could not lookup image after createdataset");
	}
	# Set the manager URN for same-SA permission checks.
	$lease->SetAttribute("manager_urn", $credential->target_urn());
	$lease->SetAttribute("creator_urn", $user->urn());
	$lease->SetAttribute("authority_urn", $dataset_urn);

	if ($needapproval) {
	    $msg = "Your dataset has not been approved yet. Watch for email.";
	}
	else {
	    $msg = "Your dataset is being allocated.";
	}
	$uuid  = $lease->uuid();
	$state = $lease->state();
	$busy  = $lease->locked() ? 1 : 0;
	$urn   = $lease->urn();
	$cred  = GeniImage::CreateDatasetCredential($lease, $user);
    }
    my $blob = {
	"state" => $state,
	"uuid"  => $uuid,
	"urn"   => $urn,
	"busy"  => $busy,
	"credential" => $cred->asString(),
    };
    if ($needapproval) {
	$blob->{'approved'} = 0;
	$blob->{'unapproved_reason'} = $unapproved_reason
	    if (defined($unapproved_reason));
    }
    else {
	$blob->{'approved'} = 1;
    }
    $blob->{'url'} = $url if (defined($url));
    
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob, $msg);
}
sub DeleteDataset($)
{
    my ($argref) = @_;
    my $credentials  = $argref->{'credentials'};
    my $dataset_urn  = $argref->{'dataset_urn'};
    my $cmd;
    require Image;
    require Lease;
    require EmulabConstants;

    if (! (defined($credentials) && defined($dataset_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    $dataset_urn = GeniHRN->new($dataset_urn);
    if ($dataset_urn->type() !~ /^(im|lt|st)?dataset$/) {
	return GeniResponse->MalformedArgsResponse("Bad dataset type");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    # This does the permission to access check.
    my $dataset = Credential2Dataset($dataset_urn, $credential);
    return $dataset
	if (GeniResponse::IsResponse($dataset));

    if (ref($dataset) eq "Lease") {
	#
	# If the lease is in use, return a busy error.
	# We make this test unlocked, but that is okay. 
	#
	if ($dataset->InUse()) {
	    return GeniResponse->Create(GENIRESPONSE_BUSY, undef,
					"$dataset is in use, try again later");
	}
	$cmd = "$DELETEDATASET -b -f -G " .
	    $dataset->pid() . "/" . $dataset->gid() . "/" . $dataset->lease_id();
    }
    else {
	$cmd = "$DELETEIMAGE -p ". $dataset->imageid();
    }
    if ($PROTOGENI_LOCALUSER) {
	$cmd = "$WAP $cmd";
	#
	# We do this as admin to avoid permission problems; caller has
	# permission to do it via credential.
	#
	GeniUtil::FlipToElabMan();
    }
    my $output = GeniUtil::ExecQuiet($cmd);
    # Not a typical op, so always print debugging info;
    print STDERR $output;
    if ($?) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef, $output);
    }
    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
}
sub ModifyDataset($)
{
    my ($argref) = @_;
    my $credentials  = $argref->{'credentials'};
    my $dataset_urn  = $argref->{'dataset_urn'};
    my $islease      = 0;
    my ($lease, $image);
    require Image;
    require Lease;
    require EmulabConstants;

    if (! (defined($credentials) && defined($dataset_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    $dataset_urn = GeniHRN->new($dataset_urn);
    if ($dataset_urn->type() !~ /^(im|lt|st)?dataset$/) {
	return GeniResponse->MalformedArgsResponse("Bad dataset type");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    # This does the permission to access check.
    my $dataset = Credential2Dataset($dataset_urn, $credential);
    return $dataset
	if (GeniResponse::IsResponse($dataset));

    if (ref($dataset) eq "Lease") {
	$lease = $dataset;
	$islease = 1;
    }
    else {
	$image = $dataset;
    }
    my $cmd;
    #
    # All we can handle is extend and modify permission bits.
    #
    if (exists($argref->{'extend'})) {
	return GeniResponse->Create(GENIRESPONSE_UNSUPPORTED, undef,
				    "IM datasets cannot be extended")
	    if (!$islease);
	$cmd = "$EXTENDDATASET ";	
    }
    elsif (exists($argref->{'read_access'}) ||
	   exists($argref->{'write_access'})) {
	$cmd = ($islease ? "$GRANTDATASET " : "$GRANTIMAGE ");
	
	if (exists($argref->{'read_access'})) {
	    my $read_access = $argref->{'read_access'};
	    return GeniResponse->MalformedArgsResponse("Bad read access")
		if (! ($read_access eq "project" || $read_access eq "global"));
	    $cmd .= " -R " . $read_access;
	}
	if (exists($argref->{'write_access'})) {
	    my $write_access = $argref->{'write_access'};
	    return GeniResponse->MalformedArgsResponse("Bad write access")
		if (! ($write_access eq "project" ||
		       $write_access eq "creator"));
	    $cmd .= " -W " . $write_access;
	}
    }
    else {
	return GeniResponse->MalformedArgsResponse("unknown operation");
    }
    if ($islease) {
	$cmd .= " " . $lease->pid() . "/" . $lease->gid() . "/" .
	    $lease->lease_id();
    }
    else {
	$cmd .= " " . $image->pid() . "," . $image->imagename();
    }
    if ($PROTOGENI_LOCALUSER) {
	$cmd = "$WAP $cmd";
	#
	# We do this as admin to avoid permission problems; caller has
	# permission to do it via credential.
	#
	GeniUtil::FlipToElabMan();
    }
    my $output = GeniUtil::ExecQuiet($cmd);
    # Not a typical op, so always print debugging info;
    print STDERR $output;
    if ($?) {
	my $val = $? >> 8;
	if ($val == 255 || $val < 0) {
	    $val = GENIRESPONSE_ERROR;
	}
	else {
	    $val = GENIRESPONSE_REFUSED;
	}
	return GeniResponse->Create($val, undef, $output);
    }
  done:
    my $blob = {};
    if ($islease) {
	$lease->Refresh();

	$blob->{'expires'}  = emutil::TBDateStringGMT($lease->lease_end());
	$blob->{'state'}    = $lease->state();
    }
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
}
sub DescribeDataset($)
{
    my ($argref) = @_;
    my $credentials  = $argref->{'credentials'};
    my $dataset_urn  = $argref->{'dataset_urn'};
    my $blob = {};
    require Image;
    require Lease;
    require Blockstore;
    require EmulabConstants;
    require WebTask;

    if (! (defined($credentials) && defined($dataset_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    $dataset_urn = GeniHRN->new($dataset_urn);
    if ($dataset_urn->type() !~ /^(im|lt|st)?dataset$/) {
	return GeniResponse->MalformedArgsResponse("Bad dataset type");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    # This does the permission to access check.
    my $dataset = Credential2Dataset($dataset_urn, $credential);
    return $dataset
	if (GeniResponse::IsResponse($dataset));

    if (ref($dataset) eq "Lease") {
	my $lease = $dataset;
	$blob->{'state'}    = $lease->state();
	$blob->{'type'}     = $lease->type();
	$blob->{"busy"}     = $lease->locked() ? 1 : 0;
	$blob->{'created'}  = emutil::TBDateStringGMT($lease->inception());
	$blob->{'expires'}  = emutil::TBDateStringGMT($lease->lease_end());
	$blob->{'lastused'} = emutil::TBDateStringGMT($lease->last_used());

	my $bstore = Blockstore->LookupByLease($lease->idx());
	if (defined($bstore)) {
	    $blob->{'size'}     = $bstore->total_size();
	}
    }
    else {
	my $image = $dataset;
	$blob->{'state'}    = "valid";
	$blob->{'type'}     = "imdataset";
	$blob->{"busy"}     = 0;
	$blob->{'size'}     = 0;
	$blob->{'created'}  = emutil::TBDateStringGMT($image->created());
	$blob->{'updated'}  = emutil::TBDateStringGMT($image->updated());
	$blob->{'expires'}  = "";
	$blob->{'lastused'} = emutil::TBDateStringGMT($image->last_used());
	#
	# Is there an active webtask, then we are taking a snapshot, so
	# report that info. 
	#
	my $webtask = $image->webtask();
	if (defined($webtask)) {
	    print STDERR Dumper($webtask);
	    
	    $blob->{'image_size'}   = $webtask->imagesize() . "KB";
	    $blob->{'image_status'} = $webtask->status();

	    if (!$webtask->HasExited()) {
		$blob->{'state'} = "allocating";
		$blob->{'busy'}  = 1;
	    }
	}
	if ($image->size()) {
	    my $kbytes = int(($image->lba_high() -
			      $image->lba_low() + 1) /
			     (1024 / $image->lba_size()));
	    $blob->{'size'} =
		Blockstore::ConvertToMebi("$kbytes" . "KiB");
	}
	#print STDERR Dumper($blob);
    }
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
}

#
# Approve a dataset (lease). Must have an SA auth credential.
#
sub ApproveDataset($)
{
    my ($argref) = @_;
    my $credentials  = $argref->{'credentials'};
    my $dataset_urn  = $argref->{'dataset_urn'};
    my $blob = {};
    require Image;
    require Lease;
    require EmulabConstants;
    require GeniImage;

    if (! (defined($credentials) && defined($dataset_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    $dataset_urn = GeniHRN->new($dataset_urn);
    if (!$dataset_urn->IsDataset()) {
	return GeniResponse->MalformedArgsResponse("Not a dataset URN");
    }
    if ($dataset_urn->IsIMDataset()) {
	return GeniResponse->MalformedArgsResponse("Not a lt/st dataset URN");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    my $lease = Credential2Dataset($dataset_urn, $credential);
    return $lease
	if (GeniResponse::IsResponse($lease));

    # Already approved. 
    return GeniResponse->Create(GENIRESPONSE_SUCCESS)
	if ($lease->state() ne "unapproved");

    #
    # We had to get an "auth" credential with explicit admin priv.
    #
    if (! (($dataset_urn->authority() eq
	    $credential->target_urn()->authority()) && 
	   $credential->owner_urn()->IsSA() &&
	   $credential->HasActualPrivilege("admin"))) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN);
    }
    my $name = $lease->pid() . "/" . $lease->lease_id();

    #
    # We do this as admin of course, so must flip.
    #
    my $cmd = "$WAP $APPROVEDATASET -b -w 10 '$name'";
    GeniUtil::FlipToElabMan();
    my $output = GeniUtil::ExecQuiet($cmd);
    # Not a typical op, so always print debugging info;
    print STDERR $output;
    if ($?) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef, $output);
    }
    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
}

sub GetDatasetCredential($)
{
    my ($argref) = @_;
    my $credentials  = $argref->{'credentials'};
    my $dataset_urn  = $argref->{'dataset_urn'};
    my $blob = {};
    require Image;
    require Lease;
    require EmulabConstants;
    require GeniImage;

    if (! (defined($credentials) && defined($dataset_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    $dataset_urn = GeniHRN->new($dataset_urn);
    if (!$dataset_urn->IsDataset()) {
	return GeniResponse->MalformedArgsResponse("Not a dataset URN");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    my $dataset = Credential2Dataset($dataset_urn, $credential);
    return $dataset
	if (GeniResponse::IsResponse($dataset));
    
    my $dataset_credential =
	GeniImage::CreateDatasetCredential($dataset, $credential->owner_cert());
    if (!defined($dataset_credential)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    return GeniResponse->Create(GENIRESPONSE_SUCCESS,
				$dataset_credential->asString());
}

#
# Map a credential to a dataset and check basic permission to access it.
#
sub Credential2Dataset($$)
{
    my ($dataset_urn, $credential) = @_;
    require Image;
    require Lease;
    require EmulabConstants;
    require GeniImage;

    #
    # See comments in CreateDataset() about these checks. In addition, we also
    # allow a local credential to be used (GetDatasetCredential()) since that
    # can be delegated by the owner.
    #
    return GeniResponse->MalformedArgsResponse("Credential does not match urn")
	if (! ($dataset_urn->urn() eq $credential->target_urn() ||
	       # Self credential with subauth matching dataset subauth.
	       $dataset_urn->authority() eq
	       $credential->target_urn()->authority() ||
	       # Locally issued credential with GetDatasetCredential().
	       $credential->target_urn()->IsOurDomain()));
    
    return GeniResponse->MalformedArgsResponse("No project specified")
	if (!defined($dataset_urn->project()));

    # Locally issued credential, use the urn in the credential.
    if ($credential->target_urn()->IsOurDomain() &&
	$credential->target_urn()->IsDataset()) {
	$dataset_urn = $credential->target_urn();
    }

    my ($target, $authority_urn, $creator_urn, $creator_uid);

    if ($dataset_urn->type() eq "imdataset" ||
	$dataset_urn->type() eq "dataset") {

	# Check for a locally created dataset (not via the geni path).
	$target = Image->Lookup($dataset_urn->project(), $dataset_urn->id());
	if (!defined($target)) {
	    # Datasets created on the geni path have the authority_urn set
	    # to the dataset_urn supplied to CreateSliver().
	    $target = Image->LookupByAuthorityURN($dataset_urn);
	}
	# Sigh, backwards compat, we did not always save the urn in the table.
	if (!defined($target)) {
	    my $project_urn =
		GeniHRN::Generate($dataset_urn->authority(), "authority", "sa");
	    my $project = Project->LookupNonLocal($project_urn);
	    if (defined($project)) {
		$target = Image->Lookup($project->pid(), $dataset_urn->id());
		if (defined($target) && !$target->isdataset()) {
		    $target = undef;
		}
	    }
	}
	if (defined($target)) {
	    $creator_uid   = $target->creator();
	    $creator_urn   = $target->creator_urn();
	    $authority_urn = $target->authority_urn();
	}
    }
    # Datasets used to all have type "dataset";
    if (!defined($target) && $dataset_urn->type() ne "imdataset") {
	#
	# Check for a locally created dataset (not via the geni path).
	#
	$target = Lease->Lookup($dataset_urn->project(),
				($dataset_urn->group() ?
				 $dataset_urn->group() :
				 $dataset_urn->project()),
				$dataset_urn->id());
	if (!defined($target)) {
	    # Datasets created on the geni path have the authority_urn set
	    # to the dataset_urn supplied to CreateSliver().
	    $target = Lease->LookupByAuthorityURN($dataset_urn);
	}
	# Sigh, backwards compat, we did not always save the urn in the table.
	if (!defined($target)) {
	    my $project_urn = GeniHRN::Generate($dataset_urn->authority(),
						"authority", "sa");
	    my $project = Project->LookupNonLocal($project_urn);
	    if (defined($project)) {
		$target = Lease->Lookup($project->pid(),
					$project->pid(),
					$dataset_urn->id());
	    }
	}
	if (defined($target)) {
	    $creator_uid   = $target->owner();
	    $creator_urn   = $target->GetAttribute("creator_urn");
	    $authority_urn = $target->GetAttribute("authority_urn");
	}
    }
    return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED)
	if (!defined($target));

    #
    # Now we can do the permission checks.
    #
    # 1. The creator of the dataset is asking for a credential.
    # 2. The caller has supplied a minted credential (say, the portal).
    #
    # Note that the portal might be the caller (cause the speaksfor is expired).
    #
    my $user = GeniUser->Lookup($credential->owner_urn(), 1)
	if ($credential->owner_urn()->type() eq "user");

    # This covers datasets created by this local user, on or off the geni path.
    goto okay
	if (defined($user) &&
	    ($creator_urn eq $user->urn || $creator_uid eq $user->uid()));
    
    #
    # Lastly, if the portal gave us a minted credential, it is allowed.
    #
    goto okay
	if ($dataset_urn->urn() eq $credential->target_urn() &&
	    $credential->owner_urn()->IsSA());
    
    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN);
  okay:
    return $target;
}

#
# Secure image download, by credential.
#
sub SecureImageDownload($)
{
    my ($argref)  = @_;
    my $credentials = $argref->{'credentials'};
    my $image_urn   = $argref->{'image_urn'};

    if (! (defined($credentials))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    # Backwards compat until all clusters updated.
    if (!defined($image_urn)) {
	$image_urn = $credential->target_urn();	
    }
    else {
	$image_urn = GeniHRN->new($image_urn);
	if (!defined($image_urn)) {
	    return GeniResponse->MalformedArgsResponse("Invalid image urn");
	}
    }
    return GeniResponse->MalformedArgsResponse("Improper type in URN")
	if (! ($image_urn->IsDataset() || $image_urn->IsImage()));
    
    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef, "fooey")
	if ($credential->target_urn()->domain() ne $OURDOMAIN);

    my ($pid,$name,$vers);

    if ($image_urn->IsDataset()) {
	$pid  = $image_urn->dsetpid();
	$name = $image_urn->dsetname();
	$vers = $image_urn->dsetvers();	
	return GeniResponse->MalformedArgsResponse("Credential does not ".
						   "match URN")
	    if (! ($pid eq $credential->target_urn()->dsetpid() &&
		   $name eq $credential->target_urn()->dsetname()));
    }
    else {
	$pid  = $image_urn->ospid();
	$name = $image_urn->osname();
	$vers = $image_urn->osvers();
	return GeniResponse->MalformedArgsResponse("Credential does not ".
						   "match URN")
	    if (! ($pid eq $credential->target_urn()->ospid() &&
		   $name eq $credential->target_urn()->osname()));
    }
    my $image = Image->Lookup($pid, $name, $vers);
    return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED)
	if (!defined($image));
    my $group = $image->GetGroup();
    return GeniResponse->Create(GENIRESPONSE_ERROR)
	if (!defined($group));

    # Better make sure we have project mounted.
    $group->GetProject()->UpdateExports();
    my $file = $image->FullImageFile();

    # Need to set our groups so we can read the file.
    GeniUtil::FlipToUser("root", $group->pid(), $group->unix_gid());
    
    if (! -r $file) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
			    "Image file does not exist or cannot be read");
    }
    #
    # Stat the file to get the bytelen for spewing.
    #
    my (undef,undef,undef,undef,undef,undef,undef,$bytelen) = stat($file);

    open(FD, "< $file") or
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Could not open file for reading");
    # Flip back now that we have it opened.
    GeniUtil::FlipToGeniUser();

    # This sets STDOUT back to apache.
    main::AbortLogging();
    print "Content-Type: application/octet-stream\n";
    print "Cache-Control: no-cache, must-revalidate\n";
    print "Pragma: no-cache\n\n";
    
    #
    # Deal with NFS read failures
    #
    my $foffset = 0;
    my $retries = 5;
    my $buf;

    while ($bytelen) {
	my $rlen = sysread(FD, $buf, 8192);

	if (! defined($rlen)) {
	    #
	    # Retry a few times on error to avoid the
	    # changing-exports-file server problem.
	    #
	    if ($retries > 0 && sysseek(FD, $foffset, 0)) {
		$retries--;
		sleep(1);
		next;
	    }
	    print STDERR "Error reading $file: $!\n";
	    last;
	}
        if ($rlen == 0) {
	    last;
	}
	if (! syswrite(STDOUT, $buf, $rlen)) {
	    print STDERR "Error writing file to stdout: $!\n";
	    last;
	}
	$foffset += $rlen;
	$bytelen -= $rlen;
	$retries = 5;
    }
    close(FD);
    if ($bytelen) {
	print STDERR "Did not get the entire file! $bytelen bytes left.\n";
	# Cannot return XML at this point.
	return -1;
    }
    # Cannot return XML at this point.
    return 0;
}

#
# Set/Clear the lockdown.
#
sub Lockdown($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $clear        = $argref->{'clear'};
    my $credentials  = $argref->{'credentials'};
    my $force        = $argref->{'force'};
    require Reservation;
    
    if (! (defined($credentials) && defined($slice_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! GeniHRN::IsValid($slice_urn)) {
	return GeniResponse->MalformedArgsResponse("Invalid URN");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    my $authority = GeniCM::CreateAuthorityFromCertificate($credential);
    return $authority
	if (GeniResponse::IsResponse($authority));

    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! (defined($slice) && defined($aggregate))) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Slice does not exist");
    }
    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    my $experiment = $slice->GetExperiment();
    if (!defined($experiment)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "No local experiment for slice");
    }
    # Terminated slices get nothing.
    if ($slice->termination_pending()) {
	return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
				    "Slice is marked for termination");
    }

    #
    # Only the SA for the slice can do this.
    #
    my $caller = GeniHRN->new($credential->owner_urn());
    if (! ($caller->IsSA() && 
	   $caller->domain() eq $slice->urn()->domain())) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
			    "Not enough permission to set/clr lockdown");
    }
    main::AddLogfileMetaDataFromSlice($slice);
    if (defined($clear) && $clear) {
	if ($slice->SetLockdown(1)) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	return GeniResponse->Create(GENIRESPONSE_SUCCESS);
    }
    
    #
    # Ask Reservation system if locking down this experiment will
    # throw the Reservation system into chaos.
    #
    my $error = "unknown error";
    
    my $rval = Reservation->Lockdown($slice, \$error, 0, 0);
    if (!$rval) {
	return GeniResponse->Create(GENIRESPONSE_SUCCESS);
    }
    if (defined($force) && $force) {
	#
	# Override the Reservation system, chaos ensues. 
	#
	if (Reservation->Lockdown($slice, \$error, 0, 1)) {
	    print STDERR "Unable to force lockdown: $error\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Unable to force lockdown: $error");
	}
	libtestbed::SENDMAIL($TBOPS, "Slice lockdown forced!",
			     "$slice_urn has been forcibly locked down,\n".
			     "throwing the reservation system into chaos.\n\n".
			     "Slice: $slice\n".
			     "Experiment: $experiment\n",
			     $TBOPS);
	
	return GeniResponse->Create(GENIRESPONSE_SUCCESS);
    }
    return GeniResponse->Create(GENIRESPONSE_REFUSED, undef, $error);
}

#
# Turn on/off "panic" mode for an experiment. We use level 1 since not
# all clusters support control network vlan modifications. 
#
sub Panic($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $clear        = $argref->{'clear'};
    my $poweroff     = $argref->{'poweroff'};
    my $radiosonly   = $argref->{'radiosonly'};
    my $credentials  = $argref->{'credentials'};
    my $forked       = 0;
    
    if (! (defined($credentials) && defined($slice_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if (! GeniHRN::IsValid($slice_urn)) {
	return GeniResponse->MalformedArgsResponse("Invalid URN");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    my $authority = GeniCM::CreateAuthorityFromCertificate($credential);
    return $authority
	if (GeniResponse::IsResponse($authority));

    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! (defined($slice) && defined($aggregate))) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Slice does not exist");
    }
    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    
    #
    # Only the SA for the slice can do this.
    #
    my $caller = GeniHRN->new($credential->owner_urn());
    if (! ($caller->IsSA() && 
	   $caller->domain() eq $slice->urn()->domain())) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
			    "Not enough permission to turn on/off panic mode");
    }
    if ($slice->WaitForLock(5) != 0) {
	return GeniResponse->BusyResponse();
    }
    $aggregate->Refresh();
    
    main::AddLogfileMetaDataFromSlice($slice);

    my $experiment = $slice->GetExperiment();
    if (!defined($experiment)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "No local experiment for slice");
    }

    #
    # Watch for the caller being out of sync with reality.
    #
    if ($clear && !$experiment->Paniced()) {
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_SUCCESS);	
    }
    elsif (!$clear && $experiment->Paniced()) {
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_SUCCESS);
    }
    # This would make no sense.
    if ($clear && $aggregate->Busy()) {
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Inconsistent busy state for clear");
    }

    #
    # OK, we want to wait for the aggregate to stop being Busy, so that
    # we can proceed with the panic.
    #
    # We also set the slice experiment cancelation flag, which will stop
    # a new experiment (or reload/reboot/restart) early.
    #
    if ($aggregate->Busy() && !$clear) {
	my $slice_uuid = $slice->uuid();
	print STDERR "aggregate is busy, marking for cancelation\n";
	$experiment->SetCancelFlag(1);

	# Do not do this, the caller needs to wait, since this is a
	# very unusual activity, we want the caller to know for sure
	# if it works or fails.
	if (0) {
	#
	# At this point, we can just return to the caller, tell it we are
	# working on it.
	#
	my $mypid = main::WrapperFork();
	if ($mypid) {
	    return GeniResponse->Create(GENIRESPONSE_INPROGRESS);
	}
	# No need to fork again.
	$forked = 1;
	}

	#
	# Now we wait. 
	#
	$slice->Flush();
	while (1) {
	    sleep(10);
	    $slice = GeniSlice->Lookup($slice_uuid);
	    if (!defined($slice)) {
		print STDERR "Slice is gone, quiting ...\n";
		goto done;
	    }
	    $aggregate->Flush();
	    $aggregate = GeniAggregate->SliceAggregate($slice);
	    # This would be unusual, so call it quits.
	    if (!defined($aggregate)) {
		print STDERR "No aggregate for slice, giving up\n";
		$slice->UnLock();
		return GeniResponse->Create(GENIRESPONSE_ERROR);
	    }
	    last
		if (!$aggregate->Busy());
	    
	    $slice->Flush();
	}
	# Make sure the cancel flag is cleared.
	$experiment->SetCancelFlag(0);
    }
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();
    my $command = "$WAP $PANIC -l " . ($poweroff ? "3" : "1") . " " .
	($MAINSITE && $radiosonly ? "-R" : "") . " " .
	($clear ? "-r " : "") . "$pid $eid";

    GeniUtil::FlipToElabMan();
    print STDERR "Running '$command'\n";
    system($command);
    if ($?) {
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    if ($clear) {
	$slice->ClearShutdown();
    }
    $slice->UnLock();
    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
}

#
# Another Emulab specific function to run linktest and return the results.
#
sub RunLinktest($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $credentials  = $argref->{'credentials'};
    my $level        = $argref->{'level'};
    my $action       = $argref->{'action'};
    my $async        = $argref->{'async'};
    my $logfile;
    
    if (! (defined($credentials) && defined($action) &&
	   defined($slice_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    if ($action !~ /^(start|stop|status)$/) {
	return GeniResponse->MalformedArgsResponse("Bad action: $action");
    }
    if ($action eq "start") {
	$level = 1
	    if (!defined($level));
	if ($level !~ /^\d$/ || $level < 1 || $level > 4) {
	    return GeniResponse->MalformedArgsResponse("Bad linktest level");
	}
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! (defined($slice) && defined($aggregate))) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Sliver does not exist");
    }
    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));

    main::AddLogfileMetaDataFromSlice($slice);

    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    # Terminated slices get nothing.
    if ($slice->termination_pending()) {
	return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
				    "Slice is marked for termination");
    }
    if (!defined(GeniCM::FlipToUser($slice, $user))) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "FlipToUser failed");
    }
    my $experiment = $slice->GetExperiment();
    if (!defined($experiment)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "No local experiment for slice");
    }
    #
    # When async, we are going to create a log file and return a spew
    # url to the caller, who can then read the output of the linktest
    # in real time. 
    #
    if ($action eq "start" && defined($async)) {
	$logfile = Logfile->Create($experiment->GetGroup());
	if (!defined($logfile)) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	$logfile->SetPublic(1);
	$logfile->Open();
	
	my $mypid = main::WrapperFork();
	if ($mypid) {
	    #
	    # Wait a few seconds for immediate errors or finish. We cannot
	    # use waitpid since the child returns, it does not exit. We can
	    # look at linktest_pid instead, but we will not know about an
	    # error. 
	    #
	    return GeniResponse->Create(GENIRESPONSE_SUCCESS,
					{"status"  => "running",
					 "url"     =>  $logfile->URL()});
	}
    }
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();
    my $output = "";

    if ($action eq "status") {
	return GeniResponse->Create(GENIRESPONSE_SUCCESS,
				    {"status"  => 
					 ($experiment->linktest_pid() ?
					  "running" : "stopped")});
    }
    elsif ($action eq "stop") {
	$output = GeniUtil::ExecQuiet("$LINKTEST -k $pid $eid");
    }
    else {
	my $command = "$LINKTEST -e -l $level -t 3600 ";
	$command .= "-N "
	    if ($experiment->HasNoNFSMounts());
	$command .= "-o " . $logfile->filename() . " "
	    if (defined($async));
	$command .= "$pid $eid";
	
	$output = GeniUtil::ExecQuiet($command);
    }
    my $exitval = $?;
    
    if (defined($async)) {
	my $fname = $logfile->filename();
	#
	# This is a pain; if linktest bailed early, the log file will
	# be empty, and the user will not see any output cause we have
	# forked and so there is no way to return the output. So stuff it
	# into the logfile for it to be spewed to the user. 
	#
	if ($exitval && -z $fname) {
	    if (open(LOG, ">" . $logfile->filename())) {
		print LOG $output;
		close(LOG);
	    }
	}
	elsif (-s $fname) {
	    $output = `cat $fname`;
	}
	#
	# Delay for bit then delete the log file. Need to do this a different
	# way at some point.
	#
	$logfile->Close();
	sleep(30);
	$logfile->Delete(1);
    }
    print STDERR $output;
    
    if ($exitval) {
	return -1
	    if (defined($async));
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef, $output);
    }
    return 0
	if (defined($async));
    return GeniResponse->Create(GENIRESPONSE_SUCCESS,
				{"status"  => "stopped",
				 "results" => $output}, $output);
}

#
# Another Emulab specific function to put a node into "recovery" mode.
# In other words, a linux MFS so the user can fix what they broke.
#
sub Recovery($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $credentials  = $argref->{'credentials'};
    my $sliver_urn   = $argref->{'sliver_urn'};
    my $clear        = $argref->{'clear'};
    
    if (! (defined($credentials) && 
	   defined($slice_urn) && defined($sliver_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! (defined($slice) && defined($aggregate))) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Sliver does not exist");
    }
    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));

    main::AddLogfileMetaDataFromSlice($slice);

    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    # Terminated slices get nothing.
    if ($slice->termination_pending()) {
	return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
				    "Slice is marked for termination");
    }
    my $sliver = GeniSliver->Lookup($sliver_urn);
    if (!defined($sliver)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Sliver does not exist");
    }
    if ($sliver->slice_uuid() ne $slice->uuid()) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Sliver is not in slice");
    }
    my $node_id = $sliver->resource_id();
    my $node = Node->Lookup($node_id);
    if (!defined($node)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "No node for sliver urn");
    }
    if ($node->IsTainted()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
				    "node is tainted - recovery mode denied");
    }
    if (!defined(GeniCM::FlipToUser($slice, $user))) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "FlipToUser failed");
    }
    my $experiment = $slice->GetExperiment();
    if (!defined($experiment)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "No local experiment for slice");
    }
    my $output = "";

    if ($clear) {
	$output = GeniUtil::ExecQuiet("$NODEADMIN -R off $node_id");
    }
    else {
	$output = GeniUtil::ExecQuiet("$NODEADMIN -R on $node_id");
    }
    print STDERR $output . "\n";
    if ($?) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Failed to change recovery mode");
    }
    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
}

#
# Another Emulab specific function to flash a new FPGA image
#
sub Flash($)
{
    my ($argref) = @_;
    my $slice_urn    = $argref->{'slice_urn'};
    my $credentials  = $argref->{'credentials'};
    my $sliver_urn   = $argref->{'sliver_urn'};
    
    if (! (defined($credentials) && 
	   defined($slice_urn) && defined($sliver_urn))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my ($credential,$speaksfor) = GeniStd::CheckCredentials($credentials);
    return $credential
	if (GeniResponse::IsResponse($credential));

    my ($slice, $aggregate) = Credential2SliceAggregate($credential);
    return $slice
	if (defined($slice) && GeniResponse::IsResponse($slice));

    if (! (defined($slice) && defined($aggregate))) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Sliver does not exist");
    }
    my $user = GeniCM::CreateUserFromCertificate($credential);
    return $user
	if (GeniResponse::IsResponse($user));

    main::AddLogfileMetaDataFromSlice($slice);

    if ($slice_urn ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN(), undef,
				    "Credential does not match the URN");
    }
    # Terminated slices get nothing.
    if ($slice->termination_pending()) {
	return GeniResponse->Create(GENIRESPONSE_INPROGRESS(), undef,
				    "Slice is marked for termination");
    }
    my $sliver = GeniSliver->Lookup($sliver_urn);
    if (!defined($sliver)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Sliver does not exist");
    }
    if ($sliver->slice_uuid() ne $slice->uuid()) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "Sliver is not in slice");
    }
    my $node_id = $sliver->resource_id();
    my $node = Node->Lookup($node_id);
    if (!defined($node)) {
	return GeniResponse->Create(GENIRESPONSE_SEARCHFAILED, undef,
				    "No node for sliver urn");
    }
    if ($node->IsTainted()) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
				    "node is tainted - flash denied");
    }
    my $flashable;
    $node->NodeAttribute("flashable", \$flashable);
    if (!defined($flashable)) {
	return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
				    "node is not flashable");
    }
    
    if (!defined(GeniCM::FlipToUser($slice, $user))) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "FlipToUser failed");
    }
    my $experiment = $slice->GetExperiment();
    if (!defined($experiment)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "No local experiment for slice");
    }
    #
    # Lock the slice; we do not let the user to mess with things.
    #
    if ($slice->Lock() != 0) {
	return GeniResponse->BusyResponse();
    }
    $aggregate->Refresh();
    # Check again after lock.
    if ($aggregate->Busy() ||
	$aggregate->Imaging()) {
	$slice->UnLock();
	return GeniResponse->BusyResponse();
    }    
    
    my $output = GeniUtil::ExecQuiet("$FLASHNODE $node_id");
    print STDERR $output . "\n";
    if ($?) {
	$slice->UnLock();
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Failed to flash radio");
    }
    $slice->UnLock();
    return GeniResponse->Create(GENIRESPONSE_SUCCESS);
}

# _Always_ make sure that this 1 is at the end of the file...
1;
