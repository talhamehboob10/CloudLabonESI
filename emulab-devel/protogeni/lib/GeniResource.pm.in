#!/usr/bin/perl -wT
#
# Copyright (c) 2008-2012 University of Utah and the Flux Group.
# 
# {{{GENIPUBLIC-LICENSE
# 
# GENI Public License
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and/or hardware specification (the "Work") to
# deal in the Work without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Work, and to permit persons to whom the Work
# is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Work.
# 
# THE WORK IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS
# IN THE WORK.
# 
# }}}
#
package GeniResource;

#
# Mapping between geni resources and Emulab resources.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

use GeniDB;
use Genixmlrpc;
use GeniResponse;
use GeniRegistry;
use GeniTicket;
use GeniCredential;
use GeniAuthority;
use GeniComponent;
use GeniSlice;
use GeniUtil;
use GeniUser;
use GeniHRN;
use GeniXML;
use emutil qw(TBGetUniqueIndex);
use User;
use Project;
use Group;
use Node;
use Interface;
use English;
use XML::Simple;
use Date::Parse;
use Data::Dumper;
use RPC::XML;
use POSIX qw(strftime);
use overload ('""' => 'Stringify');

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $BOSSNODE       = "@BOSSNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";
my $SACERT         = "$TB/etc/genisa.pem";

# Cache of objects
my %resources = ();
BEGIN { use GeniUtil; GeniUtil::AddCache(\%resources); }

#
# Lookup by uuid.
#
sub Lookup($$;$)
{
    my ($class, $arg1, $arg2) = @_;
    my $idx;

    if (!defined($arg2)) {
	if ($arg1 =~ /^(\d*)$/) {
	    $idx = $arg1;
	}
	else {
	    return undef;
	}
    }
    elsif (($arg1 =~ /^\d*$/) && GeniHRN::IsValid($arg2)) {
	my $query_result =
	    DBQueryWarn("select idx from geni_resources ".
			"where exptidx='$arg1' and manager_urn='$arg2'");

	return undef
	    if (!$query_result || !$query_result->numrows);

	($idx) = $query_result->fetchrow_array();
    }
    else {
	return undef;
    }

    return $resources{"$idx"}
        if (exists($resources{"$idx"}));

    my $query_result =
	DBQueryWarn("select * from geni_resources where idx='$idx'");
    
    return undef
	if (!$query_result || !$query_result->numrows);

    my $self              = {};
    $self->{'DBROW'}      = $query_result->fetchrow_hashref();
    $self->{'NEWTICKET'}  = undef;
    $self->{'MANIFEST'}   = undef;
    $self->{'RSPEC'}      = undef;
    $self->{'NEWRSPEC'}   = undef;
    $self->{'MODIFIED'}   = 1;
    $self->{'_authority'} = undef;
    $self->{'last_rpc_error'}  = 0;
    $self->{'last_rpc_value'}  = undef;
    $self->{'last_rpc_output'} = undef;
    bless($self, $class);

    # Add to cache.
    $resources{"$idx"} = $self;
    
    return $self;
}

#
# Lookup by experiment.
#
sub LookupAll($$)
{
    my ($class, $arg1) = @_;

    if (ref($arg1)) {
	$arg1 = $arg1->idx();
    }
    my $query_result =
	DBQueryWarn("select idx from geni_resources where exptidx='$arg1'");

    return undef
	if (!$query_result);
    return ()
	if (!$query_result->numrows);

    my @result = ();

    while (my ($idx) = $query_result->fetchrow_array()) {
	my $resource = GeniResource->Lookup($idx);
	if (!defined($resource)) {
	    print STDERR "Could not get GeniResource for $idx\n";
	    return undef
	}
	push(@result, $resource);
    }
    return @result;
}

sub SliceResources($)
{
    my ($class, $slice) = @_;
    my $slice_idx = $slice->idx();

    my $query_result =
	DBQueryWarn("select idx from geni_resources ".
		    "where slice_idx='$slice_idx'");

    return undef
	if (!$query_result);
    return ()
	if (!$query_result->numrows);

    my @result = ();

    while (my ($idx) = $query_result->fetchrow_array()) {
	my $resource = GeniResource->Lookup($idx);
	if (!defined($resource)) {
	    print STDERR "Could not get GeniResource for $idx\n";
	    return undef
	}
	push(@result, $resource);
    }
    return @result;
}

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    my $idx = $self->idx();
    my $urn = $self->manager_urn();

    return "[GeniResource: $idx, $urn]";
}

#
# Create a GeniResource in the DB.
#
sub Create($$$)
{
    my ($class, $experiment, $manager_urn) = @_;
    my @insert_data = ();

    my $slice = GeniSlice->LookupByExperiment($experiment);
    if (!defined($slice)) {
	print STDERR "*** GeniResource::Create: ".
	    "No slice registered for $experiment\n";
	return undef;
    }

    # Every one gets a new unique index.
    my $idx = TBGetUniqueIndex('next_geniidx', 1);

    my $safe_urn = DBQuoteSpecial($manager_urn);
    my $pid      = $experiment->pid();
    my $eid      = $experiment->eid();
    my $exptidx  = $experiment->idx();
    my $slice_idx= $slice->idx();
    
    # Now tack on other stuff we need.
    push(@insert_data, "idx='$idx'");
    push(@insert_data, "slice_idx='$slice_idx'");
    push(@insert_data, "created=now()");
    push(@insert_data, "manager_urn=$safe_urn");
    push(@insert_data, "pid='$pid'");
    push(@insert_data, "eid='$eid'");
    push(@insert_data, "exptidx=$exptidx");

    # Insert into DB.
    DBQueryWarn("replace into geni_resources set " . join(",", @insert_data))
	or return undef;

    return GeniResource->Lookup($idx);
}
# accessors
sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'DBROW'}->{$_[1]}); }
sub idx($)		{ return field($_[0], "idx"); }
sub exptidx($)		{ return field($_[0], "exptidx"); }
sub pid($)		{ return field($_[0], "pid"); }
sub eid($)		{ return field($_[0], "eid"); }
sub created($)          { return field($_[0], "created"); }
sub updated($)          { return field($_[0], "updated"); }
sub expires($)          { return field($_[0], "expires"); }
sub manager_urn($)      { return field($_[0], "manager_urn"); }
sub slice_idx($)        { return field($_[0], "slice_idx"); }
sub credential_idx($)   { return field($_[0], "credential_idx"); }
sub manifest_idx($)     { return field($_[0], "manifest_idx"); }
sub ticket_idx($)       { return field($_[0], "ticket_idx"); }
sub newticket_idx($)    { return field($_[0], "newticket_idx"); }
sub rspec_idx($)        { return field($_[0], "rspec_idx"); }
sub _authority($)       { return $_[0]->{'_authority'}; }
sub last_rpc_error($)   { return $_[0]->{'last_rpc_error'}; }
sub last_rpc_output($)  { return $_[0]->{'last_rpc_output'}; }
sub last_rpc_value($)   { return $_[0]->{'last_rpc_value'}; }
sub manifest_string($)  { return $_[0]->{'MANIFESTSTR'}; }
sub rspec_string($)     { return $_[0]->{'RSPECSTR'}; }
sub modified($)         { return $_[0]->{'MODIFIED'}; }
sub setmodified($$)     { $_[0]->{'MODIFIED'} = $_[1]; }
sub stashrspec($$)      { $_[0]->{'NEWRSPEC'} = $_[1]; }
sub stashedrspec($$)    { return $_[0]->{'NEWRSPEC'}; }

#
# Delete a resource record from the DB.
#
sub Delete($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $idx = $self->idx();
    DBQueryWarn("delete from geni_resources ".
		"where idx='$idx'")
	or return -1;

    delete($resources{"$idx"});
    return 0;
}

#
# Compare two refs.
#
sub SameResource($$)
{
    my ($self, $other) = @_;

    return 0
	if (! (ref($self) && ref($other)));

    return $self->idx() eq $other->idx();
}

#
# Refresh a class instance by reloading from the DB.
#
sub Refresh($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $idx = $self->idx();

    my $query_result =
	DBQueryWarn("select * from geni_resources where idx='$idx'");

    return -1
	if (!$query_result || !$query_result->numrows);

    $self->{'DBROW'}     = $query_result->fetchrow_hashref();
    $self->{'NEWTICKET'} = undef;
    $self->{'MANIFEST'}  = undef;
    $self->{'RSPEC'}     = undef;

    return 0;
}

#
# Update Fields.
#
sub Update($$)
{
    my ($self, $argref) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $idx = $self->idx();

    my $query = "update geni_resources set ".
	join(",", map("$_=" . DBQuoteSpecial($argref->{$_}),
		      keys(%{$argref})));

    $query .= " where idx='$idx'";

    return -1
	if (! DBQueryWarn($query));

    return Refresh($self);
}

#
# Set the expiration time.
#
sub SetExpiration($$)
{
    my ($self, $expires) = @_;
    my $idx = $self->idx();

    if (!defined($expires)) {
	$expires = "NULL";
    }
    elsif ($expires =~ /^\d+$/) {
	$expires = "FROM_UNIXTIME($expires)";
    }
    else {
	$expires = "'$expires'";
    }
    my $query_result =
	DBQueryWarn("update geni_resources set expires=$expires " .
		    "where idx='$idx'");
    
    return -1
	if (!$query_result);

    # Has to be in the correct format.
    $query_result =
	DBQueryWarn("select expires from geni_resources where idx='$idx'");
    return -1
	if (!$query_result || !$query_result->numrows);
    ($expires) = $query_result->fetchrow_array();
    
    $self->{'DBROW'}->{'expires'} = $expires;
    return 0;
}

#
# Return the ticket.
#
sub Ticket($)
{
    my ($self) = @_;

    return $self->{'NEWTICKET'}
        if (defined($self->{'NEWTICKET'}));

    if (!$self->newticket_idx()) {
	print STDERR "*** No new ticket defined for $self.\n";
	return undef;
    }
    my $ticket = GeniTicket->Lookup($self->newticket_idx());
    if (!defined($ticket)) {
	print STDERR "*** Could not get new ticket for $self.\n";
	return undef;
    }
    $self->{'NEWTICKET'} = $ticket;
    return $ticket;
}
# Got a ticket?
sub HaveTicket($)
{
    my ($self) = @_;

    return $self->newticket_idx();
}

#
# Return the rspec
#
sub Rspec($)
{
    my ($self) = @_;

    return $self->{'RSPEC'}
        if (defined($self->{'RSPEC'}));

    if (!$self->rspec_idx()) {
	print STDERR "*** No rspec defined for $self.\n";
	return undef;
    }
    my $rspec_idx = $self->rspec_idx();

    my $query_result =
	DBQueryWarn("select rspec from geni_rspecs ".
		    "where idx=$rspec_idx");
    if (!$query_result || !$query_result->numrows) {
	print STDERR "Could not locate rspec for $self\n";
	return undef;
    }
    my ($rspec_string) = $query_result->fetchrow_array();
    my $rspec = GeniXML::Parse($rspec_string);
    if (!defined($rspec)) {
	print STDERR "Could not parse rspec for $self\n";
	return undef;
    }
    $self->{'RSPEC'}    = $rspec;
    $self->{'RSPECSTR'} = $rspec_string;
    return $rspec;
}
sub HaveRspec($)
{
    my ($self) = @_;

    return $self->rspec_idx();
}
sub UpdateRspec($$)
{
    my ($self, $rspec) = @_;

    my $rspec_idx    = $self->rspec_idx();
    my $rspec_string = (ref($rspec) ? GeniXML::Serialize($rspec) : $rspec);

    if ($rspec_idx) {
	my $query_result = 
	    DBQueryWarn("update geni_rspecs set ".
			"  rspec=". DBQuoteSpecial($rspec_string) . ", " .
			"  created=now() ".
			"where idx=$rspec_idx");
	return -1
	    if (!defined($query_result));
    }
    else {
	my $query_result = 
	    DBQueryWarn("insert into geni_rspecs set idx=NULL, ".
			"  rspec=". DBQuoteSpecial($rspec_string) . ", " .
			"  created=now() ");
	return -1
	    if (!defined($query_result));

	$rspec_idx = $query_result->insertid;
	$self->Update({"rspec_idx" => $rspec_idx});
    }

    $self->{'RSPEC'}    = $rspec;
    $self->{'RSPECSTR'} = $rspec_string;
    return 0;
}

sub Manifest($)
{
    my ($self) = @_;

    return $self->{'MANIFEST'}
        if (defined($self->{'MANIFEST'}));

    if (!$self->manifest_idx()) {
	print STDERR "*** No manifest defined for $self.\n";
	return undef;
    }
    my $manifest_idx = $self->manifest_idx();

    my $query_result =
	DBQueryWarn("select manifest from geni_manifests ".
		    "where idx=$manifest_idx");
    if (!$query_result || !$query_result->numrows) {
	print STDERR "Could not locate manifest for $self\n";
	return undef;
    }
    my ($manifest_string) = $query_result->fetchrow_array();
    my $manifest = GeniXML::Parse($manifest_string);
    if (!defined($manifest)) {
	print STDERR "Could not getmanifest for $self\n";
	return undef;
    }
    $self->{'MANIFEST'}    = $manifest;
    $self->{'MANIFESTSTR'} = $manifest_string;
    return $manifest;
}

sub UpdateManifest($$)
{
    my ($self, $manifest) = @_;

    if (! $self->manifest_idx()) {
	print STDERR "No manifest to update for $self\n";
	return -1;
    }
    my $manifest_idx = $self->manifest_idx();
    my $manifest_string = GeniXML::Serialize($manifest);

    my $query_result =
	DBQueryWarn("update geni_manifests set ".
		    "  manifest=". DBQuoteSpecial($manifest_string) . ", " .
		    "  created=now() ".
		    "where idx=$manifest_idx");
    return -1
	if (!defined($query_result));

    $self->{'MANIFEST'}    = $manifest;
    $self->{'MANIFESTSTR'} = $manifest_string;
    return 0;
}

#
# Get Authority.
#
sub Authority($)
{
    my ($self) = @_;

    return $self->_authority()
	if (defined($self->_authority()));

    my $manager_urn = $self->manager_urn();

    #
    # Load the SA cert to act as caller context.
    #
    my $certificate = GeniCertificate->LoadFromFile($SACERT);
    if (!defined($certificate)) {
	print STDERR "*** Could not load certificate from $SACERT\n";
	return undef;
    }
    my $context = Genixmlrpc->Context($certificate);
    if (!defined($context)) {
	print STDERR "*** Could not create context to talk to clearinghouse\n";
	return undef;
    }
    #
    # Set the default RPC context. 
    #
    Genixmlrpc->SetContext($context);

    my $authority = GeniAuthority->Lookup($manager_urn);
    if (!defined($authority)) {
	$authority = GeniAuthority->CreateFromRegistry("cm", $manager_urn);
	if (!defined($authority)) {
	    print STDERR "*** Could not find $manager_urn at ClearingHouse\n";
	    return undef;
	}
    }
    $self->{'_authority'} = $authority;
    return $authority;
}
sub Version($)
{
    my ($self) = @_;
    
    return undef
	if (!defined($self->Authority()));
    return $self->Authority()->Version();
}
sub ApiLevel($)
{
    my ($self) = @_;

    return undef
	if (!defined($self->Authority()));
    return $self->Authority()->ApiLevel();
}
sub Api($)
{
    my ($self) = @_;

    return undef
	if (!defined($self->Authority()));
    return $self->Authority()->Api();
}
sub IsSFA($)
{
    my ($self) = @_;

    return undef
	if (!defined($self->Authority()));
    return $self->Authority()->IsSFA();
}

#
# Add Resources. We get an rspec to replace the current rspec.
# Ask for a ticket, and then redeem it.
#
sub GetTicket($$$$)
{
    my ($self, $user, $rspec_string, $impotent) = @_;
    my $ticket;
    my $response;

    # Always clear for caller.
    $self->{'last_rpc_error'} = 0;
    $self->{'last_rpc_output'} = undef;
    $self->{'last_rpc_value'}  = undef;

    my $slice = GeniSlice->Lookup($self->slice_idx());
    if (!defined($slice)) {
	print STDERR "*** AddResources: No slice for $self\n";
	return -1;
    }
    my $manager_urn = $self->manager_urn();

    #
    # Load the SA cert to act as caller context.
    #
    my $certificate = GeniCertificate->LoadFromFile($SACERT);
    if (!defined($certificate)) {
	print STDERR "*** Could not load certificate from $SACERT\n";
	return -1;
    }
    my $context = Genixmlrpc->Context($certificate);
    if (!defined($context)) {
	print STDERR "*** Could not create context to talk to clearinghouse\n";
	return -1;
    }
    #
    # Set the default RPC context. 
    #
    Genixmlrpc->SetContext($context);

    my $authority = GeniAuthority->CreateFromRegistry("cm", $manager_urn);
    if (!defined($authority)) {
	print STDERR "*** Could not find $manager_urn at ClearingHouse\n";
	return -1;
    }
    my $manager_version = $self->Version();
    my $manager_api     = $self->Api();

    #
    # Create a Geni user from current user doing the operation.
    #
    my $geniuser = GeniUser->CreateFromLocal($user);
    if (!defined($geniuser)) {
	print STDERR "*** Could not create a geni user from $user\n";
	return -1;
    }
    my $usercontext = Genixmlrpc->UserContext($geniuser);
    if (!defined($usercontext)) {
	print STDERR "*** Could not create user context from $geniuser\n";
	return -1;
    }

    #
    # Generate a slice credential for the user. 
    #
    my $slice_credential =
	GeniCredential->CreateSigned($slice,
				     $geniuser,
				     $GeniCredential::LOCALSA_FLAG);
    if (!defined($slice_credential)) {
	print STDERR
	    "*** Could not create a slice credential for $slice/$geniuser!\n";
	return -1;
    }

    #
    # Load sliver credential if we have it.
    #
    my $sliver_credential;
    if ($self->credential_idx()) {
	$sliver_credential = GeniCredential->Lookup($self->credential_idx());
	if (!defined($sliver_credential)) {
	    print STDERR "*** Could not get sliver credential for $self.\n";
	    return -1;
	}
    }

    my $method_name = "GetTicket";
    my $method_args = {};

    $method_args->{'impotent'} = $impotent;
    $method_args->{'rspec'}    = $rspec_string;
    if ($manager_version == 1.0) {
	$method_args->{'credential'} = $slice_credential->asString();
	#
	# Already have a credential for a sliver, then we want to update
	# the existing ticket we also have on file, and then redeem that.
	#
	if (defined($sliver_credential)) {
	    if ($self->newticket_idx()) {
		print STDERR
		    "*** Still have a new ticket defined for $self.\n";
		return -1;
	    }
	    if (!$self->ticket_idx()) {
		print STDERR "*** No ticket defined for $self.\n";
		return -1;
	    }
	    $ticket = GeniTicket->Lookup($self->ticket_idx());
	    if (!defined($ticket)) {
		print STDERR "*** Could not get ticket for $self.\n";
		return -1;
	    }
	    $method_name = "UpdateTicket";
	    $method_args->{'ticket'} = $ticket->asString();
	}
    }
    elsif ($manager_version == 2.0) {
	$method_args->{'credentials'} = [$slice_credential->asString()];
	$method_args->{'slice_urn'}   = $slice->urn();

	if ($self->newticket_idx()) {
	    $ticket = GeniTicket->Lookup($self->newticket_idx());
	    if (!defined($ticket)) {
		print STDERR "*** Could not get ticket for $self.\n";
		return -1;
	    }
	    $method_name = "UpdateTicket";
	    $method_args->{'ticket'} = $ticket->asString();
	}
	elsif (defined($sliver_credential)) {
	    $method_name = "UpdateSliver";
	    $method_args->{'sliver_urn'} = $sliver_credential->target_urn();
	}
    }
    else {
	print STDERR "GeniResource::GetTicket Unknown version at $authority\n";
	return -1;
    }
    $response =
	Genixmlrpc::CallMethod($authority->url(), $usercontext,
			       $method_name, $method_args);
    if (!defined($response)) {
	$self->{'last_rpc_error'} = GENIRESPONSE_RPCERROR();
	print STDERR "*** Internal error getting/updating ticket for $self\n";
	return -1;
    }
    $self->{'last_rpc_error'} = $response->code();
    $self->{'last_rpc_output'} = $response->output();
    $self->{'last_rpc_value'}  = $response->value();
    if ($response->code() != GENIRESPONSE_SUCCESS) {
	if ($ticket) {
	    print STDERR "Could not update ticket $ticket. Error: ";
	}
	else {
	    print STDERR "Could not get new ticket from $self. Error: ";
	}
	print STDERR $response->output() . "\n";
	return -1;
    }
    my $newticket = GeniTicket->CreateFromSignedTicket($response->value());
    if (!defined($newticket)) {
	print STDERR "*** Cannot create new ticket object:\n";
	print STDERR "*** " . $GeniTicket::CreateFromSignedError . "\n";
	print STDERR $response->value() . "\n";
	return -1;
    }
    $newticket->SetSlice($slice);
    if ($newticket->Store(TICKET_NOSTATS) != 0) {
	print STDERR "*** Could not store $newticket\n";
	return -1;
    }
    $self->Update({"newticket_idx" => $newticket->idx()});
    $self->{'NEWTICKET'} = $newticket;

    return 0;
}

#
# Redeem the ticket.
#
sub RedeemTicket($$)
{
    my ($self, $user) = @_;
    my $response;

    # Always clear for caller.
    $self->{'last_rpc_error'} = 0;
    $self->{'last_rpc_output'} = undef;
    $self->{'last_rpc_value'}  = undef;

    my $slice = GeniSlice->Lookup($self->slice_idx());
    if (!defined($slice)) {
	print STDERR "*** AddResources: No slice for $self\n";
	return -1;
    }
    my $manager_urn = $self->manager_urn();

    #
    # Load the SA cert to act as caller context.
    #
    my $certificate = GeniCertificate->LoadFromFile($SACERT);
    if (!defined($certificate)) {
	print STDERR "*** Could not load certificate from $SACERT\n";
	return -1;
    }
    my $context = Genixmlrpc->Context($certificate);
    if (!defined($context)) {
	print STDERR "*** Could not create context to talk to clearinghouse\n";
	return -1;
    }
    #
    # Set the default RPC context. 
    #
    Genixmlrpc->SetContext($context);

    my $authority = GeniAuthority->CreateFromRegistry("cm", $manager_urn);
    if (!defined($authority)) {
	print STDERR "*** Could not find $manager_urn at ClearingHouse\n";
	return -1;
    }
    my $manager_version = $self->Version();
    my $manager_api     = $self->Api();
    my $manager_apilevel= $self->ApiLevel();

    #
    # Create a Geni user from current user doing the operation.
    #
    my $geniuser = GeniUser->CreateFromLocal($user);
    if (!defined($geniuser)) {
	print STDERR "*** Could not create a geni user from $user\n";
	return -1;
    }
    my $usercontext = Genixmlrpc->UserContext($geniuser);
    if (!defined($usercontext)) {
	print STDERR "*** Could not create user context from $geniuser\n";
	return -1;
    }

    my @keys;
    if ($geniuser->GetKeyBundle(\@keys) != 0) {
	print STDERR "Could not get keys for $geniuser\n";
	return -1;
    }
    #
    # Why is the key structure different in the AM?
    #
    if (@keys && $manager_api eq "AM") {
	my @tmp = ();
	foreach my $key (@keys) {
	    push(@tmp, $key->{'key'})
		if ($key->{'type'} eq "ssh");
	}
	@keys = @tmp;
    }

    #
    # Generate a slice credential for the user. 
    #
    my $slice_credential =
	GeniCredential->CreateSigned($slice,
				     $geniuser,
				     $GeniCredential::LOCALSA_FLAG);
    if (!defined($slice_credential)) {
	print STDERR
	    "*** Could not create a slice credential for $slice/$geniuser!\n";
	return -1;
    }

    #
    # Load sliver credential if we have it.
    #
    my $sliver_credential;
    if ($self->credential_idx()) {
	$sliver_credential = GeniCredential->Lookup($self->credential_idx());
	if (!defined($sliver_credential)) {
	    print STDERR "*** Could not get sliver credential for $self.\n";
	    return -1;
	}
    }

    if (!$self->newticket_idx()) {
	print STDERR "*** No ticket defined for $self.\n";
	return -1;
    }
    my $ticket = GeniTicket->Lookup($self->newticket_idx());
    if (!defined($ticket)) {
	print STDERR "*** Could not get new ticket for $self.\n";
	return -1;
    }
    my $oldticket;
    if ($self->ticket_idx()) {
	$oldticket = GeniTicket->Lookup($self->ticket_idx());
	if (!defined($oldticket)) {
	    print STDERR "*** Could not get old ticket for $self.\n";
	    return -1;
	}
    }
    
    #
    # Redeem it. 
    #
    my $method_name = "RedeemTicket";
    my $method_args = { "ticket"     => $ticket->asString(),
			"keys"       => \@keys };

    if ($manager_version == 1.0) {
	$method_name = "UpdateSliver"
	    if (defined($sliver_credential));
	$method_args->{'credential'} = $slice_credential->asString();
    }
    elsif ($manager_version == 2.0) {
	if (defined($sliver_credential)) {
	    $method_args->{'credentials'} = [$sliver_credential->asString()]; 
	}
	else {
	    $method_args->{'credentials'} = [$slice_credential->asString()]; 
	}
	$method_args->{'slice_urn'}   = $slice->urn();
    }
    else {
	print STDERR
	    "GeniResource::RedeemTicket Unknown version at $authority\n";
	return -1;
    }
    $response =
	Genixmlrpc::CallMethod($authority->url(), $usercontext,
			       $method_name, $method_args);
    if (!defined($response)) {
	$self->{'last_rpc_error'} = GENIRESPONSE_RPCERROR();
	print STDERR
	    "*** Internal error redeeming/updating sliver for $self\n";
	return -1;
    }
    $self->{'last_rpc_error'} = $response->code();
    $self->{'last_rpc_output'} = $response->output();
    $self->{'last_rpc_value'}  = $response->value();
    if ($response->code() != GENIRESPONSE_SUCCESS) {
	if ($sliver_credential) {
	    print STDERR "Could not update sliver $sliver_credential Error: ";
	}
	else {
	    print STDERR "Could not redeem ticket $ticket. Error: ";
	}
	print STDERR $response->output() . "\n";
	return -1;
    }
    #
    # It worked, so mark the expiration time for the resource.
    #
    if ($self->SetExpiration($slice->expires())) {
	print STDERR "RenewAll: Could not set expiration for $self!\n";
    }

    #
    # Okay, so that worked. Store the new credential and the ticket and
    # the manifest.
    #
    my ($credstring, $manifest);

    #
    # Gack, too many variations.
    #
    if (ref($response->value())) {
	($credstring,$manifest) = @{ $response->value() };
    }
    else {
	$manifest = $response->value();
    }
    
    if (defined($credstring)) {
	#
	# Delete the old credential since it no longer has any value after
	# the redeem suceeded; a new credential was issued.
	#
	if (defined($sliver_credential)) {	
	    $sliver_credential->Delete();
	    $self->Update({"credential_idx" => 0});
	    $sliver_credential = undef;
	}
	$sliver_credential = GeniCredential->CreateFromSigned($credstring);
	if (!defined($sliver_credential)) {
	    print STDERR
		"** Could not create new credential from $credstring\n";
	    print STDERR "*** " . $GeniCredential::CreateFromSignedError . "\n";
	    return -1;
	}
	if ($sliver_credential->Store()) {
	    print STDERR "** Could not store $sliver_credential\n";
	    return -1;
	}
	$self->Update({"credential_idx" => $sliver_credential->idx()});
    }
    if (defined($oldticket)) {
	$oldticket->Delete(TICKET_DELETED);
    }
    
    # For the version 2 API, there is no reason to save the ticket
    # after it is redeemed.
    if ($manager_version == 1.0) {
	$self->Update({"newticket_idx" => 0,
		       "ticket_idx"    => $ticket->idx()});
    }
    else {
	if ($self->Update({"newticket_idx" => 0}) == 0) {
	    $ticket->Delete(TICKET_DELETED());
	}
    }
	
    #
    # Move this elsewhere.
    #
    if ($self->manifest_idx()) {
	my $manifest_idx = $self->manifest_idx();
	
	DBQueryWarn("update geni_manifests set ".
		    "  manifest=". DBQuoteSpecial($manifest) . ", " .
		    "  created=now() ".
		    "where idx=$manifest_idx")
	    or return -1;
    }
    else {
	# We do not care about this uuid in cooked mode.
	my $uuid = GeniUtil::NewUUID();

	my $query_result = 
	    DBQueryWarn("insert into geni_manifests set ".
			"  manifest=". DBQuoteSpecial($manifest) . ", " .
			"  idx=NULL, slice_uuid='$uuid', ".
			"  created=now()");
	return -1
	    if (!defined($query_result));

	my $manifest_idx = $query_result->insertid;
	
	$self->Update({"manifest_idx" => $manifest_idx});
    }
    return 0;
}

#
# Create a sliver on a level 0 API manager.
#
sub CreateSliver($$$$)
{
    my ($self, $user, $rspec_string, $impotent) = @_;
    my $response;

    # Always clear for caller.
    $self->{'last_rpc_error'} = 0;
    $self->{'last_rpc_output'} = undef;
    $self->{'last_rpc_value'}  = undef;

    my $slice = GeniSlice->Lookup($self->slice_idx());
    if (!defined($slice)) {
	print STDERR "*** CreateSliver: No slice for $self\n";
	return -1;
    }
    my $manager_urn = $self->manager_urn();

    #
    # Load the SA cert to act as caller context.
    #
    my $certificate = GeniCertificate->LoadFromFile($SACERT);
    if (!defined($certificate)) {
	print STDERR "*** Could not load certificate from $SACERT\n";
	return -1;
    }
    my $context = Genixmlrpc->Context($certificate);
    if (!defined($context)) {
	print STDERR "*** Could not create context to talk to clearinghouse\n";
	return -1;
    }
    #
    # Set the default RPC context. 
    #
    Genixmlrpc->SetContext($context);

    my $authority = GeniAuthority->CreateFromRegistry("cm", $manager_urn);
    if (!defined($authority)) {
	print STDERR "*** Could not find $manager_urn at ClearingHouse\n";
	return -1;
    }
    my $manager_version = $self->Version();
    my $manager_api     = $self->Api();

    #
    # Create a Geni user from current user doing the operation.
    #
    my $geniuser = GeniUser->CreateFromLocal($user);
    if (!defined($geniuser)) {
	print STDERR "*** Could not create a geni user from $user\n";
	return -1;
    }
    my $usercontext = Genixmlrpc->UserContext($geniuser);
    if (!defined($usercontext)) {
	print STDERR "*** Could not create user context from $geniuser\n";
	return -1;
    }

    my @keys;
    if ($geniuser->GetKeyBundle(\@keys) != 0) {
	print STDERR "Could not get keys for $geniuser\n";
	return -1;
    }
    #
    # Why is the key structure different in the AM?
    #
    if (@keys && $manager_api eq "AM") {
	my @tmp = ();
	foreach my $key (@keys) {
	    push(@tmp, $key->{'key'})
		if ($key->{'type'} eq "ssh");
	}
	@keys = @tmp;
    }

    #
    # Generate a slice credential for the user. 
    #
    my $slice_credential =
	GeniCredential->CreateSigned($slice,
				     $geniuser,
				     $GeniCredential::LOCALSA_FLAG);
    if (!defined($slice_credential)) {
	print STDERR
	    "*** Could not create a slice credential for $slice/$geniuser!\n";
	return -1;
    }

    #
    # Do it. 
    #
    my $method_name = "CreateSliver";
    my $method_args = {};
    my @method_args = ($method_args);
    $method_args->{'impotent'} = $impotent;
    $method_args->{'rspec'}    = $rspec_string;
    $method_args->{'keys'}     = \@keys;

    if ($manager_api eq "AM") {
	@method_args = ($slice->urn(),
			[$slice_credential->asString()], $rspec_string,
			[{"urn" => $geniuser->urn(), "keys" => \@keys}]);
    }
    elsif ($manager_version == 2.0) {
	$method_args->{'credentials'} = [$slice_credential->asString()];
	$method_args->{'slice_urn'}   = $slice->urn();
    }
    else {
	print STDERR
	    "*** GeniResource::CreateSliver Unknown version at $authority\n";
	return -1;
    }
    $response =
	Genixmlrpc::CallMethod($authority->url(), $usercontext,
			       $method_name, @method_args);
    if (!defined($response)) {
	$self->{'last_rpc_error'} = GENIRESPONSE_RPCERROR();
	print STDERR "*** Internal error creating sliver for $self\n";
	return -1;
    }
    $self->{'last_rpc_error'} = $response->code();
    $self->{'last_rpc_output'} = $response->output();
    $self->{'last_rpc_value'}  = $response->value();
    if ($response->code() != GENIRESPONSE_SUCCESS) {
	print STDERR "Could not create sliver on $self Error: ";
	print STDERR $response->output() . "\n";
	return -1;
    }
    #
    # It worked, so mark the expiration time for the resource.
    #
    if ($self->SetExpiration($slice->expires())) {
	print STDERR "Could not set expiration for $self!\n";
    }

    #
    # Okay, so that worked. Store the new credential and the manifest.
    #
    my ($credstring,$manifest);
    if ($manager_api eq "AM") {
	$manifest = $response->value();
    }
    else {
	($credstring,$manifest) = @{ $response->value() };
	my $sliver_credential = GeniCredential->CreateFromSigned($credstring);
	if (!defined($sliver_credential)) {
	    print STDERR
		"** Could not create new credential from $credstring\n";
	    print STDERR "*** " . $GeniCredential::CreateFromSignedError . "\n";
	    return -1;
	}
	if ($sliver_credential->Store()) {
	    print STDERR "** Could not store $sliver_credential\n";
	    return -1;
	}
	$self->Update({"credential_idx" => $sliver_credential->idx()});
    }
	
    #
    # Move this elsewhere.
    #
    if ($self->manifest_idx()) {
	my $manifest_idx = $self->manifest_idx();
	
	DBQueryWarn("update geni_manifests set ".
		    "  manifest=". DBQuoteSpecial($manifest) . ", " .
		    "  created=now() ".
		    "where idx=$manifest_idx")
	    or return -1;
    }
    else {
	# We do not care about this uuid in cooked mode.
	my $uuid = GeniUtil::NewUUID();

	my $query_result = 
	    DBQueryWarn("insert into geni_manifests set ".
			"  manifest=". DBQuoteSpecial($manifest) . ", " .
			"  idx=NULL, slice_uuid='$uuid', ".
			"  created=now()");

	return -1
	    if (!defined($query_result));

	my $manifest_idx = $query_result->insertid;
	
	$self->Update({"manifest_idx" => $manifest_idx});
    }
    return 0;
}

#
# Update the manifest.
#
sub GetManifest($$)
{
    my ($self, $user) = @_;
    my $response;

    # Always clear for caller.
    $self->{'last_rpc_error'} = 0;
    $self->{'last_rpc_output'} = undef;
    $self->{'last_rpc_value'}  = undef;

    my $slice = GeniSlice->Lookup($self->slice_idx());
    if (!defined($slice)) {
	print STDERR "*** GetManifest: No slice for $self\n";
	return -1;
    }
    my $manager_urn = $self->manager_urn();

    my $authority = GeniAuthority->CreateFromRegistry("cm", $manager_urn);
    if (!defined($authority)) {
	print STDERR "*** Could not find $manager_urn at ClearingHouse\n";
	return -1;
    }
    my $manager_version = $self->Version();
    my $manager_api     = $self->Api();

    #
    # Create a Geni user from current user doing the operation.
    #
    my $geniuser = GeniUser->CreateFromLocal($user);
    if (!defined($geniuser)) {
	print STDERR "*** Could not create a geni user from $user\n";
	return -1;
    }
    my $usercontext = Genixmlrpc->UserContext($geniuser);
    if (!defined($usercontext)) {
	print STDERR "*** Could not create user context from $geniuser\n";
	return -1;
    }

    #
    # Do it. 
    #
    my $method_name = "Resolve";
    my $method_args = {};
    my @method_args = ($method_args);

    if ($manager_api eq "AM") {
	#
	# Generate a slice credential for the user. 
	#
	my $slice_credential =
	    GeniCredential->CreateSigned($slice,
					 $geniuser,
					 $GeniCredential::LOCALSA_FLAG);
	if (!defined($slice_credential)) {
	    print STDERR
		"*** Could not create a slice credential for ".
		"$slice/$geniuser!\n";
	    return -1;
	}
	$method_name = "ListResources";
	@method_args = ([$slice_credential->asString()],
			{"geni_slice_urn" => $slice->urn()});
    }
    else {
	#
	# Load sliver credential.
	#
	if (!$self->credential_idx()) {
	    print STDERR "*** No credential defined for $self.\n";
	    return -1;
	}
	my $sliver_credential =
	    GeniCredential->Lookup($self->credential_idx());
	if (!defined($sliver_credential)) {
	    print STDERR "*** Could not get sliver credential for $self.\n";
	    return -1;
	}
	$method_args->{'credentials'} = [$sliver_credential->asString()];
	$method_args->{'urn'}         = $sliver_credential->target_urn();
    }
    $response =
	Genixmlrpc::CallMethod($authority->url(), $usercontext,
			       $method_name, @method_args);
    if (!defined($response)) {
	$self->{'last_rpc_error'} = GENIRESPONSE_RPCERROR();
	print STDERR
	    "*** Internal error getting manifest for $self\n";
	return -1;
    }
    $self->{'last_rpc_error'}  = $response->code();
    $self->{'last_rpc_output'} = $response->output();
    $self->{'last_rpc_value'}  = $response->value();
    if ($response->code() != GENIRESPONSE_SUCCESS) {
	print STDERR "Could not get manifest for $self. Error: ";
	print STDERR $response->output() . "\n";
	return -1;
    }
    my $manifest = ($manager_api eq "AM" ? $response->value() :
		    $response->value()->{'manifest'});
    
    #
    # Okay, so that worked. Store the new manifest.
    #
    # Move this elsewhere.
    #
    if ($self->manifest_idx()) {
	my $manifest_idx = $self->manifest_idx();
	
	DBQueryWarn("update geni_manifests set ".
		    "  manifest=". DBQuoteSpecial($manifest) . ", " .
		    "  created=now() ".
		    "where idx=$manifest_idx")
	    or return -1;
    }
    else {
	# We do not care about this uuid in cooked mode.
	my $uuid = GeniUtil::NewUUID();

	my $query_result =
	    DBQueryWarn("insert into geni_manifests set ".
			"  manifest=". DBQuoteSpecial($manifest) . ", " .
			"  idx=NULL, slice_uuid='$uuid', ".
			"  created=now()");

	return -1
	    if (!defined($query_result));

	my $manifest_idx = $query_result->insertid;
	
	$self->Update({"manifest_idx" => $manifest_idx});
    }
    return 0;
}

#
# Release outstanding ticket.
#
sub ReleaseTicket($$)
{
    my ($self, $user) = @_;
    my $response;

    return 0
	if (!$self->newticket_idx());

    # Always clear for caller.
    $self->{'last_rpc_error'} = 0;
    $self->{'last_rpc_output'} = undef;
    $self->{'last_rpc_value'}  = undef;

    my $slice = GeniSlice->Lookup($self->slice_idx());
    if (!defined($slice)) {
	print STDERR "*** ClearResources: No slice for $self\n";
	return -1;
    }
    my $manager_urn = $self->manager_urn();

    #
    # Load the SA cert to act as caller context.
    #
    my $certificate = GeniCertificate->LoadFromFile($SACERT);
    if (!defined($certificate)) {
	print STDERR "*** Could not load certificate from $SACERT\n";
	return -1;
    }
    my $context = Genixmlrpc->Context($certificate);
    if (!defined($context)) {
	print STDERR "*** Could not create context to talk to clearinghouse\n";
	return -1;
    }
    #
    # Set the default RPC context. 
    #
    Genixmlrpc->SetContext($context);

    my $authority = GeniAuthority->CreateFromRegistry("cm", $manager_urn);
    if (!defined($authority)) {
	print STDERR "*** Could not find $manager_urn at ClearingHouse\n";
	return -1;
    }
    my $manager_version = $self->Version();
    my $manager_api     = $self->Api();

    #
    # Create a Geni user from current user doing the operation.
    #
    my $geniuser = GeniUser->CreateFromLocal($user);
    if (!defined($geniuser)) {
	print STDERR "*** Could not create a geni user from $user\n";
	return -1;
    }
    my $usercontext = Genixmlrpc->UserContext($geniuser);
    if (!defined($usercontext)) {
	print STDERR "*** Could not create user context from $geniuser\n";
	return -1;
    }

    #
    # Generate a slice credential for the user. 
    #
    my $slice_credential =
	GeniCredential->CreateSigned($slice,
				     $geniuser,
				     $GeniCredential::LOCALSA_FLAG);
    if (!defined($slice_credential)) {
	print STDERR
	    "*** Could not create a slice credential for ".
	    "$slice/$geniuser!\n";
	return -1;
    }

    #
    # Load sliver credential if we have it.
    #
    my $sliver_credential;
    if ($self->credential_idx()) {
	$sliver_credential = GeniCredential->Lookup($self->credential_idx());
	if (!defined($sliver_credential)) {
	    print STDERR "*** Could not get sliver credential for $self.\n";
	    return -1;
	}
    }
    my $newticket;
    if ($self->newticket_idx()) {
	$newticket = GeniTicket->Lookup($self->newticket_idx());
	if (!defined($newticket)) {
	    print STDERR "*** Could not get new ticket for $self.\n";
	    return -1;
	}
    }

    if (defined($newticket)) {
	my $method_name = "ReleaseTicket";
	my $method_args = { "ticket" => $newticket->asString() };

	if ($manager_version == 1.0) {
	    $method_args->{'credential'} = $slice_credential->asString();
	}
	elsif ($manager_version == 2.0) {
	    $method_args->{'credentials'} = [$slice_credential->asString()];
	    $method_args->{'slice_urn'}   = $slice->urn();
	}
	else {
	    print STDERR
		"GeniResource::Clear Unknown version at $authority\n";
	    return -1;
	}
	print STDERR "Deleting $newticket on $authority\n";
	$response =
	    Genixmlrpc::CallMethod($authority->url(), $usercontext,
				   $method_name, $method_args);
	if (!defined($response)) {
	    $self->{'last_rpc_error'} = GENIRESPONSE_RPCERROR();
	    print STDERR "*** Internal error releasing ticket for $self\n";
	    return -1;
	}
	$self->{'last_rpc_error'} = $response->code();
	$self->{'last_rpc_output'} = $response->output();
	$self->{'last_rpc_value'}  = $response->value();
	if ($response->code() != GENIRESPONSE_SUCCESS &&
	    $response->code() != GENIRESPONSE_BADARGS &&
	    $response->code() != GENIRESPONSE_SEARCHFAILED) {
	    print STDERR "Could not release ticket for $self. Error: ";
	    print STDERR $response->output() . "\n";
	    return -1;
	}
	$newticket->Delete(TICKET_DELETED);
	$self->Update({"newticket_idx" => 0});
    }
    return 0;
}
#
# Clear all resources. 
#
sub Clear($$)
{
    my ($self, $user) = @_;
    my $response;

    # Always clear for caller.
    $self->{'last_rpc_error'} = 0;
    $self->{'last_rpc_output'} = undef;
    $self->{'last_rpc_value'}  = undef;

    my $slice = GeniSlice->Lookup($self->slice_idx());
    if (!defined($slice)) {
	print STDERR "*** ClearResources: No slice for $self\n";
	return -1;
    }
    my $manager_urn = $self->manager_urn();

    #
    # Load the SA cert to act as caller context.
    #
    my $certificate = GeniCertificate->LoadFromFile($SACERT);
    if (!defined($certificate)) {
	print STDERR "*** Could not load certificate from $SACERT\n";
	return -1;
    }
    my $context = Genixmlrpc->Context($certificate);
    if (!defined($context)) {
	print STDERR "*** Could not create context to talk to clearinghouse\n";
	return -1;
    }
    #
    # Set the default RPC context. 
    #
    Genixmlrpc->SetContext($context);

    my $authority = GeniAuthority->CreateFromRegistry("cm", $manager_urn);
    if (!defined($authority)) {
	print STDERR "*** Could not find $manager_urn at ClearingHouse\n";
	return -1;
    }
    my $manager_version = $self->Version();
    my $manager_api     = $self->Api();

    #
    # Create a Geni user from current user doing the operation.
    #
    my $geniuser = GeniUser->CreateFromLocal($user);
    if (!defined($geniuser)) {
	print STDERR "*** Could not create a geni user from $user\n";
	return -1;
    }
    my $usercontext = Genixmlrpc->UserContext($geniuser);
    if (!defined($usercontext)) {
	print STDERR "*** Could not create user context from $geniuser\n";
	return -1;
    }

    #
    # Generate a slice credential for the user. 
    #
    my $slice_credential =
	GeniCredential->CreateSigned($slice,
				     $geniuser,
				     $GeniCredential::LOCALSA_FLAG);
    if (!defined($slice_credential)) {
	print STDERR
	    "*** Could not create a slice credential for ".
	    "$slice/$geniuser!\n";
	return -1;
    }

    #
    # Load sliver credential if we have it.
    #
    my $sliver_credential;
    if ($self->credential_idx()) {
	$sliver_credential = GeniCredential->Lookup($self->credential_idx());
	if (!defined($sliver_credential)) {
	    print STDERR "*** Could not get sliver credential for $self.\n";
	    return -1;
	}
    }
    my $newticket;
    if ($self->newticket_idx()) {
	$newticket = GeniTicket->Lookup($self->newticket_idx());
	if (!defined($newticket)) {
	    print STDERR "*** Could not get new ticket for $self.\n";
	    return -1;
	}
    }
    my $oldticket;
    if ($self->ticket_idx()) {
	$oldticket = GeniTicket->Lookup($self->ticket_idx());
	if (!defined($oldticket)) {
	    print STDERR "*** Could not get old ticket for $self.\n";
	    return -1;
	}
    }

    if (defined($newticket)) {
	my $method_name = "ReleaseTicket";
	my $method_args = { "ticket" => $newticket->asString() };

	if ($manager_version == 1.0) {
	    $method_args->{'credential'} = $slice_credential->asString();
	}
	elsif ($manager_version == 2.0) {
	    $method_args->{'credentials'} = [$slice_credential->asString()];
	    $method_args->{'slice_urn'}   = $slice->urn();
	}
	else {
	    print STDERR
		"GeniResource::Clear Unknown version at $authority\n";
	    return -1;
	}
	print STDERR "Deleting $newticket on $authority\n";
	$response =
	    Genixmlrpc::CallMethod($authority->url(), $usercontext,
				   $method_name, $method_args);
	if (!defined($response)) {
	    $self->{'last_rpc_error'} = GENIRESPONSE_RPCERROR();
	    print STDERR "*** Internal error releasing ticket for $self\n";
	    return -1;
	}
	$self->{'last_rpc_error'} = $response->code();
	$self->{'last_rpc_output'} = $response->output();
	$self->{'last_rpc_value'}  = $response->value();
	if ($response->code() != GENIRESPONSE_SUCCESS &&
	    $response->code() != GENIRESPONSE_BADARGS &&
	    $response->code() != GENIRESPONSE_SEARCHFAILED) {
	    print STDERR "Could not release ticket for $self. Error: ";
	    print STDERR $response->output() . "\n";
	    return -1;
	}
	$newticket->Delete(TICKET_DELETED);
	$self->Update({"newticket_idx" => 0});
    }
    if (defined($oldticket)) {
	$oldticket->Delete(TICKET_DELETED);
	$self->Update({"ticket_idx" => 0});
    }

    my $method_name = "DeleteSlice";
    my $method_args = {};
    my @method_args = ($method_args);

    if ($manager_api eq "AM") {
	$method_name = "DeleteSliver";
	@method_args = ($slice->urn(), [$slice_credential->asString()]);
    }
    elsif ($manager_version == 1.0) {
	$method_args->{'credential'} = $slice_credential->asString();
    }
    elsif ($manager_version == 2.0) {
	$method_args->{'credentials'} = [$slice_credential->asString()];
	$method_args->{'slice_urn'}   = $slice->urn();
    }
    else {
	print STDERR "GeniResource::Clear Unknown version at $authority\n";
	return -1;
    }
    print STDERR "Deleting sliver on $authority\n";
    $response =
	Genixmlrpc::CallMethod($authority->url(), $usercontext,
			       $method_name, @method_args);
    if (!defined($response)) {
	$self->{'last_rpc_error'} = GENIRESPONSE_RPCERROR();
	print STDERR "*** Internal error deleting sliver for $self\n";
	return -1;
    }
    $self->{'last_rpc_error'} = $response->code();
    $self->{'last_rpc_output'} = $response->output();
    $self->{'last_rpc_value'}  = $response->value();
    if ($response->code() != GENIRESPONSE_SUCCESS &&
	$response->code() != GENIRESPONSE_SEARCHFAILED) {
	print STDERR "Could not delete sliver for $self. Error: ";
	print STDERR $response->output() . "\n";
	return -1;
    }
    #
    # Delete this now; no point in waiting for the CM to tell us.
    #
    # Needs to move elsewhere I think.
    #
    my $clientsliver =
	GeniSlice::ClientSliver->LookupByAuthority($slice,
						      $manager_urn);
    $clientsliver->Delete()
	if (defined($clientsliver));
    
    if (defined($sliver_credential)) {
	$sliver_credential->Delete();
	$self->Update({"credential_idx" => 0});
    }
    if (defined($self->rspec_idx())) {
	my $rspec_idx = $self->rspec_idx();
	DBQueryWarn("delete from geni_rspecs where idx='$rspec_idx'") 
	    && $self->Update({"rspec_idx" => 0});
    }

    #
    # Move this elsewhere.
    #
    if ($self->manifest_idx()) {
	my $manifest_idx = $self->manifest_idx();

	DBQueryWarn("delete from geni_manifests ".
		    "where idx=$manifest_idx");
	
	$self->Update({"manifest_idx" => 0});
    }
    return 0;
}

#
# Purge all resources. 
#
sub Purge($$)
{
    my ($self, $user) = @_;
    my $response;

    # Always clear for caller.
    $self->{'last_rpc_error'} = 0;
    $self->{'last_rpc_output'} = undef;
    $self->{'last_rpc_value'}  = undef;

    my $slice = GeniSlice->Lookup($self->slice_idx());
    if (!defined($slice)) {
	print STDERR "*** ClearResources: No slice for $self\n";
	return -1;
    }
    my $manager_urn = $self->manager_urn();
    my $authority = GeniAuthority->CreateFromRegistry("cm", $manager_urn);
    if (!defined($authority)) {
	print STDERR "*** Could not find $manager_urn at ClearingHouse\n";
	return -1;
    }
    my $manager_version = $self->Version();
    my $manager_api     = $self->Api();

    #
    # Create a Geni user from current user doing the operation.
    #
    my $geniuser = GeniUser->CreateFromLocal($user);
    if (!defined($geniuser)) {
	print STDERR "*** Could not create a geni user from $user\n";
	return -1;
    }
    my $usercontext = Genixmlrpc->UserContext($geniuser);
    if (!defined($usercontext)) {
	print STDERR "*** Could not create user context from $geniuser\n";
	return -1;
    }

    #
    # Generate a slice credential for the user. 
    #
    my $slice_credential =
	GeniCredential->CreateSigned($slice,
				     $geniuser,
				     $GeniCredential::LOCALSA_FLAG);
    if (!defined($slice_credential)) {
	print STDERR
	    "*** Could not create a slice credential for $slice/$geniuser!\n";
	return -1;
    }

    if ($self->credential_idx()) {
	my $sliver_credential =
	    GeniCredential->Lookup($self->credential_idx());
	if (defined($sliver_credential)) {
	    $sliver_credential->Delete();	
	    $self->Update({"credential_idx" => 0});
	}
    }
    if ($self->newticket_idx()) {
	my $newticket = GeniTicket->Lookup($self->newticket_idx());
	if (defined($newticket)) {
	    $newticket->Delete(TICKET_DELETED);
	    $self->Update({"newticket_idx" => 0});
	}
    }
    if ($self->ticket_idx()) {
	my $ticket = GeniTicket->Lookup($self->ticket_idx());
	if (defined($ticket)) {
	    $ticket->Delete(TICKET_DELETED);
	    $self->Update({"ticket_idx" => 0});
	}
    }
    #
    # Move this elsewhere.
    #
    if ($self->manifest_idx()) {
	my $manifest_idx = $self->manifest_idx();

	DBQueryWarn("delete from geni_manifests ".
		    "where idx=$manifest_idx");
	
	$self->Update({"manifest_idx" => 0});
    }
    my $method_name = "DeleteSlice";
    my $method_args = {};
    my @method_args = ($method_args);

    if ($manager_api eq "AM") {
	$method_name = "DeleteSliver";
	@method_args = ($slice->urn(), [$slice_credential->asString()]);
    }
    elsif ($manager_version == 1.0) {
	$method_args->{'credential'} = $slice_credential->asString();
    }
    elsif ($manager_version == 2.0) {
	$method_args->{'credentials'} = [$slice_credential->asString()];
	$method_args->{'slice_urn'}   = $slice->urn();
    }
    else {
	print STDERR
	    "GeniResource::Purge Unknown version at $authority\n";
	return -1;
    }
    $response =
	Genixmlrpc::CallMethod($authority->url(), $usercontext,
			       $method_name, @method_args);
    if (!defined($response)) {
	$self->{'last_rpc_error'} = GENIRESPONSE_RPCERROR();
	print STDERR "*** Internal error deleting sliver for $self\n";
	return -1;
    }
    $self->{'last_rpc_error'} = $response->code();
    $self->{'last_rpc_output'} = $response->output();
    $self->{'last_rpc_value'}  = $response->value();
    if ($response->code() != GENIRESPONSE_SUCCESS &&
	$response->code() != GENIRESPONSE_SEARCHFAILED) {
	print STDERR "Could not delete sliver for $self. Error: ";
	print STDERR $response->output() . "\n";
	return -1;
    }
    if (defined($self->rspec_idx())) {
	my $rspec_idx = $self->rspec_idx();
	DBQueryWarn("delete from geni_rspecs where idx='$rspec_idx'") 
	    && $self->Update({"rspec_idx" => 0});
    }
    #
    # Delete this now; no point in waiting for the CM to tell us.
    #
    # Needs to move elsewhere I think.
    #
    my $clientsliver =
	GeniSlice::ClientSliver->LookupByAuthority($slice,
						      $manager_urn);
    $clientsliver->Delete()
	if (defined($clientsliver));
    return 0;
}

#
# Start/Stop/Restart a sliver.
#
sub SliverAction($$$@)
{
    my ($self, $action, $user, @urns) = @_;
    my $response;

    # Always clear for caller.
    $self->{'last_rpc_error'} = 0;
    $self->{'last_rpc_output'} = undef;
    $self->{'last_rpc_value'}  = undef;

    #
    # Load sliver credential if we have it.
    #
    my $sliver_credential;
    if ($self->credential_idx()) {
	$sliver_credential = GeniCredential->Lookup($self->credential_idx());
	if (!defined($sliver_credential)) {
	    print STDERR "*** Could not get sliver credential for $self.\n";
	    return -1;
	}
    }
    else {
	print STDERR "*** No sliver credential for $self.\n";
	return -1;
    }

    my $slice = GeniSlice->Lookup($self->slice_idx());
    if (!defined($slice)) {
	print STDERR "*** AddResources: No slice for $self\n";
	return -1;
    }
    my $manager_urn = $self->manager_urn();
    my $authority = GeniAuthority->CreateFromRegistry("cm", $manager_urn);
    if (!defined($authority)) {
	print STDERR "*** Could not find $manager_urn at ClearingHouse\n";
	return -1;
    }
    my $manager_version = $self->Version();
    my $manager_api     = $self->Api();

    #
    # Not supported by the AM interface.
    #
    if ($manager_api eq "AM") {
	print STDERR
	    "GeniResource::${action}Sliver Not supported on AM $authority\n";
	return -1;
    }

    #
    # Create a Geni user from current user doing the operation.
    #
    my $geniuser = GeniUser->CreateFromLocal($user);
    if (!defined($geniuser)) {
	print STDERR "*** Could not create a geni user from $user\n";
	return -1;
    }
    my $usercontext = Genixmlrpc->UserContext($geniuser);
    if (!defined($usercontext)) {
	print STDERR "*** Could not create user context from $geniuser\n";
	return -1;
    }

    #
    # Generate a slice credential for the user. 
    #
    my $slice_credential =
	GeniCredential->CreateSigned($slice,
				     $geniuser,
				     $GeniCredential::LOCALSA_FLAG);
    if (!defined($slice_credential)) {
	print STDERR
	    "*** Could not create a slice credential for $slice/$geniuser!\n";
	return -1;
    }
    if (!defined($self->Manifest())) {
	print STDERR "*** Could not load manifest\n";
	return -1;
    }

    #
    # Do it. 
    #
    my $method_name = "${action}Sliver";
    my $method_args = { "manifest" => $self->{'MANIFESTSTR'} };

    if ($manager_version == 1.0) {
	$method_args->{'credential'} = $sliver_credential->asString();
    }
    elsif ($manager_version == 2.0) {
	$method_args->{'credentials'} = [$slice_credential->asString()];
	if (@urns) {
	    $method_args->{'sliver_urns'} = \@urns;
	}
	else {
	    $method_args->{'slice_urn'} = $slice->urn();
	}
    }
    else {
	print STDERR
	    "GeniResource::${action}Sliver Unknown version at $authority\n";
	return -1;
    }
    $response =
	Genixmlrpc::CallMethod($authority->url(), $usercontext,
			       $method_name, $method_args);
    if (!defined($response)) {
	$self->{'last_rpc_error'} = GENIRESPONSE_RPCERROR();
	print STDERR
	    "*** Internal error ${action}ing sliver for $self\n";
	return -1;
    }
    $self->{'last_rpc_error'} = $response->code();
    $self->{'last_rpc_output'} = $response->output();
    $self->{'last_rpc_value'}  = $response->value();
    if ($response->code() != GENIRESPONSE_SUCCESS) {
	print STDERR "Could not ${action} sliver $sliver_credential Error: ";
	print STDERR $response->output() . "\n";
	return -1;
    }
    return 0;
}
sub StartSliver($$)
{
    my ($self, $user) = @_;

    return $self->SliverAction("Start", $user);
}
sub StopSliver($$)
{
    my ($self, $user) = @_;

    return $self->SliverAction("Stop", $user);
}
sub RestartSliver($$@)
{
    my ($self, $user, @urns) = @_;

    return $self->SliverAction("Restart", $user, @urns);
}

#
# Call the sliver status function, returning an array.
#
sub SliverStatus($$$)
{
    my ($self, $user, $pref) = @_;
    my ($response);

    # Always clear for caller.
    $self->{'last_rpc_error'} = 0;
    $self->{'last_rpc_output'} = undef;
    $self->{'last_rpc_value'}  = undef;

    my $slice = GeniSlice->Lookup($self->slice_idx());
    if (!defined($slice)) {
	print STDERR "*** SliverStatus: No slice for $self\n";
	return -1;
    }
    my $manager_urn = $self->manager_urn();
    my $authority = GeniAuthority->CreateFromRegistry("cm", $manager_urn);
    if (!defined($authority)) {
	print STDERR "*** Could not find $manager_urn at ClearingHouse\n";
	return -1;
    }
    my $manager_version = $self->Version();
    my $manager_api     = $self->Api();

    #
    # Load sliver credential if we have it.
    #
    my $sliver_credential;
    if ($self->credential_idx()) {
	$sliver_credential = GeniCredential->Lookup($self->credential_idx());
	if (!defined($sliver_credential)) {
	    print STDERR "*** Could not get sliver credential for $self.\n";
	    return -1;
	}
    }
    elsif ($manager_api ne "AM") {
	print STDERR "*** No sliver credential for $self.\n";
	return -1;
    }

    #
    # Create a Geni user from current user doing the operation.
    #
    my $geniuser = GeniUser->CreateFromLocal($user);
    if (!defined($geniuser)) {
	print STDERR "*** Could not create a geni user from $user\n";
	return -1;
    }
    my $usercontext = Genixmlrpc->UserContext($geniuser);
    if (!defined($usercontext)) {
	print STDERR "*** Could not create user context from $geniuser\n";
	return -1;
    }

    #
    # Do it. 
    #
    my $method_name = "SliverStatus";
    my $method_args = {};
    my @method_args = ($method_args);

    if ($manager_api eq "AM") {
	#
	# Generate a slice credential for the user. 
	#
	my $slice_credential =
	    GeniCredential->CreateSigned($slice,
					 $geniuser,
					 $GeniCredential::LOCALSA_FLAG);
	if (!defined($slice_credential)) {
	    print STDERR
		"*** Could not create a slice credential for ".
		"$slice/$geniuser!\n";
	    return -1;
	}
	@method_args = ($slice->urn(), [$slice_credential->asString()]);
    }
    elsif ($manager_version == 1.0) {
	$method_args->{'credential'} = $sliver_credential->asString();
    }
    elsif ($manager_version == 2.0) {
	$method_args->{'credentials'} = [$sliver_credential->asString()];
	$method_args->{'slice_urn'}   = $slice->urn();
    }
    else {
	print STDERR
	    "GeniResource::SliverStatus Unknown version at $authority\n";
	return -1;
    }
    $response =
	Genixmlrpc::CallMethod($authority->url(), $usercontext,
			       $method_name, @method_args);
    if (!defined($response)) {
	$self->{'last_rpc_error'} = GENIRESPONSE_RPCERROR();
	print STDERR
	    "*** Internal error getting sliver status for $self\n";
	return -1;
    }
    $self->{'last_rpc_error'} = $response->code();
    $self->{'last_rpc_output'} = $response->output();
    $self->{'last_rpc_value'}  = $response->value();
    if ($response->code() != GENIRESPONSE_SUCCESS) {
	print STDERR "Could not get sliver status for $self. Error: ";
	print STDERR $response->output() . "\n";
	return -1;
    } 
    my $blob = {
	"state"   => "unknown",
    };
    if ($manager_api eq "AM") {
	my $details = {};
	
	foreach my $amg (@{ $response->value()->{'geni_resources'} }) {
	    $details->{$amg->{'geni_urn'}} = {
		"component_urn" => undef,
		"state"         => "unknown",
		"status"        => $amg->{'geni_status'},
		"error"         => $amg->{'geni_error'},
		};
	}
	$blob->{'details'} = $details;
	$blob->{'status'}  = $response->value()->{'geni_status'},
    }
    elsif ($manager_version == 1.0) {
	$blob->{'details'} = $response->value()->{'detailsNew'};
	$blob->{'status'}  = $response->value()->{'status'},
    }
    elsif ($manager_version == 2.0) {
	$blob->{'state'}   = $response->value()->{'state'};
	$blob->{'details'} = $response->value()->{'details'};
	$blob->{'status'}  = $response->value()->{'status'},
    }
    $$pref = $blob
	if (defined($pref));
    
    return 0;
}

#
# Call the Discover function, returning the advertisement (xml string).
#
sub Discover($$$)
{
    my ($self, $user, $pref) = @_;
    my $response;

    # Always clear for caller.
    $self->{'last_rpc_error'} = 0;
    $self->{'last_rpc_output'} = undef;
    $self->{'last_rpc_value'}  = undef;

    my $slice = GeniSlice->Lookup($self->slice_idx());
    if (!defined($slice)) {
	print STDERR "*** Discover: No slice for $self\n";
	return -1;
    }
    my $manager_urn     = $self->manager_urn();
    my $manager_version = $self->Version();
    my $manager_api     = $self->Api();

    my $authority = GeniAuthority->CreateFromRegistry("cm", $manager_urn);
    if (!defined($authority)) {
	print STDERR "*** Could not find $manager_urn at ClearingHouse\n";
	return -1;
    }

    #
    # Create a Geni user from current user doing the operation.
    #
    my $geniuser = GeniUser->CreateFromLocal($user);
    if (!defined($geniuser)) {
	print STDERR "*** Could not create a geni user from $user\n";
	return -1;
    }
    my $usercontext = Genixmlrpc->UserContext($geniuser);
    if (!defined($usercontext)) {
	print STDERR "*** Could not create user context from $geniuser\n";
	return -1;
    }

    #
    # Generate a slice credential for the user. 
    #
    my $slice_credential =
	GeniCredential->CreateSigned($slice,
				     $geniuser,
				     $GeniCredential::LOCALSA_FLAG);
    if (!defined($slice_credential)) {
	print STDERR
	    "*** Could not create a slice credential for $slice/$geniuser!\n";
	return -1;
    }

    #
    # Do it. 
    #
    my $method_name = "DiscoverResources";
    my $method_hash = { "available"     => "true",
			"rspec_version" => RPC::XML::string->new("0.2")};
    my @method_args = ($method_hash);

    if ($manager_api eq "AM") {
	$method_name = "ListResources";
	@method_args = ([$slice_credential->asString()],
			{'geni_available' => "true",
			 'rspec_version'  => RPC::XML::string->new("0.2")});
    }
    elsif ($manager_version == 1.0) {
	$method_hash->{'credential'} = $slice_credential->asString();
    }
    elsif ($manager_version == 2.0) {
	$method_hash->{'credentials'} = [$slice_credential->asString()];
    }
    else {
	print STDERR
	    "GeniResource::DiscoverResources Unknown version at $authority\n";
	return -1;
    }
    $response =
	Genixmlrpc::CallMethod($authority->url(), $usercontext,
			       $method_name, @method_args);
    if (!defined($response)) {
	$self->{'last_rpc_error'} = GENIRESPONSE_RPCERROR();
	print STDERR
	    "*** Internal error doing DiscoverResources for $self\n";
	return -1;
    }
    $self->{'last_rpc_error'} = $response->code();
    $self->{'last_rpc_output'} = $response->output();
    $self->{'last_rpc_value'}  = $response->value();
    if ($response->code() != GENIRESPONSE_SUCCESS) {
	print STDERR "Could not discover resources $slice_credential Error: ";
	print STDERR $response->output() . "\n";
	return -1;
    }
    $$pref = $response->value()
	if (defined($pref));
    
    return 0;
}

#
# Class method to renew resources for an experiment/slice.
#
sub RenewExperimentResources($;$)
{
    my ($experiment, $force) = @_;

    my $slice = GeniSlice->LookupByExperiment($experiment);
    if (!defined($slice)) {
	print STDERR
	    "*** RenewExperimentResources: No slice for $experiment\n";
	return -1;
    }
    return RenewSliceResources($slice, $force);
}

sub RenewSliceResources($;$)
{
    my ($slice, $force) = @_;

    $force = 0
	if (!defined($force));

    #
    # Get the resource objects.
    #
    my @resources = GeniResource->SliceResources($slice);
    return 0
	if (!@resources);

    #
    # If the expiration is more then 30 days out, do not bother.
    #
    my $when = str2time($slice->expires());
    return 0
	if (!$force && $when > time() + (3600 * 24 * 30));

    # Good default
    my $expires = time() + (3600 * 24 * 90);

    if ($slice->SetExpiration($expires)) {
	print STDERR "RenewSliceResources: ".
	    "Could not set expiration for $slice!\n";
	return -1
    }

    #
    # Cull out resources that are more then 30 days out.
    #
    if (!$force) {
	my @tmp = ();
	foreach my $resource (@resources) {
	    # Nothing to renew yet
	    next
		if ($resource->credential_idx());
	    
	    if (!defined($resource->expires())) {
		push(@tmp, $resource);
		next;
	    }
	    my $resource_expires = str2time($resource->expires());
	    push(@tmp, $resource)
		if (time() + (3600 * 24 * 30) > $resource_expires);
	}
	@resources = @tmp;
	return 0
	    if (!@resources);
    }
    return RenewResources(@resources);
}

#
# Class method to renew a set of resources.
#
sub RenewResources(@)
{
    my @resources = @_;

    #
    # Load the SA cert to act as caller context.
    #
    my $certificate = GeniCertificate->LoadFromFile($SACERT);
    if (!defined($certificate)) {
	print STDERR "*** Could not load certificate from $SACERT\n";
	return -1;
    }
    my $context = Genixmlrpc->Context($certificate);
    if (!defined($context)) {
	print STDERR "*** Could not create context to talk to clearinghouse\n";
	return -1;
    }
    
    #
    # Set the default RPC context. 
    #
    Genixmlrpc->SetContext($context);

    # Hash the slice credentials so we generate them only once.
    my %credentials;

    foreach my $resource (@resources) {
	# No sliver, skip.
	next
	    if (! $resource->credential_idx());

	# Always clear for caller.
	$resource->{'last_rpc_error'} = 0;
	$resource->{'last_rpc_output'} = undef;
	$resource->{'last_rpc_value'}  = undef;

	my $slice = GeniSlice->Lookup($resource->slice_idx());
	if (!defined($slice)) {
	    print STDERR "RenewAll: No slice for $resource\n";
	    next;
	}

	my $manager_urn = $resource->manager_urn();
	my $authority   = GeniAuthority->Lookup($manager_urn);
	if (!defined($authority)) {
	    print STDERR "RenewAll: Could not locate $manager_urn\n";
	    next;
	}
	my $manager_version = $resource->Version();
	my $manager_api     = $resource->Api();

	#
	# Generate a slice credential.
	#
	if (!exists($credentials{$slice->uuid()})) {
	    my $credential = GeniCredential->Create($slice, $certificate);
	    if (!defined($credential)) {
		print STDERR
		    "RenewAll: Could not create credential for $slice!\n";
		next;
	    }
	    if ($credential->Sign($GeniCredential::LOCALSA_FLAG) != 0) {
		print STDERR
		    "RenewAll: Could not sign credential $credential!\n";
		next;
	    }
	    $credentials{$slice->uuid()} = $credential;
	}
	my $slice_credential = $credentials{$slice->uuid()};
	
	#
	# Do it. 
	#
	print STDERR "Renewing $slice on $authority\n";
	
	my $method_name = "RenewSlice";
	my $method_args = { };

	if ($manager_version == 1.0) {
	    $method_args->{'credential'} = $slice_credential->asString();
	}
	elsif ($manager_version == 2.0) {
	    $method_args->{'credentials'} = [$slice_credential->asString()];
	    $method_args->{'slice_urn'}   = $slice->urn();
	}
	else {
	    print STDERR
		"GeniResource::RenewAll Unknown version at $authority\n";
	    return -1;
	}
	my $response =
	    Genixmlrpc::CallMethod($authority->url(), $context,
				   $method_name, $method_args);
	if (!defined($response)) {
	    $resource->{'last_rpc_error'} = GENIRESPONSE_RPCERROR();
	    print STDERR
		"RenewAll: Internal error doing renew for $resource\n";
	    next;
	}
	$resource->{'last_rpc_error'} = $response->code();
	$resource->{'last_rpc_output'} = $response->output();
	$resource->{'last_rpc_value'}  = $response->value();
	if ($response->code() != GENIRESPONSE_SUCCESS) {
	    print STDERR "RenewAll: Could not renew $slice_credential Error: ";
	    print STDERR $response->output() . "\n";
	    next;
	}
	#
	# It worked, so mark this resource as renewed. Since an individual
	# resource could fail to renew, we want to know which ones to come
	# back to later.
	#
	if ($resource->SetExpiration($slice->expires())) {
	    print STDERR "RenewAll: Could not set expiration for $resource!\n";
	    next;
	}
    }
    return 0;
}

#
# Create a local proxy node for a resource (node).
#
sub CreateProxyNode($$)
{
    my ($self, $urn) = @_;

    #
    #
    #
    return undef;
}

# _Always_ make sure that this 1 is at the end of the file...
1;

