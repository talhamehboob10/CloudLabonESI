#!/usr/bin/perl -wT
#
# Copyright (c) 2008-2020 University of Utah and the Flux Group.
# 
# {{{GENIPUBLIC-LICENSE
# 
# GENI Public License
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and/or hardware specification (the "Work") to
# deal in the Work without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Work, and to permit persons to whom the Work
# is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Work.
# 
# THE WORK IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS
# IN THE WORK.
# 
# }}}
#
package GeniCredential;

#
# Some simple credential stuff.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

use GeniDB;
use GeniCertificate;
use GeniResponse;
use GeniUtil;
use GeniXML;
use GeniHRN;
use emutil;
use English;
use XML::Simple;
use XML::LibXML;
use Data::Dumper;
use File::Temp qw(tempfile);
use Date::Parse;
use POSIX qw(strftime);
use Time::Local;
use Carp qw(cluck carp);
use overload ('""' => 'Stringify');

# Exported variables
use vars qw(@EXPORT_OK $LOCALSA_FLAG $LOCALCM_FLAG $LOCALMA_FLAG $CHECK_UUID
            $CreateFromSignedError);

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBAPPROVAL     = "@TBAPPROVALEMAIL@";
my $TBAUDIT   	   = "@TBAUDITEMAIL@";
my $BOSSNODE       = "@BOSSNODE@";
my $OURDOMAIN      = "@OURDOMAIN@";
my $SIGNCRED	   = "$TB/sbin/signgenicred";
my $VERIFYCRED	   = "$TB/sbin/verifygenicred";
my $NFREE	   = "$TB/bin/nfree";
my $OPENSSL	   = "/usr/bin/openssl";

# Signing flags
$LOCALSA_FLAG	   = 1;
$LOCALCM_FLAG	   = 2;
$LOCALMA_FLAG	   = 3;
$CHECK_UUID        = 1;  # Default to true, enabling uuid checks
@EXPORT_OK	   = qw($LOCALSA_FLAG $LOCALCM_FLAG $LOCALMA_FLAG $CHECK_UUID);

# Capability Flags.

#
# Look for a signed credential in the DB. At present, we store a credential
# by user/object (uuid/uuid), not worrying about different flavors of creds
# with different permissions. This is basically a cache on the client side of
# credentials in use so that they do not need to be regenerated.
#
sub Lookup($$;$)
{
    my ($class, $arg1, $arg2) = @_;
    my $query_result;

    if (!defined($arg2)) {
	if ($arg1 =~ /^(\d*)$/) {
	    $query_result =
		DBQueryWarn("select * from geni_credentials ".
			    "where idx='$arg1'");
	}
	else {
	    return undef;
	}
    }
    elsif (defined($arg1)) {
	my $target_uuid = (ref($arg1) ? $arg1->uuid() : $arg1);
	my $owner_uuid  = (ref($arg2) ? $arg2->uuid() : $arg2);

	return undef
	    if (! ($target_uuid =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/ &&
		   $owner_uuid  =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/));
	
	$query_result =
	    DBQueryWarn("select * from geni_credentials ".
			"where owner_uuid='$owner_uuid' and ".
			"      this_uuid='$target_uuid'");
    }
    else {
	return undef;
    }
    return undef
	if (!$query_result || !$query_result->numrows);

    my $row = $query_result->fetchrow_hashref();
    
    my $credential =
	GeniCredential->CreateFromSigned($row->{'credential_string'}, 1);

    return undef
	if (!defined($credential));

    # Mark as coming from the DB.
    $credential->{'idx'}          = $row->{'idx'};
    return $credential;
}
  
#
# Create an unsigned credential object.
#
sub Create($$$)
{
    my ($class, $target, $owner) = @_;

    return undef
	if (! (ref($target) && ref($owner)));

    #
    # Every ticket/credential its own uuid.
    #
    my $uuid = GeniUtil::NewUUID();

    my $self = {};
    $self->{'type'}          = "privilege";
    $self->{'uuid'}          = $uuid;
    $self->{'valid_until'}   = $target->expires();
    $self->{'target_uuid'}   = $target->uuid();
    $self->{'owner_uuid'}    = $owner->uuid();
    # Convenience stuff.
    $self->{'target_cert'}   = $target->GetCertificate();
    $self->{'owner_cert'}    = $owner->GetCertificate();
    $self->{'string'}        = undef;
    $self->{'capabilities'}  = undef;
    $self->{'extensions'}    = undef;
    $self->{'parent_cred'}   = undef;
    $self->{'idx'}	     = undef;	# Only set when stored to DB.
    bless($self, $class);

    return $self;
}
# accessors
sub field($$)           { return ($_[0]->{$_[1]}); }
sub idx($)		{ return field($_[0], "idx"); }
sub type($)		{ return field($_[0], "type"); }
sub uuid($)		{ return field($_[0], "uuid"); }
sub expires($)		{ return field($_[0], "valid_until"); }
sub target_uuid($)	{ return field($_[0], "target_uuid"); }
sub slice_uuid($)	{ return field($_[0], "target_uuid"); }
sub owner_uuid($)	{ return field($_[0], "owner_uuid"); }
sub asString($)		{ return field($_[0], "string"); }
sub capabilities($)	{ return field($_[0], "capabilities"); }
sub extensions($)	{ return field($_[0], "extensions"); }
sub owner_cert($)	{ return $_[0]->{"owner_cert"}; }
sub target_cert($)	{ return $_[0]->{"target_cert"}; }
sub hrn($)		{ return $_[0]->{"target_cert"}->hrn(); }
sub target_urn($)       { return $_[0]->{"target_cert"}->urn(); }
sub owner_urn($)        { return $_[0]->{"owner_cert"}->urn(); }
sub signer_certs($)     { return $_[0]->{"signer_certs"}; }
sub parent_cred($)      { return $_[0]->{"parent_cred"}; }

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    my $target_uuid = $self->target_uuid();
    my $owner_uuid  = $self->owner_uuid();

    return "[GeniCredential: $target_uuid, $owner_uuid]";
}

#
# Is expired? 
#
sub IsExpired($)
{
    my ($self) = @_;

    return 0
	if (! ref($self));

    my $expires = $self->expires();
    return 0
	if (!defined($expires));
    
    $expires = str2time($expires);

    return (time() >= $expires);
}

#
# Set the expiration time for a credential. Only changes the
# in memory copy, not the DB.
#
sub SetExpiration($$)
{
    my ($self, $expires) = @_;

    $self->{'valid_until'} =
	POSIX::strftime("20%y-%m-%dT%H:%M:%S", localtime($expires));

    return 0;
}

#
# Set the type; only useful before signing.
#
sub SetType($$)
{
    my ($self, $type) = @_;

    $self->{'type'} = $type;
    return 0;
}

#
# Compare the certs inside a credential to make sure that the
# certs for the target/owner have not changed. Say, if the user
# regens their certificate, we need to invalidate any cached
# credentials based on that cert.
#
sub SameCerts($$$)
{
    my ($self, $target, $owner) = @_;

    return -1
	if (! (ref($target) && ref($owner)));

    my $current_target_cert = $self->target_cert();
    my $current_owner_cert  = $self->owner_cert();
    my $other_target_cert   = $target->GetCertificate();
    my $other_owner_cert    = $owner->GetCertificate();

    return 0
	if (!$current_owner_cert->SameCert($other_owner_cert));
    return 0
	if (!$current_target_cert->SameCert($other_target_cert));
    
    return 1;
}

#
# Add a capability to the array.
#
sub AddCapability($$$)
{
    my ($self, $name, $delegate) = @_;

    return -1
	if (!ref($self));

    if (!defined($self->capabilities())) {
	$self->{'capabilities'} = {};
    }
    $self->{'capabilities'}->{$name} = {"can_delegate" => $delegate};
    return 0;
}

#
# Add an extension. Each extension is an xml element.
# If the element is in a different namespace it has to be specified
# during element construction.
# It also accepts key/value pairs. When key/value pair is specified
# It converts them to <key>value</key> xml element and 
# adds under extensions.
sub AddExtension
{
    my $self = shift;
    my $elem = undef;
    return -1
	      if (!ref($self));
    if (@_ == 1) {
        # it means xml element is specified.
        $elem = shift;
    }
    elsif (@_ == 2) {
        # it means key/value pair is specified.
        $elem = XML::LibXML::Element->new($_[0]);
        $elem->appendText($_[1]);
    }
    else {
        return -1;
    }
    
    my $root = $self->extensions();
    $root = XML::LibXML::Element->new("extensions")
    if (!defined($root));
    $root->appendChild($elem);
    $self->{'extensions'} = $root;
    return 0;
}

#
# Convenience function; create a signed credential for the target,
# issued to the provided user.
#
sub CreateSigned($$$;$)
{
    my ($class, $target, $owner, $signer) = @_;

    return undef
	if (! (ref($target) && ref($owner)));

    $signer = $target->GetCertificate()
	if (!defined($signer));

    my $credential = GeniCredential->Create($target, $owner);
    if (!defined($credential)) {
	print STDERR "Could not create credential for $target, $owner\n";
	return undef;
    }
    if ($credential->Sign($signer) != 0) {
	$credential->Delete();
	print STDERR "Could not sign credential for $target, $owner\n";
	return undef;
    }
    return $credential;
}

#
# Create a self signed credential.
#
sub GetSelfCredential($$)
{
    my ($class, $me) = @_;

    #
    # Oh, this is kinda bogus, but need to know who we are
    # so we can sign it properly. 
    #
    my $which  = $me->type();
    my $signer;
    if ($which eq "sa") {
	$signer = $LOCALSA_FLAG;
    }
    elsif ($which eq "cm") {
	$signer = $LOCALCM_FLAG;
    }
    elsif ($which eq "ch" || $which eq "ma") {
	$signer = $LOCALMA_FLAG;
    }
    else {
	print STDERR "Could not determine who we are\n";
	return undef;
    }
    return GeniCredential->CreateSigned($me, $me, $signer);
}

# Find an element (which must exist exactly once) within a node.
my $find = sub
{
    my( $node, $name ) = @_;

    my @cnodes = grep( $_->nodeName eq $name, $node->childNodes );

    return undef unless scalar( @cnodes ) == 1;

    return $cnodes[ 0 ];
};

#
# Create a credential object from a signed credential string.
#
# We keep the error in a global variable for the caller if wanted.
# Certainly not ideal but I do not want to complicate things by
# using eval/die to mimic try/finally. We are not thread safe and
# never will be, so lets not get crazy.
#
$CreateFromSignedError = undef;

sub CreateFromSigned($$;$)
{
    my ($class, $string, $nosig) = @_;
    my $msg = undef;

    #
    # This flag is used to avoid verifying the signature since I do not
    # really care if the component gives me a bad ticket; I am not using
    # it locally, just passing it back to the component at some point.
    #
    $nosig = 0
	if (!defined($nosig));

    if (!defined($string)) {
	$msg = "No string";
	goto bad;
    }
    
    # First verify the credential
    if (! $nosig) {
	my ($fh, $filename) = tempfile(UNLINK => 1);
	if (!defined($fh)) {
	    $msg = "Error creating temporary file";
	    goto bad;
	}
	print $fh $string;
	close($fh);
	my $output = GeniUtil::ExecQuiet("$VERIFYCRED $filename");
	if ($?) {
	    unlink($filename);
	    $msg = $output;
	    chomp($msg);
	    goto bad;
	}
	unlink($filename);
    }

    # Use XML::LibXML to convert to something we can mess with.
    my $parser = XML::LibXML->new;
    my $doc;
    eval {
	$doc = $parser->parse_string($string);
    };
    if ($@) {
	$msg = "Failed to parse credential string: $@";
	goto bad;
    }
    my $root = $doc->documentElement();
    my $credential_el = &$find( $root, "credential" );
    goto bad unless defined( $credential_el );

    # Type of the credential.
    my $type_node = &$find( $credential_el, "type" );
    goto bad
	if (!defined($type_node));
    my $credtype = $type_node->to_literal();
    goto bad
	if (!defined($credtype) || $credtype eq "");

    # Expiration
    my $expires_node = &$find( $credential_el, "expires" );
    if (!defined($expires_node)) {
	$msg = "Credential is missing expires node";
	goto bad;
    }
    my $expires = $expires_node->to_literal();
    if ($expires =~ /^(\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d)(\.\d+)?Z?$/)
    {
	$expires = $1 . 'Z';
    }

    if (! ($expires =~ /^[-\w:.\/]+/)) {
	$msg = "Invalid expires date in credential";
	goto bad;
    }
    # Convert to a localtime.
    my $when = timegm(strptime($expires));
    if (!defined($when)) {
	$msg = "Could not parse expires: '$expires'";
	goto bad;
    }
    $expires = POSIX::strftime("20%y-%m-%dT%H:%M:%S", localtime($when));

    # Dig out the signatures.
    my ($signatures) = $doc->getElementsByTagName("signatures");
    my @signatures   = $signatures->getElementsByTagName("Signature");
    
    # We deal with ABAC on a totally separate path. Results in a bit
    # of code duplication, but so be it.
    if ($credtype eq "abac") {
	my $ref = {
	    'type'        => $credtype,
	    'string'      => $string,
	    'valid_until' => $expires,
	    'signatures'  => \@signatures,
	};
	return GeniCredential::ABAC->CreateFromSigned($ref, $root);
    }

    # Dig out the entire credential structure to save it.
    my ($credential) = $doc->getElementsByTagName("credential");

    # Dig out the extensions
    # now extensions is an xml element.
    my ($extensions) = GeniXML::FindNodes('//n:extensions', 
                        $root)->get_nodelist;
    
    # UUID of the credential.
    my $uuid_node = &$find( $credential_el, "uuid" );
    goto bad
	if (!defined($uuid_node));
    my $this_uuid = $uuid_node->to_literal();
    $this_uuid = undef
	if (defined($this_uuid) && $this_uuid eq "");

    #
    # No longer require this uuid; only PG credentials have it.
    # If we try to store it, throw an error. See below.
    #
    if (defined($this_uuid) &&
	! ($this_uuid =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/)) {
	$msg = "Invalid this_uuid in credential";
        goto bad;
    }

    # Dig out the target certificate.
    my $cert_node = &$find( $credential_el, "target_gid" );
    goto bad
	if (!defined($cert_node));
    my $target_certificate =
	GeniCertificate->LoadFromString($cert_node->to_literal());
    goto bad
	if (!defined($target_certificate));

    if (!($target_certificate->uuid() =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/)
        && $CHECK_UUID) {
        $msg = "Invalid target_uuid in credential";
        goto bad;
    }
    if (!($target_certificate->hrn() =~ /^[-\w\.]+$/)) {
	my $hrn = $target_certificate->hrn();
	$msg = "Invalid hrn $hrn in target of credential";
	goto bad;
    }
    if (!GeniHRN::IsValid($target_certificate->urn())) {
	$msg = "Invalid urn in target certificate of credential";
	goto bad;
    }

    # Dig out the owner certificate.
    $cert_node = &$find( $credential_el, "owner_gid" );
    goto bad
	if (!defined($cert_node));

    my $owner_certificate =
	GeniCertificate->LoadFromString($cert_node->to_literal());
    goto bad
	if (!defined($owner_certificate));

    if (!($owner_certificate->uuid() =~ /^\w+\-\w+\-\w+\-\w+\-\w+$/)
        && $CHECK_UUID) {
        $msg = "Invalid owner_uuid in credential";
        goto bad;
    }
    if (!($owner_certificate->hrn() =~ /^[-\w\.]+$/)) {
	my $hrn = $owner_certificate->hrn();
	$msg = "Invalid hrn $hrn in owner of credential";
	goto bad;
    }
    if (!GeniHRN::IsValid($owner_certificate->urn())) {
	$msg = "Invalid urn in owner certificate of credential";
	goto bad;
    }

    #
    # Break apart the delegation chain, we want to find the root
    # credential.
    #
    my $leaf_cred  = $credential;
    my $root_cred  = $leaf_cred;
    my $root_xmlid;
    
    # This is how we know which signature signs the root.
    my ($xmlid_attribute) = $root_cred->attributes();
    if (! ($xmlid_attribute &&
	   ($root_xmlid = $xmlid_attribute->getValue()))) {
	$msg = "No XML id in credential";
	goto bad;
    }

    #
    # The last child of the credentials node will be a parent credential,
    # if there is a parent. 
    #
    my $temp = $credential;
    
    while (defined($temp)) {
	my @childnodes  = $temp->childNodes();
	undef($temp);

	foreach my $child (@childnodes) {
	    if (defined($child->localname) && $child->localname eq "parent") {
		my ($parent_cred) = $child->getElementsByTagName("credential");

		$root_cred = $temp = $parent_cred;

		# This is how we know which signature signs the root.
		($xmlid_attribute) = $root_cred->attributes();
		if (! ($xmlid_attribute &&
		       ($root_xmlid = $xmlid_attribute->getValue()))) {
		    $msg = "No XML id in credential";
		    goto bad;
		}
		last;
	    }
	}
    }

    #
    # Now search the signatures list for the one that has the same
    # ref id as the root_xmlid above. 
    #
    my $signer_certs = [];
    
    foreach my $signode (@signatures) {
	my @attributes = $signode->attributes();
	foreach my $attr (@attributes) {
	    if ($attr->getValue() eq "Sig_${root_xmlid}") {
		# extract the signer certs from enclosed certs
		my $cert_nodes =
		    $signode->getElementsByTagName("X509Certificate");
		foreach my $node (@$cert_nodes) {
		    my $signer_cert = $node->to_literal();
		    push(@$signer_certs, $signer_cert);
		}
		last;
	    }
	}
    }
    if (! @{ $signer_certs }) {
	$msg = "Cannot find signer certs in credential";
	goto bad;
    }
    
    my $self = {};
    $self->{'capabilities'}  = undef;
    $self->{'extensions'}    = $extensions;
    $self->{'type'}          = $credtype;
    $self->{'uuid'}          = $this_uuid;
    $self->{'valid_until'}   = $expires;
    $self->{'target_uuid'}   = $target_certificate->uuid();
    $self->{'target_cert'}   = $target_certificate;
    $self->{'owner_uuid'}    = $owner_certificate->uuid();
    $self->{'owner_cert'}    = $owner_certificate;
    $self->{'string'}        = $string;
    $self->{'parent_cred'}   = undef;
    $self->{'credentialdoc'} = $credential;
    $self->{'signatures'}    = \@signatures;
    $self->{'signer_certs'}  = $signer_certs;
    $self->{'root_cred'}     = $root_cred;
    $self->{'idx'}	     = undef;	# Only set when stored to DB.
    bless($self, $class);

    # Dig out the capabilities
    foreach my $cap (GeniXML::FindNodes('n:credential/' .
					'n:privileges/n:privilege',
					$root)->get_nodelist()) {
	my $name = GeniXML::FindElement('n:name', $cap);
	my $delegate = GeniXML::FindElement('n:can_delegate', $cap);
	if (defined($name) && defined($delegate)) {
	    $self->AddCapability($name->textContent(),
				 $delegate->textContent());
	}
    }
    return $self;

  bad:
    if (!defined($msg)) {
	$msg = "Internal error creating credential object";
    }
    print STDERR "$msg\n";
    cluck("$msg");
    $CreateFromSignedError = $msg;
    return undef;
}

# Returns a NodeList for a given XPath using a given node as
# context. 'n' is defined to be the prefix for the namespace of the
# node.
#sub findnodes_n($$)
#{
#    my ($path, $node) = @_;
#    my $xc = XML::LibXML::XPathContext->new();
#    my $ns = $node->namespaceURI();
#    if (defined($ns)) {
#	$xc->registerNs('ns', $node->namespaceURI());
#    } else {
#	$path =~ s/\bn://g;
#    }
#    return $xc->findnodes($path, $node);
#}

# Returns the first Node which matches a given XPath against a given
# node. Works like findnodes_n.
#sub findfirst_n($$)
#{
#    my ($path, $node) = @_;
#    return findnodes_n($path, $node)->pop();
#}

#
# Might have to delete this from the DB.
#
sub Delete($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    if (defined($self->idx())) {
	my $idx  = $self->idx();
	my $uuid = $self->uuid();
	
	DBQueryWarn("delete from geni_certificates where uuid='$uuid'")
	    or return -1;
	DBQueryWarn("delete from geni_credentials where idx='$idx'")
	    or return -1;
    }
    return 0;
}

#
# Delete stored credentials for a particular target.
#
sub DeleteForTarget($$)
{
    my ($class, $target) = @_;
    my $target_uuid = $target->uuid();

    DBQueryWarn("delete from geni_credentials where this_uuid='$target_uuid'")
	or return -1;

    return 0;
}

#
# Sign the credential.
#
sub Sign($$)
{
    my ($self, $how) = @_;

    return -1
	if (!ref($self));

    # If no capabilities, then allow all rights, with delegation.
    if (!defined($self->capabilities())) {
	$self->AddCapability("*", 1);
    }
    # This little wrapup is for xmlout.
    my $cap_xml = "<privileges>\n";
    foreach my $cap (keys(%{ $self->capabilities() })) {
	my $can_delegate = $self->capabilities()->{$cap}->{'can_delegate'};
	$cap_xml .= "<privilege>";
	$cap_xml .= "<name>$cap</name>";
	$cap_xml .= "<can_delegate>$can_delegate</can_delegate>";
	$cap_xml .= "</privilege>\n";
    }
    $cap_xml .= "</privileges>";

    my $extensions = $self->extensions();
    $cap_xml .= GeniXML::Serialize($extensions)
        if (defined($extensions) && $extensions->hasChildNodes());
    # Every one gets a new unique index, which is used in the xml:id below.
    my $idx = TBGetUniqueIndex('next_ticket', 1);

    #
    # Need the certificates for target and owner of the credential.
    #
    if (!defined($self->target_cert())) {
	print STDERR "No target certificate attached to $self\n";
	return -1;
    }
    my $target_cert = $self->target_cert()->cert();
    my $target_urn = $self->target_urn();
    if (! defined($target_urn)) {
	$target_urn = $self->target_uuid();
    }

    if (!defined($self->owner_cert())) {
	print STDERR "No owner certificate attached to $self\n";
	return -1;
    }
    my $owner_cert = $self->owner_cert()->cert();
    my $owner_urn = $self->owner_urn();
    if (! defined($owner_urn)) {
	$owner_urn = $self->owner_uuid();
    }
    my $cred_uuid = $self->uuid();

    # Credential expiration: hard-code to 24 hours, if the underlying
    # object does not define an expiration.
    if (!defined($self->expires())) {
	$self->SetExpiration(time() + 24 * 60 * 60);
    }
    my $expires = POSIX::strftime("20%y-%m-%dT%H:%M:%SZ",
				  gmtime(str2time($self->expires())));

    #
    # Create a template xml file to sign.
    #
    my $id = sprintf( "%04X%04X%04X%04X", int( rand( 0x10000 ) ), 
		      int( rand( 0x10000 ) ), int( rand( 0x10000 ) ),
		      int( rand( 0x10000 ) ) );

    # If this is a delegation, need to construct a different XML file.
    my $parent_xml = "";
    if (defined($self->{'parent_cred'})) {
	$parent_xml = "<parent>" . 
	    $self->{'parent_cred'}->{'credentialdoc'}->toString() . 
	    "</parent>";
    }
    my $type = $self->type();
    
    my $template =
	"<credential xml:id=\"ref$id\">\n".
	" <type>$type</type>\n".
	" <serial>$idx</serial>\n".
	" <owner_gid>$owner_cert</owner_gid>\n".
	" <owner_urn>$owner_urn</owner_urn>\n".
	" <target_gid>$target_cert</target_gid>\n".
	" <target_urn>$target_urn</target_urn>\n".
	" <uuid>$cred_uuid</uuid>\n".
	" <expires>$expires</expires>\n".
	"  $cap_xml". $parent_xml .
        "</credential>\n";
    if (defined($self->{'parent_cred'})) {
	$template = "<signed-credential>\n$template\n<signatures>";
	foreach my $sig (@{ $self->{'parent_cred'}->{'signatures'}}) {
	    $template .= $sig->toString();
	}
	$template .= "</signatures></signed-credential>\n";
    }
    my ($fh, $filename) = tempfile(UNLINK => 1);
    return -1
	if (!defined($fh));

    print $fh "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n";
    print $fh $template;
    close($fh);

    #
    # Who signs the credential? $how is either a flag (CM or SA) or its
    # a certificate object in the DB. 
    #
    my $certificate;
    my $certfile;
    
    if (ref($how)) {
	if ($how->certfile()) {
	    $certificate = "-c " . $how->certfile();
	}
	else {
	    # We have to delete this before we return.
	    $certfile = $how->WriteToFile(1);
	    if (!defined($certfile)) {
		print STDERR "Could not write $how to temp file\n";
		goto bad;
	    }
	    $certificate = "-c $certfile";
	}
    }
    elsif (-e "$how") {
	$certificate = "-c $how";
    }
    elsif ($how == $LOCALSA_FLAG) {
	$certificate = "-c $TB/etc/genisa.pem";
    }
    elsif ($how == $LOCALCM_FLAG) {
	$certificate = "-c $TB/etc/genicm.pem";
    }
    elsif ($how == $LOCALMA_FLAG) {
	if (defined($main::GENI_CHPEMFILE)) {
	    # See xmlrpc/protogeni-ch.pl.in
	    $certificate = "-c $main::GENI_CHPEMFILE";
	}
	else {
	    $certificate = "-c $TB/etc/genich.pem";
	}
    }
    else {
	print STDERR "Invalid 'how' argument to Sign()\n";
	goto bad;
    }

    #
    # Fire up the signer and capture the output. This is the signed credential
    # that is returned. 
    #
    if (! open(SIGNER, "$SIGNCRED $certificate $filename |")) {
	print STDERR "Could not start $SIGNCRED on $filename\n";
	goto bad;
    }
    my $credential = "";
    while (<SIGNER>) {
	$credential .= $_;
    }
    if (!close(SIGNER)) {
	print STDERR "Could not sign $filename\n";
	goto bad;
    }
    $self->{'string'} = $credential;
    unlink($filename);
    unlink($certfile)
	if (defined($certfile));
    return 0;
  bad:
    unlink($filename)
	if (defined($filename));
    unlink($certfile)
	if (defined($certfile));
    return -1;
}

#
# Delegate to another owner. This creates a new credential.
#
sub Delegate($$)
{
    my ($self, $owner) = @_;

    my $credential = GeniCredential->Create($self->target_cert(), $owner);
    if (!defined($credential)) {
	print STDERR "Could not delegate $self to $owner\n";
	return undef;
    }
    #
    # The new credential has no privs; the caller has to fill
    # them for this credential to be useful.
    #
    $credential->{'parent_cred'} = $self;
    $credential->{'valid_until'} = $self->{'valid_until'};
    return $credential;
}

#
# Store the given signed credential in the DB. 
#
sub Store($)
{
    my ($self) = @_;
    my @insert_data  = ();

    # Do not store again.
    return 0
	if (defined($self->idx()));

    if (defined($self->{'parent_cred'})) {
	print STDERR "Not allowed to store delegated credential: $self\n";
	return -1;
    }
    # Foreign credentials will not have this, and we should never
    # store them, so throw an error.
    if (!defined($self->uuid())) {
	print STDERR "Not allowed to store foreign credential: $self\n";
	return -1;
    }

    # Every credential store gets a new unique index.
    my $idx = TBGetUniqueIndex('next_ticket', 1);
    
    my $this_uuid  = $self->target_uuid();
    my $owner_uuid = $self->owner_uuid();
    my $uuid       = $self->uuid();
    my $expires    = $self->expires();

    # Now tack on other stuff we need.
    push(@insert_data, "created=now()");
    push(@insert_data, "idx='$idx'");
    push(@insert_data, "this_uuid='$this_uuid'");
    push(@insert_data, "owner_uuid='$owner_uuid'");
    push(@insert_data, "uuid='$uuid'");
    
    my $safe_credential = DBQuoteSpecial($self->asString());
    push(@insert_data, "credential_string=$safe_credential");

    if (defined($expires)) {
	my $safe_expires = DBQuoteSpecial($expires);
	push(@insert_data, "valid_until=$safe_expires");
    }

    DBQueryWarn("lock tables geni_credentials write")
	or return undef;
    my $query_result =
	DBQueryWarn("select uuid from geni_credentials ".
		    "where this_uuid='$this_uuid' and ".
		    "      owner_uuid='$owner_uuid'");
    goto bad
	if (!$query_result);
    if ($query_result->numrows) {
	my ($ouuid) = $query_result->fetchrow_array();
	print STDERR "*** Duplicate uuid in geni_credentials table\n";
	print STDERR "*** $uuid,$this_uuid,$owner_uuid : $ouuid\n";
	goto bad;
    }
    # Insert into DB.
    DBQueryWarn("insert into geni_credentials set " . join(",", @insert_data))
	or goto bad;
    DBQueryWarn("unlock tables");

    # If sucessfully stored, set the idx field so we know.
    $self->{'idx'} = $idx;
    return 0;
  bad:
    DBQueryWarn("unlock tables");
    return -1;
}

sub HasPrivilege($$)
{
    my ( $self, $p ) = @_;

    return 0
	if( !defined( $self->{ 'capabilities' } ) );

    return 1
	if( defined( $self->{ 'capabilities' }->{ "*" } ) );

    return defined( $self->{ 'capabilities' }->{ $p } );
}

sub HasActualPrivilege($$)
{
    my ($self, $p) = @_;

    return 0
	if (!defined($self->{'capabilities'}));

    return exists($self->{'capabilities'}->{$p}) ? 1 : 0;
}

sub CheckCredential($;$$)
{
    my ($credential, $target, $nocheck) = @_;
    $nocheck = 0
	if (!defined($nocheck));

    if (!ref($credential)) {
	$credential = GeniCredential->CreateFromSigned($credential);
	if (!defined($credential)) {
	    return GeniResponse->MalformedArgsResponse($GeniCredential::CreateFromSignedError);
	}
    }
    #
    # Well formed credentials must now have URNs.
    #
    return GeniResponse->MalformedArgsResponse("Malformed credentials; missing URNs")
	if (! (defined($credential->owner_urn()) &&
	       defined($credential->target_urn()) &&
	       GeniHRN::IsValid($credential->owner_urn()) &&
	       GeniHRN::IsValid($credential->target_urn())));

    #
    # Make sure the credential was issued to the caller.
    #
    if (!$nocheck && $credential->owner_urn() ne $ENV{'GENIURN'}) {
	    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
					"This is not your credential");
    }

    #
    # Here is where we check that the signer of the credential has
    # the same URN (root) as the thing being signed.
    #
    if (1) {
	my @signer_certs = ();

	foreach my $signer (@{ $credential->signer_certs() }) {
	    my $cert = GeniCertificate->LoadFromString($signer);

	    if (!defined($cert)) {
		print STDERR "Could not load signer certificate:\n";
		print STDERR "$signer\n";
		return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
					"Could not load signer certificate");
	    }
	    push(@signer_certs, $cert);
	}
	my $certificate = shift(@signer_certs);
	
	if ($certificate->VerifySSLChain(@signer_certs) != 0) {
	    my @lines = $certificate->asText();
	    print STDERR "Cannot find root CA for credential signer\n";
	    print STDERR "=====================\n";
	    print STDERR "@lines\n";
	    print STDERR "=====================\n";
	    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
			"Cannot find root certificate for credential signer");
	}
	push(@signer_certs, $certificate->rootcert());

	#
	# Check URN namespace of the first signer against the target.
	#
	if ($credential->target_cert()->VerifySignerURN($certificate)) {
	    my @lines = $certificate->asText();
	    print STDERR "Credential signer in wrong URN namespace for target:\n";
	    print STDERR "@lines\n";
	    if (exists($ENV{'LOGFILEID'})) {
		main::AddLogfileMetaData("cert_error",
					 "Wrong URN namespace for target");
	    }
	    if (0) {
		return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
		    "Credential signer in wrong URN namespace for target: ".
		     $credential->target_cert()->urn() . "/" . $certificate->urn());
	    }
	}
	
	#
	# Now verify chain with respect to URN namespace. This also
	# makes sure that there are no extraneous certs by checking
	# subject against the issuer. 
	#
	my $errorstr;
	
	if ($certificate->VerifyGeniChain(\$errorstr, @signer_certs)) {
	    print STDERR "Failed to verify Geni chain: $errorstr\n";
	    print STDERR $certificate->urn() . "\n";
	    if (exists($ENV{'LOGFILEID'})) {
		main::AddLogfileMetaData("cert_error",
					 "Chain error: $errorstr");
	    }
	    foreach my $signer (@signer_certs) {
		print STDERR $signer->urn() . "\n";
	    }
	    if (0) {
		return GeniResponse->Create(GENIRESPONSE_FORBIDDEN,
					    undef, $errorstr);
	    }
	}
    }
    
    #
    # If an authority is provided, the target must match the authority.
    #
    if (defined($target)) {
	my $target_hrn = $target->urn();
	my $this_hrn   = GeniHRN->new($credential->target_urn());

	# The point here, is that the subauth is not relevant; we assume that
	# any credential signed at either level is valid. 
	if (! ($target_hrn->domain() eq $this_hrn->domain() &&
	       $target_hrn->type() eq $this_hrn->type() &&
	       $target_hrn->id() eq $this_hrn->id())) {
	    return GeniResponse->Create(GENIRESPONSE_FORBIDDEN, undef,
				"This credential is for another target!")
	}
    }
    return $credential;
}

#
# Load a certificate from a file. This creates an object, but does
# not store it in the DB.
#
sub LoadFromFile($$)
{
    my ($class, $filename) = @_;
    my $contents = "";

    if (! open(CRED, $filename)) {
	print STDERR "Could not open $filename: $!\n";
	return undef;
    }
    while (<CRED>) {
	$contents .= $_;
    }
    close(CRED);

    return GeniCredential->CreateFromSigned($contents);
}
sub LoadFromString($$)
{
    my ($class, $string) = @_;

    return GeniCredential->CreateFromSigned($string);
}

#
# Write a credential to a tempfile.
#
sub WriteToFile($)
{
    my ($self) = @_;

    # We want this file to be passed back but deleted at script exit.
    my ($tempfile, $filename) = tempfile(UNLINK => 1);
    print $tempfile $self->asString();
    close $tempfile;
    return $filename;
}

########################################################################
# ABAC version of a credential. This a total hack job, will need to
# be flushed and redone later.
#
package GeniCredential::ABAC;

use Exporter;
use SelfLoader ();
use vars qw(@ISA @EXPORT $AUTOLOAD);
@ISA    = qw(Exporter SelfLoader);
@EXPORT = qw ( );

use English;
use GeniDB;
use GeniHRN;
use GeniCertificate;
use GeniResponse;
use Carp;
use Data::Dumper;
use overload ('""' => 'Stringify');

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    
    return "[GeniCredential::ABAC ]";
}

AUTOLOAD {
    my $self  = $_[0];
    my $type  = ref($self) or croak "$self is not an object";
    my $name  = $AUTOLOAD;
    $name =~ s/.*://;   # strip fully-qualified portion

    confess("No such method '$name' in class $type");
    return undef;
}
sub field($$)           { return ($_[0]->{$_[1]}); }
sub asString($)		{ return field($_[0], "string"); }
sub type($)		{ return field($_[0], "type"); }
sub expires($)		{ return field($_[0], "valid_until"); }
sub owner_cert($)	{ return field($_[0], "owner_cert"); }
sub target_cert($)	{ return field($_[0], "target_cert"); }
sub owner_urn($)        { return field($_[0], "owner_cert")->urn(); }
sub target_urn($)       { return field($_[0], "target_cert")->urn(); }
sub owner_uuid($)       { return field($_[0], "owner_cert")->uuid(); }
sub target_uuid($)      { return field($_[0], "target_cert")->uuid(); }
sub signer_certs($)     { return field($_[0], "signer_certs"); }

# Break circular reference someplace to avoid exit errors.
sub DESTROY {
    my $self = shift;

    $self = undef;
}

sub CreateFromSigned($$$)
{
    my ($class, $self, $root) = @_;
    my $msg = undef;

    # Find an element (which must exist exactly once) within a node.
    my $find = sub
    {
	my( $node, $name ) = @_;

	my @cnodes = grep( $_->nodeName eq $name, $node->childNodes );

	return undef unless scalar( @cnodes ) == 1;

	return $cnodes[ 0 ];
    };

    my $credential_el = &$find( $root, "credential" );
    goto bad unless defined( $credential_el );

    my @signatures = @{ $self->{'signatures'} };
    #
    # There should be just a single signature at this point. 
    #
    if (@signatures > 1) {
	$msg = "Too many signatures in ABAC credential";
	goto bad;
    }

    #
    # Dig out the signer certs.
    #
    my $signer_certs = [];
    my $cert_nodes   = $signatures[0]->getElementsByTagName("X509Certificate");

    foreach my $node (@$cert_nodes) {
	my $signer_cert = $node->to_literal();
	push(@$signer_certs, $signer_cert);
    }
    if (! @{ $signer_certs }) {
	$msg = "Cannot find signer certs in credential";
	goto bad;
    }
    $self->{'signer_certs'}  = $signer_certs;
    $self->{'idx'}	     = undef;	# Only set when stored to DB.
    bless($self, $class);
    return $self;
    
  bad:
    if (!defined($msg)) {
	$msg = "Internal error creating ABAC credential object";
    }
    print STDERR "$msg\n";
    return undef;
}

#
# Set the owner/target cert so that this looks something like a
# normal credential.
#
sub SetTargetCert($$)
{
    my ($self, $cert) = @_;

    $self->{'target_cert'} = $cert;
    return 0;
}
sub SetOwnerCert($$)
{
    my ($self, $cert) = @_;

    $self->{'owner_cert'} = $cert;
    return 0;
}

# Need this.
sub IsExpired($)
{
    my ($self) = @_;

    return GeniCredential::IsExpired($self);
}

sub CheckCredential($)
{
    my ($self) = @_;
    
    # By this point, we know that the original credential has already been
    # checked, and the signature is correct. So we can check if the ABAC
    # content of the credential matches what we expect.
   
    # First make sure that the certificates are in the format 
    # that ABAC::ID->new_ID_chunk expects.
    my $user_cert = $self->target_cert()->cert();
    if ($user_cert !~ /^-----BEGIN CERTIFICATE-----/) {
        $user_cert = "-----BEGIN CERTIFICATE-----\n".
                     $user_cert .
                     "-----END CERTIFICATE-----\n";
    } 
    if ($user_cert !~ /\n$/) {
        $user_cert .= "\n";
    }

    my $tool_cert = $self->owner_cert()->cert();
    if ($tool_cert !~ /^-----BEGIN CERTIFICATE-----/) {
        $tool_cert = "-----BEGIN CERTIFICATE-----\n".
                     $tool_cert .
                     "-----END CERTIFICATE-----\n";
    } 
    if ($tool_cert !~ /\n$/) {
        $tool_cert .= "\n";
    }

    require ABAC;

    my $user = ABAC::ID->new_ID_chunk($user_cert);
    my $tool = ABAC::ID->new_ID_chunk($tool_cert);

    my $role = $user->keyid() . ".speaks_for_" . $user->keyid();
    my $prin = "".$tool->keyid();

    my $find_one_subel_helper = sub
    {
        my( $node, $name, $prev_error_msg ) = @_;

        if (!defined($node)) {
            return (undef, $prev_error_msg );
        }

        my @cnodes = grep( $_->nodeName eq $name, $node->childNodes );

        if (scalar( @cnodes ) < 1) {
            my $msg = "No node '$name' found";
            return (undef, defined($prev_error_msg) ? $prev_error_msg . "\n" . $msg : $msg);
        }
        if (scalar( @cnodes ) > 1) {
            my $msg = "Found multiple '$name' nodes (expected only one).";
            return (undef, defined($prev_error_msg) ? $prev_error_msg . "\n" . $msg : $msg);
        }

        return ($cnodes[ 0 ], $prev_error_msg);
    };

    my $el_to_str_helper = sub
    {
        my( $node, $prev_error_msg ) = @_;

        if (!defined($node)) {
            return (undef, $prev_error_msg );
        }

        my $node_lit = $node->to_literal();
        if (!defined($node_lit) || $node_lit eq "") {
            my $msg = "No string literal found in node '" . $node->nodeName . "'";
            return (undef, defined($prev_error_msg) ? $prev_error_msg . "\n" . $msg : $msg);
        }

        return ($node_lit, $prev_error_msg);
    };

    my $parser = XML::LibXML->new;
    my $doc;
    eval {
        $doc = $parser->parse_string($self->asString());
    };
    if ($@) {
        my $msg = "Failed to parse credential string: $@";
        print STDERR "$msg\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
            "$msg");
    }
    my ($credential_el) = $doc->getElementsByTagName("credential");
    if (!defined($credential_el)) {
        my $error_msg = "Could not find credential element";
        print STDERR "Error parsing ABAC Credential XML: $error_msg\n";
        return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
            "Error parsing ABAC Credential XML: $error_msg");
    }
    my $error_msg = undef;
    (my $abac_el, $error_msg) = &$find_one_subel_helper($credential_el, "abac", $error_msg);
    (my $rt0_el, $error_msg) = &$find_one_subel_helper($abac_el, "rt0", $error_msg);
    (my $head_el, $error_msg) = &$find_one_subel_helper($rt0_el, "head", $error_msg);
    (my $tail_el, $error_msg) = &$find_one_subel_helper($rt0_el, "tail", $error_msg);
    (my $headprin_el, $error_msg) = &$find_one_subel_helper($head_el, "ABACprincipal", $error_msg);
    (my $headrole_el, $error_msg) = &$find_one_subel_helper($head_el, "role", $error_msg);
    (my $tailprin_el, $error_msg) = &$find_one_subel_helper($tail_el, "ABACprincipal", $error_msg);
    (my $headprinkeyid_el, $error_msg) = &$find_one_subel_helper($headprin_el, "keyid", $error_msg);
    (my $tailprinkeyid_el, $error_msg) = &$find_one_subel_helper($tailprin_el, "keyid", $error_msg);

    (my $headrole_str, $error_msg) = &$el_to_str_helper($headrole_el, $error_msg);
    (my $headprin_str, $error_msg) = &$el_to_str_helper($headprinkeyid_el, $error_msg);
    (my $tailprin_str, $error_msg) = &$el_to_str_helper($tailprinkeyid_el, $error_msg);

    if (defined($error_msg)) {
        print STDERR "Error parsing ABAC Credential XML: $error_msg\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Error parsing ABAC Credential XML: $error_msg");
    }

    my $needed_statement = $role . "<-" . $prin;
    my $cred_statement = $headprin_str . "." . $headrole_str . "<-" . $tailprin_str;
    if ($needed_statement ne $cred_statement) {
        print STDERR "ABAC statement in credential does not match needed speaksfor ABAC statement.\n";
        return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
            "ABAC statement in credential does not match needed speaksfor ABAC statement. ".
            "Need='$needed_statement' Got='$cred_statement'");
    }

    return $self;
}

# _Always_ make sure that this 1 is at the end of the file...
1;
