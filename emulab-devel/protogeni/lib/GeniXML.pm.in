#!/usr/bin/perl -w
#
# Copyright (c) 2010-2021 University of Utah and the Flux Group.
# 
# {{{GENIPUBLIC-LICENSE
# 
# GENI Public License
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and/or hardware specification (the "Work") to
# deal in the Work without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Work, and to permit persons to whom the Work
# is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Work.
# 
# THE WORK IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS
# IN THE WORK.
# 
# }}}
#
package GeniXML;

use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA = "Exporter";
@EXPORT = qw(Parse ParseFile GetXmlVersion IsVersion0 FindNodes FindNodesNS
FindFirst FindFirstNS FindElement FindAttr GetNodeByVirtualId GetLinkByVirtualId
IsLanNode IsLocalNode IsTunnel GetExpires GetLinkWideProperties GetIp GetVnodeId
GetNodeId GetVirtualId GetInterfaceId GetInterfaceNodeId GetSliverId
GetManagerId GetColocate GetSubnodeOf GetStartupCommand GetTarball
GetVirtualizationType SetVirtualizationSubtype GetVirtualizationSubtype
GetExclusive SetExclusive GetLinkManager SetText GetText Serialize
CreateDocument AddElement RemoveChild PolicyExists GetMask
GetDiskImage IsUntaggedLan IsTaggedLan GetAddressPools GetHopLinkID GetCapabilitySection
GetSuggestedVlanFromHop GetAvailableVlanFromHop SetVlanTagInHop
GetProfileParamaters);

use English;
use Data::Dumper;
use XML::LibXML;
use XML::LibXML::XPathContext;
use XML::LibXML::NodeList;
use GeniHRN;
use GeniResponse;
use GeniUtil;
use Carp qw(cluck carp);
use Scalar::Util qw(looks_like_number);

use vars qw($RSPEC_0_1 $RSPEC_0_2 $RSPEC_2 $RSPEC_3
            $RSPEC_0_1_NS $RSPEC_0_2_NS $RSPEC_2_NS
            $EMULAB_NS $JACKS_NS $XSI_NS $STITCH_NS $SHAREDVLAN_NS $SITEINFO_NS
            $RSPEC_TOUR
            $REQUEST_2_URL $MANIFEST_2_URL
            $REQUEST_3_URL $MANIFEST_3_URL
	    $PROFILE_PARAMETERS_NS);
$RSPEC_0_1 = "0.1";
$RSPEC_0_2 = "0.2";
$RSPEC_2 = "2";
$RSPEC_3 = "3";

our $RSPEC_0_1_NS = "http://www.protogeni.net/resources/rspec/0.1";
our $RSPEC_0_2_NS = "http://www.protogeni.net/resources/rspec/0.2";
our $RSPEC_2_NS = "http://www.protogeni.net/resources/rspec/2";
our $RSPEC_3_NS = "http://www.geni.net/resources/rspec/3";
our $EMULAB_NS = "http://www.protogeni.net/resources/rspec/ext/emulab/1";
our $JACKS_NS = "http://www.protogeni.net/resources/rspec/ext/jacks/1";
our $SITEINFO_NS = "http://www.protogeni.net/resources/rspec/ext/site-info/1";
our $XSI_NS = "http://www.w3.org/2001/XMLSchema-instance";
our $STITCH_NS = "http://hpn.east.isi.edu/rspec/ext/stitch/0.1/";
our $SHAREDVLAN_NS = "http://www.geni.net/resources/rspec/ext/shared-vlan/1";
our $SHAREDVLAN_PG_NS = "http://www.protogeni.net/resources/rspec/ext/shared-vlan/1";
our $PROFILE_PARAMETERS_NS = "http://www.protogeni.net/resources/rspec/ext/profile-parameters/1";
our $RSPEC_TOUR = "http://www.protogeni.net/resources/rspec/ext/apt-tour/1";

$REQUEST_2_URL = "http://www.protogeni.net/resources/rspec/2/request.xsd";
$MANIFEST_2_URL = "http://www.protogeni.net/resources/rspec/2/manifest.xsd";
$REQUEST_3_URL = "http://www.geni.net/resources/rspec/3/request.xsd";
$MANIFEST_3_URL = "http://www.geni.net/resources/rspec/3/manifest.xsd";

# Configure variables
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";

# Name Space stuff
my $DELAY_NS = "http://www.protogeni.net/resources/rspec/ext/delay/1";

# Returns the document element by parsing a given string. If the
# string fails to parse, returns undefined.
sub Parse($)
{
    my ($xml) = @_;
    my $parser = XML::LibXML->new;
    my $doc;
    eval {
        $doc = $parser->parse_string($xml);
    };
    if ($@) {
	carp("Failed to parse xml string: $@\nXML: $xml\n\n");
	return undef;
    } else {
	return $doc->documentElement();
    }
}

sub ParseFile($)
{
    my ($file) = @_;
    my $parser = XML::LibXML->new;
    my $doc;
    eval {
        $doc = $parser->parse_file($file);
    };
    if ($@) {
	carp("Failed to parse xml string: $@");
	return undef;
    } else {
	return $doc->documentElement();
    }
}

# Determines the rspec version of a node by examining is namespace URI
sub GetXmlVersion($)
{
    my ($node) = @_;
    my $result = undef;
    my $ns = $node->namespaceURI();
    if (defined($ns)) {
	if ($ns =~ /geni.net\/resources\/rspec\/3$/) {
	    $result = $RSPEC_3;
	} elsif ($ns =~ /protogeni.net\/resources\/rspec\/0.1$/) {
	    $result = $RSPEC_0_1;
	} elsif ($ns =~ /protogeni.net\/resources\/rspec\/0.2$/) {
	    $result = $RSPEC_0_2;
	} elsif ($ns =~ /protogeni.net\/resources\/rspec\/2$/) {
	    $result = $RSPEC_2;
	} else {
	    carp("Unknown rspec namespace: " . $ns);
	    $result = $RSPEC_0_1;
	}
    }
    return $result;
}

my $pgre = qr/protogeni.net\/resources\/rspec\/[\d\.]+$/;

sub IsVersion0($)
{
    my ($node) = @_;
    
    #
    # Yuck, we call this all over the place, but if the thing we call
    # it on (say, an emulab:vhost) is in its own namespace, then the
    # test above in GetXmlVersion makes no sense and fails.
    #
    my $ns = $node->namespaceURI();
    return 0
	if (!defined($ns));
    
    return 0
	if (defined($ns) && $ns !~ $pgre);

    my $version = GetXmlVersion($_[0]);
    return defined($version)
	&& ($version eq $RSPEC_0_1 || $version eq $RSPEC_0_2);
}


# Returns a NodeList for a given XPath using a given node as
# context. 'n' is defined to be the prefix for the namespace of the
# node.
sub FindNodes($$)
{
    my ($path, $node) = @_;
    my $result = undef;
    my $ns = undef;
    eval {
	my $xc = XML::LibXML::XPathContext->new();
	$ns = $node->namespaceURI();
	if (defined($ns)) {
	    $xc->registerNs('n', $ns);
	} else {
	    $path =~ s/\bn://g;
	}
	$result = $xc->findnodes($path, $node);
    };
    if ($@) {
	if (! defined($ns)) {
	    $ns = "undefined";
	}
        cluck "Failed to find nodes using XPath path='$path', ns='$ns': $@\n";
	return XML::LibXML::NodeList->new();
    } else {
	return $result;
    }
}

# Returns a NodeList for a given XPath using a given namespace as
# context. 'n' is defined to be the prefix for the given namespace.
sub FindNodesNS($$$)
{
    my ($path, $node, $nsURI) = @_;
    my $result = undef;
    return XML::LibXML::NodeList->new()
        if (!defined($node));
    eval { 
  my $xc = XML::LibXML::XPathContext->new();
  if (defined($nsURI)) {
      $xc->registerNs('n', $nsURI);
  } else {
      $path =~ s/\bn://g;
  }
  $result = $xc->findnodes($path, $node);
    };
    if ($@) {
  if (! defined($nsURI)) {
      $nsURI = "undefined";
  }
        cluck "Failed to find nodes using XPath path='$path', nsURI='$nsURI': $@\n";        
  return XML::LibXML::NodeList->new();
    } else { 
  return $result;
    } 
}


# Returns the first Node which matches a given XPath against a given
# node. If that node is not of the specified type, returns
# undefined. Works like FindNodes.
sub FindNodeType($$$)
{
    my ($path, $node, $type) = @_;
    my $result = FindNodes($path, $node)->pop();
    if (defined($result) && $result->nodeType() != $type) {
	$result = undef;
    }
    return $result;
}

# Returns the first Node which matches a given XPath.
sub FindFirst($$)
{
    my ($path, $node) = @_;
    return FindNodes($path, $node)->pop();
}

# Returns the first Node which matches a given XPath.
sub FindFirstNS($$$)
{
    my ($path, $node, $ns) = @_;
    return FindNodesNS($path, $node, $ns)->pop();
}

# Returns the first Element which matches a given XPath.
sub FindElement($$)
{
    my ($path, $node) = @_;
    return FindNodeType($path, $node, XML_ELEMENT_NODE);
}

# Returns the first Attribute which matches a given XPath.
sub FindAttr($$)
{
    my ($path, $node) = @_;
    return FindNodeType($path, $node, XML_ATTRIBUTE_NODE);
}

sub GetElementByVirtualId($$$)
{
    my ($name, $type, $node) = @_;
    my @list = FindNodes('n:'.$type.'[@virtual_id = "'.$name.'"]',
			 $node)->get_nodelist();
    if (scalar(@list) == 0) {
	@list = FindNodes('n:'.$type.'[@nickname = "'.$name.'"]',
			  $node)->get_nodelist();
    }
    if (scalar(@list) == 0) {
	@list = FindNodes('n:'.$type.'[@client_id = "'.$name.'"]',
			  $node)->get_nodelist();
    }
    my $result = undef;
    if (scalar(@list) > 0)
    {
	$result = $list[0];
    }
    if (scalar(@list) > 1)
    {
	cluck("WARNING: Multiple $type with virtual_id $name found");
    }
    return $result;
}

sub GetNodeByVirtualId($$)
{
    my ($name, $node) = @_;
    return GetElementByVirtualId($name, 'node', $node);
}

sub GetVhostByVirtualId($$)
{
    my ($name, $node) = @_;

    return FindNodesNS('n:vhost[@client_id = "'.$name.'"]',
		       $node, $EMULAB_NS)->pop();
}

sub GetLinkByVirtualId($$)
{
    my ($name, $node) = @_;
    return GetElementByVirtualId($name, 'link', $node);    
}

# Returns true if a given XML Node is an RSpec node and is of type lan
sub IsLanNode($)
{
    my ($node) = @_;
    my $result = 0;
    if (defined($node) && $node->localname() eq "node") {
	foreach my $lan (FindNodes("n:hardware_type",
				   $node)->get_nodelist()) {
	    my $typeName = GetFirstText($lan, "type_name", "name");
	    if (defined($typeName) && $typeName eq "lan") {
		$result = 1;
		last;
	    }
	}
    }
    return $result;
}

# Returns true if a given XML Node is an RSpec node and either has
# the current CM as a 'component_manager_urn' or
# 'component_manager_uuid or no component_manager defined.
sub IsLocalNode($)
{
    my ($node) = @_;
    my $result = 0;
    if (defined($node) && $node->localname() eq "node") {
	my $manager_uuid  = GetManagerId($node);
	if (! defined($manager_uuid) ||
	    GeniHRN::Equal($manager_uuid, $ENV{'MYURN'}) ||
	    $manager_uuid eq $ENV{'MYUUID'}) {

	    $result = 1;
	}
    }
    return $result;
}

sub IsTunnel($)
{
    my ($link)  = @_;
    my $tunnel_type = TunnelType($link);

    return 1
	if (defined($tunnel_type) &&
	    $tunnel_type =~ /^(tunnel|gre-tunnel|egre-tunnel)$/);

    return 0;
}

sub TunnelType($)
{
    my ($link) = @_;
    my $result = undef;
    
    if (IsVersion0($link)) {
	my $link_type = GetText("link_type", $link);
	if (defined($link_type)) {
	    $result = "tunnel";
	}
    } else {
	my @types = FindNodes("n:link_type", $link)->get_nodelist();
	foreach my $current (@types) {
	    my $name = GetText("name", $current);
	    if (defined($name)) {
		$result = $name;
		last;
	    }
	}
    }
    return $result;
}

sub LinkType($)
{
    return TunnelType($_[0]);
}

sub SetLinkType($$)
{
    my ($link, $newtype) = @_;

    return -1
	if (IsVersion0($link));

    my @types = FindNodes("n:link_type", $link)->get_nodelist();
    foreach my $type (@types) {
	$link->removeChild($type);
    }
    return 0
	if (!defined($newtype));

    my $type = AddElement("link_type", $link);
    return -1
	if (!defined($type));
    
    SetText("name", $type, $newtype);
    return 0;
}

sub IsLayer1($)
{
    my $linktype = LinkType($_[0]);
    
    return 1
	if (defined($linktype) && $linktype eq "layer1");
    
    return 0;
}

sub GetExpires($)
{
    my ($node) = @_;
    my $result = undef;
    my $text = GetFirstText($node, "valid_until", "expires");
    if (defined($text)) {
	if ($text =~
	  /[0-9]{4}-[0-9]{1,2}-[0-9]{1,2}T[0-9]{1,2}:[0-9]{1,2}:[0-9]{1,2}Z/) {
	    $result = $text;
	} else {
	    $result = GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					   "$text: Invalid Datetime Format");
	}
    }
    return $result;
}

sub SetExpires($$)
{
    my ($node, $arg) = @_;
    if (IsVersion0($node)) {
	SetText("valid_until", $node, $arg);
    } else {
	SetText("expires", $node, $arg);
    }
}

#
# An optimization for when you just want symmetrical properties for the
# entire link/lan. Saves a lot of XML on a big topology.
#
sub GetLinkWideProperties($)
{
    my ($link) = @_;

    if (IsVersion0($link)) {
	my $bandwidth = GeniXML::GetText("bandwidth", $link);
	return undef
	    if (!defined($bandwidth));

	return {"bandwidth" => $bandwidth};
    }
    
    my $ref = GeniXML::FindNodesNS("n:properties", $link, $EMULAB_NS)->pop();
    return undef
	if (!defined($ref));

    my $bandwidth = GeniXML::GetText("capacity", $ref);
    my $latency   = GeniXML::GetText("latency", $ref);
    my $lossrate  = GeniXML::GetText("packet_loss", $ref);
    return undef
	if (!(defined($bandwidth) || defined($latency) || defined($lossrate)));

    return {"bandwidth" => $bandwidth,
	    "latency"   => $latency,
	    "lossrate"  => $lossrate};
}

sub GetLinkProperties($)
{
    my ($link) = @_;
    my @result = ();
    
    if (! IsVersion0($link)) {
	@result = FindNodes("n:property", $link)->get_nodelist();
    }
    return @result;
}

sub GetMask($$)
{
    my ($ifaceref, $node) = @_;
    my $result = undef;
    if (IsVersion0($ifaceref)) {
	$result = GetText("tunnel_ip", $ifaceref);
    } else {
	my $id = GetInterfaceId($ifaceref);
	my @ifaces = FindNodes("n:interface", $node)->get_nodelist();
	foreach my $iface (@ifaces) {
	    my $testid = GetInterfaceId($iface);
	    if (defined($id) && defined($testid) && $testid eq $id) {
		my $ip = FindFirst("n:ip", $iface);
		if (defined($ip)) {
		    $result = GetFirstText($ip, "netmask", "mask");
		}
		last;
	    }
	}
    }
    return $result;
}

sub GetIp($$)
{
    my ($ifaceref, $node) = @_;
    my $result = undef;
    if (IsVersion0($ifaceref)) {
	$result = GetText("tunnel_ip", $ifaceref);
    } else {
	my $id = GetInterfaceId($ifaceref);
	my @ifaces = FindNodes("n:interface", $node)->get_nodelist();
	foreach my $iface (@ifaces) {
	    my $testid = GetInterfaceId($iface);
	    if (defined($id) && defined($testid) && $testid eq $id) {
		my $ip = FindFirst("n:ip", $iface);
		if (defined($ip)) {
		    $result = GetText("address", $ip);
		}
		last;
	    }
	}
    }
    return $result;
}

# Returns the vnode id in the emulab extension or failing that the component_id
sub GetVnodeId($)
{
    my ($node) = @_;
    my $result = undef;
    if (IsVersion0($node)) {
	$result = GetNodeId($node);
    } else {
	my $vnoderef = GeniXML::FindNodesNS("n:vnode", $node,
					    $EMULAB_NS)->pop();
	if (defined($vnoderef)) {
	    $result = GetText("name", $vnoderef);
	}
	if (! defined($result)) {
	    $result = GetNodeId($node);
	}
    }
    return $result;
}

# Returns the uuid or urn of an RSpec node or undef if it is not a node.
sub GetNodeId($)
{
    my ($node) = @_;
    my $result = GetFirstText($node, "component_uuid", "component_id",
			      "component_urn", "uuid");
    if (defined($result) && $result eq "") {
	$result = undef;
    }
    return $result;
}

sub GetVirtualId($)
{
    my ($node) = @_;
    return GetFirstText($node, "client_id", "virtual_id", "nickname");
}

sub GetInterfaceId($)
{
    my ($node) = @_;
    return GetFirstText($node, "client_id", "virtual_interface_id",
			"iface_name", "virtual_port_id", "virtual_id");
}

sub GetInterfaceNodeId($)
{
    my ($node) = @_;
    return GetFirstText($node, "virtual_node_id", "node_nickname");
}

sub GetSliverId($)
{
    my ($node) = @_;
    return GetFirstText($node, "sliver_id", "sliver_urn");
}

sub DeleteSliverId($)
{
    my ($node) = @_;
    $node->removeAttribute("sliver_id");
    $node->removeAttribute("sliver_urn");
}

sub GetManagerId($)
{
    my ($node) = @_;
    my $result = GetFirstText($node, "component_manager_id",
			      "component_manager_urn",
			      "component_manager_uuid");
    if (defined($result) && $result eq "") {
	$result = undef;
    }
    return $result;
}

sub SetManagerId($$)
{
    my ($node, $urn) = @_;

    foreach my $tag ("component_manager_urn",
		     "component_manager_id", "component_manager_uuid") {
	$node->removeAttribute($tag);
    }
    GeniXML::SetText("component_manager_id", $node, $urn);    
    return $node;
}

sub AddManagerToLink($$)
{
    my ($link, $urn) = @_;

    my $ref = AddElement("component_manager", $link);
    return undef
	if (!defined($ref));

    GeniXML::SetText("name", $ref, $urn);
    return $link;
}

sub GetColocate($)
{
    my ($node) = @_;
    my $result = GetFirstText($node, "colocate", "phys_nickname");
    return $result;
}

sub GetSubnodeOf($)
{
    my ($node) = @_;
    my $result = undef;
    if (IsVersion0($node)) {
	$result = GetText("subnode_of", $node);
    } else {
	my @relations = FindNodes("n:relation", $node)->get_nodelist();
	foreach my $current (@relations) {
	    if (GetText("type", $current) eq "subnode_of") {
		$result = GetText("client_id", $current);
		last;
	    }
	}
    }
    return $result;
}
sub GetInstantiateOn($)
{
    my ($node) = @_;
    my $result = undef;
    if (IsVersion0($node)) {
	$result = GetText("instantiate_on", $node);
    } else {
	my @relations = FindNodes("n:relation", $node)->get_nodelist();
	foreach my $current (@relations) {
	    if (GetText("type", $current) eq "instantiate_on") {
		$result = GetText("client_id", $current);
		last;
	    }
	}
    }
    return $result;
}

sub GetServices($)
{
    my ($node) = @_;
    my @result = ();
    my @services = FindNodes("n:services", $node)->get_nodelist();

    foreach my $service (@services) {
	foreach my $current ($service->childNodes()) {
	    my $item;
	    my $type = $current->nodeName();
	
	    if ($type eq "execute") {
		$type = "execute";
		my $cmd  = GetText("command", $current);
		my $shell= GetText("shell", $current);
		$item = {"type"   => $type,
			 "cmd"    => $cmd,
			 "shell"  => $shell};
	    }
	    elsif ($type eq "install") {
		$type = "install";
		my $dir = GetText("install_path", $current);
		my $url = GetText("url", $current);
		$item = {"type"   => $type,
			 "dir"    => $dir,
			 "url"    => $url};
	    }
	    else {
		next;
	    }
	    push(@result, $item);
	}
    }
    return @result;
}
sub GetExecuteServices($)
{
    my ($node)   = @_;
    my @result   = ();
    my @services = GetServices($node);
    return ()
	if (!@services);
    
    foreach my $service (@services) {
	push(@result, $service)
	    if ($service->{'type'} eq "execute");
    }
    return @result;
}

#
# Program agents are also in the services element, but they are in the
# Emulab name space.
#
sub GetProgramAgents($)
{
    my ($node) = @_;
    my @result = ();
    my @services = FindNodes("n:services", $node)->get_nodelist();

    foreach my $service (@services) {
	my @agents = FindNodesNS("n:program-agent",
				 $service, $EMULAB_NS)->get_nodelist();
	foreach my $agent (@agents) {
	    my $name       = GetText("name", $agent);
	    my $command    = GetText("command", $agent);
	    my $directory  = GetText("directory", $agent);
	    my $start      = GetText("onexpstart", $agent);

	    my $item = {"name"       => $name,
			"command"    => $command,
			"dir"        => $directory,
			"onexpstart" => (defined($start) &&
					 lc("$start") eq "true" ? 1 : 0),
	    };
	    push(@result, $item);
	}
    }
    return @result;
}

sub GetNodeAttributes($)
{
    my ($node) = @_;
    my @result = ();

    my @attributes =
	FindNodesNS("n:node_attribute", $node, $EMULAB_NS)->get_nodelist();

    foreach my $attr (@attributes) {
	my $key   = GetText("key", $attr);
	my $value = GetText("value", $attr);
	if (defined($key) && $key ne "" && defined($value)) {
	    push(@result, {"key" => $key, "value" => $value});
	}
    }
    return @result;
}

sub GetNodeDesires($)
{
    my ($node) = @_;
    my @result = ();

    my @desires = FindNodesNS("n:fd", $node, $EMULAB_NS)->get_nodelist();

    foreach my $desire (@desires) {
	my $name   = GetText("name", $desire);
	my $weight = GetText("weight", $desire);
	if (defined($name) && $name ne "" && defined($weight)) {
	    push(@result, {"name" => $name, "weight" => $weight});
	}
    }
    return @result;
}

sub GetStartupCommand($)
{
    my ($node) = @_;
    my $result = undef;
    if (IsVersion0($node)) {
        $result = GetText("startup_command", $node);
    } else {
	my $execute = FindFirst("n:services/n:execute", $node);
	if (defined($execute)) {
	    $result = GetText("command", $execute);
	}
    }
    return $result;
}

#
# Get root ssh key directive. Returns a list (pub,priv) booleans.
#
sub GetRootKey($)
{
    my ($node) = @_;
    my $keyref = GeniXML::FindNodesNS("n:rootkey", $node,
				      $EMULAB_NS)->pop();
    return (undef,undef)
	if (!defined($keyref));
    
    my $priv = GetText("private", $keyref);
    if (defined($priv)) {
	$priv = (lc("$priv") eq "true" ? 1 : 0);
    }
    my $pub  = GetText("public", $keyref);
    if (defined($pub)) {
	$pub = (lc("$pub") eq "true" ? 1 : 0);
    }
    return ($pub,$priv);
}

#
# Are keys disabled at top level.
#
sub DisableRootKey($)
{
    my ($rspec) = @_;
    my $keyref = GeniXML::FindNodesNS("n:disablerootkey", $rspec,
				      $EMULAB_NS)->pop();
    return 0
	if (!defined($keyref));

    return 1;
}

sub SkipVlans($)
{
    my ($rspec) = @_;
    
    my $tmp = GeniXML::FindNodesNS("n:skipvlans", $rspec, $EMULAB_NS)->pop();
    return 1
	if (defined($tmp));

    return 0;
}

sub GetTarball($)
{
    my ($node) = @_;
    my $result = undef;
    if (IsVersion0($node)) {
        $result = GetText("tarfiles", $node);
    } else {
	$result = "";
	my @tarlist = FindNodes("n:services/n:install",
				$node)->get_nodelist();
	foreach my $current (@tarlist) {
	    my $url = GetText("url", $current);
	    my $install = GetText("install_path", $current);
	    if (defined($url) && defined($install)) {
		# TODO: Make sure url/install don't have semicolons or spaces
		# TODO: Flag an error if either one is not defined
		if ($result ne "") {
		    $result .= ";";
		}
		$result .= $install . " " . $url;
	    }
	}
	if (defined($result) && $result eq "") {
	    $result = undef;
	}
    }
    return $result;
}

sub GetVirtualizationType($)
{
    my ($node) = @_;
    my $result = "emulab-vnode";
    if (IsVersion0($node)) {
	$result = GetText("virtualization_type", $node);
    }
    return $result;
}

sub SetVirtualizationSubtype($$)
{
    my ($node, $arg) = @_;
    my $result = 1;
    if (IsVersion0($node)) {
	$result = SetText("virtualization_subtype", $node, $arg);
    } else {
	my $type = FindFirst("n:sliver_type", $node);
	if (! defined($type)) {
	    $type = AddElement("sliver_type", $node);
	}
	SetText("name", $type, $arg);
    }
    return $result;
}

sub GetVirtualizationSubtype($)
{
    my ($node) = @_;
    my $result = undef;
    if (IsVersion0($node)) {
	$result = GetText("virtualization_subtype", $node);
    } else {
	my $type = FindFirst("n:sliver_type", $node);
	if (defined($type)) {
	    $result = GetText("name", $type);
	}
    }
    return $result;
}

sub IsAvailable($)
{
    my ($node) = @_;
    my $result = 0;
    my $available = FindFirst("n:available", $node);
    if (defined($available)) {
	my $now = GetText("now", $available);
	if (defined($now) && lc($now) eq "true") {
	    $result = 1;
	}
    }
    return $result;
}

sub GetDiskImage($)
{
    my ($node) = @_;
    my $result = undef;
    if (IsVersion0($node)) {
	$result = FindFirst("n:disk_image", $node);
    } else {
	my $type = FindFirst("n:sliver_type", $node);
	if (defined($type)) {
	    $result = FindFirst("n:disk_image", $type);
	}
    }
    return $result;
}

sub SetDiskImage($$)
{
    my ($node, $urn) = @_;
    my $diskref   = undef;
    if (IsVersion0($node)) {
	$diskref = FindFirst("n:disk_image", $node);
	if (!defined($diskref)) {
	    $diskref = AddElement("disk_image", $node);
	}
    }
    else {
	my $type = FindFirst("n:sliver_type", $node);
	if (! defined($type)) {
	    $type = AddElement("sliver_type", $node);
	}
	$diskref = FindFirst("n:disk_image", $type);
	if (!defined($diskref)) {
	    $diskref = AddElement("disk_image", $type);
	}
    }
    if (GeniHRN::IsValid($urn)) {
	$diskref->removeAttribute("url");
	GeniXML::SetText("name", $diskref, $urn);
    }
    else {
	$diskref->removeAttribute("name");
	GeniXML::SetText("url", $diskref, $urn);
    }
    return $diskref;
}

sub GetExclusive($)
{
    my ($node) = @_;
    my $exclusive = GetText("exclusive", $node);
    my $result = $exclusive;
    if (defined($exclusive) && ! IsVersion0($node)) {
	$result = ($exclusive eq "true");
    }
    return $result;
}

sub SetExclusive($$)
{
    my ($node, $arg) = @_;
    my $result = 1;
    if (IsVersion0($node)) {
	$result = SetText("exclusive", $node, $arg);
    } else {
	my $textArg = "false";
	if ($arg) {
	    $textArg = "true";
	}
	$result = SetText("exclusive", $node, $textArg);
    }
    return $result;
}

sub GetLinkAttributes($)
{
    my ($link) = @_;
    my @result = ();

    my @attributes =
	FindNodesNS("n:link_attribute", $link, $EMULAB_NS)->get_nodelist();

    foreach my $attr (@attributes) {
	my $key   = GetText("key", $attr);
	my $value = GetText("value", $attr);
	if (defined($key) && $key ne "" && defined($value)) {
	    push(@result, {"key" => $key, "value" => $value});
	}
    }
    return @result;
}

sub GetLinkManager($)
{
    my ($link) = @_;
    return GetFirstText($link, "id", "name");
}

sub GetDelayPipes($)
{
    my ($node) = @_;
    my @result = ();
    
    if (! IsVersion0($node)) {
	my $type = FindFirst("n:sliver_type", $node);
	if (defined($type)) {
	    my $name = GetText("name", $type);
	    if (defined($name) && $name eq "delay") {
		@result = FindNodesNS("n:sliver_type_shaping/n:pipe", $type,
				      $DELAY_NS)->get_nodelist();
	    }
	}
    }
    return @result;
}

sub GetLinkDelayPipes($)
{
    my ($link) = @_;
    my @result = FindNodesNS("n:sliver_type_shaping/n:pipe", $link,
			     $DELAY_NS)->get_nodelist();
    return @result;
}

sub HasXenSettings($)
{
    my ($node) = @_;

    my $type = FindFirst("n:sliver_type", $node);
    if (defined($type)) {
	my $settings = FindNodesNS("n:xen", $type, $EMULAB_NS)->pop();
	return 1
	    if (defined($settings));
    }
    return 0;
}

sub HasDockerSettings($)
{
    my ($node) = @_;

    my $type = FindFirst("n:sliver_type", $node);
    if (defined($type)) {
	my $settings = FindNodesNS("n:docker", $type, $EMULAB_NS)->pop();
	return 1
	    if (defined($settings));
    }
    return 0;
}

sub UseTypeDefaultImage($)
{
    my ($node) = @_;
    my $result = 0;
    my @foo    = FindNodesNS("n:use_type_default_image", $node,
			     $EMULAB_NS)->get_nodelist();
    if (scalar(@foo) > 0) {
	my $enabled = GetText("enabled", $foo[0]);
	$result = defined($enabled) && $enabled eq "true";
    }
    return $result;
}

sub XenPtype($)
{
    my ($node) = @_;

    my $type = FindFirst("n:sliver_type", $node);
    if (defined($type)) {
	my $ptype = FindNodesNS("n:xen_ptype", $type, $EMULAB_NS)->pop();
	if (defined($ptype)) {
	    my $name = GetText("name", $ptype);
	    return $name
		if (defined($name) && $name ne "");
	}
    }
    return undef;
}

sub DockerPtype($)
{
    my ($node) = @_;

    my $type = FindFirst("n:sliver_type", $node);
    if (defined($type)) {
	my $ptype = FindNodesNS("n:docker_ptype", $type, $EMULAB_NS)->pop();
	if (defined($ptype)) {
	    my $name = GetText("name", $ptype);
	    return $name
		if (defined($name) && $name ne "");
	}
    }
    return undef;
}

sub MultiplexFactor($)
{
    my ($rspec) = @_;
    
    my $mfactor = FindNodesNS("n:collocate_factor", $rspec, $EMULAB_NS)->pop();
    if (defined($mfactor)) {
	my $count = GetText("count", $mfactor);
	return $count
	    if (defined($count) && $count =~ /^\d+$/);
    }
    return undef;
}

sub FromEmulabPortal($)
{
    my ($rspec) = @_;
    
    my $element = FindNodesNS("n:portal", $rspec, $EMULAB_NS)->pop();
    if (defined($element)) {
	my $which = GetText("name", $element);
	return 1
	    if (defined($which) && $which eq "emulab");
    }
    return 0;
}
sub GetPortal($)
{
    my ($rspec) = @_;
    
    my $element = FindNodesNS("n:portal", $rspec, $EMULAB_NS)->pop();
    if (!defined($element)) {
	return undef;
    }
    my $tag = GetText("name", $element);
    my $url = GetText("url", $element);
    return ($tag, $url);
}
sub SetPortal($$$$$)
{
    my ($rspec, $portal, $url, $pid, $eid) = @_;
    
    my $element = FindNodesNS("n:portal", $rspec, $EMULAB_NS)->pop();
    if (!defined($element)) {
	$element = AddElement("portal", $rspec, $EMULAB_NS);	
    }
    SetText("name", $element, $portal);
    SetText("url", $element, $url);
    SetText("project", $element, $pid);
    SetText("experiment", $element, $eid);
    return 0;
}
sub ClearPortal($)
{
    my ($rspec) = @_;
    
    my $element = FindNodesNS("n:portal", $rspec, $EMULAB_NS)->pop();
    if (defined($element)) {
	$rspec->removeChild($element);
    }
    return 0;
}

sub PackingStrategy($)
{
    my ($rspec) = @_;
    
    my $tmp = FindNodesNS("n:packing_strategy", $rspec, $EMULAB_NS)->pop();
    if (defined($tmp)) {
	my $strategy = GetText("strategy", $tmp);
	return $strategy
	    if (defined($strategy) && $strategy =~ /^(pack|balance)$/);
    }
    return undef;
}

sub OpenFlowController($)
{
    my ($link) = @_;
    my $result = undef;
    
    my @stuff = FindNodesNS("n:openflow_controller", $link,
			    $EMULAB_NS)->get_nodelist();
    if (scalar(@stuff) > 0) {
	my $controller = GetText("url", $stuff[0]);
	$result = $controller
	    if (defined($controller));
    }
    return $result;
}

sub GetXenSettings($)
{
    my ($node) = @_;
    my $result = {};

    my $type = FindFirst("n:sliver_type", $node);
    return undef
	if (!defined($type));
    
    my $settings = FindNodesNS("n:xen", $type, $EMULAB_NS)->pop();
    return undef
	if (!defined($settings));
    
    my $tmp = GetText("cores", $settings);
    $result->{"cores"} = $tmp
	if (defined($tmp));
    $tmp = GetText("ram", $settings);
    $result->{"ram"} = $tmp
	if (defined($tmp));
    $tmp = GetText("disk", $settings);
    $result->{"disk"} = $tmp
	if (defined($tmp));

    return $result;
}

sub GetDockerSettings($)
{
    my ($node) = @_;
    my $result = {};

    my $type = FindFirst("n:sliver_type", $node);
    return undef
	if (!defined($type));
    
    my $settings = FindNodesNS("n:docker", $type, $EMULAB_NS)->pop();
    return undef
	if (!defined($settings));
    
    my $tmp = GetText("cores", $settings);
    $result->{"cores"} = $tmp
	if (defined($tmp));
    $tmp = GetText("ram", $settings);
    $result->{"ram"} = $tmp
	if (defined($tmp));
    $tmp = GetText("extimage", $settings);
    $result->{"extimage"} = $tmp
	if (defined($tmp));
    $tmp = GetText("extserver", $settings);
    $result->{"extserver"} = $tmp
	if (defined($tmp));
    $tmp = GetText("extuser", $settings);
    $result->{"extuser"} = $tmp
	if (defined($tmp));
    $tmp = GetText("extpassword", $settings);
    $result->{"extpassword"} = $tmp
	if (defined($tmp));
    $tmp = GetText("dockerfile", $settings);
    $result->{"dockerfile"} = $tmp
	if (defined($tmp));
    $tmp = GetText("tbaugmentation", $settings);
    $result->{"tbaugmentation"} = $tmp
	if (defined($tmp));
    $tmp = GetText("tbaugmentation_update", $settings);
    $result->{"tbaugmentation_update"} = $tmp
	if (defined($tmp));
    $tmp = GetText("ssh_style", $settings);
    $result->{"ssh_style"} = $tmp
	if (defined($tmp));
    $tmp = GetText("exec_shell", $settings);
    $result->{"exec_shell"} = $tmp
	if (defined($tmp));
    $tmp = GetText("entrypoint", $settings);
    $result->{"entrypoint"} = $tmp
	if (defined($tmp));
    $tmp = GetText("cmd", $settings);
    $result->{"cmd"} = $tmp
	if (defined($tmp));
    $tmp = GetText("env", $settings);
    $result->{"env"} = $tmp
	if (defined($tmp));
    $tmp = GetText("privileged", $settings);
    $result->{"privileged"} = $tmp
	if (defined($tmp));

    return $result;
}

sub GetElabInElabSettings($)
{
    my ($ref) = @_;
    my $result = {};

    my $settings = FindNodesNS("n:elabinelab", $ref, $EMULAB_NS)->pop();
    return undef
	if (!defined($settings));
    
    foreach my $attr ($settings->attributes()) {
	$result->{$attr->nodeName} = $attr->getValue();
    }
    return $result;
}

#
# Experiment firewalls are different then node firewalls
#
sub GetExperimentFirewallSettings($)
{
    my ($node) = @_;
    my $style  = "basic";
    my @rules  = ();

    my $type = FindFirst("n:sliver_type", $node);
    return undef
	if (!defined($type));
    
    my $settings = FindNodesNS("n:firewall_config", $type, $EMULAB_NS)->pop();
    return undef
	if (!defined($settings));
    
    my $tmp = GetText("style", $settings);
    $style = $tmp
	if (defined($tmp));

    foreach my $ruleref (FindNodesNS("n:rule", $settings,
				     $EMULAB_NS)->get_nodelist()) {
	my $rule = $ruleref->textContent();
	push(@rules, $rule);
    }
    return { "style" => $style, "rules" => \@rules };
}

sub HasFirewallSettings($)
{
    my ($node) = @_;

    my @settings = FindNodesNS("n:firewall", $node,
			       $EMULAB_NS)->get_nodelist();
    return 1
	if (@settings);

    return 0;
}

sub GetFirewallSettings($)
{
    my ($node) = @_;
    my $result = { "style"      => "basic",
		   "exceptions" => [] };

    my $settings = FindNodesNS("n:firewall", $node, $EMULAB_NS)->pop();
    return undef
	if (!defined($settings));

    my $tmp = GetText("style", $settings);
    $result->{"style"} = $tmp
	if (defined($tmp));

    foreach my $exception (FindNodesNS("n:firewall/n:exception", $node,
				       $EMULAB_NS)->get_nodelist()) {
	my $port = GetText("port", $exception);
	next
	    if (!defined($port));
	my $foo = {"port" => $port};
	my $ip  = GetText("ip", $exception);
	$foo->{'ip'} = $ip
	    if (defined($ip));
	my $dir  = GetText("direction", $exception);
	$foo->{'direction'} = $dir
	    if (defined($dir));
	
	push(@{ $result->{'exceptions'} }, $foo);
    }
    return $result;
}

sub HasTagSetting($)
{
    my ($link) = @_;
    my @tagged = FindNodesNS("n:vlan_tagging", $link,
			     $EMULAB_NS)->get_nodelist();
    return scalar(@tagged);
}

sub HasMultiplexSetting($)
{
    my ($link) = @_;
    my @tmp    = FindNodesNS("n:link_multiplexing", $link,
			     $EMULAB_NS)->get_nodelist();
    return scalar(@tmp);
}

sub NoInterSwitch($)
{
    my ($link) = @_;
    my $result = 0;
    my @tmp = FindNodesNS("n:interswitch", $link,
			     $EMULAB_NS)->get_nodelist();
    if (scalar(@tmp) > 0) {
	my $allow = GetText("allow", $tmp[0]);
	$result = (defined($allow) && $allow eq "false" ? 1 : 0);
    }
    return $result;
}

sub HasBestEffortSetting($)
{
    my ($link) = @_;
    my @tagged = FindNodesNS("n:best_effort", $link,
			     $EMULAB_NS)->get_nodelist();
    return scalar(@tagged);
}

sub HasForceShapingSetting($)
{
    my ($link) = @_;
    my @foo = FindNodesNS("n:force_shaping", $link,
			  $EMULAB_NS)->get_nodelist();
    return scalar(@foo);
}

sub HasJumboFramesSetting($)
{
    my ($link) = @_;
    my @foo = FindNodesNS("n:jumboframes", $link,
			  $EMULAB_NS)->get_nodelist();
    return scalar(@foo);
}

sub HasNoBandwidthShapingSetting($)
{
    my ($link) = @_;
    my @foo = FindNodesNS("n:force_nobwshaping", $link,
			  $EMULAB_NS)->get_nodelist();
    return scalar(@foo);
}

sub HasTrivialSetting($)
{
    my ($link) = @_;
    my @tmp = FindNodesNS("n:trivial_ok", $link,
			  $EMULAB_NS)->get_nodelist();
    return scalar(@tmp);
}

sub IsUntaggedLan($)
{
    my ($link) = @_;
    my $result = 0;
    my @tagged = FindNodesNS("n:vlan_tagging", $link,
			     $EMULAB_NS)->get_nodelist();
    if (scalar(@tagged) > 0) {
	my $enabled = GetText("enabled", $tagged[0]);
	$result = defined($enabled) && $enabled eq "false";
    }
    return $result;
}

sub IsTaggedLan($)
{
    my ($link) = @_;
    my $result = 0;
    my @tagged = FindNodesNS("n:vlan_tagging", $link,
			     $EMULAB_NS)->get_nodelist();
    if (scalar(@tagged) > 0) {
	my $enabled = GetText("enabled", $tagged[0]);
	$result = defined($enabled) && $enabled eq "true";
    }
    return $result;
}

sub IsMultiplexedLan($)
{
    my ($link) = @_;
    my $result = 0;
    my @tmp    = FindNodesNS("n:link_multiplexing", $link,
			     $EMULAB_NS)->get_nodelist();
    if (scalar(@tmp) > 0) {
	my $enabled = GetText("enabled", $tmp[0]);
	$result = defined($enabled) && $enabled eq "true";
    }
    return $result;
}

sub TrivialOkay($)
{
    my ($link) = @_;
    my $result = 0;
    my @tmp    = FindNodesNS("n:trivial_ok", $link,
			     $EMULAB_NS)->get_nodelist();
    if (scalar(@tmp) > 0) {
	my $enabled = GetText("enabled", $tmp[0]);
	$result = defined($enabled) && $enabled eq "true";
    }
    return $result;
}

sub RoutableControlIP($)
{
    my ($node) = @_;
    
    my @routable_control_ip =
	GeniXML::FindNodesNS("n:routable_control_ip", $node,
			     $GeniXML::EMULAB_NS)->get_nodelist();
    return scalar(@routable_control_ip);
}
    
sub GetAddressPools($)
{
    my ($rspec) = @_;
    my $result = [];
    my @pools = FindNodesNS("n:routable_pool", $rspec,
			    $EMULAB_NS)->get_nodelist();
    foreach my $pool (@pools) {
	my $client_id = GetText("client_id", $pool);
	my $count = GetText("count", $pool);
	my $type = GetText("type", $pool);
	my $cmurn = GetText("component_manager_id", $pool);
	my $list = [];

	my @ips = FindNodesNS("n:ipv4", $pool,
			      $EMULAB_NS)->get_nodelist();
	foreach my $ipref (@ips) {
	    my $ip = GetText("address", $ipref);
	    my $mask = GetText("mask", $ipref);
	    push(@{$list}, {"ipv4" => $ip, "mask" => $mask});
	}
	push(@{ $result },
	     {
		 "client_id" => $client_id,
		 "count" => $count,
		 "type" => $type,
		 "cmurn" => $cmurn,
		 "list" => $list,
	     });
    }
    return $result;
}

sub RoutingStyle($)
{
    my ($rspec) = @_;
    my $result  = undef;
    my $element = FindNodesNS("n:routing_style", $rspec, $EMULAB_NS)->pop();
    if (defined($element)) {
	$result = GetText("style", $element);
    }
    return $result;
}

sub DelayImage($)
{
    my ($rspec) = @_;
    my $result  = undef;
    my $element = FindNodesNS("n:delay_image", $rspec, $EMULAB_NS)->pop();
    if (defined($element)) {
	$result = GetText("urn", $element);
    }
    return $result;
}

sub GetSharedLanName($)
{
    my ($iface) = @_;

    if (! IsVersion0($iface)) {
	my $interface_name = FindNodesNS("n:link_shared_vlan", $iface,
					 $SHAREDVLAN_NS)->pop();
	if (! defined($interface_name)) {
	    $interface_name = FindNodesNS("n:link_shared_vlan", $iface,
					  $SHAREDVLAN_PG_NS)->pop();
	}
	if (defined($interface_name)) {
	    my $name = GetText("name", $interface_name);
	    if (defined($name) and $name ne "") {
		return $name;
	    }
	}
    }
    return undef;
}

sub CreateSharedLan($)
{
    my ($linkref) = @_;

    return undef
	if (IsVersion0($linkref));
    
    my $ref = FindNodesNS("n:create_shared_vlan",
			  $linkref, $SHAREDVLAN_NS)->pop();
    if (!defined($ref)) {
	$ref = FindNodesNS("n:link_shared_vlan", $linkref,
			   $SHAREDVLAN_PG_NS)->pop();
    }
    if (defined($ref)) {
	my $name = GetText("name", $ref);
	if (defined($name) and $name ne "") {
	    return $name;
	}
    }
    return undef;
}

# Takes an attribute/element name, *NOT AN XPATH* and a node and sets
# the text of that node to a particular value. If the node is an
# attribute, the value is set. If it is an element with just a text
# node child, that node is replaced.
# Returns 1 on success and 0 on failure.
sub SetText($$$)
{
    my ($name, $node, $text) = @_;
    my $result = 0;
    my $child = FindFirst('@n:'.$name, $node);
    if (! defined($child)) {
	$child = FindFirst('@'.$name, $node);
    }
    if (defined($child)) {
	if ($child->nodeType() == XML_ATTRIBUTE_NODE) {
	    $child->setValue($text);
	    $result = 1;
	}
    } else {
	$child = FindFirst('n:'.$name, $node);
	if (defined($child)) {
	    my @grand = $child->childNodes();
	    if (scalar(@grand) == 1
		&& $grand[0]->nodeType() == XML_TEXT_NODE) {
		$grand[0]->setData($text);
		$result = 1;
	    } elsif (scalar(@grand) == 0
		     && $child->nodeType() == XML_ELEMENT_NODE) {
		$child->appendText($text);
		$result = 1;
	    }
	} elsif ($node->nodeType() == XML_ELEMENT_NODE) {
	    my $ns = $node->namespaceURI();
	    if (defined($ns)) {
# TODO: Submit bug report for the library. This call is bugged.
#		$node->setAttributeNS($ns, "rs:$name", $text);
		$node->setAttribute($name, $text);
	    } else {
		$node->setAttribute($name, $text);
	    }
	    $result = 1;
	}
    }
    return $result;
}

# Get the text contents of a child of a node with a particular
# name. This can be either an attribute or an element.
sub GetText($$)
{
    my ($name, $node) = @_;
    my $result = undef;
    my $child = FindFirst('@n:'.$name, $node);
    if (! defined($child)) {
	$child = FindFirst('@'.$name, $node);
    }
    if (! defined($child)) {
	$child = FindFirst('n:'.$name, $node);
    }
    if (defined($child)) {
	$result = $child->textContent();
    }
    if (defined($result)) {
	$result =~ s/^\s*(.*)\s*$/$1/s;
    }
    return $result;
}

# Run GetText serially using the initial argument as an XML node
# reference and the remaining arguments as names and return the first
# defined result. Returns undefined if there are no names or if all
# GetText calls return undefined.
sub GetFirstText($@)
{
    my $node = shift(@_);
    my $result = undef;
    foreach my $name (@_) {
	$result = GetText($name, $node);
	if (defined($result)) {
	    last;
	}
    }
    return $result;
}

# Converts the XML representation of a node to a UTF-8 string and
# outputs it as a complete XML document.
sub Serialize($;$)
{
    my ($node, $format) = @_;
    $format = 0 if (!defined($format));
    my $newnode = $node->cloneNode(1);
    return $newnode->toString($format);
}

# Create a new XML document with a given namespace URI and document
# element name.
sub CreateDocument($$)
{
    my ($ns, $name) = @_;
    my $doc = XML::LibXML::Document->createDocument("1.0", "UTF-8");
    my $root = $doc->createElementNS($ns, "$name");
    $doc->setDocumentElement($root);
    return $doc;
}

# Add a new element to a node. The new element will have the given
# name and be otherwise empty.
sub AddElement($$;$)
{
    my ($name, $node, $namespace) = @_;
    my $ns = $namespace;
    if (! defined($namespace)) {
	$ns = $node->namespaceURI();
    }
    my $child = $node->addNewChild($ns, "rs:$name");
    return $child;
}

# Remove a node with a given name from a node. It will be removed
# whether it is an attribute or an element. The name is not an xpath.
sub RemoveChild($$)
{
    my ($name, $node) = @_;
    my $child = FindFirst('@n:'.$name, $node);
    if (! defined($child)) {
	$child = FindFirst('n:'.$name, $node);
    }
    if (defined($child)) {
	$node->removeChild($child);
    }
}

# Replaces a node (oldnode) with a copy of another node (newnode)
sub ReplaceNode($$)
{
    my ($oldnode, $newnode) = @_;
    my $copy = $newnode->cloneNode(1);
    $oldnode->replaceNode($copy);
    return $copy;
}

# checks for the existense of policy in extensions of the given
# credential.
sub PolicyExists($$)
{
    my ($policy, $credential) = @_;
    my $exists = 0;

    return 0
        if (!ref($credential) or !defined($policy));
    my $extensions_elem = $credential->extensions();
    return 0
        if (!defined($extensions_elem));
    my $policies = GeniXML::FindNodesNS("//n:policy_exceptions/*",
          $extensions_elem, $GeniUtil::EXTENSIONS_NS);
    foreach my $epolicy ($policies->get_nodelist) {
        if ($policy eq $epolicy->string_value) {
            $exists = 1;
            last;
        }      
    }       
  
    return $exists;
}

sub GetHopLinkID($)
{
    my ($ref)  = @_;
    my $result = "";
			
    my $link = FindFirst("n:link", $ref);
    if (defined($link)) {
	$result = GetText("id", $link);
    }
    return $result;
}

sub GetHopCapabilitySection($)
{
    my ($hopref) = @_;
    
    #
    # Dig out the section we need from the hop.
    #
    my $tmp = FindFirst("n:link", $hopref);
    $tmp = (FindFirst("n:switchingCapabilityDescriptor", $tmp) ||
	    FindFirst("n:switchingCapabilityDescriptors", $tmp))
	if (defined($tmp));
    $tmp = FindFirst("n:switchingCapabilitySpecificInfo", $tmp)
	if (defined($tmp));
    if (defined($tmp) &&
	FindFirst("n:switchingCapabilitySpecificInfo_L2sc", $tmp)) {
	$tmp = FindFirst("n:switchingCapabilitySpecificInfo_L2sc", $tmp)
    }
    return $tmp;
}

sub GetSuggestedVlanFromHop($)
{
    my ($hopref) = @_;
    my $capref   = GetHopCapabilitySection($hopref);
    return undef
	if (!defined($capref));

    my $tag = GeniXML::GetText("suggestedVLANRange", $capref);
    $tag = undef
	if (defined($tag) && ! looks_like_number($tag));
    return $tag;
}

sub GetAvailableVlanFromHop($)
{
    my ($hopref) = @_;
    my $capref   = GetHopCapabilitySection($hopref);
    return undef
	if (!defined($capref));

    my $tag = GeniXML::GetText("vlanRangeAvailability", $capref);
    return $tag;
}

sub SetVlanTagInHop($$)
{
    my ($hopref, $tag) = @_;

    my $capref = GetHopCapabilitySection($hopref);
    return undef
	if (!defined($capref));

    GeniXML::SetText("vlanRangeAvailability", $capref, "$tag");
    GeniXML::SetText("suggestedVLANRange", $capref, "$tag");
    return 0;
}

sub GetJacksSiteId($)
{
    my ($node) = @_;

    my $site = FindNodesNS("n:site", $node, $JACKS_NS)->pop();
    return undef
	if (!defined($site));

    return GetText("id", $site);
}

sub SetJacksSiteManagerId($$)
{
    my ($node, $urn) = @_;

    my $site = FindNodesNS("n:site", $node, $JACKS_NS)->pop();
    return -1
	if (!defined($site));

    return SetManagerId($site, $urn);
}

sub GetADBTarget($)
{
    my ($node) = @_;

    my $target = GetText( "adb_target", $node );

    return $target
	if( defined( $target ) );

    $node = FindNodesNS( "n:adb_target", $node, $EMULAB_NS )->pop();

    return $node->getAttribute( "target_id" )
	if( defined( $node ) );

    return undef;
}

sub GetProfileParameters($)
{
    my ($rspec) = @_;
    my $result = [];
    my @parameters = FindNodesNS("n:parameter", $rspec,
			    $PROFILE_PARAMETERS_NS)->get_nodelist();
    foreach my $parameter (@parameters) {
	my $name = GetText( "name", $parameter );
	my $value = GetText( "value", $parameter );
	push( @{ $result }, {
	    "name" => $name,
	    "value" => $value
	      } );
    }
    return $result;
}

sub HasRepositories($)
{
    my ($rspec) = @_;
    
    return FindNodesNS("n:repository", $rspec, $EMULAB_NS)->pop();
}

sub GetRepositories($)
{
    my ($rspec) = @_;
    my $result = [];
    
    foreach my $repo (FindNodesNS("n:repository", $rspec,
				  $EMULAB_NS)->get_nodelist()) {
	my $type    = GetText("type", $repo);
	my $url     = GetText("url", $repo);
	my $refspec = GetText("refspec", $repo);
	my $commit  = GetText("commit", $repo);
	
	push(@{ $result }, { "type"     => $type,
			     "url "     => $url,
			     "refspec " => $refspec,
			     "commit"   => $commit});
    }
    return $result;
}

sub GetSpectrum($)
{
    my ($ref)  = @_;
    my @result = ();

    foreach my $element (FindNodesNS("n:spectrum", $ref,
				     $EMULAB_NS)->get_nodelist()) {
	push(@result, {
	    "frequency_low"  => GetText("frequency_low", $element),
	    "frequency_high" => GetText("frequency_high", $element),
	    "power"          => GetText("power", $element)});
    }
    return \@result;
}
sub GetFrontend($)
{
    my ($ref)  = @_;
    my @result = ();

    my $frontend = FindNodesNS("n:frontend", $ref, $EMULAB_NS)->pop();
    return undef
	if (!defined($frontend));

    return GetText("name", $frontend);
}
sub GetBusRoutes($)
{
    my ($ref)  = @_;
    my @result = ();

    foreach my $element (FindNodesNS("n:busroute", $ref,
				     $EMULAB_NS)->get_nodelist()) {
	push(@result, {
	    "name"  => GetText("name", $element),
	    "dom"   => $element});
    }
    return \@result;
}

# _Always_ make sure that this 1 is at the end of the file...
1;
