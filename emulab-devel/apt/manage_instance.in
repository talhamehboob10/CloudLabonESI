#!/usr/bin/perl -w
#
# Copyright (c) 2000-2021 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
use English;
use strict;
use Getopt::Std;
use XML::Simple;
use Data::Dumper;
use CGI;
use POSIX ":sys_wait_h";
use POSIX qw(setsid strftime ceil floor);
use File::Temp qw(tempfile tmpnam);
use Date::Parse;
use JSON;

#
# Back-end script to manage APT profiles.
#
sub usage()
{
    print("Usage: manage_instance snapshot instance ".
	  "[-n node_id] [-i imagename] [-u node|all]\n");
    print("Usage: manage_instance consoleurl instance node\n");
    print("Usage: manage_instance terminate instance\n");
    print("Usage: manage_instance refresh instance\n");
    print("Usage: manage_instance reboot instance node_id ...\n");
    print("Usage: manage_instance powercycle instance node_id ...\n");
    print("Usage: manage_instance reload instance node_id ...\n");
    print("Usage: manage_instance recovery instance [-c] node_id\n");
    print("Usage: manage_instance flash instance [-c] node_id\n");
    print("Usage: manage_instance deletenodes instance node_id ...\n");
    print("Usage: manage_instance deleteaggregates instance urn ...\n");
    print("Usage: manage_instance addaggregates instance rspec ...\n");
    print("Usage: manage_instance monitor instance\n");
    print("Usage: manage_instance lockdown instance set|clear user|admin\n");
    print("Usage: manage_instance panic instance set|clear\n");
    print("Usage: manage_instance linktest instance [-k | level]\n");
    print("Usage: manage_instance writecreds instance directory\n");
    print("Usage: manage_instance updatekeys instance [uid] \n");
    print("Usage: manage_instance extend instance ".
	  "[-M] [-m message | -f filename] hours\n");
    print("Usage: manage_instance denyextension instance [-m message] [filename]\n");
    print("Usage: manage_instance maxextension instance\n");
    print("Usage: manage_instance pushextension instance\n");
    print("Usage: manage_instance moreinfo instance [-m message] [filename]\n");
    print("Usage: manage_instance utilization instance\n");
    print("Usage: manage_instance schedterminate instance [-m message] days [filename]\n");
    print("Usage: manage_instance idledata instance\n");
    print("Usage: manage_instance openstackstats instance\n");
    print("Usage: manage_instance getmanifests instance\n");
    print("Usage: manage_instance dumpmanifests instance\n");
    print("Usage: manage_instance pushmanifest instance\n");
    print("Usage: manage_instance warn instance\n");
    print("Usage: manage_instance status instance\n");
    print("Usage: manage_instance applyextensionpolicy instance\n");
    exit(-1);
}
my $optlist     = "dt:s";
my $debug       = 0;
my $silent      = 0;
my $gotlock     = 0;
my $webtask_id;
my $webtask;
my $this_user;
my $geniuser;

#
# Configure variables
#
my $TB		   = "@prefix@";
my $TBOPS          = "@TBOPSEMAIL@";
my $TBLOGS         = "@TBLOGSEMAIL@";
my $OURDOMAIN      = "@OURDOMAIN@";
my $MYURN          = "urn:publicid:IDN+${OURDOMAIN}+authority+cm";
my $PROTOUSER      = "elabman";
my $SUDO           = "/usr/local/bin/sudo";
my $CREATESLIVERS  = "$TB/bin/create_slivers";
my $MANAGEINSTANCE = "$TB/bin/manage_instance";
my $MANAGEIMAGES   = "$TB/bin/manage_images";
my $IMPORTER       = "$TB/sbin/image_import";
my $DESTROYWBSTORE = "$TB/sbin/destroywbstore";
my $WAP            = "$TB/sbin/wap";
my $TBACCT         = "$TB/sbin/tbacct";
my @SAVEARGV       = @ARGV;

#
# Untaint the path
#
$ENV{'PATH'} = "$TB/bin:$TB/sbin:/bin:/usr/bin:/usr/bin:/usr/sbin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1;

#
# Load the Testbed support stuff.
#
use lib "@prefix@/lib";
use EmulabConstants;
use emdb;
use emutil;
use libEmulab;
use libtestbed;
use User;
use Project;
use APT_Profile;
use APT_Instance;
use APT_Geni;
use APT_Utility;
use GeniXML;
use GeniHRN;
use Genixmlrpc;
use GeniResponse;
use GeniSlice;
use GeniImage;
use GeniUser;
use WebTask;
use EmulabFeatures;

# Protos
sub fatal($);
sub UserError($;$);
sub DoSnapshot();
sub DoConsole();
sub DoTerminate();
sub DoSchedTerminate();
sub DoExtend();
sub DoDenyOrMoreInfo($);
sub DoRefresh();
sub DoReboot();
sub DoStart();
sub DoPowerCycle();
sub DoReload();
sub DoRecovery();
sub DoFlash();
sub DoLockdown();
sub DoPanic();
sub DoManifests();
sub DoDumpManifests();
sub DoLinktest();
sub DoUpdateKeys();
sub DoDeleteNodes();
sub DoDeleteAggregates();
sub DoAddAggregates();
sub DoUtilization();
sub DoIdleData();
sub DoOpenstack();
sub DoCheckAutoApprove();
sub CheckAutoApprove($$);
sub DoMaxExtension();
sub DoMaxExtensionInternal($$);
sub DoApplyExtensionPolicy();
sub WriteCredentials();
sub StartMonitor();
sub StartMonitorInternal(;$);
sub DoImageTrackerStuff($$$$$$$$);
sub DoWarn();
sub DoDelete();
sub DoStatus();
sub DoPrestageImages();
sub DoPushExtension();
sub DoPushManifest();
sub DoTop();
sub DenyExtensionInternal($);
sub ExtendInternal($$$$$$);
sub CallMethodOnAggregates($$$@);
sub ResponseErrorMessage($$);
sub RelocateImage($$$$);

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"t"})) {
    $webtask_id = $options{"t"};
}
if (defined($options{"d"})) {
    $debug++;
}
if (defined($options{"s"})) {
    $silent = 1;
}
if (@ARGV < 2) {
    usage();
}
my $action   = shift(@ARGV);
my $token    = shift(@ARGV);
my $instance = APT_Instance->Lookup($token);
if (!defined($instance)) {
    $instance = APT_Instance->LookupBySlice($token);
}
#
# Grab the webtask object.
#
if (defined($webtask_id)) {
    $webtask = WebTask->Lookup($webtask_id);
    if (!defined($webtask)) {
	fatal("Could not lookup/create webtask for profile");
    }
    $webtask->AutoStore(1);
}

if (getpwuid($UID) eq "nobody") {
    $this_user = User->ImpliedUser();
}
else  {
    $this_user = User->ThisUser();
}
# If a guest user, we will not have an actual user, which is okay.
if (defined($this_user)) {
    $geniuser = GeniUser->CreateFromLocal($this_user);
}

if (!defined($instance)) {
    # Lets not make this a fatal error; when coming from the web interface,
    # we do not need to send email. 
    UserError("No such instance $token", GENIRESPONSE_SEARCHFAILED());
}
my $uuid = $instance->uuid();

if ($action eq "snapshot") {
    DoSnapshot();
}
if ($action eq "extend") {
    DoExtend();
}
elsif ($action eq "denyextension") {
    DoDenyOrMoreInfo("deny")
}
elsif ($action eq "moreinfo") {
    DoDenyOrMoreInfo("info")
}
elsif ($action eq "consoleurl") {
    DoConsole()
}
elsif ($action eq "terminate") {
    DoTerminate()
}
elsif ($action eq "warn") {
    DoWarn()
}
elsif ($action eq "schedterminate") {
    DoSchedTerminate()
}
elsif ($action eq "refresh") {
    DoRefresh()
}
elsif ($action eq "powercycle") {
    DoPowerCycle()
}
elsif ($action eq "reboot") {
    DoReboot()
}
elsif ($action eq "reload") {
    DoReload()
}
elsif ($action eq "start") {
    DoStart()
}
elsif ($action eq "recovery") {
    DoRecovery()
}
elsif ($action eq "flash") {
    DoFlash()
}
elsif ($action eq "monitor") {
    StartMonitor()
}
elsif ($action eq "lockdown") {
    DoLockdown()
}
elsif ($action eq "panic") {
    DoPanic()
}
elsif ($action eq "linktest") {
    DoLinktest()
}
elsif ($action eq "updatekeys") {
    DoUpdateKeys()
}
elsif ($action eq "writecreds") {
    WriteCredentials()
}
elsif ($action eq "getmanifests") {
    DoManifests()
}
elsif ($action eq "dumpmanifests") {
    DoDumpManifests()
}
elsif ($action eq "deletenodes") {
    DoDeleteNodes()
}
elsif ($action eq "deleteaggregates") {
    DoDeleteAggregates()
}
elsif ($action eq "addaggregates") {
    DoAddAggregates()
}
elsif ($action eq "utilization") {
    DoUtilization()
}
elsif ($action eq "idledata") {
    DoIdleData()
}
elsif ($action eq "openstackstats") {
    DoOpenstack()
}
elsif ($action eq "maxextension") {
    DoMaxExtension()
}
elsif ($action eq "checkautoapprove") {
    DoCheckAutoApprove()
}
elsif ($action eq "applyextensionpolicy") {
    DoApplyExtensionPolicy()
}
elsif ($action eq "delete") {
    DoDelete()
}
elsif ($action eq "status") {
    DoStatus()
}
elsif ($action eq "prestageimages") {
    DoPrestageImages()
}
elsif ($action eq "pushextension") {
    DoPushExtension()
}
elsif ($action eq "pushmanifest") {
    DoPushManifest()
}
elsif ($action eq "top") {
    DoTop()
}
else {
    usage();
}
exit(0);

#
# Take a snapshot. Implies a single node instance, for now.
#
sub DoSnapshot()
{
    my $errmsg;
    my $logfile;
    my $errcode        = -1;
    my $exitcode       = -1;
    my $needunlock     = 0;
    my $old_status     = $instance->status();
    my $node_id;
    my $imagename;
    my $description;
    my $cloneprofile;
    my $update_profile;
    my $copyback_uuid;
    my $copyback_urn;
    my $copyback_hash;
    my $swebtask;
    my $nosnapshot     = 0;
    my $mustnotexist   = 0;
    my $wholedisk      = 0;
    my $update_prepare = 0;
    my $doversions = 0;
    my $usetracker = 0;
    my $relocate   = 0;
    my $operation  = "image-only"; # Default to just snapshot.

    my $optlist = "n:i:u:Uc:O:SseD:";
    my %options = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }
    if (defined($options{"n"})) {
	$node_id = $options{"n"};
    }
    if (defined($options{"i"})) {
	$imagename = $options{"i"};
    }
    if (defined($options{"c"})) {
	$cloneprofile = $options{"c"};
    }
    if (defined($options{"u"})) {
	$update_profile = $options{"u"};
	if ($update_profile !~ /^(node|all)$/) {
	    usage();
	}
    }
    if (defined($options{"U"})) {
	$update_prepare = 1;
    }
    if (defined($options{"D"})) {
	$description = ReadFile($options{"D"});
    }
    if (defined($options{"s"})) {
	$nosnapshot = 1;
    }
    if (defined($options{"e"})) {
	$wholedisk = 1;
	# Must be a brand new image for wholedisk. 
	$mustnotexist = 1;
    }
    if (defined($options{"S"})) {
	$nosnapshot = 1;
	$mustnotexist = 1;
    }
    if (defined($options{"O"})) {
	$operation = $options{"O"};
	if ($operation !~
	    /^(update-profile|copy-profile|new-profile|image-only)$/) {
	    usage();
	}
	if ($operation eq "update-profile") {
	    $update_profile = "node";
	}
    }
    if (defined($cloneprofile) && defined($update_profile)) {
	fatal("Not allowed to update profile when cloning a profile");
    }
    if (defined($cloneprofile) && !defined($imagename)) {
	fatal("Must supply image name when cloning a profile");
    }
    if ($old_status ne "ready") {
	fatal("Instance must be in the ready state to take a snapshot");
    }
    my $slice = $instance->GetGeniSlice();
    if (!defined($slice)) {
	fatal("No slice for quick VM: $uuid");
    }
    
    #
    # Might be a clone (manage_profile).
    #
    my $sliver_urn;
    my $aggregate;
    my $node;
    my $profile;

    if (defined($cloneprofile)) {
	$profile = APT_Profile->Lookup($cloneprofile);
    }
    else {
	$profile = APT_Profile->Lookup($instance->profile_id());
    }
    if (!defined($profile)) {
	fatal("Could not lookup profile for " .
	      (defined($cloneprofile) ? "cloning" : "snapshot"));
    }
    my $project = Project->Lookup($profile->pid_idx());
    if (!defined($project)) {
	fatal("Could not lookup project for $profile");
    }
    
    #
    # Sanity checks. 
    #
    my @aggs = $instance->AggregateList();
    if (! @aggs) {
	fatal("No slivers for instance!");
    }
    if (!defined($node_id)) {
	# We snapshot the one node in the instance.
	if (@aggs != 1) {
	    fatal("Too many aggregates (> 1) to snapshot");
	}
	my ($agg) = @aggs;
	my $manifest = GeniXML::Parse($agg->manifest());
	if (! defined($manifest)) {
	    fatal("Could not parse manifest for $agg");
	}
	my @nodes = GeniXML::FindNodes("n:node", $manifest)->get_nodelist();
	if (@nodes != 1) {
	    fatal("Too many nodes (> 1) to snapshot");
	}
	($node)     = @nodes;
	$sliver_urn = GeniXML::GetSliverId($node);
	$node_id    = GeniXML::GetVirtualId($node);
	$aggregate  = $agg;
	# Profile Snapshot, always use the profile name. Clone passes in name.
	if (!defined($imagename)) {
	    $imagename = $profile->name();
	}
    }
    else {
	my $nodecount = 0;
	
	# Find the node in its manifest.
	foreach my $agg (@aggs) {
	    my $manifest = GeniXML::Parse($agg->manifest());
	    if (! defined($manifest)) {
		fatal("Could not parse manifest for $agg");
	    }
	    foreach my $ref (GeniXML::FindNodes("n:node",
					$manifest)->get_nodelist(),
			     GeniXML::FindNodesNS("n:vhost", $manifest,
					$GeniXML::EMULAB_NS)->get_nodelist()) {
		$nodecount++;
		
		my $client_id   = GeniXML::GetVirtualId($ref);
		my $manager_urn = GetManagerId($ref);
		my $urn          = GeniXML::GetSliverId($ref);

		# No sliver urn or a different aggregate.
		next
		    if (! (defined($urn) &&
			   defined($manager_urn) &&
			   $manager_urn eq $agg->aggregate_urn()));

		if ($node_id eq $client_id) {
		    $node = $ref;
		    $sliver_urn = $urn;
		    $aggregate = $agg;
		    last;
		}
	    }
	}
	if (!defined($sliver_urn)) {
	    fatal("Could not find node '$node_id' in manifest");
	}
	#
	# So, we want Profile snapshot above (of a single node profile) and
	# Node snapshot in a single node profile to behave the same wrt the
	# image name, so look at the nodecount to see if need to append the
	# nodeid to the imagename. 
	#
	if (!defined($imagename)) {
	    $imagename = $profile->name();
	    if ($nodecount > 1) {
		$imagename .= "." . $node_id;
	    }
	}
    }
    #
    # Make sure a valid imagename. This a local test of course, but this
    # only works on IG aggregates anyway.
    #
    if (! TBcheck_dbslot($imagename, "images",
			 "imagename", TBDB_CHECKDBSLOT_ERROR)) {
	$errmsg   = "Invalid imagename: " . TBFieldErrorString() . "\n";
	$errcode  = GENIRESPONSE_ERROR;
	$exitcode = 1;
	goto uerror;
    }
    
    #
    # Instruct the remote cluster to copy the image back to its origin,
    # but we need to ask the IMS for uuid of the image that is running,
    # so we can tell the cluster, which then tells the origin cluster.
    # We also need to know what the new URN of the image will be, for
    # updating the profile. 
    #
    if (GetSiteVar("protogeni/use_imagetracker") &&	
	EmulabFeatures->FeatureEnabled("APT_UseImageTracker",
					   $this_user, $project)) {
	$usetracker = 1;

	#
	# When cloning, we use the URN returned by the cluster; it is
	# the origin of the new image.
	#
	if (!defined($cloneprofile)) {
	    my $rval = DoImageTrackerStuff($aggregate, $node, $project,
					   $imagename,
					   \$copyback_uuid, \$copyback_urn,
					   \$relocate, \$errmsg);
	    if ($rval) {
		if ($rval < 0) {
		    fatal($errmsg);
		}
		else {
		    $errcode  = GENIRESPONSE_ERROR;
		    $exitcode = 1;
		    goto uerror;
		}
	    }
	}
	elsif ($aggregate->GetAptAggregate()->nolocalimages()) {
	    $relocate = 1;
	}
    }
    if (0) {
	fatal("$copyback_uuid, $copyback_urn, $relocate\n");
    }

    #
    # We are not going to allow this if the instance is on a different
    # cluster then where the image was originally created, since otherwise
    # the image provenancewill look like spaghetti. 
    #
    if (defined($update_profile)) {
	my $diskref = GeniXML::GetDiskImage($node);
	if (defined($diskref)) {
	    my $authority = $aggregate->GetGeniAuthority();
	    my $image_url = GeniXML::GetText("url", $diskref);
	    if (defined($image_url) && !$usetracker) {
		require URI;

		# Get the hostname for the image URL.
		my $uri = URI->new($image_url);
		if (!defined($uri)) {
		    fatal("Could not parse $image_url");
		}
		my $image_host = $uri->host();

		# Get the hostname for the authority.
		$uri = URI->new($authority->url());
		if (!defined($uri)) {
		    fatal("Could not parse authority URL");
		}
		my $authority_host = $uri->host();

		# Compare domains.
		$image_host =~ s/^([^.]+\.)//;
		$authority_host =~ s/^([^.]+\.)//;
	
		if ($image_host ne $authority_host) {
		    $errmsg  = "Not allowed to take a snapshot on this cluster";
		    $errcode  = GENIRESPONSE_ERROR;
		    $exitcode = 1;
		    goto uerror;
		}
	    }
	}
	# Do this here to avoid output to logfile.
	$doversions =
	    EmulabFeatures->FeatureEnabled("APT_ProfileVersions",
					   $this_user, $project);
    }
    if ($slice->Lock()) {
	$errmsg  = "Experiment is busy, please try again later.";
	$errcode = GENIRESPONSE_BUSY;
	$exitcode = 1;
	goto uerror;
    }
    $needunlock = 1;

    if (!$nosnapshot) {
	#
	# Grab the webtask, but only after we have it locked, since we are
	# going to modify it. This is a different webtask then the one we
	# got on the command line. The command line webtask is for reporting
	# he results of the command, while the instance webtask is used to
	# report ongoing status of the imaging operation (to the web UI).
	#
	$swebtask = $instance->webtask();
	# We reuse this so clear it.
	$swebtask->Reset();
	$swebtask->AutoStore(1);
	# These are for the web server (imaging status).
	$swebtask->aggregate_urn($aggregate->aggregate_urn());
	$swebtask->client_id($node_id);
	$swebtask->operation($operation) if (defined($operation));
	$swebtask->imagename($imagename);
	
	$instance->SetStatus("imaging");
	$aggregate->SetStatus("imaging");
    }

    # Shorten default timeout
    Genixmlrpc->SetTimeout(60);

    if ($relocate) {
	#
	# When relocating an image back here, the URN we get back from
	# the cluster is not the URN the user is going to use. We need
	# to form a local URN to use after the copy back. 
	#
	# XXX Need to check if we can use the URN earlier in the process.
	#
	$copyback_urn = GeniHRN::GenerateImage($OURDOMAIN, $instance->pid(),
					       $imagename, undef);
    }
    
    #
    # This returns pretty fast, and then the imaging takes place in
    # the background at the aggregate. 
    #
    my $response =
	$aggregate->CreateImage($sliver_urn, $imagename,
 				$update_prepare, $copyback_uuid,
				undef, $nosnapshot, $mustnotexist, $wholedisk,
				$description,
				$relocate ? $copyback_urn : undef);
    if ($response->code() != GENIRESPONSE_SUCCESS) {
	$errcode = $response->code();
	($exitcode,$errmsg) = ResponseErrorMessage($aggregate, $response);
	# Important to tell web user about these.
	if ($response->code() == GENIRESPONSE_NOSPACE ||
	    $response->code() == GENIRESPONSE_FORBIDDEN || 
	    $response->code() == GENIRESPONSE_REFUSED || 
	    $response->code() == GENIRESPONSE_ALREADYEXISTS) {
	    $exitcode = 1;
	}
	if (!$nosnapshot) {
	    $instance->SetStatus($old_status);
	    $aggregate->SetStatus($old_status);
	}
	goto uerror;
    }
    my ($image_urn, $image_url,
	$version_urn, $version_url) = @{ $response->value() };

    if ((!defined($version_urn) || $version_urn =~ /:0$/) && !$relocate) {
	#
	# For version zero, kill the version number.
	#
	$version_urn = $image_urn;
	$version_url = $image_url
    }
    my $image_name;

    # When using the image server we use URNs. 
    if ($usetracker) {
	# DoImageTrackerStuff determined that we use whatever the cluster
	# tells us, cause it is the home of the image.
	if (!defined($copyback_urn)) {
	    $image_name = $version_urn;
	}
	else {
	    $image_name = $copyback_urn;
	}
    }
    elsif ($aggregate->OnLocalCluster()) {
	$image_name = $version_urn;
    }
    else {
	$image_name = $version_url;
    }
    
    if ($nosnapshot) {
	if (defined($webtask)) {
	    $webtask->image_urn($version_urn);
	    $webtask->image_url($version_url);
	    $webtask->image_name($image_name);
	}
	print "$version_urn,$version_url,$image_name\n";
	$slice->UnLock();
	exit(0);
    }
    if (defined($swebtask)) {
	$swebtask->image_urn($version_urn);
	$swebtask->image_url($version_url);
	$swebtask->image_name($image_name);

	# We tell the web interface that the image has to be copied
	# back,
	if (defined($copyback_urn)) {
	    $swebtask->copyback_urn($copyback_urn);
	}
    }
    print "$version_urn,$version_url,$image_name\n";

    #
    # Exit and leave child to poll.
    #
    if (! $debug) {
        $logfile = TBMakeLogname("snapshot");
	
	if (my $childpid = TBBackGround($logfile)) {
	    # Parent exits normally, web interface watches.
	    exit(0);
	}
	# Let parent exit;
	sleep(2);
    }
    # Bind the process id. This is important when the caller is
    # manage_profile, doing a clone.
    $webtask->SetProcessID($PID)
	if (defined($webtask));

    #
    # Poll for a reasonable amount of time.
    #
    my $seconds  = 1500;
    my $interval = 15;
    my $ready    = 0;
    my $sliver_ready = 0;
    my $failed   = 0;

    while ($seconds > 0) {
	sleep($interval);
	$seconds -= $interval;
    
	my $response = $aggregate->SliceStatus();
	if ($response->code() != GENIRESPONSE_SUCCESS &&
	    $response->code() != GENIRESPONSE_NETWORK_ERROR &&
	    $response->code() != GENIRESPONSE_SERVER_UNAVAILABLE &&
	    $response->code() != GENIRESPONSE_BUSY) {
	    $errmsg = "Sliverstatus failed: ". $response->output() . "\n";
	    $failed = 1;
	    last;
	}
	next
	    if ($response->code() == GENIRESPONSE_BUSY ||
		$response->code() == GENIRESPONSE_SERVER_UNAVAILABLE ||
		$response->code() == GENIRESPONSE_NETWORK_ERROR);

	my $blob = $response->value();
	# This is the per-aggregate status, we always set this for web UI.
	$aggregate->UpdateSliverStatusAll($blob->{'details'});
	
	if ($blob->{'status'} eq "failed") {
	    $failed = 1;
	    last;
	}
	elsif ($blob->{'status'} eq "ready") {
	    $sliver_ready = 1;
	}
	
	#
	# We are watching for the image status to report ready or failed.
	#
	$response = $aggregate->ImageInfo($image_urn);
	if ($response->code() != GENIRESPONSE_SUCCESS &&
	    $response->code() != GENIRESPONSE_NETWORK_ERROR &&
	    $response->code() != GENIRESPONSE_SERVER_UNAVAILABLE &&
	    $response->code() != GENIRESPONSE_BUSY) {
	    $errmsg = "Imageinfo failed: ". $response->output() . "\n";
	    $failed = 1;
	    last;
	}
	next
	    if ($response->code() == GENIRESPONSE_BUSY ||
		$response->code() == GENIRESPONSE_SERVER_UNAVAILABLE ||
		$response->code() == GENIRESPONSE_NETWORK_ERROR);

	my $imageblob = $response->value();
	# print Dumper($imageblob);
	if (defined($swebtask)) {
	    my %blobcopy = %{ $imageblob };

	    #
	    # If the image is ready, but needs to be copied back to
	    # its origin, hold off ready till later. We will wait for
	    # the copyback to finish, see below.
	    #
	    if ($imageblob->{'status'} eq "ready" && defined($copyback_urn)){
		$blobcopy{'status'} = "copying";
		# Until all clusters updated.
		if (exists($imageblob->{'hash'})) {
		    $copyback_hash = $imageblob->{'hash'};
		}
	    }
	    # This is also being updated by the event system.
	    $instance->UpdateImageStatus(\%blobcopy);
	}
	if ($imageblob->{'status'} eq "ready") {
	    $ready = 1;
	    last;
	}
	elsif ($imageblob->{'status'} eq "failed") {
	    $failed = 1;
	    last;
	}
    }
    # Cause of image status events.
    $swebtask->Refresh()
	if (defined($swebtask));
    
    if ($failed) {
	$errmsg = "Imaging failed"
	    if (!defined($errmsg));
	goto bad;
    }
    elsif (!$ready) {
	$errmsg  = "Imaging timed out";
	$errcode = -2;
	goto bad;
    }
    #
    # We cannot change a geni-lib script profile, so no need to do this.
    # But we can change a portal converted profile.
    #
    elsif (defined($update_profile) &&
	   (!defined($profile->script()) || $profile->portal_converted())) {
	#
	# New image. Might not have changed if the cluster is not doing
	# image versions.
	#
	# DoImageTrackerStuff determined that we use whatever the cluster
	# tells us, cause it is the home of the image.
	#
	my $newimage = $version_urn
	    if ($usetracker && !defined($copyback_urn));
	# And fall back to url
	$newimage = $version_url
	    if (!defined($newimage));

	#
	# Okay, is the rspec going to change. This is kinda annoying to
	# figure out, so lets just run the code in impotent mode and have
	# it tell us the number of nodes that will get updated.
	#
	my $changed = 
	    $profile->UpdateDiskImage($node_id, $newimage,
				      ($update_profile eq "all" ? 1 : 0), 1);

	if ($changed > 0) {
	    #
	    # Create a new version of the profile and update the rspec
	    # to reflect the new image version. 
	    #
	    if ($doversions) {
		$profile = $profile->NewVersion($this_user);
		if (!defined($profile)) {
		    print STDERR "Could not create new profile version\n";
		    $webtask->Exited(70)
			if (defined($webtask));
		    exit(1);
		}
	    }
	    $profile->UpdateDiskImage($node_id, $newimage,
				      ($update_profile eq "all" ? 1 : 0), 0);
	    $profile->InsertImageRecords();
	    #
	    # For a portal converted profile, we need to regen the script.
	    #
	    if ($profile->portal_converted()) {
		if ($profile->Convert2Genilib() != 0) {
		    fatal("Could not convert rspec to geni-lib");
		}
	    }
	}
    }
    if ($relocate) {
	my $pid = $project->pid();

	if (RelocateImage($instance->pid(),
			  $imagename, $version_urn, $version_url) != 0) {
	    $errmsg  = "Failed to copy image back to the Portal";
	    $errcode = 1;
	    goto bad;
	}
	elsif (defined($swebtask)) {
	    $swebtask->image_status("ready");
	}
    }
    #
    # If there is a copyback_urn, we want to wait for that to finish.
    #
    elsif (defined($copyback_urn)) {
	#
	# We know the copyback is done when the IMS has the info.
	#
	my $copied  = 0;
	$seconds  = 1200;

	while ($seconds > 0) {
	    $seconds -= $interval;

	    #
	    # It would clearly be more more efficient to just look in
	    # the IMS database. 
	    #
	    Genixmlrpc->SetContext(APT_Geni::GeniContext());
	    my $blob = GeniImage::GetImageData($copyback_urn, \$errmsg);
	    Genixmlrpc->SetContext(undef);
	    # We get back undefined if the image is not posted yet.
	    if (defined($blob)) {
		# print Dumper($blob);
		
		#
		# We actually wait for the hash since might not be
		# a versioned image. 
		#
		if (!defined($copyback_hash) ||
		    $copyback_hash eq $blob->{'sha1hash'}) {
		    $copied = 1;
		    last;
		}
	    }
	    sleep($interval);
	}
	# Tell the web interface. 
	if (!$copied) {
	    $errmsg  = "Failed to copy image back to its origin cluster";
	    $errcode = 1;
	    goto bad;
	}
	elsif (defined($swebtask)) {
	    $swebtask->image_status("ready");
	}
    }
    $instance->SetStatus("ready");
    $aggregate->SetStatus("ready");

    $swebtask->Exited(0);
    $webtask->Exited(0)
	if (defined($webtask));
    $slice->UnLock();
    
    if (defined($logfile)) {
	if (-s $logfile) {
	    SENDMAIL($TBOPS,
		     "Instance Snapshot Complete",
		     "Finished taking snapshot of $instance.\n",
		     $TBOPS, undef, $logfile);
	}
	unlink($logfile);
    }
    if (!$sliver_ready) {
	#
	# Image is ready, but sliver is not. Start a monitor so that
	# web interface is updated.
	#
	StartMonitorInternal();
    }
    exit(0);
  bad:
    if (!$sliver_ready) {
	#
	# Image is ready, but sliver is not. Start a monitor so that
	# web interface is updated.
	#
	StartMonitorInternal();
    }
    $instance->SetStatus("ready");
    $aggregate->SetStatus("ready");
    if (defined($logfile)) {
	SENDMAIL($TBOPS,
		 "Snapshot failed",
		 "Error taking snapshot of $instance:\n\n".
		 "$errmsg\n",
		 $TBOPS, undef, $logfile);
	unlink($logfile);
    }
  uerror:
    print STDERR "$errmsg\n";
    if (defined($errmsg) && defined($webtask)) {
	$webtask->Exited($errcode);
	$webtask->output($errmsg);
    }
    # For display in the imaging modal.
    if (defined($errmsg) && defined($swebtask)) {
	$swebtask->Exited($errcode);
	$swebtask->output($errmsg);
    }
    $slice->UnLock()
	if ($needunlock);

    exit($exitcode);
}

sub DoImageTrackerStuff($$$$$$$$)
{
    my ($aggregate, $node, $project, $newname,
	$puuid, $purn, $prelocate, $perrmsg) = @_;
    my $node_id = GeniXML::GetVirtualId($node);
    my $needrelocate = $aggregate->GetAptAggregate()->nolocalimages() ? 1 : 0;
    my $errmsg;

    print "DoImageTrackerStuff: $needrelocate\n";

    #
    # if the target aggregate is us, then obviously no relocate needed.
    #
    $needrelocate = 0
	if ($aggregate->aggregate_urn() eq $MYURN);
    
    #
    # If we do not have a diskinfo section, we will use the URN we get back
    # from the cluster (it is a snapshot of the default image).
    #
    my $diskinfo = GeniXML::GetDiskImage($node);
    if (!defined($diskinfo)) {
	$$prelocate = $needrelocate;
	return 0;
    }

    #
    # This one needs more thought, it might be a URL.
    #
    my $image_token = GeniXML::GetText("name", $diskinfo);
    if (!defined($image_token)) {
	$image_token = GeniXML::GetText("url", $diskinfo);
	if (!defined($image_token)) {
	    $$prelocate = $needrelocate;
	    return 0;
	}
    }
    if (GeniHRN::IsValid($image_token)) {
	my ($auth,$ospid) = GeniHRN::ParseImage($image_token);
	if (!defined($ospid)) {
	    $$perrmsg = "Invalid image urn: $image_token";
	    return 1;
	}
    }
    
    Genixmlrpc->SetContext(APT_Geni::GeniContext());
    my $blob = GeniImage::GetImageData($image_token, \$errmsg);
    Genixmlrpc->SetContext(undef);

    print Dumper($blob);
    
    if (!defined($blob)) {
	if (GeniHRN::IsValid($image_token)) {
	    #
	    # See if this is for a system image (emulab-ops). If it is,
	    # and the domain is not the MS, then retry with a MS URN.
	    #
	    # This is sorta temporary; at some point there will not be any
	    # profiles using the URNs that are not in the image tracker.
	    # Of course a user is free to set the URN to anything the want,
	    # which is why I expect this code to be here for a while. 
	    #
	    my $urn;
	    my $hrn = GeniHRN->new($image_token);
	    my ($auth,$ospid,$os,$vers) = $hrn->ParseImage();
	    if ($ospid eq TBOPSPID() && $auth ne "emulab.net") {
		$urn = GeniHRN::GenerateImage("emulab.net",
						 TBOPSPID(), $os, $vers);
		Genixmlrpc->SetContext(APT_Geni::GeniContext());
		$blob = GeniImage::GetImageData($urn, \$errmsg);
		Genixmlrpc->SetContext(undef);
	    }
	    # Temp fix.
	    if (!defined($blob)) {
		if (lc($hrn->domain()) eq "apt.emulab.net" &&
		    lc($hrn->domain()) eq lc($aggregate->domain())) {
		    return 0;
		}
	    }
	}
	if (!defined($blob)) {
	    $$perrmsg = "Could not get info from the image server for ".
		"$image_token:\n" . $errmsg;
	    return 1;
	}
    }
    #
    # We can look for a deprecated image here and warn the user early.
    #
    if (!$this_user->IsAdmin() &&
	exists($blob->{'deprecated'}) && $blob->{'deprecated'}) {
	$$perrmsg = "$image_token is deprecated; not allowed to clone ".
	    "or snapshot";
	return 1;
    }
        
    #
    # System Image? We use the URN we get back from CreateImage().
    # Image aliases are always system images.
    # The cluster will be the origin for the new image unless it
    # needs to be relocated back home.
    #
    if ((exists($blob->{'issystem'}) && $blob->{'issystem'}) ||
	(exists($blob->{'isimagealias'}) && $blob->{'isimagealias'})) {
	$$prelocate = $needrelocate;
	return 0;
    }

    my $image_urn     = $blob->{'urn'};
    my $copyback_uuid = $blob->{'version_uuid'};
    my $copyback_urn  = $image_urn;

    my $hrn = GeniHRN->Parse($image_urn);
    if (!defined($hrn)) {
	$$perrmsg = "Could not parse $image_urn\n";
	return -1;
    }
    if (!$hrn->IsImage()) {
	$$perrmsg = "$image_urn is not an image URN\n";
	return -1;
    }
    my $projhrn = GeniHRN->Parse($blob->{'project_urn'});
    if (!defined($projhrn)) {
	$$perrmsg = "Could not parse " . $blob->{'project_urn'} . "\n";
	return -1;
    }

    #
    # Whenever we cross projects, we expect the cluster to create
    # a new image. We use the URN that is returned.
    #
    if (lc($projhrn->subauth()) ne lc($project->pid())) {
	# We use the URN we get back from CreateSliver().
	$$prelocate = $needrelocate;
	return 0;
    }

    #
    # What happens if the user is doing a snapshot on the cluster where
    # the image lives? The copyback (import) makes no sense in that case,
    # We can use the URN the cluster returns.
    #
    if (lc($hrn->domain()) eq lc($aggregate->domain())) {
	$$prelocate = $needrelocate;
	return 0;
    }

    #
    # Different cluster
    #
    # Is this node currently running a different image then what
    # the new name will be? Is so, then we expect the cluster to
    # start a new image and we use the URN it returns.
    #
    if ($newname ne $hrn->osname()) {
	$$prelocate = $needrelocate;
	return 0;
    }

    #
    # If we are going to update the profile, we need to know what to
    # change the image urn to, and that depends on what version the
    # image is currently at, AT THE ORIGIN CLUSTER. The urn we get back
    # from the snapshotting cluster is not what we care about, we need
    # a urn for the origin cluster. But that depends on what version the
    # origin cluster is at (the highest numbered version). But if we are
    # doing a snapshot of an earlier version, we cannot generate the
    # version here, we have to ask what it will be. 
    #
    if ($blob->{'isversioned'}) {
	$copyback_urn = GeniHRN::GenerateImage($hrn->authority(),
					       $hrn->ospid(),
					       $hrn->osname(),
					       $blob->{'maxversion'} + 1);
    }
    $$puuid = $copyback_uuid;
    $$purn  = $copyback_urn;
    return 0;
}

#
# Ask the console URL for a node in an instance.
#
sub DoConsole()
{
    my $errmsg;
    usage()
	if (!@ARGV);
    my $node_id = shift(@ARGV);

    #
    # Sanity check to make sure the node is really in the rspec, since
    # we need its sliver urn to ask for the console url.
    #
    my $sliver_urn;
    my $sliver;
    foreach my $obj ($instance->AggregateList()) {
	next
	    if (!defined($obj->manifest()) || $obj->manifest() eq "");
	
	my $manifest = GeniXML::Parse($obj->manifest());
	if (! defined($manifest)) {
	    fatal("Could not parse manifest for $obj");
	}
	my @nodes = (GeniXML::FindNodes("n:node", $manifest)->get_nodelist(),
		     GeniXML::FindNodesNS("n:vhost", $manifest,
					  $GeniXML::EMULAB_NS)->get_nodelist());
	foreach my $node (@nodes) {
	    my $client_id   = GeniXML::GetVirtualId($node);
	    my $urn         = GeniXML::GetSliverId($node);
	    my $manager_urn = GetManagerId($node);

	    # No sliver urn or a different aggregate.
	    next
		if (! (defined($urn) &&
		       defined($manager_urn) &&
		       $manager_urn eq $obj->aggregate_urn()));

	    if ($node_id eq $client_id) {
		$sliver_urn = $urn;
		$sliver = $obj;
	    }
	}
    }
    if (!defined($sliver_urn)) {
	fatal("Could not find node '$node_id' in manifest");
    }
    if ($sliver->GetAptAggregate()->CheckStatus(\$errmsg)) {
	print STDERR "$errmsg\n";
	if (defined($webtask)) {
	    $webtask->output($errmsg);
	    $webtask->Exited(GENIRESPONSE_SERVER_UNAVAILABLE);
	}
	exit(1);
    }
    my $response = $sliver->ConsoleInfo($sliver_urn);

    if ($response->code() == GENIRESPONSE_RPCERROR) {
	print STDERR "RPC Error: " . $response->error() . "\n";
	if (defined($webtask)) {
	    $webtask->output($response->error());
	    $webtask->Exited($response->code());
	}
	exit(-1);
    }
    if ($response->code() == GENIRESPONSE_NETWORK_ERROR ||
	$response->code() == GENIRESPONSE_SERVER_UNAVAILABLE) {
	print STDERR "RPC Error: " . $response->error() . "\n";
	if (defined($webtask)) {
	    $webtask->output($response->error());
	    $webtask->Exited($response->code());
	}
	exit(1);
    }
    if ($response->code() == GENIRESPONSE_UNAVAILABLE) {
	print STDERR "Server says there is no console for $node_id\n";
	if (defined($webtask)) {
	    $webtask->output("Sorry, $node_id does not have a console line");
	    $webtask->Exited($response->code());
	}
	exit(1);
    }
    if ($response->code() == GENIRESPONSE_SEARCHFAILED) {
	print STDERR "Server says $node_id has been deallocated\n";
	if (defined($webtask)) {
	    $webtask->output("Sorry, $node_id has been deallocated");
	    $webtask->Exited($response->code());
	}
	exit(1);
    }
    if ($response->code() == GENIRESPONSE_FORBIDDEN) {
	print STDERR "Server says access to $node_id console is forbidden\n";
	if (defined($webtask)) {
	    $webtask->output("Sorry, access to $node_id console is forbidden");
	    $webtask->Exited($response->code());
	}
	exit(1);
    }
    if ($response->code() == XMLRPC_NO_SUCH_METHOD) {
	print STDERR "Server does not support console access\n";
	if (defined($webtask)) {
	    $webtask->output("Sorry, server does not support console access");
	    $webtask->Exited(GENIRESPONSE_NOT_IMPLEMENTED);
	}
	exit(1);
    }
    if ($response->code() != GENIRESPONSE_SUCCESS) {
	fatal($response->error());
    }
    my $url;
    my $pswd;
    my $logurl;
    my $authobject;
	
    if (ref($response->value())) {
	$url  = $response->value()->{'url'};
	$pswd = $response->value()->{'password'}
	    if (exists($response->value()->{'password'}));
	$logurl = $response->value()->{'logurl'}
	    if (exists($response->value()->{'logurl'}));
	# This is a JSON string, just pass it along.
	if (exists($response->value()->{'authobject'})) {
	    $authobject = $response->value()->{'authobject'};
	}
	print Dumper($response->value());
    }
    else {
	$url = $response->value();
    }
    if (defined($webtask)) {
	if ($response->code()) {
	    $webtask->output($response->error());
	}
	else {
	    $webtask->url($url);
	    $webtask->password($pswd) if (defined($pswd));
	    $webtask->logurl($logurl) if (defined($logurl));
	    $webtask->authobject($authobject) if (defined($authobject));
	}
	$webtask->Exited($response->code());
	exit($response->code());
    }
    # For command line operation too.
    if ($response->code()) {
	fatal($response->error());
    }
    print $url . "\n";
    print $pswd . "\n" if (defined($pswd));
    print $logurl . "\n" if (defined($logurl));
    exit(0);
}

#
# Terminate
#
sub DoTerminate()
{
    my $errmsg;
    my $errcode;
    my $exitcode = 1;
    my $logfile;
    my $doperms  = 0;
    my $takelock = 0;
    my $nolock   = 0;
    my $expired  = $RECORDHISTORY_TERMINATED;

    my $optlist = "eLX";
    my %options = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }
    if (defined($options{"e"})) {
	$expired = $RECORDHISTORY_EXPIRED;
    }
    if (defined($options{"L"})) {
	$takelock = 1;
    }
    if (defined($options{"X"})) {
	$doperms = 1;
    }

    #
    # NOTE: This is called from legacy XMLRPC server, so do a permission
    # check here for it. Only the creator on this path, the web interface
    # will suffice for anyone else.
    #
    if ($doperms) {
	my $creator = $instance->GetGeniUser();
	if (!defined($creator)) {
	    fatal("Cannot lookup creator");
	}
	if (!$this_user->SameUser($creator->emulab_user())) {
	    UserError("Not enough permission to terminate experiment");
	}
    }

    #
    # Admins can terminate a paniced experiment, we will pass along an
    # admin credential to tell the CM its okay.
    #
    if ($instance->paniced() && !$this_user->IsAdmin()) {
	fatal("Only administrators can terminate a paniced experiment")
    }
    
    my $slice = $instance->GetGeniSlice();
    if (!defined($slice)) {
	#
	# No slice (typically) means we never got far enough to the
	# get the sliver created on the backend cluster.
	#
	# Do this just in case, it is harmless.
	#
	if (-x $DESTROYWBSTORE) {
	    system("$DESTROYWBSTORE -B -s FAIL $uuid");
	}
	goto killit;
    }
    #
    # Lock the slice in case it is doing something else, like taking
    # a disk image.
    #
    # When told to take the lock, we take it and go.
    #
    if ($takelock) {
	$slice->TakeLock();
    }
    elsif ($slice->Lock()) {
	sleep(1);
	
	if ($instance->canceled()) {
	    print "Instance is already marked as canceled\n";
	    exit(0);
	}
	
	#
	# A couple of special states where the user can interrupt an
	# experiment that is setting up. This means the user is giving
	# up on it, and we want to tell the aggregate to kill it. Not
	# all aggregates are going to allow this, so need to be able
	# to deal with that.
	#
	if (! ($instance->status() eq "provisioned" ||
	       $instance->status() eq "prestaging")) {
	    $errmsg = "Experiment is busy, unable to lock it";

	    if (defined($webtask)) {
		$webtask->output($errmsg);
		$webtask->Exited(GENIRESPONSE_BUSY);
	    }
	    print STDERR "$errmsg\n";
	    exit(GENIRESPONSE_BUSY);
	}
	print "Marking instance canceled\n";
	$instance->MarkCanceled();
	# We have an obvious race here since we do not have the lock.
	exit(0);
    }
    my $old_status = $instance->status();
    $instance->SetStatus("terminating");

    #
    # If still scheduled, then no reason to save this in the history, it
    # was never started.
    #
    if ($old_status eq "scheduled") {
	goto killit;
    }

    #
    # Exit and let caller poll for status.
    #
    if (!$debug) {
        $logfile = TBMakeLogname("terminate");
	
	if (my $childpid = TBBackGround($logfile)) {
	    my $status = 0;
	    #
	    # Wait a couple of seconds to see if there is going to be an
	    # immediate error. Then return and let it continue to run. This
	    # allows the web server to see quick errors. Later errors will
	    # have to be emailed. 
	    #
	    sleep(5);
	    my $foo = waitpid($childpid, &WNOHANG);
	    if ($foo) {
		$status = $? >> 8;
	    }
	    exit($status);
	}
    }

    #
    # Tell syncthing the instance is terminating. 
    #
    if (-x $DESTROYWBSTORE) {
	print STDERR "Calling $DESTROYWBSTORE\n";
	
	system("$DESTROYWBSTORE -d -B -s ".
	       ($old_status eq "failed" ? "FAIL" : "DONE") . " $uuid");
    }

    # Skip terminated aggregates, since we retry later on failure.
    my @agglist;
    foreach my $agg ($instance->AggregateList()) {
	#
	# Messy here; there is no experiment record at the remote
	# cluster until we get out of image staging, but there are
	# several states that mean we are staging images.
	#
	if ($agg->status() eq "prestage" ||
	    $agg->status() eq "staging" ||
	    $agg->status() eq "staged") {
	    $agg->SetStatus("terminated");
	}
	push(@agglist, $agg)
	    if ($agg->status() ne "terminated");
    }
    my $response;

    #
    # Helper callback to send the proper arguments.
    #
    my $coderef = sub {
	my ($sliver) = @_;

	# Flag that we want to clear the panic, so send an auth credential.
	return $sliver->Terminate($instance->paniced() ? 1 : undef);
    };
    $errcode = CallMethodOnAggregates($coderef, 2, \$response, @agglist);
				      
    if ($errcode) {
	$exitcode = -1;
	$errmsg   = $response;
	goto bad;
    }

    #
    # Look at all the responses, update the status. 
    #
    my @responses = @{$response};
    foreach my $agg (@agglist) {
	my $response = shift(@responses);
	my $code = $response->code();

	# SEARCHFAILED is success too
	if ($code == GENIRESPONSE_SUCCESS ||
	    $code == GENIRESPONSE_SEARCHFAILED) {
	    $agg->MarkTerminated();
	    next;
	}
	($exitcode,$errmsg) = ResponseErrorMessage($agg, $response);
	
	#
	# These will typically clear up at some point so abort
	# sending any email.
	#
	if ($code == GENIRESPONSE_BUSY ||
	    $code == GENIRESPONSE_SERVER_UNAVAILABLE ||
	    $code == GENIRESPONSE_NETWORK_ERROR) {
	    if (defined($logfile)) {
		unlink($logfile);
		$logfile = undef;
	    }
	    $errcode  = $code;
	    $exitcode = 1;
	}
	else {
	    # We are going to send mail below, so exit with positive status
	    # so web interface does not send email.
	    $errcode  = $code;
	    $exitcode = 1;
	}
    }
    # Will have to try again later.
    goto bad
	if ($errcode);

    $instance->SetStatus("terminated");
    $instance->RecordHistory($expired);
    if (defined($logfile)) {
	my $instance_name = $instance->name();
	my $slice_uuid    = $slice->uuid();
	my $brand         = $instance->Brand();
	$brand->SendEmail($brand->LogsEmailAddress(),
			  "manage_instance @SAVEARGV",
			  "Name: $instance_name\n".
			  "Slice: $slice_uuid\n\n",
			  $brand->OpsEmailAddress(),
			  "X-Portal: Terminate", $logfile);
    }
  killit:
    $slice->Delete() if (defined($slice));
    $instance->Delete();
    unlink($logfile)
	if (defined($logfile));
    exit(0);
    
  bad:
    print STDERR $errmsg . "\n";
    $instance->SetStatus($old_status);
    if (defined($logfile)) {
	my $instance_name = $instance->name();
	my $slice_uuid    = $slice->uuid();
	SENDMAIL($TBOPS,
		 "Unable to terminate instance $uuid",
		 "Name: $instance_name\n".
		 "Slice: $slice_uuid\n\n".
		 "$errmsg\n",
		 $TBOPS, undef, $logfile)
	    if (!$silent);
	unlink($logfile);
    }
    if (defined($webtask)) {
	$webtask->output($errmsg);
	$webtask->Exited($errcode);
    }
    #
    # Also, mark the instance as canceled so that the apt daemon will
    # pick it up later (for the case that the instance is not expired)
    #
    $instance->MarkCanceled();
    # User has given up routes, even if we cannot terminate some aggregates.
    $instance->DeleteRoutes();
    $slice->UnLock();
    exit($exitcode);
}

#
# Delete. Do not use this unless you know what you are doing!  It is
# for killing off instances that got into whacked out state cause of
# earlier errors or boss crashing, etc.
#
sub DoDelete()
{
    my $expired = $RECORDHISTORY_TERMINATED;
    my $force   = 0;

    my $optlist = "Fe";
    my %options = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }
    if (defined($options{"F"})) {
	$force = 1;
    }
    if (defined($options{"e"})) {
	$expired = $RECORDHISTORY_EXPIRED;
    }
    if (!$force) {
	fatal("Refusing to do this, use the -F option if you really mean it");
    }
    my $slice = $instance->GetGeniSlice();
    if (!defined($slice)) {
	#
	# No slice (typically) means we never got far enough to the
	# get the sliver created on the backend cluster.
	#
	goto killit;
    }
    $instance->SetStatus("terminated");
    $slice->Delete();
    $instance->RecordHistory($expired);

  killit:
    $instance->Delete();
    exit(0);
}

#
# Request an extension; all this code used to be in PHP, that was silly.
#
sub DoExtend()
{
    my $force    = 0;
    my $doperms  = 0;
    my $errcode  = 1;
    my $autoextend_maximum = GetSiteVar("aptui/autoextend_maximum");
    my $autoextend_maxage  = GetSiteVar("aptui/autoextend_maxage");
    my $autoextend_freedays= 2;
    my $creator       = $instance->GetGeniUser();
    my $slice         = $instance->GetGeniSlice();
    my $name          = $instance->name();
    my $pid           = $instance->pid();
    my $url           = $instance->webURL();
    my $clusters      = join(",", map { $_->domain() }
			     $instance->AggregateList());
    my $pcount        = $instance->physnode_count();
    my $expires_time  = str2time($slice->expires());
    my $created_time  = str2time($instance->started());
    my $extensions    = $instance->Brand()->ExtensionsEmailAddress();
    my $granted       = 0;
    my $needapproval  = 0;
    my $autoapprove_info;
    my $maxextension;
    my $message;
    my $reason;
    my $errmsg;
    my $wantstring;
    my $grantstring;
    
    usage()
	if (!@ARGV);

    my $optlist = "m:f:hFe:X";
    my %options = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }
    usage()
	if (!@ARGV);
    my $wanted = shift(@ARGV);
    
    if (defined($options{"F"})) {
	# Be careful
	if (!$this_user->IsAdmin()) {
	    fatal("Only admins can use the -F option");
	}
	$force = 1;
    }
    if (defined($options{"X"})) {
	$doperms = 1;
    }
    if (defined($options{"m"})) {
	$reason = $options{"m"};
    }
    elsif (defined($options{"f"})) {
	my $filename = $options{"f"};
	if (! -e $filename) {
	    fatal("$filename does not exist");
	}
	open(MSG, $filename) or
	    fatal("Could not open $filename");
	
	$reason = "";
	while (<MSG>) {
	    $reason .= $_;
	}
	close(MSG);
    }
    if (defined($options{"e"})) {
	$maxextension = str2time($options{"e"});
	if (!$maxextension) {
	    $errmsg  = "Illegal max extension date";
	    $errcode = -1;
	    goto bad;
	}	
    }

    #
    # NOTE: This is called from legacy XMLRPC server, so do a permission
    # check here for it. Only the creator on this path, the web interface
    # will suffice for anyone else.
    #
    if ($doperms) {
	if (!defined($creator)) {
	    fatal("Cannot lookup creator");
	}
	if (!$this_user->SameUser($creator->emulab_user())) {
	    UserError("Not enough permission to extend experiment");
	}
    }

    #
    # Lock the slice in case it is doing something else, like taking
    # a disk image.
    #
    if ($slice->Lock()) {
	$errcode = GENIRESPONSE_BUSY;
	$errmsg  ="Experiment is busy, cannot lock it. Try again later.";
	if (defined($webtask)) {
	    $webtask->output($errmsg);
	    $webtask->Exited($errcode);
	}
	print STDERR "$errmsg\n";
	exit($errcode);
    }
    if (defined($reason) &&
	!TBcheck_dbslot($reason, "default", "fulltext",
			 TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	$errmsg  = "Illegal characters in your reason";
	$errcode = 1;
	goto bad;
    }
    # Lets allow a date too.
    if ($wanted !~ /^\d+$/) {
	my $when = str2time($wanted);
	if (!$when) {
	    $errmsg  = "Illegal number of hours or date";
	    $errcode = 1;
	    goto bad;
	}
	$wanted = int(($when - $expires_time) / 3600);
	if ($wanted < 1) {
	    $errmsg  = "Expiration is too soon";
	    $errcode = 1;
	    goto bad;
	}
    }
    
    # Helper function.
    my $needAdminApproval = sub {
	my ($wanted, $granted, $reason, $message) = @_;
	# Subtract out the extra free time we added.
	my $howlong = $wanted - $granted;
	my $new_expires = POSIX::strftime("20%y-%m-%d %H:%M:%S %Z",
					  localtime(str2time($slice->expires())+
						    ($howlong * 3600)));
	my $created     = POSIX::strftime("20%y-%m-%d %H:%M:%S %Z",
				  localtime(str2time($instance->started())));
	$instance->Brand()->SendEmail($extensions,
		"Experiment Extension Request: $name",
		"A request to extend this experiment was made but requires\n".
                "administrator approval" .
                ($message ? " $message" : "") . ".\n\n" .
                "The request was for $wantstring, we granted $grantstring, ".
                "the reason given is:\n\n".
                $reason . "\n\n".
                "This experiment was started on $created\n".
                "Granting the request would set the expiration to $new_expires\n".
                "It is running on $clusters\n".
                "\n\n". $url . "\n\n",
                $creator->email());

	# Flag for the dashboard page. 
	$instance->ExtensionRequested($reason, $granted);

	# Need to return this to the web interface via the webtask.
	return "Your request requires admininstrator approval".
	    ($message ? " $message" : "") . ". " .
	    "You will receive email if/when your ".
	    "request is granted (or denied). Thanks!";
    };

    #
    # If no physical nodes (only VMs), double the maximums.
    #
    if (!$instance->physnode_count()) {
        $autoextend_maxage  *= 2;
        $autoextend_maximum *= 2;
    }

    #
    # Always grant if < 24 hours, unless an extension limit.
    #
    if ($wanted < 24 && !$instance->extension_limit()) {
	$message = "Short extension granted for $wanted hours.";
	$reason  = $message if (!defined($reason));
	$granted = $wanted;
    }
    #
    # Admin user, we do whatever it says to do.
    #
    elsif ($this_user->IsAdmin()) {
	$message = "Your experiment was extended by the site administrator.";
	$granted = $wanted;
    }
    elsif (0) {
	$message = "because we are testing extension stuff";
	$granted = 0;
	$needapproval = 1;
    }
    else {
	my $diff  = $expires_time - time();
	my $cdiff = time() - $created_time;

	if (! defined($reason)) {
	    $errcode = -1;
	    $errmsg  = "You must supply a reason for this extension";
	    goto bad;
	}

	#
	# If admin lockout, we are refusing any more free time.
	#
	if ($instance->extension_disabled()) {
	    $message = "because you are not allowed any more extensions";
	    $granted = 0;
	}
	#
	# Is there an extension limit.
	#
	elsif ($instance->extension_limit()) {
	    my $diff = $expires_time - $created_time;
	    my $max  = 3600 * $instance->extension_limit();

	    if ($diff >= $max) {
		#
		# Already out to the limit.
		#
		$granted = 0;
	    }
	    else {
		#
		# Give them up to as much as the extension limits them to. 
		# Note that this could turn out to be zero.
		#
		if ($diff + ($wanted * 3600) > $max) {
		    $granted = int(($max - $diff) / 3600);
		    $message = "because your extension is limited by local ".
			"policy";
		}
		else {
		    $granted = $wanted;
		}
	    }
	    if ($granted == 0) {
		if (defined($instance->extension_limit_reason())) {
		    $message = $instance->extension_limit_reason();
		}
		else {
		    $message = "because you have exceeded the maximum ".
			"extension allowed by local policy";
		}
		#
		# Mark as admin disabled now so they do not get to ask again,
		# but not if admin_after_limit is set, then it goes through
		# the need admin approval path.
		#
		if ($instance->extension_admin_after_limit()) {
		    $needapproval = 1;
		}
		else {
		    $instance->Update({"extension_disabled" => 1,
				       "extension_disabled_reason" =>$message});
		}
	    }
	    # Avoid any change to granted below.
	    goto grant;
	}
	#
	# After maxage, all extension requests require admin approval.
	#
	elsif ($cdiff > (3600 * 24 * $autoextend_maxage)) {
	    #
	    # Well, if they asked for less then the free grant, and
	    # the experiment is going to expire very soon, we give
	    # them some extra time. This is a nice loophole people will
	    # probably notice.
	    #
	    my $mindiff = $autoextend_freedays * 3600 * 24;
	    
	    if ($diff < $mindiff) {
		$granted = int(($mindiff - $diff) / 3600);
	    }
	    else {
		$granted = 0;
	    }
	    if ($wanted > $granted) {
		if (CheckAutoApprove($wanted, \$autoapprove_info) == 0) {
		    if ($autoapprove_info->{'approve'}) {
			# Informational for now.
			if (0) {
			    $granted = $wanted;
			    goto grant;
			}
		    }
		}
		$needapproval = 1;
		$message = "because it was started more then ".
		    "$autoextend_maxage days ago";
	    }
	}
	#
	# Registered users are granted up to the autoextend_maximum
	# automatically. Beyond that, requires approval, but we still
	# give them whatever the free extension is, since we want to
	# give them extra time until the next meeting of the "resource
	# management committee."
	#
	elsif ($wanted > $autoextend_maximum * 24) {
	    if (CheckAutoApprove($wanted, \$autoapprove_info) == 0) {
		if ($autoapprove_info->{'approve'}) {
		    # Informational for now.
		    if (0) {
			$granted = $wanted;
			goto grant;
		    }
		}
	    }
	    $needapproval = 1;
	    $message = "because it was for longer then $autoextend_maximum days";
	    #
	    # Plenty of time left, no extension just a message.
	    #
	    if ($diff > (3600 * 24 * 3)) {
		$granted = 0;
	    }
	    else {
                $granted = $autoextend_maximum * 24;
	    }
	}
	elsif ($diff > (3600 * 24 * 7)) {
	    my $days = POSIX::ceil($diff / (3600 * 24.0));
	    $errmsg  = "You still have $days day(s) left before expiration!";
	    $errcode = 1;
	    goto bad;
	}
	else {
	    $granted = $wanted;
	}
	#
	# The most we allow is the autoextend_maximum out, no
	# matter what they asked for. So, if the autoextend_maximum
	# is a week and there are five days left and they asked
	# for seven, we give them two.
	#
	if ($granted && ($expires_time + ($granted * 3600)) >
	    (time() + (3600 * 24 * $autoextend_maximum))) {
	    $granted =
		int(((3600 * 24 * $autoextend_maximum) - $diff) / 3600.0);
	}
    }
    #
    # Do the extension.
    #
  grant:
    if ($granted) {
	my $seconds = $granted * 3600;
	    
	if ($errcode = ExtendInternal($slice,
				      $seconds, $force, 0, 1, \$errmsg)) {
	    goto bad;
	}
    }
    my $expires = POSIX::strftime("20%y-%m-%d %H:%M:%S %Z",
				  localtime(str2time($slice->expires())));
    my $created = POSIX::strftime("20%y-%m-%d %H:%M:%S %Z",
				  localtime(str2time($instance->started())));
    my $now     = POSIX::strftime("20%y-%m-%d %H:%M:%S %Z", localtime());
    my $before  = POSIX::strftime("20%y-%m-%d %H:%M:%S %Z",
				  localtime($expires_time));

    # Format hours into days/hours.
    $wantstring  = APT_Instance::HoursToEnglish($wanted);
    $grantstring = APT_Instance::HoursToEnglish($granted);

    #
    # New extension mechanism
    #
    my $extensionargs = {
	"action"   => "request",
	"wanted"   => $wanted,
	"granted"  => $granted,
	"admin"    => $this_user->IsAdmin() ? 1 : 0,
	"expiration" => TBDateStringLocal($expires_time),
    };
    if ($needapproval) {
	$extensionargs->{"needapproval"} = 1;
    }
    if (defined($maxextension)) {
	$extensionargs->{"maxextension"} = TBDateStringLocal($maxextension);
    }
    if (defined($message)) {
	$extensionargs->{"message"} = $message;
    }
    if (defined($reason)) {
	$extensionargs->{"reason"} = $reason;
    }
    if (defined($this_user)) {
    	$extensionargs->{"uid"}     = $this_user->uid();
	$extensionargs->{"uid_idx"} = $this_user->uid_idx();
    }
    else {
	# A guest user, only the creator can request an extension.
    	$extensionargs->{"uid"}     = $instance->creator();
	$extensionargs->{"uid_idx"} = $instance->creator_idx();
    }
    if (defined($autoapprove_info)) {
    	$extensionargs->{"autoapproved"} = $autoapprove_info->{'approve'};
    	$extensionargs->{"autoapproved_reason"} = $autoapprove_info->{'reason'};
	if (defined($autoapprove_info->{'metrics'})) {
	    my $metrics = eval { encode_json($autoapprove_info->{'metrics'}); };
	    if (!$@) {
		$extensionargs->{"autoapproved_metrics"} = $metrics;
	    }
	}
    }
    my $extensioninfo =
	APT_Instance::ExtensionInfo->Create($instance, $extensionargs);
    if (!defined($extensioninfo)) {
	print STDERR "Could not create extension info object\n";
    }

    #
    # We store each extension request in an ongoing text field.
    #
    my $text =
	"Date: $now\n".
	"Wanted: $wantstring, Granted: $grantstring\n".
	"Before: $before\n".
	"After $expires\n".
	"Reason:\n".
	(defined($reason) ? "$reason\n\n" : "\n") .
	"-----------------------------------------------\n";
    $instance->AddExtensionHistory($text);

    if ($needapproval) {
	$errmsg  = &$needAdminApproval($wanted, $granted, $reason, $message);
	# The web interface (JS code) uses this error code. 
	$errcode = 2;
	goto bad;
    }
    my $mailmessage = $message;
	
    if ($this_user->IsAdmin()) {
	$mailmessage .= "\n\n" . $reason if (defined($reason));
    }
    else {
	my $pre = "A request to extend your experiment was made, you were\n".
	    "granted ";
	if ($granted < $wanted) {
	    if ($granted == 0) {
		$pre .= "nothing";
	    }
	    else {
		$pre .= "only $grantstring";
	    }
	    if (defined($mailmessage)) {
		$pre .= " $mailmessage";
	    }
	    $mailmessage = $pre . ". ";
	}
	else {
	    $mailmessage = $pre . $grantstring . ". ";
	}
	$mailmessage .= "\n\n" . "The request was for ${wantstring}.";
	$mailmessage .= "\n\nYour reason was:\n${reason}"
	    if (defined($reason));
    }
    $instance->Brand()->SendEmail($creator->email(),
	       "Experiment Extension: $pid/$name",
	       $mailmessage .
               "\n\n".
               "Your experiment was started on $created\n".
 	       "Your experiment will now expire at $expires\n".
	       "You are using $pcount physical nodes.\n".
               "It is running on $clusters\n\n".
               "$url\n",
	       "$extensions",
	       "BCC: $extensions");
    
    if (!$this_user->IsAdmin()) {
	#
	# We do not want to overwrite the reason in the DB if this
	# was an admin extension, we want to keep whatever the user
	# has written previously. This currently used by the web interface
	# to show the latest reason.
	#
	$instance->Update({"extension_reason" => $reason});
    }
    else {
	#
	# Any time an admin issues an extension, we clear the flag that tells
	# the dashboard page there is an oustanding request.
	#
	$instance->Update({"extension_requested" => 0});
    }
    $instance->BumpExtensionCount($granted);
    if (defined($webtask)) {
	$webtask->granted($granted);
	$webtask->message(defined($message) ? $message : "");
	$webtask->Exited(0);
    }
    $slice->UnLock();
    exit(0);
    
  bad:
    $slice->UnLock();
    print STDERR $errmsg . "\n";
    if (defined($webtask)) {
	$webtask->output($errmsg);
	$webtask->Exited($errcode);
    }
    exit($errcode);
}
sub ExtendInternal($$$$$$)
{
    my ($slice, $seconds, $force, $nolockdown, $savedokay, $perrmsg) = @_;
    my $errcode  = -1;
    my $errmsg;
    my @delayed  = ();
    my @refused  = ();
    my @failed   = ();
    my @busy     = ();
    my $tmp;
    
    # Save in case of error.
    my $oldexpires = str2time($slice->expires());

    #
    # Before we ask the clusters, confirm that there are no conflicting
    # RF reservations for this instance.
    #
    my $rfmax =
	APT_Reservation::Group::RFReservation::MaxExtension($instance, \$tmp);
    if (!defined($rfmax)) {
	# Some kind of error.
	$errmsg  = "Internal error determining Range max extension: $tmp";
	$errcode = -1;
	goto bad;
    }
    if ($debug) {
	print "Range Max extension is $rfmax\n";
    }
    if ($oldexpires + $seconds > $rfmax) {
	if ($debug) {
	    print "New expiration is greater then Range max extension\n";
	    if (defined($tmp)) {
		print "-> $tmp\n";
	    }
	}
	if (!$force) {
	    $errmsg = "Extension refused cause it conflicts with an existing ".
		"Range reservation";
	    $errcode = 1;
	    goto bad;
	}
    }
    # Ditto route reservations.
    my $rmax =
	APT_Reservation::Group::RouteReservation::MaxExtension($instance);
    if (!defined($rmax)) {
	# Some kind of error.
	$errmsg  = "Internal error determining Route max extension";
	$errcode = -1;
	goto bad;
    }
    if ($debug) {
	print "Route Max extension is $rmax\n";
    }
    if ($oldexpires + $seconds > $rmax) {
	if ($debug) {
	    print "New expiration is greater then Route max extension\n";
	}
	if (!$force) {
	    $errmsg = "Extension refused cause it conflicts with an existing ".
		"Range reservation";
	    $errcode = 1;
	    goto bad;
	}
    }
    # Need to update slice before creating new credential. 
    if ($slice->IsExpired()) {
	$slice->SetExpiration(time() + $seconds);
    }
    else {
	$slice->AddToExpiration($seconds);
    }
    my $new_expires = $slice->ExpirationGMT();

    #
    # Helper callback to send the proper arguments.
    #
    my $coderef = sub {
	my ($sliver) = @_;

	return $sliver->Extend($new_expires, $this_user, $force);
    };
    my $responses;

    #
    # The retries could leave the user hanging on the modal for close
    # to a minute, but thats much better then bailing too soon cause of
    # a transient issue.
    #
    $errcode = CallMethodOnAggregates($coderef, 2, \$responses,
				      $instance->AggregateList());
    if ($errcode) {
	$errmsg = $responses;
	goto bad;
    }
    
    #
    # Do not throw an error when its a network error, keep going. If
    # the only error is a network error, we might be able to use the
    # saved max extension.
    #
    foreach my $agg ($instance->AggregateList()) {
	my $response = shift(@{$responses});
	my $code     = $response->code();
	my $aptagg   = $agg->GetAptAggregate();
    
	if ($code) {
	    if ($code == GENIRESPONSE_REFUSED) {
		# We want the user to see REFUSED.
		$errmsg = "Extension refused at ".
		    $aptagg->name() . ": " . $response->error();
		$errcode = 1;
		push(@refused, $agg);
	    }
	    elsif (($code == GENIRESPONSE_NETWORK_ERROR ||
		    $code == GENIRESPONSE_SERVER_UNAVAILABLE) &&
		   $aptagg->precalcmaxext()) {
		#
		# We must be able to reach aggregates that are not
		# marked for precalc. But if it is, remember the ones
		# we cannot reach, for below.
		#
		push(@delayed, $agg);
		if ($debug) {
		    print "Could not extend at precalc marked aggregate ".
			$aptagg->nickname() . "\n";
		}
	    }
	    else {
		($errcode,$errmsg) = ResponseErrorMessage($agg, $response);
		print STDERR $errmsg . "\n";
		push(@failed, $agg);
	    }
	}
    }
    # Success at all aggregates.
    return 0
	if (! ($errcode || @delayed));
    
    # One aggregate and one error is easy, just tell the user.
    goto bad
	if ($errcode && $instance->AggregateList() == 1);

    #
    # Anything but delayed is harder.
    #
    if (@refused || @busy || @failed) {
	$errmsg = "";
	
	#
	# Maybe send email with details?
	# Be nice to retry the busy ones, but we do not want the user
	# to see the spinner for too long.
	#
	if (@refused) {
	    $errmsg .= "The extension was refused at ".
		join(", ", map($_->GetAptAggregate()->nickname(), @refused)) .
		". ";
	}
	if (@failed) {
	    $errmsg .= "The extension failed at ".
		join(", ", map($_->GetAptAggregate()->nickname(), @failed)) .
		". ";
	}
	if (@busy) {
	    $errmsg .= "The extension could not be made at ".
		join(", ", map($_->GetAptAggregate()->nickname(), @failed)) .
		" because they were busy. ";
	}
	$errcode = 1;
	goto bad;
    }
    
    #
    # If the only error is from delayed aggregates, try to handle that. 
    #
    if (@delayed) {
	goto bad
	    if (!$savedokay || !defined($instance->maxextension()));

	#
	# Need to serialize at this point, since another experiment could
	# be in the same predicament, but only one can use their saved max
	# extension if they overlap on clusters used by the experiment.
	#
	if (APT_Utility::ExtensionLock()) {
	    print STDERR "Could not get max extension lock\n";
	    goto bad;
	}
	$instance->Refresh();
	if (!defined($instance->maxextension())) {
	    APT_Utility::ExtensionUnlock();
	    goto bad;
	}
	# Sanity check.
	my $maxtime = str2time($instance->maxextension());
	my $exptime = str2time($new_expires);
	if ($exptime > $maxtime) {
	    print STDERR "Saved max extension is greater then new expires!\n";
	    APT_Utility::ExtensionUnlock();
	    goto bad;
	}
	foreach my $agg (@delayed) {
	    $agg->MarkExtensionPush();
	}
	$instance->PurgeMaxExtension();
	APT_Utility::ExtensionUnlock();
    }
    return 0;

  bad:
    # Reset back to original expiration, sorry.
    $slice->SetExpiration($oldexpires);
    $$perrmsg = $errmsg;
    return $errcode;
}
#
# Ask the reservation system for the maximum date to which this experiment
# can be extended.
#
sub DoMaxExtension()
{
    my $slice = $instance->GetGeniSlice();
    my $result;
    my $errcode;
    my $errmsg;

    if ($instance->ExtensionPushPending()) {
	$errcode = 1;
	$errmsg  = "A previous extension is still pending because some ".
	    "clusters were offline when the previous extension was made, ".
	    "and those clusters are still unreachable. Please try ".
	    "again later.";
	goto bad;
    }
    $errcode = DoMaxExtensionInternal($instance, \$result);
    if ($errcode) {
	$errmsg = $result;
	goto bad;
    }
    if ($debug) {
	print "Max extension: " .
	    TBDateStringLocal($result->{'maxextension'})  . "\n";
	if (exists($result->{'reservations'})) {
	    if (keys(%{$result->{'reservations'}})) {
		print Dumper($result->{'reservations'});
	    }
	}
    }
    # For offline aggregate extensions.
    $instance->SaveMaxExtension($result->{'maxextension'});

    if (defined($webtask)) {
	$webtask->MaxExtension(TBDateStringGMT($result->{'maxextension'}));
	$webtask->Reservations($result->{'reservations'})
	    if (exists($result->{'reservations'}));
	$webtask->Exited(0);
    }
    exit(0);
  bad:
    # Clear offline aggregate extension value on error.
    $instance->SaveMaxExtension(undef);
    
    print STDERR "$errmsg\n" if (defined($errmsg));
    if (defined($webtask)) {
	$webtask->output($errmsg) if (defined($errmsg));
	$webtask->Exited($errcode);
    }
    if ($errcode < 0) {
	print STDERR "\n\n" . $instance->webURL() . "\n";
    }
    exit($errcode);
}

sub DoMaxExtensionInternal($$)
{
    my ($instance, $prval) = @_;
    my $slice = $instance->GetGeniSlice();
    my $maxinfo;
    my $errmsg;
    my $errcode;
    my $tmp;
    my $expires = str2time($slice->expires());
    # This matches what MaxSliceExtension() does
    my $newmax  = $expires + (60 * 60 * 24 * 180);
    my $blob = {"maxextension" => undef, "reservations" => {}};
    my @aggregates = ();

    #
    # For now, if there are any deferred aggregates (offline), then
    # there is no point in asking any of them, we cannot determine
    # a max extension, have to wait till later.
    #
    if ($instance->DeferredAggregateList()) {
	$errcode = GENIRESPONSE_SERVER_UNAVAILABLE();
	$errmsg  = "Cannot determine max extension because some ".
	    "aggregates are deferred";
	goto bad;
    }

    foreach my $aggregate ($instance->AggregateList()) {
	next
	    if ($aggregate->isAL2S() || $aggregate->isStitch());
	push(@aggregates, $aggregate);
    }

    #
    # Call MaxExtension on all clusters.
    #
    my $responses;

    $errcode = CallMethodOnAggregates("MaxExtension", 0, \$responses,
				      @aggregates);
    if ($errcode) {
	$errmsg = $responses;
	goto bad;
    }

    # Process the max extension from each aggregate
    foreach my $aggregate (@aggregates) {
	my $response = shift(@{$responses});
	my $aptagg   = $aggregate->GetAptAggregate();
	my $result   = $response->value();
	my $code     = $response->code();
	my $reslist  = {};
	my $max;

	if ($code) {
	    if ($code == GENIRESPONSE_REFUSED) {
		# We want the user to see REFUSED.
		$errmsg = "No extension possible at ".
		    $aptagg->name() . ": " . $response->error();
		$errcode = $code;
		goto bad;
	    }
	    elsif (($code == GENIRESPONSE_NETWORK_ERROR ||
		    $code == GENIRESPONSE_SERVER_UNAVAILABLE) &&
		   $aptagg->precalcmaxext() &&
		   defined($instance->maxextension())) {
		#
		# If this is an aggregate that allows precalc, and we have
		# a stored maxextension, then use that for this aggregate.
		# We must always get back a maxextension from aggregates that
		# do not allow precalc.
		#
		$max = str2time($instance->maxextension());
		if ($debug) {
		    print "Using stored maxextension for ".
			$aptagg->nickname() . ": " .
			$instance->maxextension() . "\n";
		}
	    }
	    else {
		($errcode,$errmsg) =
		    ResponseErrorMessage($aggregate, $response);
		goto bad;
	    }
	}
	# See above, might be using stored max extension.
	if (!defined($max)) {
	    if (ref($result)) {
		$max     = $result->{'maxextension'};
		$reslist = $result->{'reservations'};
	    }
	    else {
		$max = $result;
	    }
	    $max = str2time($max);
	    if ($debug) {
		print "$aggregate: $max\n";
		print Dumper($result);
	    }
	}
	$newmax = $max
	    if (!defined($newmax));
	$newmax = $max
	    if ($max < $newmax);

	# Map project/user to local users (if appropriate).
	foreach my $res (values(%{$reslist})) {
	    my $project = APT_Utility::MapProjectURN($res->{'project'});
	    if (defined($project)) {
		$res->{'remote_pid'} = $res->{'pid'};
		$res->{'pid'}        = $project->pid();
		$res->{'pid_idx'}    = $project->pid_idx();
	    }
	    else {
		$res->{'remote_pid'} = $res->{'pid'};
	    }
	    my $geniuser = APT_Utility::MapUserURN($res->{'user'});
	    if (defined($geniuser)) {
		$res->{'remote_uid'} = $res->{'uid'};
		$res->{'uid'}        = $geniuser->uid();
		$res->{'uid_idx'}    = $geniuser->uid_idx();
	    }
	    else {
		$res->{'remote_uid'} = $res->{'uid'};
	    }
		
	    #
	    # Add these for the web interface since we are already messing
	    # with the results.
	    #
	    $res->{'cluster'} = $aptagg->urn();
	    $res->{'cluster_id'} = $aptagg->nickname();

	    # We need numbers.
	    $res->{'nodes'} = int($res->{'nodes'});
	    $res->{'using'} = int($res->{'using'});

	    #
	    # Hmm, undef/null is a pain with XMLRPC.
	    #
	    foreach my $key ("approved", "cancel", "deleted") {
		if (!exists($res->{$key}) || $res->{$key} eq "") {
		    $res->{$key} = undef;
		}
	    }
	    #
	    # Lets calculate a utilization numbers, this will update the
	    # res hash. Flag says not an active reservation.
	    #
	    APT_Utility::ReservationUtilization($res, 0);
	}
	$blob->{'reservations'}->{$aptagg->urn()} = $reslist;
    }
    #
    # See if we are bounded by RF reservations.
    #
    my $rfmax =
	APT_Reservation::Group::RFReservation::MaxExtension($instance, \$tmp);
    if (!defined($rfmax)) {
	# Some kind of error.
	$errmsg  = "Internal error determining RF max extension: $tmp";
	$errcode = -1;
	goto bad;
    }
    if ($debug) {
	print "RF Max extension is $rfmax, Node max is $newmax\n";
    }
    if ($newmax > $rfmax) {
	if ($debug) {
	    print "Cutting back max extension cause of RF reservations.\n";
	    if (defined($tmp)) {
		print "-> $tmp\n";
	    }
	}
	$newmax = $rfmax;
    }
    #
    # Ditto for a route reservations.
    #
    my $rmax =
	APT_Reservation::Group::RouteReservation::MaxExtension($instance);
    if (!defined($rmax)) {
	# Some kind of error.
	$errmsg  = "Internal error determining Route max extension";
	$errcode = -1;
	goto bad;
    }
    if ($debug) {
	print "Route Max extension is $rmax, current max is $newmax\n";
    }
    if ($newmax > $rmax) {
	if ($debug) {
	    print "Cutting back max extension cause of Route reservations.\n";
	}
	$newmax = $rmax;
    }
    $blob->{'maxextension'} = $newmax;
    $$prval = $blob;
    return 0;
    
  bad:
    $$prval = $errmsg;
    return $errcode;
}

sub PushExtensionInternal()
{
    my $errmsg;
    my $errcode;
    my @aggregates = ();
    my $slice = $instance->GetGeniSlice();
    my $new_expires = $slice->ExpirationGMT();
    
    foreach my $aggregate ($instance->AggregateList()) {
	next
	    if (!defined($aggregate->extension_needpush()));

	push(@aggregates, $aggregate);
    }
    return 0
	if (!@aggregates);

    print "Trying to push extension: " . TBDateStringLocal($new_expires) , "\n";
    
    #
    # Push the new expiration out.
    #
    my $coderef = sub {
	my ($sliver) = @_;

	return $sliver->Extend($new_expires, $this_user, 0);
    };
    my $responses;

    $errcode = CallMethodOnAggregates($coderef, 0, \$responses, @aggregates);
    if ($errcode) {
	print STDERR $responses . "\n";
	return -1;
    }
    my $hosed = 0;

    # Lets see which ones we were able to update.
    foreach my $aggregate (@aggregates) {
	my $response = shift(@{$responses});
	my $code     = $response->code();
	my $aptagg   = $aggregate->GetAptAggregate();

	if ($code) {
	    if ($code == GENIRESPONSE_NETWORK_ERROR ||
		$code == GENIRESPONSE_SERVER_UNAVAILABLE) {
		# Still out of contact, keep going.
		print STDERR "$aggregate is still unreachable, skipping\n";
	    }
	    elsif ($code == GENIRESPONSE_REFUSED) {
		# We want the caller to know this, its bad.
		print STDERR "Extension was refused at ".
		    $aptagg->name() . ": " . $response->error() . "\n";
		$aggregate->ClearExtensionPush();
		$hosed++;
	    }
	    else {
		# All other errors mean we are hosed!
		(undef, $errmsg) = ResponseErrorMessage($aggregate, $response);
		print STDERR "$errmsg\n";
		$aggregate->ClearExtensionPush();
		$hosed++;
	    }
	}
	else {
	    # Success, clear the push flag.
	    print "Successfully pushed the extension to " .
		$aptagg->name() . "\n";
	    $aggregate->ClearExtensionPush();
	}
    }
    # If any failed fatally, we gotta do something!
    if ($hosed) {
	return 1;
    }
    return 0;
}

#
# Push out delayed extension.
#
sub DoPushExtension()
{
    my $slice = $instance->GetGeniSlice();

    if ($slice->Lock()) {
	print STDERR "Experiment is busy, cannot lock it.\n";
	exit(GENIRESPONSE_BUSY());
    }
    $instance->Refresh();
    if (PushExtensionInternal()) {
	# If any failed fatally, we gotta do something!
	$slice->UnLock();
	exit(-1);
    }
    $slice->UnLock();
    exit(0);
}

#
# Deny extension, sending optional email to user (which is also saved in
# the extension history). We used to do this in PHP, which was silly.
#
sub DoDenyOrMoreInfo($)
{
    my ($action) = @_;
    my $errcode = -1;
    my $reason;

    if (! $this_user->IsAdmin()) {
	fatal("Only administrators can deny extensions or request info");
    }
    if (@ARGV == 2) {
	my $arg = shift(@ARGV);
	if ($arg eq "-m") {
	    $reason = shift(@ARGV);
	}
	else {
	    usage();
	}
    }
    elsif (@ARGV == 1) {
	my $filename = shift(@ARGV);
	if (! -e $filename) {
	    fatal("$filename does not exist");
	}
	open(MSG, $filename) or
	    fatal("Could not open $filename");
	
	$reason = "";
	while (<MSG>) {
	    $reason .= $_;
	}
	close(MSG);
    }
    my $creator   = $instance->GetGeniUser();
    my $slice     = $instance->GetGeniSlice();
    my $name      = $instance->name();
    my $pid       = $instance->pid();
    my $expires   = POSIX::strftime("20%y-%m-%d %H:%M:%S %Z",
				    localtime(str2time($slice->expires())));
    my $created   = POSIX::strftime("20%y-%m-%d %H:%M:%S %Z",
				    localtime(str2time($instance->started())));
    my $now       = POSIX::strftime("20%y-%m-%d %H:%M:%S %Z", localtime());
    my $url       = $instance->webURL();
    my $pcount    = $instance->physnode_count();
    my $extensions= $instance->Brand()->ExtensionsEmailAddress();
    my $clusters  = join(",", map { $_->domain() }
			 $instance->AggregateList());
    my ($message,$subject);
    if ($action eq "deny") {
	$message = "Your extension was denied by the site administrator!";
	$subject = "Experiment Extension Denied: $pid/$name";
    }
    else {
	$message = "Hi, we need more information about your experiment: $name";
	$subject = "Information request for Experiment: $pid/$name";
    }

    #
    # New extension mechanism
    #
    my $extensionargs = {
	"action"   => ($action eq "deny" ? "deny" : "info"),
	"uid"      => $this_user->uid(),
	"uid_idx"  => $this_user->uid_idx(),
	"message"  => $message,
	"admin"    => $this_user->IsAdmin() ? 1 : 0};
    if (defined($reason)) {
	$extensionargs->{"reason"} = $reason;
    }
    my $extensioninfo =
	APT_Instance::ExtensionInfo->Create($instance, $extensionargs);
    if (!defined($extensioninfo)) {
	print STDERR "Could not create extension info object\n";
	return -1;
    }

    #
    # We store each extension request in an ongoing text field.
    #
    my $text =
        "Date: $now\n".
        "Expires: $expires\n".
        "Reason:\n".
	$message . "\n\n".
        $reason . "\n\n".
        "-----------------------------------------------\n";
    $instance->Brand()->SendEmail($creator->email(), $subject,
	       $message . "\n\n" .
               $reason . "\n\n".
               "Your experiment was started on $created\n".
 	       "Your experiment expires at $expires\n".
	       "You are using $pcount physical nodes.\n".
               "It is running on $clusters\n\n".
               "$url\n",
	       "$extensions",
	       "BCC: $extensions");

    $instance->AddExtensionHistory($text);
    # For the dashboard and status page.
    if ($action eq "deny") {
	$instance->Update({"extension_requested" => 0,
			   "extension_denied"    => 1,
			   "extension_denied_reason" => $reason});
    }
    return 0;
}

#
# Refresh; ask the aggregate for status and set the instance status
# accordingly.
#
sub DoRefresh()
{
    my $errmsg;
    my $errcode = 0;
    my $exitcode = -1;
    
    my $slice = $instance->GetGeniSlice();
    if (!defined($slice)) {
	print STDERR "No slice for instance\n";
	$instance->RecordHistory($RECORDHISTORY_TERMINATED);
	$instance->Delete();
	exit(0);
    }
    # Shorten default timeout
    Genixmlrpc->SetTimeout(30);
    
    #
    # Lock the slice in case it is doing something else, like taking
    # a disk image.
    #
    if ($slice->Lock()) {
	$errmsg = "Experiment is busy, cannot lock it. Please try again later";
	$errcode = GENIRESPONSE_BUSY;
	$exitcode = 1;
	goto bad;
    }
    #
    # Call Refresh on all clusters and see what failed. 
    #
    my $response;

    $errcode = CallMethodOnAggregates("SliceStatus", 0, \$response,
				      $instance->ActiveAggregateList());
    if ($errcode) {
	$errmsg = $response;
	goto bad;
    }
    my $readycount= 0;

    #
    # Look at all the responses. We are going to watch for the case that a
    # failed instance moves back to the ready state, which can happen via
    # user or admin intervention. We do not go in the other direction.
    #
    my @responses = @{$response};
    foreach my $agg ($instance->ActiveAggregateList()) {
	my $response = shift(@responses);
	
	if ($response->code() != GENIRESPONSE_SUCCESS &&
	    $response->code() != GENIRESPONSE_SEARCHFAILED) {
	    $errcode = $response->code();
	    ($exitcode, $errmsg) = ResponseErrorMessage($agg, $response);
	    next;
	}
	next
	    if ($response->code() == GENIRESPONSE_SEARCHFAILED);

	my $blob = $response->value();

	if ($blob->{'status'} eq "ready") {
	    $readycount++;
	    $agg->SetStatus("ready");
	}
	elsif ($blob->{'status'} eq "failed") {
	    $agg->SetStatus("failed");
	}
	# This is the per-aggregate status, we always set this for web UI.
	$agg->UpdateSliverStatusAll($blob->{'details'});
	# And set the top level slice status. Need to create a hash with
	# the subset we want in the DB. 
	my $slice_status_blob = {
	    "status" => $blob->{'status'},
	    "utc"    => $blob->{'utc'},
	    "state"  => $blob->{'state'},
	};
	# This should probably be done atomically with sliver status.
	$agg->UpdateSliceStatus($slice_status_blob);
	
	if ($debug) {
	    print STDERR Dumper($blob);
	}
    }
    goto bad
	if ($errcode);

    if ($readycount == scalar($instance->ActiveAggregateList())) {
	if ($instance->status() eq "failed") {
	    $instance->SetStatus("ready");
	}
    }
    $slice->UnLock();
    exit(0);

  bad:
    $slice->UnLock();
    print STDERR $errmsg . "\n";
    if (defined($webtask)) {
	$webtask->output($errmsg);
	$webtask->Exited($errcode);
    }
    exit($exitcode);
}

#
# Reboot or Reload nodes.
#
sub DoRebootOrReload($)
{
    my ($which) = @_;
    my $errmsg;
    my $errcode;
    my $exitcode = -1;
    my $doperms  = 0;
    my $locked   = 0;

    my $optlist = "X";
    my %options = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }
    if (defined($options{"X"})) {
	$doperms = 1;
    }
    usage()
	if (!@ARGV);

    #
    # NOTE: This is called from legacy XMLRPC server, so do a permission
    # check here for it. Only the creator on this path, the web interface
    # will suffice for anyone else.
    #
    if ($doperms) {
	my $creator = $instance->GetGeniUser();
	if (!defined($creator)) {
	    fatal("Cannot lookup creator");
	}
	if (!$this_user->SameUser($creator->emulab_user())) {
	    UserError("Not enough permission to reboot nodes");
	}
    }

    my $slice = $instance->GetGeniSlice();
    if (!defined($slice)) {
	print STDERR "No slice for instance\n";
	goto killit;
    }

    my %sliver_urns = ();
    my %slice_urns  = ();
    my %node_ids    = ();
    my @slivers     = ();
    foreach my $obj ($instance->AggregateList()) {
	# Not finished or failure.
	next
	    if (!$obj->manifest());
	
	my $manifest = GeniXML::Parse($obj->manifest());
	if (! defined($manifest)) {
	    fatal("Could not parse manifest");
	}
	my @nodes = (GeniXML::FindNodes("n:node", $manifest)->get_nodelist(),
		     GeniXML::FindNodesNS("n:vhost", $manifest,
					  $GeniXML::EMULAB_NS)->get_nodelist());

	# List of this agg nodes as we find them.
	my @aggnodes = ();
	
	foreach my $node (@nodes) {
	    my $client_id   = GeniXML::GetVirtualId($node);
	    my $sliver_urn  = GeniXML::GetSliverId($node);
	    my $manager_urn = GetManagerId($node);

	    # No sliver urn or a different aggregate.
	    next
		if (! (defined($sliver_urn) &&
		       defined($manager_urn) &&
		       $manager_urn eq $obj->aggregate_urn()));

	    push(@aggnodes, $node);
	    
	    if (grep {$_ eq $client_id} @ARGV) {
		if (!exists($sliver_urns{$obj->aggregate_urn()})) {
		    $sliver_urns{$obj->aggregate_urn()} = [];
		    push(@slivers, $obj);
		}
		push(@{ $sliver_urns{$obj->aggregate_urn()} }, $sliver_urn);
		$node_ids{$sliver_urn} = $client_id;
	    }
	}
	next
	    if (!exists($sliver_urns{$obj->aggregate_urn()}));
	
	#
	# If we are doing all the nodes at an aggregate, we want to apply
	# the operation to the slice instead of individual slivers.
	#
	if (scalar(@aggnodes) ==
	    scalar(@{ $sliver_urns{$obj->aggregate_urn()}})) {
	    # This will cause the operation to apply to the entire aggregate.
	    $sliver_urns{$obj->aggregate_urn()} = [];
	}
    }
    if (!@slivers) {
	$errmsg   = "Cannot find any nodes to reboot";
	$errcode  = GENIRESPONSE_SEARCHFAILED;
	$exitcode = 1;
	goto bad;
    }

    #
    # Lock the slice in case it is doing something else, like taking
    # a disk image.
    #
    if ($slice->Lock()) {
	$errmsg = "Experiment is busy, cannot lock it. Please try again later";
	$errcode  = GENIRESPONSE_BUSY;
	$exitcode = 1;
	goto bad;
    }
    $locked = 1;

    #
    # Helper callback to send the proper arguments.
    #
    my $coderef = sub {
	my ($sliver) = @_;
	my @urns     = @{ $sliver_urns{$sliver->aggregate_urn()} };

	return $sliver->SliverAction($which, @urns);
    };

    # Invoke on all clusters
    my $response;

    $errcode = CallMethodOnAggregates($coderef, 2, \$response, @slivers);
    if ($errcode) {
	$errmsg = $response;
	goto bad;
    }

    #
    # Look at all the responses.
    #
    foreach my $agg (@slivers) {
	my $response = shift(@{$response});
	my $code = $response->code();

	if ($code != GENIRESPONSE_SUCCESS) {
	    $errcode = $code;
	    
	    if ($code == GENIRESPONSE_REFUSED) {
		# We want the user to see REFUSED.
		$errmsg = "Not able to $which at ".
		    $agg->GetAptAggregate()->name() . ": " .
		    $response->error();
		$exitcode = 1;
	    }
	    else {
		($exitcode, $errmsg) = ResponseErrorMessage($agg, $response);
	    }
	    next;
	}
    }
    goto bad
	if ($errcode);

    $slice->UnLock();
    if (defined($webtask)) {
	$webtask->Exited(0);
    }
    #
    # Start the monitor so the web interface will see when the node
    # has actually come back up.
    #
    # XXX This will not return unless a monitor is already running.
    StartMonitorInternal();
    exit(0);
  killit:
    $instance->RecordHistory($RECORDHISTORY_TERMINATED);
    $instance->Delete();
    exit(0);
  bad:
    $slice->UnLock() if ($locked);
    print STDERR $errmsg . "\n";
    if (defined($webtask)) {
	$webtask->output($errmsg);
	$webtask->Exited($errcode);
    }
    exit($exitcode);
}
sub DoReboot()     { return DoRebootOrReload("reboot"); }
sub DoReload()     { return DoRebootOrReload("reload"); }
sub DoStart()      { return DoRebootOrReload("start"); }
sub DoPowerCycle() { return DoRebootOrReload("powercycle"); }

#
# Recovery mode.
#
sub DoRecovery()
{
    my ($errmsg, $exitcode, $errcode);
    my $clear = 0;

    my $optlist = "c";
    my %options = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }
    if (defined($options{"c"})) {
	$clear = 1;
    }
    usage()
	if (!@ARGV);
    my $node_id = shift(@ARGV);

    #
    # Sanity check to make sure the node is really in the rspec, since
    # we need its sliver urn.
    #
    my $sliver_urn;
    my $sliver;
    foreach my $obj ($instance->AggregateList()) {
	my $manifest = GeniXML::Parse($obj->manifest());
	if (! defined($manifest)) {
	    fatal("Could not parse manifest for $obj");
	}
	my @nodes = (GeniXML::FindNodes("n:node", $manifest)->get_nodelist(),
		     GeniXML::FindNodesNS("n:vhost", $manifest,
					  $GeniXML::EMULAB_NS)->get_nodelist());
	foreach my $node (@nodes) {
	    my $client_id   = GeniXML::GetVirtualId($node);
	    my $urn         = GeniXML::GetSliverId($node);
	    my $manager_urn = GetManagerId($node);

	    # No sliver urn or a different aggregate.
	    next

		if (! (defined($urn) &&
		       defined($manager_urn) &&
		       $manager_urn eq $obj->aggregate_urn()));

	    if ($node_id eq $client_id) {
		$sliver_urn = $urn;
		$sliver = $obj;
	    }
	}
    }
    if (!defined($sliver_urn)) {
	fatal("Could not find node '$node_id' in manifest");
    }
    if ($sliver->GetAptAggregate()->CheckStatus(\$errmsg)) {
	print STDERR "$errmsg\n";
	if (defined($webtask)) {
	    $webtask->output($errmsg);
	    $webtask->Exited(GENIRESPONSE_SERVER_UNAVAILABLE);
	}
	exit(1);
    }
    my $response = $sliver->Recovery($sliver_urn, $clear);
    if ($response->code() != GENIRESPONSE_SUCCESS) {
	$errcode = $response->code();
	($exitcode,$errmsg) = ResponseErrorMessage($sliver, $response);
	
	# Important to tell web user about this
	if ($response->code() == GENIRESPONSE_FORBIDDEN) {
	    $exitcode = 1;
	}
	goto bad;
    }
    exit(0);
  bad:
    print STDERR "$errmsg\n";
    if (defined($errmsg) && defined($webtask)) {
	$webtask->Exited($errcode);
	$webtask->output($errmsg);
    }
    exit($exitcode);
}

#
# Flash a radio
#
sub DoFlash()
{
    my ($errmsg, $exitcode, $errcode);
    my $locked = 0;

    my $optlist = "";
    my %options = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }
    usage()
	if (!@ARGV);
    my $node_id = shift(@ARGV);

    #
    # Sanity check to make sure the node is really in the rspec, since
    # we need its sliver urn.
    #
    my $sliver_urn;
    my $sliver;
    foreach my $obj ($instance->AggregateList()) {
	my $manifest = GeniXML::Parse($obj->manifest());
	if (! defined($manifest)) {
	    fatal("Could not parse manifest for $obj");
	}
	my @nodes = (GeniXML::FindNodes("n:node", $manifest)->get_nodelist(),
		     GeniXML::FindNodesNS("n:vhost", $manifest,
					  $GeniXML::EMULAB_NS)->get_nodelist());
	foreach my $node (@nodes) {
	    my $client_id   = GeniXML::GetVirtualId($node);
	    my $urn         = GeniXML::GetSliverId($node);
	    my $manager_urn = GetManagerId($node);

	    # No sliver urn or a different aggregate.
	    next

		if (! (defined($urn) &&
		       defined($manager_urn) &&
		       $manager_urn eq $obj->aggregate_urn()));

	    if ($node_id eq $client_id) {
		$sliver_urn = $urn;
		$sliver = $obj;
	    }
	}
    }
    if (!defined($sliver_urn)) {
	fatal("Could not find node '$node_id' in manifest");
    }

    #
    # Lock the slice in case it is doing something else, like taking
    # a disk image.
    #
    if ($instance->Lock()) {
	$errmsg = "Experiment is busy, cannot lock it. Please try again later";
	$errcode  = GENIRESPONSE_BUSY;
	$exitcode = 1;
	goto bad;
    }
    $locked = 1;
    
    if ($sliver->GetAptAggregate()->CheckStatus(\$errmsg)) {
	print STDERR "$errmsg\n";
	if (defined($webtask)) {
	    $webtask->output($errmsg);
	    $webtask->Exited(GENIRESPONSE_SERVER_UNAVAILABLE);
	}
	$instance->Unlock();
	exit(1);
    }
    my $response = $sliver->Flash($sliver_urn);
    if ($response->code() != GENIRESPONSE_SUCCESS) {
	$errcode = $response->code();
	($exitcode,$errmsg) = ResponseErrorMessage($sliver, $response);
	
	# Important to tell web user about this
	if ($response->code() == GENIRESPONSE_FORBIDDEN) {
	    $exitcode = 1;
	}
	goto bad;
    }
    $instance->Unlock();
    exit(0);
  bad:
    $instance->Unlock() if ($locked);
    print STDERR "$errmsg\n";
    if (defined($errmsg) && defined($webtask)) {
	$webtask->Exited($errcode);
	$webtask->output($errmsg);
    }
    exit($exitcode);
}

#
# 
#
sub DoManifests()
{
    my $errmsg;
    my $errcode;
    my $exitcode = -1;
    my $response;
    
    my $slice = $instance->GetGeniSlice();
    if (!defined($slice)) {
	print STDERR "No slice for instance\n";
	goto killit;
    }

    #
    # Lock the slice in case it is doing something else, like taking
    # a disk image.
    #
    if ($slice->Lock()) {
	$errmsg  = "Experiment is busy, cannot lock it. Please try again later";
	$errcode  = GENIRESPONSE_BUSY;
	$exitcode = 1;
	goto bad;
    }

    #
    # Helper callback; if we get back a manifest lets set it here (in
    # the child) and avoid the copy through the webtask/database.
    # Clear the manifest from the response structure to prevent that.
    #
    my $coderef = sub {
	my ($sliver) = @_;

	my $response = $sliver->GetManifest();
	if (defined($response) &&
	    $response->code() == GENIRESPONSE_SUCCESS) {
	    my $manifest = $response->value()->{'manifest'};
	    if ($debug) {
		print STDERR $manifest . "\n";
	    }
	    $sliver->SetManifest($manifest);
	    $response->value(0);
	}
	return $response;
    };
    
    # Invoke on all clusters
    $errcode = CallMethodOnAggregates($coderef, 0, \$response,
				      $instance->ActiveAggregateList());
    if ($errcode) {
	$errmsg = $response;
	goto bad;
    }

    #
    # Look at all the responses.
    #
    foreach my $agg ($instance->ActiveAggregateList()) {
	my $response = shift(@{$response});
	my $code = $response->code();

	if ($code != GENIRESPONSE_SUCCESS) {
	    ($exitcode, $errmsg) = ResponseErrorMessage($agg, $response);
	    $errcode = $code;
	    next;
	}
    }
    goto bad
	if ($errcode);

    if ($instance->MergeManifests()) {
	print STDERR "Could not merge manifests\n";
    }
    elsif (PushManifestInternal($instance->manifest())) {
	print STDERR "Could not push manifests\n";
    }
    $slice->UnLock();
    exit(0);
  bad:
    $slice->UnLock();
    print STDERR $errmsg . "\n";
    if (defined($webtask)) {
	$webtask->output($errmsg);
	$webtask->Exited($errcode);
    }
    exit($exitcode);
}

#
# 
#
sub DoDumpManifests()
{
    my $optlist = "jX";
    my $doperms = 0;
    my $asjson  = 0;
    my %options = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }
    if (defined($options{"j"})) {
	$asjson = 1;
    }
    if (defined($options{"X"})) {
	$doperms = 1;
    }
    #
    # NOTE: This is called from legacy XMLRPC server, so do a permission
    # check here for it. Only the creator on this path, the web interface
    # will suffice for anyone else.
    #
    if ($doperms) {
	my $creator = $instance->GetGeniUser();
	if (!defined($creator)) {
	    fatal("Cannot lookup creator");
	}
	if (!$this_user->SameUser($creator->emulab_user())) {
	    UserError("Not enough permission to get experiment manifests");
	}
    }

    if ($instance->status() ne "ready") {
	UserError("Experiment is not in the ready state");
    }
    my $blob = {};

    foreach my $agg ($instance->AggregateList()) {
	$blob->{$agg->aggregate_urn()} = $agg->manifest();
    }
    if ($asjson) {
	my $json = eval { encode_json($blob); };
	if ($@) {
	    fatal($@);
	}
	print $json;
    }
    else {
	print Dumper($blob);
    }
    exit(0);
}

#
# Delete nodes.
#
sub DoDeleteNodes()
{
    my $logname;
    my $errmsg;
    my $errcode;
    my $exitcode = -1;
    my $response;
    my $gotlock = 0;

    my $optlist    = "fNS";
    my $foreground = 0;
    my $nolock     = 0;	# Caller holds the lock.
    my $nostatus   = 0; # Caller handles instance status changes.
    my %options    = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }
    if (defined($options{"f"})) {
	$foreground = 1;
    }
    if (defined($options{"N"})) {
	$nolock = 1;
    }
    if (defined($options{"S"})) {
	$nostatus = 1;
    }
    usage()
	if (!@ARGV);

    my $slice = $instance->GetGeniSlice();
    if (!defined($slice)) {
	fatal("No slice for instance");
    }
    my @aggregates  = ();
    my @delaggs     = ();
    my %allmap      = ();
    my %aggmap      = ();
    foreach my $obj ($instance->AggregateList()) {
	my $manifest = GeniXML::Parse($obj->manifest());
	if (! defined($manifest)) {
	    fatal("Could not parse manifest");
	}
	my @nodes = GeniXML::FindNodes("n:node", $manifest)->get_nodelist();
	# Not allowed to delete last node.
	if (@nodes == 1) {
	    $errmsg   = "Only one node left, not allowed to delete any more.";
	    $errcode  = 1;
	    $exitcode = 1;
	    goto bad;
	}
	my $delcount = 0;
	$allmap{$obj->aggregate_urn()} = [];	

	foreach my $node (@nodes) {
	    my $client_id   = GeniXML::GetVirtualId($node);
	    my $sliver_urn  = GeniXML::GetSliverId($node);
	    my $manager_urn = GetManagerId($node);
	    
	    # No sliver urn or a different aggregate.
	    next
		if (! (defined($sliver_urn) &&
		       defined($manager_urn) &&
		       $manager_urn eq $obj->aggregate_urn()));
	    #
	    # So we can make sure the user does not try to delete all nodes
	    # at this aggregate.
	    #
	    push(@{ $allmap{$obj->aggregate_urn()} }, $client_id);
	    
	    if (grep {$_ eq $client_id} @ARGV) {
		if (!exists($aggmap{$obj->aggregate_urn()})) {
		    $aggmap{$obj->aggregate_urn()} = [];
		}
		push(@{ $aggmap{$obj->aggregate_urn()} }, $client_id);
		$delcount++;
	    }
	}
	#
	# Tell the user to Terminate instead.  When more then one
	# aggregate, more complicated, since we need to delete the
	# aggregate (at the cluster) and remove from the instance. Worry
	# about this when it becomes a problem.
	#
	if ($delcount == scalar(@{ $allmap{$obj->aggregate_urn()} })) {
	    if (scalar($instance->AggregateList()) == 1) {
		$errmsg   = "Not allowed to delete all nodes, ".
		    "please use Terminate instead";
		print STDERR $errmsg . "\n";
		if (defined($webtask)) {
		    $webtask->output($errmsg);
		    $webtask->Exited(1);
		}
		exit(1);
	    }
	    else {
		push(@delaggs, $obj);
	    }
	}
	elsif ($delcount) {
	    push(@aggregates, $obj);
	}
    }
    if (scalar(@delaggs) == scalar($instance->AggregateList())) {
	$errmsg   = "Not allowed to delete all nodes, ".
	    "please use Terminate instead";
	print STDERR $errmsg . "\n";
	if (defined($webtask)) {
	    $webtask->output($errmsg);
	    $webtask->Exited(1);
	}
	exit(1);
    }
    if (! (@aggregates || @delaggs)) {
	$errmsg   = "Cannot find anything to delete!";
	print STDERR $errmsg . "\n";
	if (defined($webtask)) {
	    $webtask->output($errmsg);
	    $webtask->Exited(1);
	}
	exit(1);
    }

    #
    # Lock the slice in case it is doing something else, like taking
    # a disk image.
    #
    if (!$nolock && $slice->Lock()) {
	$errmsg = "Experiment is busy, cannot lock it. Please try again later";
	$errcode  = GENIRESPONSE_BUSY;
	$exitcode = 1;
	goto bad;
    }
    $gotlock = 1;

    #
    # For efficiency, we ask for the credential bundle, and then pass
    # it into DeleteNodes.
    #
    my $credentials;
    if ($instance->GetAllCredentials(1, \$credentials, \$errmsg)) {
	$errmsg   = "Cannot generate credentials";
	$errcode  = GENIRESPONSE_ERROR;
	$exitcode = -1;
	goto bad;
    }
    
    #
    # Helper callback to send the proper arguments.
    #
    my $coderef = sub {
	my ($sliver) = @_;
	my @nodes    = @{ $aggmap{$sliver->aggregate_urn()} };
	my $creds    = $credentials->{$sliver->aggregate_urn()};

	$sliver->SetStatus("provisioning");
	my $response = $sliver->DeleteNodes($creds, @nodes);
	
	# We get back a new manifest. Set it here and clear from the
	# response structure so it does not copy through the webtask/db.
	if ($response && $response->code() == GENIRESPONSE_SUCCESS) {
	    $sliver->SetManifest($response->value());
	
	    # Delete sliver status rows.
	    foreach my $node_id (@nodes) {
		$sliver->DeleteSliverStatus($node_id);
	    }
	    $response->value(0);
	}
	else {
	    $sliver->SetStatus("ready");
	}
	return $response;
    };

    #
    # Set the status back to provisioning for the web interface.
    #
    $instance->SetStatus("provisioning") if (!$nostatus);

    #
    # Delete aggregates first, that should be quick.
    #
    if (@delaggs) {
	my $taskopt = (defined($webtask) ? "-t $webtask_id" : "");
	
	system("$MANAGEINSTANCE $taskopt deleteaggregates $uuid -N -S ".
	       join(" ", map {"'" . $_->aggregate_urn() . "'"} @delaggs));
	if ($?) {
	    exit($? >> 8);
	}
    }

    # Invoke on all clusters
    $errcode = CallMethodOnAggregates($coderef, 0, \$response, @aggregates);
    if ($errcode) {
	$errmsg = $response;
	goto bad;
    }

    #
    # Look at all the responses.
    #
    foreach my $agg (@aggregates) {
	my $response = shift(@{$response});
	my $code = $response->code();

	if ($code != GENIRESPONSE_SUCCESS) {
	    ($exitcode, $errmsg) = ResponseErrorMessage($agg, $response);
	    $errcode = $code;
	    next;
	}
	# We need to reload the sliver since it was modified in a child.
	$agg->Refresh();
    }
    goto bad
	if ($errcode);

    #
    # Let the web interface continue, we poll now.
    #
    if (! ($debug || $foreground)) {
	$logname = TBMakeLogname("deletenode");
	if (TBBackGround($logname)) {
	    exit(0);
	}	
	# Kill the webtask, no longer allowed to change it.
	$webtask = undef;
    }
    $instance->SetStatus("provisioned") if (!$nostatus);
    $instance->ComputeNodeCounts();
    my @return_codes = ();

    if (ParRun({"maxwaittime" => 99999,
		"maxchildren" => scalar(@aggregates)}, \@return_codes,
	       \&APT_Instance::Aggregate::WaitForSliver, @aggregates)) {
	#
	# The parent caught a signal. Leave things intact so that we can
	# kill things cleanly later.
	#
	$errmsg = "Internal error waiting for slivers";
	goto bad;
    }
    #
    # Check the exit codes. 
    #
    foreach my $aggobj (@aggregates) {
	my $code = shift(@return_codes);

	# Updated in a forked child, must refresh. 
	$aggobj->Refresh();
	
	if ($code) {
	    if ($aggobj->webtask()->output()) {
		$errmsg = $aggobj->webtask()->output();
	    }
	    else {
		$errmsg = "WaitforSliver Failure at ".$aggobj->aggregate_urn();
	    }
	    $errcode = $aggobj->webtask()->exitcode();
	    goto bad;
	}
    }
    unlink($logname) if (defined($logname));
    $slice->UnLock() if (!$nolock);
    $instance->SetStatus("ready") if (!$nostatus);
    $webtask->Exited(0)
	if (defined($webtask));
    exit(0);
  bad:
    $instance->SetStatus("ready") if (!$nostatus);
    $slice->UnLock() if (!$nolock && $gotlock);
    print STDERR $errmsg . "\n";
    if (defined($webtask)) {
	$webtask->output($errmsg);
	$webtask->Exited($errcode);
    }
    exit($exitcode);
}

#
# Delete aggregates from an instance. Not allowed to delete the last one.
#
# XXX: Need to fix the manifests after delete (or add).
#
sub DoDeleteAggregates()
{
    my $errmsg;
    my $errcode;
    my $exitcode = -1;
    my $response;

    my $optlist    = "NS";
    my $nolock     = 0;	# Caller holds the lock.
    my $nostatus   = 0; # Caller handles instance status changes.
    my %options    = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }
    if (defined($options{"N"})) {
	$nolock = 1;
    }
    if (defined($options{"S"})) {
	$nostatus = 1;
    }

    my $slice = $instance->GetGeniSlice();
    if (!defined($slice)) {
	fatal("No slice for instance");
    }
    my @aggregates  = ();
    my $agghash     = $instance->AggregateHash();

    #
    # Lock the slice in case it is doing something else, like taking
    # a disk image.
    #
    if (!$nolock && $slice->Lock()) {
	$errmsg = "Experiment is busy, cannot lock it. Please try again later";
	$errcode  = GENIRESPONSE_BUSY;
	$exitcode = 1;
    }
    $gotlock = 1 if (!$nolock);
    
    if (@ARGV) {
	# Sanity check on the list.
	foreach my $urn (@ARGV) {
	    if (! GeniHRN::IsValid($urn)) {
		fatal("Not a valid urn: $urn");
	    }
	    if (!exists($agghash->{$urn})) {
		print "Aggregate is not in this experiment, skipping: $urn\n";
		next;
	    }
	    push(@aggregates, $agghash->{$urn});
	}
    }
    else {
	foreach my $agg ($instance->AggregateList()) {
	    if ($agg->status() eq "canceled") {
		push(@aggregates, $agg);
	    }
	}
    }
    if (!@aggregates) {
	print "Nothing to do, exiting\n";
	if (defined($webtask)) {
	    $webtask->Exited(0);
	}
	$slice->UnLock() if (!$nolock);
	exit(0);
    }

    #
    # Any aggregates that never got out of the created phase can be
    # deleted immediately. 
    #
    my @tmp = ();
    foreach my $aggregate (@aggregates) {
	if ($aggregate->status() eq "created" ||
	    $aggregate->status() eq "prestage") {
	    #
	    # Need to deal with history entries.
	    #
	    print "$aggregate never started.\n";
	    $aggregate->MarkTerminated();
	    next;
	}
	#
	# Mark as canceled in case we cannot reach the clusters, the scheduler
	# will look for this and try again
	#
	$aggregate->SetStatus("canceled");

	#
	# Look to see if the aggregate is online, lets not bounce the
	# status page around more then necessary.
	#
	my $aptagg = $aggregate->GetAptAggregate();
	if ($aptagg->CheckStatus(\$errmsg, 1) != 0) {
	    print "$aptagg is not reachable, skipping: $errmsg\n";
	    next;
	}
	push(@tmp, $aggregate);
    }
    if (!@tmp) {
	goto done;
    }
    @aggregates = @tmp;
        
    #
    # Helper callback to send the proper arguments.
    #
    my $coderef = sub {
	my ($sliver) = @_;
	$sliver->SetStatus("terminating");

	# Flag that we want to clear the panic, so send an auth credential.
	return $sliver->Terminate($instance->paniced() ? 1 : undef);
    };

    #
    # Set the status back to provisioning for the web interface.
    #
    $instance->SetStatus("provisioning") if (!$nostatus);

    # Invoke on all clusters
    $errcode = CallMethodOnAggregates($coderef, 2, \$response, @aggregates);
    if ($errcode) {
	$errmsg = $response;
	goto bad;
    }

    # Flag, do we need to merge/push a new manifest.
    my $needpush = 0;

    #
    # Look at all the responses, update the status. 
    #
    my @responses = @{$response};
    foreach my $agg (@aggregates) {
	my $response = shift(@responses);
	my $code = $response->code();

	# SEARCHFAILED is success too
	if ($code == GENIRESPONSE_SUCCESS ||
	    $code == GENIRESPONSE_SEARCHFAILED) {
	    $agg->MarkTerminated();
	    $needpush = 1;
	    next;
	}
	($exitcode,$errmsg) = ResponseErrorMessage($agg, $response);
	
	#
	# These will typically clear up at some point.
	#
	if ($code == GENIRESPONSE_BUSY ||
	    $code == GENIRESPONSE_SERVER_UNAVAILABLE ||
	    $code == GENIRESPONSE_NETWORK_ERROR) {
	    $errcode  = $code;
	    $exitcode = 1;

	    # So we know to try again later.
	    $agg->SetStatus("canceled");
	}
	else {
	    # Tell the caller, which is going to be the daemon. Not yet sure
	    # how we will handle this error.
	    $errcode  = $code;
	    $exitcode = -1;
	}
    }
    # If we made any changes, merge/push the manifests.
    if ($needpush) {
	if ($instance->MergeManifests()) {
	    print STDERR "Could not merge manifests\n";
	}
	elsif (PushManifestInternal($instance->manifest())) {
	    print STDERR "Could not push manifests\n";
	}
    }
    # Will have to try again later.
    goto bad
	if ($errcode);
  done:
    $slice->UnLock() if (!$nolock);
    $instance->SetStatus("ready") if (!$nostatus);
    $webtask->Exited(0)
	if (defined($webtask));
    exit(0);
  bad:
    $instance->SetStatus("ready") if (!$nostatus);
    $slice->UnLock() if (!$nolock);
    print STDERR $errmsg . "\n";
    if (defined($webtask)) {
	$webtask->output($errmsg);
	$webtask->Exited($errcode);
    }
    exit($exitcode);
}

#
# Add aggregates to a running experiment. We do this by rspec; we merge
# the new rspec fragment into the existing rspec. 
#
# XXX: New rspec needs to be fully bound for now.
# XXX: Need to fix the manifests after add.
#
sub DoAddAggregates()
{
    my $errmsg;
    my $errcode;
    my $exitcode = -1;
    my $response;

    my $optlist    = "Nc";
    my $nolock     = 0;	# Caller holds the lock.
    my $docreate   = 0; # Fire off create_slivers.
    my %options    = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }
    if (defined($options{"N"})) {
	$nolock = 1;
    }
    if (defined($options{"c"})) {
	$docreate = 1;
    }
    if ($docreate && $nolock) {
	fatal("Not allowed to use -N and -c together");
    }
    usage()
	if (@ARGV != 1);

    my $filename = $ARGV[0];
    if (! -e $filename) {
	fatal("No such file");
    }
    my $rspecstr = emutil::ReadFile($filename);
    if (!$rspecstr) {
	fatal("Could not read $filename: $!");
    }
    my $rspecfrag = GeniXML::Parse($rspecstr);
    if (! defined($rspecfrag)) {
	fatal("Could not parse rspec fragment");
    }
    my $slice = $instance->GetGeniSlice();
    if (!defined($slice)) {
	fatal("No slice for instance");
    }
    #
    # Lock the slice early since we are going to be messing with the rspec.
    #
    if (!$nolock && $slice->Lock()) {
	$errmsg = "Experiment is busy, cannot lock it. Please try again later";
	print STDERR $errmsg . "\n";
	if (defined($webtask)) {
	    $webtask->output($errmsg);
	    $webtask->Exited(GENIRESPONSE_BUSY);
	}
	exit(1);
    }
    # For fatal()
    $gotlock = 1 if (!$nolock);

    #
    # Simplification; instance has to be in ready state to change it. 
    #
    if ($instance->status() ne "ready") {
	$errmsg = "Experiment is not ready. Please try again later";
	print STDERR $errmsg . "\n";
	if (defined($webtask)) {
	    $webtask->output($errmsg);
	    $webtask->Exited(GENIRESPONSE_BUSY);
	}
	$slice->UnLock() if (!$nolock);
	exit(1);
    }
    my $rspec = GeniXML::Parse($instance->rspec());
    if (! defined($rspec)) {
	fatal("Could not parse instance rspec");
    }
    my @aggregates  = ();
    my $agghash     = $instance->AggregateHash();

    #
    # Sanity check the new rspec fragment to make sure we can actually merge
    # it into the instance rspec.
    #
    foreach my $ref (GeniXML::FindNodes("n:node", $rspecfrag)->get_nodelist()) {
	my $client_id   = GetVirtualId($ref);
	my $manager_urn = GetManagerId($ref);

	if (!defined($client_id)) {
	    fatal("No client ID for node");
	}
	if (!defined($manager_urn)) {
	    fatal("No manager for $client_id");
	}
	if (!GeniHRN::IsValid($manager_urn)) {
	    fatal("Invalid manager urn for $client_id: $manager_urn");
	}
	if (exists($agghash->{$manager_urn})) {
	    fatal("Aggregate already exists for instance");
	}
	if (GeniXML::GetNodeByVirtualId($client_id, $rspec)) {
	    fatal("Already have a node with client id: $client_id");
	}
	my $aptaggregate = APT_Aggregate->Lookup($manager_urn);
	if (!defined($aptaggregate)) {
	    fatal("No such APT Aggregate: $manager_urn\n");
	}
    }
    foreach my $ref (GeniXML::FindNodes("n:node", $rspecfrag)->get_nodelist()) {
	my $manager_urn = GetManagerId($ref);
	
	if (!$instance->GetAggregate($manager_urn)) {
	    my $aggobj = $instance->AddAggregate($manager_urn);
	    if (!defined($aggobj)) {
		fatal("Could not create aggregate object for $manager_urn");
	    }
	    push(@aggregates, $aggobj);

	    #
	    # Mark for prestaging images if needed. Must also change
	    # the instance status for create_slivers. Needs more
	    # thought.
	    #
	    my $aptaggregate = APT_Aggregate->Lookup($manager_urn);
	    if ($aptaggregate->prestageimages()) {
		$aggobj->SetStatus("prestage");
	    }
	}
	$rspec->appendChild($ref);
    }
    $instance->Update({"rspec" => GeniXML::Serialize($rspec)});
    
    if ($docreate) {
	system("$CREATESLIVERS -L -f " .
	       ($debug ? "-d " : "") .  $instance->uuid());
	if ($?) {
	    my $code = $? >> 8;
	    $code = -1
		if ($code == 255);
	    if (defined($webtask)) {
		$webtask->Exited($code)
	    }
	    exit($code);
	}
	# We passed the lock to create_slivers.
	exit(0);
    }
    else {
	#
	# Mark it as deferred so the scheduler will pick it up. 
	#
	foreach my $agg (@aggregates) {
	    $agg->Defer();
	}
	$instance->Defer();
    }
    $slice->UnLock() if (!$nolock);
    $webtask->Exited(0)
	if (defined($webtask));
    exit(0);
}

#
# Start up the monitor for an instance. Only one though.
#
sub StartMonitor()
{
    my $waitforstartup = 0;
    
    if (@ARGV && $ARGV[0] eq "-w") {
	$waitforstartup = 1;
    }
    return StartMonitorInternal($waitforstartup);
}

sub StartMonitorInternal(;$)
{
    my ($waitforstartup) = @_;
    my $logfile;
    my $failed = 0;

    # Wait for the startup command to finish.
    $waitforstartup = 0
	if (!defined($waitforstartup));
    
    my $slice = $instance->GetGeniSlice();
    if (!defined($slice)) {
	fatal("No slice for instance");
    }
    if ($instance->monitor_pid()) {
	my $pid = $instance->monitor_pid();
	if (kill(0, $pid)) {
	    print STDERR "Monitor already running ($pid). ".
		"Kill it before starting a new one.\n";
	    return 1;
	}
	$instance->Update({"monitor_pid" => 0});
    }
    if (!$debug) {
	$logfile = TBMakeLogname("aptmonitor");
	if (TBBackGround($logfile)) {
	    return $PID;
	}
    }
    $instance->Update({"monitor_pid" => $PID});

    #
    # We just did the operation, no need to ask so soon, and we
    # avoid locking the slice in case the user wants to reboot
    # another node right away. For reboot/reload, nothing interesting
    # is going to be reported for a while.
    #
    sleep(30);
    
    my $seconds  = ($waitforstartup ? 7200 : 1800);
    my $interval = 15;
    # Shorten default timeout now.
    Genixmlrpc->SetTimeout(30);

    my $coderef = sub {
	my ($sliver) = @_;
	my $webtask  = $sliver->webtask();
	my $errmsg;

	my $response = $sliver->SliceStatus();
	if ($response->code() != GENIRESPONSE_SUCCESS &&
	    $response->code() != GENIRESPONSE_SERVER_UNAVAILABLE &&
	    $response->code() != GENIRESPONSE_BUSY &&
	    $response->code() != GENIRESPONSE_NETWORK_ERROR) {
	    print STDERR "SliverStatus failed: ". $response->error() . "\n";
	    $webtask->output($response->error());
	    $webtask->exitcode($response->code());
	    return $response;
	}
	# Indicate not done but need to continue. 
	if ($response->code() != GENIRESPONSE_SUCCESS) {
	    $response->code(GENIRESPONSE_INPROGRESS);
	    return $response;
	}
	my $blob = $response->value();
	# This is the per-aggregate status, we always set this for web UI.
	$sliver->UpdateSliverStatusAll($blob->{'details'});
	if ($debug) {
	    print STDERR Dumper($blob->{'details'});
	}
	# Look for nodes still executing
	my $executing = 0;
	if ($waitforstartup) {
	    foreach my $urn (keys(%{$blob->{'details'}})) {
		my $details = $blob->{'details'}->{$urn};
		
		$executing++
		    if (exists($details->{'execute_state'}) &&
			$details->{'execute_state'} ne "exited");
	    }
	}
	#
	# We poll until the status goes ready, and if waiting for the
	# startup commands to finish, for all of them to no longer be
	# executing.
	#
	if ($blob->{'status'} eq "ready") {
	    # Update the toplevel status for the sliver. Note that by
	    # going to ready, if we failed initially, the user can get
	    # themselves out of failure mode for the instance, say by
	    # reboot or reload.
	    $sliver->SetStatus("ready");

	    return $response
		if (!$executing || !$waitforstartup);
	}
	# Indicate not done but need to continue. 
	$response->code(GENIRESPONSE_INPROGRESS);
	return $response;
    };

    #
    # We poll only those aggregates that are not ready yet.
    #
    my @aggregates = ();
    # Skip deferred aggregates for now.
    foreach my $ref ($instance->AggregateList()) {
	push(@aggregates, $ref)
	    if ($ref->deferred());
    }

    while ($seconds > 0 && @aggregates) {
	my $response;
	my $errcode;
	$seconds -= $interval;
	
	#
	# Lock the slice in case it is doing something else, like taking
	# a disk image. Just skip this turn.
	#
	if ($slice->Lock()) {
	    #
	    # Lets make sure the instance still exists. It could disappear
	    # during the sleep, which would cause the Lock() to fail. 
	    last
		if ($instance->Refresh());
	    goto delay;
	}
	$errcode = CallMethodOnAggregates($coderef, 0, \$response, @aggregates);
	if ($errcode) {
	    $slice->UnLock();
	    print STDERR "Failed to get status: $response\n";
	    $failed = 1;
	    last;
	}
	$slice->UnLock();
	
	#
	# Check the responses. Busy means keep going, all other errors
	# are bad news.
	#
	my @tmp = ();
	foreach my $aggregate (@aggregates) {
	    my $response = shift(@{$response});
	    my $code = $response->code();
	    # Updated in the forked child, need to refresh.
	    $aggregate->Refresh();

	    next
		if ($code == GENIRESPONSE_SUCCESS);
	    push(@tmp, $aggregate);
	}
	@aggregates = @tmp;
	last
	    if (!@aggregates);
      delay:
	sleep($interval);
    }
    if ($seconds < 0) {
	print STDERR "Timed out in the monitor waiting for ready\n";
	$failed = 1;
    }
    if (!$failed && $instance->status() eq "failed") {
	#
	# Try to move the instance to ready if it failed but better now.
	#
	my $ready = 1;
	foreach my $agg ($instance->AggregateList()) {
	    $ready = 0
		if ($agg->status() ne "ready");
	}
	$instance->SetStatus("ready")
	    if ($ready);
    }
    unlink($logfile)
	if (defined($logfile) && !$debug);
    exit($failed ? -1 : 0);
}

#
# Experiment lockdown.
#
sub DoLockdownInternal($$$$)
{
    my ($setclr,$which,$force, $perrmsg) = @_;
    my $errmsg;
    my $errcode;
    my $response;

    my $slice = $instance->GetGeniSlice();
    if (!defined($slice)) {
	fatal("No slice for instance");
    }
    my $admin_lockdown = $instance->admin_lockdown();
    my $user_lockdown  = $instance->user_lockdown();

    if ($which eq "all") {
	$admin_lockdown = $user_lockdown = ($setclr eq "clear" ? 0 : 1);
    }
    elsif ($which eq "admin") {
	$admin_lockdown = ($setclr eq "clear" ? 0 : 1);
    }
    elsif ($which eq "user") {
	$user_lockdown = ($setclr eq "clear" ? 0 : 1);
    }
    my $clear = ($admin_lockdown || $user_lockdown ? 0 : 1);

    #
    # We cannot lockdown at AL2S, so look to see if we cross it, and if
    # so we send an email warning.
    #
    my @aggregates = ();

    if ($instance->AggregateList() > 1) {
	foreach my $agg ($instance->AggregateList()) {
	    if ($agg->isAL2S()) {
		if (!$clear) {
		    my $project = $instance->GetProject();
		    $project->SendEmail($this_user->email(),
				"Failed to completely lock down APT Instance",
				"Failed to completely lock down $instance,\n".
				"cause it crosses AL2S.\n\n".
				$instance->webURL() . "\n",
				$project->OpsEmailAddress(),
				"CC: " . $project->OpsEmailAddress());
		}
	    }
	    else {
		push(@aggregates, $agg);
	    }
	}
    }
    else {
	@aggregates = $instance->AggregateList();
    }

    #
    # Helper callback to send the proper arguments.
    #
    my $coderef = sub {
	my ($sliver) = @_;

	return $sliver->Lockdown($clear, $force);
    };

    # Invoke on all clusters
    $errcode = CallMethodOnAggregates($coderef, 2, \$response, @aggregates);
    if ($errcode) {
	$$perrmsg = $response;
	return $errcode;
    }

    #
    # Look at all the responses.
    #
    foreach my $agg (@aggregates) {
	my $response = shift(@{$response});
	my $code = $response->code();

	if ($code != GENIRESPONSE_SUCCESS) {
	    if ($code == GENIRESPONSE_REFUSED) {
		$errcode = $code;
		$errmsg  = $response->error();
	    }
	    else {
		($errcode, $errmsg) = ResponseErrorMessage($agg, $response);
	    }
	    next;
	}
    }
    if ($errcode) {
	$$perrmsg = $errmsg;
	return $errcode;
    }
    #
    # Change local state only if operation succeeds.
    #
    if ($slice->SetLockdown($clear)) {
	print STDERR "Could not update slice lockdown\n";
	return -1
    }
    if ($instance->SetLockdown($admin_lockdown, $user_lockdown)) {
	print STDERR "Could not update instance lockdown flags\n";
	return -1
    }
    return 0;
}

sub DoLockdown()
{
    my $errmsg;
    my $errcode = -1;
    my $force   = 0;
    
    my $optlist = "f";
    my %options = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }
    if (defined($options{"f"})) {
	$force = 1;
    }
    usage()
	if (@ARGV != 2);
    my $setclr = shift(@ARGV);
    my $which  = shift(@ARGV);

    fatal("Must specify either 'admin' or 'user'")
	if ($which !~ /^(admin|user|all)$/);
    fatal("Must specify either 'set' or 'clear'")
	if ($setclr !~ /^(set|clear)$/);

    my $slice = $instance->GetGeniSlice();
    if (!defined($slice)) {
	fatal("No slice for instance");
    }
    if ($slice->Lock()) {
	$errmsg = "Experiment is busy, cannot lock it. Please try again later";
	$errcode = 1;
	goto bad;
    }
    $errcode = DoLockdownInternal($setclr, $which, $force, \$errmsg);
    if ($errcode) {
	$errmsg = "Failed to lockdown instance: $errcode"
	    if (!defined($errmsg));
	goto bad;
    }
    $slice->UnLock();
    exit(0);
    
  bad:
    $slice->UnLock();
    print STDERR $errmsg . "\n";
    if (defined($webtask)) {
	$webtask->output($errmsg);
	$webtask->Exited($errcode);
    }
    exit($errcode);
}

sub DoPanic()
{
    my $errmsg;
    my $errcode  = -1;
    my $exitcode = -1;
    my $response;
    my $logfile;
    
    my $optlist     = "LpfR";
    my $takelock    = 0;
    my $poweroff    = 0;
    my $radiosonly  = 0;
    my $foreground  = 0;
    
    my %options = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }
    if (defined($options{"L"})) {
	$takelock = 1;
    }
    if (defined($options{"p"})) {
	$poweroff = 1;
	if (defined($options{"R"})) {
	    $radiosonly = 1;
	}
    }
    if (defined($options{"f"})) {
	$foreground = 1;
    }
    usage()
	if (@ARGV != 1);
    
    my $setclr = shift(@ARGV);
    fatal("Must specify either 'set' or 'clear'")
	if ($setclr !~ /^(set|clear)$/);

    my $slice = $instance->GetGeniSlice();
    if (!defined($slice)) {
	fatal("No slice for instance");
    }
    #
    # When told to take the lock, we take it and go.
    #
    if ($takelock) {
	$slice->TakeLock();
    }
    elsif ($slice->Lock()) {
	$errmsg = "Experiment is busy, cannot lock it. Please try again later";
	$errcode  = GENIRESPONSE_BUSY;
	$exitcode = 1;
	goto bad;
    }
    # Check the panic flag after locking, in case someone beat us to it.
    $instance->Refresh();
    if ($setclr eq "set") {
	if ($instance->paniced()) {
	    print "Already in a panic!\n";	
	    if (defined($webtask)) {
		$webtask->output("Already in a panic");
		$webtask->Exited(0);
	    }
	    $slice->UnLock();
	    exit(0);
	}
    }
    else {
	if (!$instance->paniced()) {
	    print "No longer in a panic!\n";
	    if (defined($webtask)) {
		$webtask->output("No longer in a panic");
		$webtask->Exited(0);
	    }
	    $slice->UnLock();
	    exit(0);
	}
    }

    #
    # No panic at stitching aggregates, so look to see if we cross any.
    #
    my @aggregates = ();

    if ($instance->AggregateList() > 1) {
	foreach my $agg ($instance->AggregateList()) {
	    next
		if ($agg->isAL2S() || $agg->isStitch());
	    push(@aggregates, $agg);
	}
    }
    else {
	@aggregates = $instance->AggregateList();
    }

    #
    # Exit and let caller poll for status.
    #
    if (!$foreground) {
        $logfile = TBMakeLogname("panic");
	
	if (my $childpid = TBBackGround($logfile)) {
	    #
	    # Wait a couple of seconds to see if there is going to be an
	    # immediate error. Then return and let it continue to run. This
	    # allows the web server to see quick errors. Later errors will
	    # have to be emailed. 
	    #
	    sleep(15);
	    my $foo = waitpid($childpid, &WNOHANG);
	    if ($foo) {
		my $status = $? >> 8;
		if ($status) {
		    print "There was a problem changing panic mode ...\n";
		    system("/bin/cat $logfile");
		}
		exit($status);
	    }
	    # Child still running.
	    print "Proceeding in the background ...\n";
	    exit(0);
	}
    }

    #
    # Helper callback to send the proper arguments.
    #
    my $coderef = sub {
	my ($sliver) = @_;

	return $sliver->Panic(($setclr eq "clear" ? 1 : 0),
			      $poweroff, $radiosonly);
    };

    # Invoke on all clusters
    $errcode = CallMethodOnAggregates($coderef, 0, \$response, @aggregates);
    if ($errcode) {
	$errmsg   = $response;
	$exitcode = -1;
	goto bad;
    }

    #
    # Look at all the responses.
    #
    foreach my $agg (@aggregates) {
	my $response = shift(@{$response});
	my $code = $response->code();

	if ($code != GENIRESPONSE_SUCCESS) {
	    if ($code == GENIRESPONSE_SEARCHFAILED) {
		# Skip this one, but do not reset the errcode in case
		# this is a multi aggregate instance.
		next;
	    }
	    $errcode = $code;

	    ($exitcode, $errmsg) = ResponseErrorMessage($agg, $response);
	}
    }
    goto bad
	if ($errcode);

    #
    # Do not mark as paniced unless we get all the aggregates.
    #
    if ($instance->SetPanic(($setclr eq "clear" ? 1 : 0))) {
	$errmsg   = "Could not update instance panic flag";
	$errcode  = GENIRESPONSE_ERROR;
	$exitcode = -1;
	goto bad;
    }
    $slice->UnLock();
    unlink($logfile)
	if (defined($logfile) && !$debug);
    exit(0);

  bad:
    $slice->UnLock();
    print STDERR $errmsg . "\n";
    if (defined($webtask)) {
	$webtask->output($errmsg);
	$webtask->Exited($errcode);
    }
    unlink($logfile)
	if (defined($logfile) && !$debug);
    exit($exitcode);
}

#
# Linktest
# 
sub DoLinktest()
{
    my $action = "start";
    my $level  = 1;
    my $errmsg;
    my $errcode = 1;
    my $exitcode = -1;
    my $response;
    
    if (@ARGV) {
	my $arg = shift(@ARGV);
	if ($arg eq "-k") {
	    $action = "stop";
	}
	elsif ($arg =~ /^\d$/ && $arg >= 1 && $arg <= 4) {
	    $level = $arg;
	}
	else {
	    usage();
	}
    }
    my $slice = $instance->GetGeniSlice();
    if (!defined($slice)) {
	fatal("No slice for instance!");
    }

    #
    # Lock the slice in case it is doing something else, like taking
    # a disk image.
    #
    if ($slice->Lock()) {
	$errcode = GENIRESPONSE_BUSY;
	$errmsg  ="Experiment is busy, cannot lock it. Try again later.";
	if (defined($webtask)) {
	    $webtask->output($errmsg);
	    $webtask->Exited($errcode);
	}
	print STDERR "$errmsg\n";
	exit(1);
    }
    # Check after lock to prevent concurrent startup. 
    if ($action eq "start") {
	if ($instance->status() ne "ready") {
	    $slice->UnLock();
	    fatal("Must be ready to run linktest!");
	}
	# Change status now.
	$instance->SetStatus("linktest");
    }
    else {
	if ($instance->status() ne "linktest") {
	    $slice->UnLock();
	    fatal("Linktest is not running!");
	}
    }
    
    #
    # Only clusters with nodes.
    #
    my @aggregates = ();

    if ($instance->AggregateList() > 1) {
	foreach my $agg ($instance->AggregateList()) {
	    push(@aggregates, $agg)
		if ($agg->physnode_count() || $agg->virtnode_count());	    
	}
    }
    else {
	@aggregates = $instance->AggregateList();
    }

    #
    # Helper callback to send the proper arguments.
    #
    my $coderef = sub {
	my ($sliver) = @_;

	return $sliver->RunLinktest($action, $level);
    };

    # Invoke on all clusters
    $errcode = CallMethodOnAggregates($coderef, 0, \$response, @aggregates);
    if ($errcode) {
	$errmsg = $response;
	goto bad;
    }

    #
    # Look at all the responses.
    #
    foreach my $agg (@aggregates) {
	my $response = shift(@{$response});
	my $code = $response->code();

	if ($code != GENIRESPONSE_SUCCESS) {
	    $errcode = $code;
	    ($exitcode, $errmsg) = ResponseErrorMessage($agg, $response);
	    next;
	}
	my $blob = $response->value();
	if ($blob->{'status'} eq "running") {
	    $agg->webtask()->status("running");
	    $agg->webtask()->url($blob->{'url'});
	}
	elsif ($blob->{'status'} eq "stopped") {
	    $agg->webtask()->status("stopped");
	    $agg->webtask()->results($blob->{'results'});
	}
    }
    goto bad
	if ($errcode);

    if ($action eq "stop") {
	$instance->SetStatus("ready");
	$slice->UnLock();
	exit(0);
    }
    #
    # Okay, now we want to wait for linktest to finish on all the clusters
    # so that we can change the status back to ready.
    #
    my $logfile = TBMakeLogname("linktest");
	
    if (my $childpid = TBBackGround($logfile)) {
	sleep(1);
	my $status = 0;
	my $foo = waitpid($childpid, &WNOHANG);
	if ($foo) {
	    $status = $? >> 8;
	}
	# Kill the webtask, no longer allowed to change it.
	$webtask = undef;
	# Unlock so user can stop linktest.
	$slice->UnLock();
	exit($status);
    }
    #
    # Loop, asking each cluster for the linktest status.
    #
    my $tlimit  = 3600;
    my $errors  = 0;
    my %running = map { $_->aggregate_urn() => $_ } @aggregates;
    while ($tlimit > 0 && keys(%running)) {
	foreach my $sliver (values(%running)) {
	    my $response = $sliver->RunLinktest("status");
	    if ($response->code() != GENIRESPONSE_SUCCESS) {
		if ($response->code() == GENIRESPONSE_SERVER_UNAVAILABLE ||
		    $response->code() == GENIRESPONSE_BUSY ||
		    $response->code() == GENIRESPONSE_NETWORK_ERROR) {
		    next;
		}
		print STDERR "Could not get linktest status for sliver: ".
		    $response->error() . "\n";
		delete($running{$sliver->aggregate_urn()});
		
		# If the sliver was deleted during linktest, we do not
		# consider it an error.
		if ($response->code() != GENIRESPONSE_SEARCHFAILED) {
		    $errors++;
		}
		next;
	    }
	    my $blob = $response->value();
	    if ($blob->{'status'} eq "stopped") {
		delete($running{$sliver->aggregate_urn()});
	    }
	}
	$tlimit -= 15;
	sleep(15);
    }
    if ($tlimit <= 0) {
	print STDERR "Linktest run timed out!\n";
	# Lets generate email for now, still debugging.
	$errors++;
    }
    $instance->SetStatus("ready")
	if ($action eq "start");
    if ($errors) {
	SENDMAIL($TBOPS,
		 "Error running linktest",
		 "Error running linktest on $instance.\n",
		 $TBOPS, undef, $logfile);
    }
    unlink($logfile);
    exit(0);
  bad:
    $instance->SetStatus("ready")
      if ($action eq "start");
    
    $slice->UnLock();
    print STDERR $errmsg . "\n";
    if (defined($webtask)) {
	$webtask->output($errmsg);
	$webtask->Exited($errcode);
    }
    exit($errcode);
}

#
# Update SSH keys.
# 
sub DoUpdateKeys()
{
    my $target_user;
    my $errmsg;
    my $errcode = 1;
    my $exitcode = -1;
    my $response;
    
    if (@ARGV) {
	my $uid = shift(@ARGV);
	# If a target user, we are operating on that user, not the
	# entire instance.
	$target_user = User->Lookup($uid);
	if (!defined($target_user)) {
	    fatal("no such target user $uid");
	}
	$target_user = GeniUser::LocalUser->Create($target_user);
    }
    my $slice = $instance->GetGeniSlice();
    if (!defined($slice)) {
	fatal("No slice for instance!");
    }

    # This returns in CM format.
    my $sshkeys;
    if ($instance->GetSSHKeys(\$sshkeys, $target_user) < 0 || !@{$sshkeys}) {
	fatal("Could not get ssh keys for instance");
    }

    #
    # The AM API uses a different ssh key structure.
    #
    my $users = [];
    foreach my $user (@{$sshkeys}) {
	my @tmp = map { $_->{'key'} } @{$user->{'keys'}};
	
	push(@{$users},
	     {"urn"  => $user->{'urn'},
	      "keys" => [ @tmp ] });
    }

    #
    # Lock the slice in case it is doing something else, like taking
    # a disk image.
    #
    if ($slice->Lock()) {
	$errcode  = GENIRESPONSE_BUSY;
	$exitcode = 1;
	$errmsg   = "Experiment is busy, cannot lock it. Try again later.";
    }
    if (! $instance->ActiveAggregateList()) {
	print STDERR "No active aggregates to update keys on\n";
	$slice->UnLock();
	exit(0);
    }

    #
    # Only clusters with nodes.
    #
    my @aggregates = ();

    if ($instance->ActiveAggregateList() > 1) {
	foreach my $agg ($instance->ActiveAggregateList()) {
	    push(@aggregates, $agg)
		if ($agg->physnode_count() || $agg->virtnode_count());	    
	}
    }
    else {
	@aggregates = $instance->ActiveAggregateList();
    }

    #
    # Helper callback to send the proper arguments.
    #
    my $coderef = sub {
	my ($sliver) = @_;

	return $sliver->UpdateKeys($users);
    };

    # Invoke on all clusters
    $errcode = CallMethodOnAggregates($coderef, 1, \$response, @aggregates);
    if ($errcode) {
	$errmsg = $response;
	goto bad;
    }

    #
    # Look at all the responses.
    #
    foreach my $agg (@aggregates) {
	my $response = shift(@{$response});
	my $code = $response->code();

	if ($code != GENIRESPONSE_SUCCESS) {
	    $errcode = $code;
	    ($exitcode, $errmsg) = ResponseErrorMessage($agg, $response);
	    next;
	}
    }
    goto bad
	if ($errcode);

    $slice->UnLock();
    exit(0);
  bad:
    $slice->UnLock();
    print STDERR $errmsg . "\n";
    if (defined($webtask)) {
	$webtask->output($errmsg);
	$webtask->Exited($errcode);
    }
    exit($exitcode);
}

#
# Initiate or check the status of image prestaging.
#
sub DoPrestageImages()
{
    my $errmsg;
    my $errcode   = 0;
    my $exitcode  = 0;
    my $response;
    my $logfile;
    my $imagelist;
    my @aggregate_list = ();
    my $optlist     = "Nwb";
    my $waitmode    = 0; 
    my $nolock      = 0;	# Caller holds the lock.
    my $background  = 0;
    my $wholeexpt   = 0;
    my $prevstatus;
    
    my %options = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }
    if (defined($options{"N"})) {
	$nolock = 1;
    }
    if (defined($options{"b"})) {
	$background = 1;
    }
    if (defined($options{"w"})) {
	$waitmode = 1;
    }
    usage()
	if (@ARGV < 1);
    my $op = shift(@ARGV);

    if (! ($op eq "prestage" || $op eq "status")) {
	fatal("Bad operation, must be prestage or status");
    }
    if ($instance->GetImageList(\$errmsg, \$imagelist)) {
	print STDERR "Could not get imagelist: $errmsg\n";
	exit(-1);
    }
    if (@ARGV) {
	foreach my $urn (@ARGV) {
	    my $agg = $instance->GetAggregate($urn);
	    if (!defined($agg)) {
		fatal("Not an aggregate in this experiment: $urn");
	    }
	    push(@aggregate_list, $agg);
	}
    }
    else {
	@aggregate_list = $instance->AggregateList();
	$wholeexpt = 1;
    }

    #
    # For prestaging, prune out system images, these never need to be
    # checked and just wastes time.
    #
    my %tmp = ();
    foreach my $urn (keys(%{$imagelist})) {
	my @list   = @{$imagelist->{$urn}};
	my @pruned = ();

	foreach my $imageurn (@list) {
	    my $hrn = GeniHRN->new($imageurn);
	    next
		if ($hrn->ospid() eq TBOPSPID());

	    push(@pruned, $imageurn);
	}
	if (@pruned) {
	    $tmp{$urn} = \@pruned;
	}
    }
    $imagelist = \%tmp;

    my $slice = $instance->GetGeniSlice();
    if (!defined($slice)) {
	fatal("No slice for instance!");
    }
    if (!$nolock && $slice->Lock()) {
	$errcode  = GENIRESPONSE_BUSY;
	$exitcode = 1;
	$errmsg   = "Experiment is busy, cannot lock it. Try again later.";
	goto bad;
    }

    #
    # Only clusters that are using images,
    #
    my %aggregates   = ();
    my %aggregateops = ();

    foreach my $agg (@aggregate_list) {
	if ($op eq "prestage") {
	    #
	    # When doing a prestage, issue a prestage command if we have
	    # not done that. Otherwise issue a status call so the web UI
	    # gets updated.
	    #
	    next
		if (! ($agg->status() eq "prestage" ||
		       $agg->status() eq "staging"));

	    # No images, mark aggregate ready.
	    if (!exists($imagelist->{$agg->aggregate_urn()})) {
		$agg->SetStatus("staged");
		next;
	    }
	    if ($agg->status() eq "prestage") {
		$aggregateops{$agg->aggregate_urn()} = "prestage";
	    }
	    else {
		$aggregateops{$agg->aggregate_urn()} = "status";
	    }
	}
	elsif ($op eq "status") {
	    #
	    # When doing a status, only those aggs that are now staging.
	    #
	    next
		if ($agg->status() ne "staging");

	    $aggregateops{$agg->aggregate_urn()} = "status";
	}
	# For tracking (lack of) progress;
	$agg->_lastchange(time());
	# Last results.
	$agg->_lastresult(undef);
	
	$aggregates{$agg->aggregate_urn()} = $agg;
    }
    if (!keys(%aggregates)) {
	print "No images to prestage or precheck\n";
	goto done;
    }

    #
    # Exit and leave child to poll.
    #
    if ($background) {
        $logfile = TBMakeLogname("prestage");
	
	if (my $childpid = TBBackGround($logfile)) {
	    # Parent exits normally, web interface watches.
	    exit(0);
	}
	# Let parent exit;
	sleep(2);
	$webtask->SetProcessID($PID)
	    if (defined($webtask));
    }

    #
    # When operating on the whole experiment, set the instance status
    # to prestaging for the web interface. Not really necessary since
    # we still how the prestaging table. See the apt scheduler, that is
    # when we operate this way; prestaging images to an experiment that
    # starts in the future. 
    #
    if ($wholeexpt) {
	$prevstatus = $instance->status();
	$instance->SetStatus("prestaging");
    }

    #
    # Helper callback to send the proper arguments.
    #
    my $coderef = sub {
	my ($sliver) = @_;
	my $urn = $sliver->aggregate_urn();
	my $op  = $aggregateops{$urn};

	return $sliver->PrestageImages($op, $imagelist->{$urn});
    };

    #
    # Helper function to update the aggregate record in case of error.
    #
    my $markAggregateFailure = sub {
	my ($aggregate, $code, $message) = @_;

	my $blob = {
	    "status"  => "failed",
	    "code"    => $code,
	    "message" => $message,
	};
	my $text = eval { encode_json($blob); };
	if ($@) {
	    print STDERR "Failed to json encode blob: $@\n";
	    print STDERR Dumper($blob);
	    return -1;
	}
	$aggregate->Update({"prestage_data" => $text});
	return 0;
    };

    while (keys(%aggregates)) {
	# Invoke on all clusters. Retry in case of transient unreachability. 
	$errcode = CallMethodOnAggregates($coderef, 2,
					  \$response, values(%aggregates));
	if ($errcode) {
	    $errmsg = $response;
	    $slice->UnLock() if (!$nolock);
	    goto bad;
	}

	#
	# Look at all the responses.
	#
	foreach my $agg (values(%aggregates)) {
	    my $response = shift(@{$response});
	    my $code     = $response->code();

	    if ($code != GENIRESPONSE_SUCCESS) {
		$errcode = $code;
		($exitcode, $errmsg) = ResponseErrorMessage($agg, $response);
		
		#
		# These error codes mean we need to stop trying and wait
		# till later. Do not exit with an error.
		#
		if ($code == GENIRESPONSE_BUSY ||
		    $code == GENIRESPONSE_NETWORK_ERROR ||
		    $code == GENIRESPONSE_SERVER_UNAVAILABLE) {
		    $exitcode = 0;
		}
		else {
		    #
		    # Mark as nonfatal, let the caller decide.
		    #
		    $exitcode = 1;
		}
		&$markAggregateFailure($agg, $code, $errmsg);
		delete($aggregates{$agg->aggregate_urn()});
		next;
	    }
	    if (! (defined($response->value()) &&
		   ref($response->value()) eq "HASH" &&
		   exists($response->value()->{"status"}) &&
		   ref($response->value()->{"status"}) eq "HASH")) {
		print Dumper($response->value());
		$errmsg   = "Malformed response from $agg";
		$exitcode = -1;
		$errcode  = GENIRESPONSE_ERROR();
		&$markAggregateFailure($agg, "error", $errcode, $errmsg);
		delete($aggregates{$agg->aggregate_urn()});
		next;
	    }
	    # For debugging, lets set this early.
	    if (defined($response->logurl()) && $op eq "prestage" &&
		!defined($agg->public_url())) {
		$agg->SetPublicURL($response->logurl());
	    }
	    #
	    # The results is a hash, one per aggregate, with a status for
	    # the entire aggregate (all images ready, or not ready). Also
	    # a hash, one per image, with the status for that image and
	    # the current download size. This will hopefully be helpful
	    # enough to tell the user something in the web UI about what
	    # is going on.
	    #
	    my $result = {
		"status" => "ready",
		"images" => {},
	    };
	    my $blob = $response->value()->{"status"};
	    foreach my $urn (keys(%{$blob})) {
		my $info = $blob->{$urn};
		if (!exists($info->{"status"})) {
		    print Dumper($info);
		    $errmsg   = "Malformed response from $agg for $urn";
		    $exitcode = -1;
		    $errcode  = GENIRESPONSE_ERROR();
		    &$markAggregateFailure($agg, "error", $errcode, $errmsg);
		    delete($aggregates{$agg->aggregate_urn()});
		    last;
		}
		my $status = {
		    "status" => $info->{"status"},
		};
		if (exists($info->{"progress"})) {
		    $status->{"progress"} = $info->{"progress"};
		}
		if (exists($info->{"size"})) {
		    $status->{"size"} = $info->{"size"};
		}
		$result->{"images"}->{$urn} = $status;
	    
		if ($info->{"status"} ne "ready") {
		    # If any images not ready, the aggregate is not ready.
		    $result->{"status"} = "notready";
		
		    print "Image $urn at $agg is still not ready. ";
		    if (exists($info->{"progress"})) {
			print $info->{"progress"} . "KB have been imported.";
		    }
		    print "\n";
		}
		else {
		    print "Image $urn at $agg is ready\n";
		}
	    }
	    my $text = eval { encode_json($result); };
	    if ($@) {
		print Dumper($result);
		$errmsg   = "Failed to json encode blob: $@\n";
		$exitcode = -1;
		$errcode  = GENIRESPONSE_ERROR();
		&$markAggregateFailure($agg, "error", $errcode, $errmsg);
		delete($aggregates{$agg->aggregate_urn()});
		next;
	    }
	    if ($debug) {
		print Dumper($result);
	    }
	    $agg->Update({"prestage_data" => $text});

	    #
	    # Check for forward progress by comparing to previous call.
	    # We expect to see something change at each aggregate within
	    # a small number of minutes. 
	    #
	    if ($result->{"status"} ne "ready" && $agg->_lastresult()) {
		my $last = $agg->_lastresult();

		foreach my $urn (keys(%{ $result->{'images'} })) {
		    my $this = $result->{'images'}->{$urn};
		    next
			if ($this->{'status'} eq "ready");

		    my $prev = $last->{'images'}->{$urn};
		    if ($prev->{'progress'} != $this->{'progress'}) {
			# Forward motion
			$agg->_lastchange(time());
		    }
		    else {
			if (time() - $agg->_lastchange() > 120) {
			    print Dumper($last);
			    print Dumper($result);

			    #
			    # Needs more thought; what to do when this
			    # happens. At the moment, we throw an error
			    # back to create_slivers. 
			    #
			    $errmsg   = "Timed out, no progress on $urn ".
				"at $agg";
			    $exitcode = 1;
			    $errcode  = GENIRESPONSE_TIMEDOUT();
			    &$markAggregateFailure($agg, "error",
						   $errcode, $errmsg);
			    delete($aggregates{$agg->aggregate_urn()});
			    last;
			}
		    }
		}
	    }
	    # Save locally for next loop.
	    $agg->_lastresult($result);

	    #
	    # Advance the status for the aggregate.
	    #
	    if ($result->{"status"} eq "ready") {
		# Done staging at this aggregate.
		$agg->SetStatus("staged");
		delete($aggregates{$agg->aggregate_urn()});
	    }
	    elsif ($agg->status() eq "prestage") {
		# No errors for any of the images, so advance to staging
		$agg->SetStatus("staging");
	    }
	}
	last
	    if (!$waitmode || $exitcode);
	sleep(5);
    }
    if ($exitcode) {
	$slice->UnLock() if (!$nolock);
	goto bad;
    }
  done:
    if (defined($webtask)) {
	$webtask->Exited(0);
    }
    $instance->SetStatus($prevstatus) if ($wholeexpt);
    $slice->UnLock() if (!$nolock);
    unlink($logfile) if (defined($logfile));
    exit(0);
  bad:
    print STDERR $errmsg . "\n";
    if (defined($webtask)) {
	$webtask->output($errmsg);
	$webtask->Exited($errcode);
    }
    elsif ($background && $exitcode < 0) {
	SENDMAIL($TBOPS,
		 "Error prestaging images",
		 "Error prestaging images on $instance.\n",
		 $TBOPS, undef, $logfile);
    }
    $instance->SetStatus($prevstatus) if ($wholeexpt);
    unlink($logfile) if (defined($logfile));
    exit($exitcode);
}

#
# Get utilization info from the the clusters.
# 
sub DoUtilization()
{
    my $utilization;
    my $errmsg;
    my $errcode;
    my $exitcode = -1;
    my $response;
    my @aggregates = ();
    my $results = {};

    my $slice = $instance->GetGeniSlice();
    if (!defined($slice)) {
	fatal("No slice for instance!");
    }
    
    #
    # Get the nodeid to client id mapping
    #
    my %client_ids = ();
    foreach my $aggregate ($instance->AggregateList()) {
	#
	# Skip aggregates with no nodes.
	#
	next
	    if (! ($aggregate->physnode_count() ||
		   $aggregate->virtnode_count()));
	# Or no manifest.
	next
	    if (!defined($aggregate->manifest()) ||
		$aggregate->manifest() eq "");
	
	my $manifest = GeniXML::Parse($aggregate->manifest());
	if (! defined($manifest)) {
	    fatal("Could not parse manifest");
	}
	push(@aggregates, $aggregate);	
	$client_ids{$aggregate->aggregate_urn()} = {};
	
	my @nodes = GeniXML::FindNodes("n:node", $manifest)->get_nodelist();
	foreach my $node (@nodes) {
	    my $client_id = GeniXML::GetVirtualId($node);
	    my $node_id   = GeniXML::GetVnodeId($node);
	    my $manager_urn = GeniXML::GetManagerId($node);

	    # Combined rspec.
	    next
		if (!defined($manager_urn) ||
		    $manager_urn ne $aggregate->aggregate_urn());

	    $client_ids{$aggregate->aggregate_urn()}->{$node_id} = $client_id;
	}
    }

    # Invoke on all clusters
    $errcode = CallMethodOnAggregates("Utilization", 1,
				      \$response, @aggregates);
    if ($errcode) {
	$errmsg = $response;
	goto bad;
    }

    #
    # Look at all the responses.
    #
    foreach my $agg (@aggregates) {
	my $response = shift(@{$response});
	my $code = $response->code();

	if ($code != GENIRESPONSE_SUCCESS) {
	    $errcode = $code;
	    if ($code == GENIRESPONSE_REFUSED) {
		$exitcode = 1;
		$errmsg   = $response->error();
	    }
	    else {
		($exitcode, $errmsg) = ResponseErrorMessage($agg, $response);
	    }
	    next;
	}
	my $blob = $response->value();
	
	#
	# Annotate the result with some extra info for the web UI.
	#
	foreach my $node_id (keys(%{ $blob->{'details'}->{'nodes'} })) {
	    $blob->{'details'}->{'nodes'}->{$node_id}->{"client_id"} =
		$client_ids{$agg->aggregate_urn()}->{$node_id};
	}
	if ($debug) {
	    print Dumper($blob);
	}
	$results->{$agg->aggregate_urn()} = $blob;
    }
    goto bad
	if ($errcode);

    $webtask->results($results);
    exit(0);
  bad:
    print STDERR $errmsg . "\n";
    if (defined($webtask)) {
	$webtask->output($errmsg);
	$webtask->Exited($errcode);
    }
    exit($exitcode);
}

#
# Grab the openstack utilization file and stick it into the DB.
# 
sub DoOpenstack()
{
    my $errmsg;
    my $errcode = 1;
    
    #
    # Need to look inside the rspec to find the name of the controller node.
    #
    if (scalar($instance->AggregateList()) > 1) {
	$errmsg = "Too many aggregates, ".
	    "is this really an Openstack experiment?";
	goto bad;
    }
    my ($aggregate) = $instance->AggregateList();
    if (!defined($aggregate->manifest())) {
	$errmsg = "Mo manifest for experiment";
	goto bad;
    }
    my $manifest = GeniXML::Parse($aggregate->manifest());
    if (! defined($manifest)) {
	$errmsg = "Could not parse manifest for $aggregate";
	goto bad;
    }
    #
    # We have to look inside the parameters to find the controller node.
    #
    my $NS = "http://www.protogeni.net/resources/rspec/ext/johnsond/1";
    my $controller;
    foreach my $param (GeniXML::FindNodesNS("n:profile_parameters/n:parameter",
					    $manifest, $NS)->get_nodelist()) {
	my $value = $param->textContent();
	if ($value =~ /^([^=]+)="(.+)"$/) {
	    if (lc($1) eq "controller") {
		$controller = $2;
		print "Controller = $controller\n"
		    if ($debug);
		last;
	    }
	}
    }
    if (!defined($controller)) {
	$errmsg = "Could not find the CONTROLLER parameter";
	goto bad;
    }
    #
    # So now we can ask the aggregate to grab the file from the proper
    # node in the topology; we do not want the cluster to have to figure
    # that part out. Hmm, maybe we should tell the cluster what file too?
    #
    my $response = $aggregate->OpenstackData($controller);
    if (!defined($response)) {
	$errmsg   = "RPC Error calling GetOpenstackStats on $aggregate\n";
	$errcode = -1;
	goto bad;
    }
    if ($response->code() != GENIRESPONSE_SUCCESS) {
	$errmsg  = "Could not get openstack json file for sliver: ".
	    $response->output();
	$errcode = $response->code();
	goto bad;
    }
    if ($debug) {
	print $response->value() . "\n";
    }
    if (defined($webtask)) {
	$webtask->openstackstats($response->value());
    }
    else {
	$instance->Update({"openstack_utilization" => $response->value()});
    }
    exit(0);
  bad:
    print STDERR $errmsg . "\n";
    if (defined($webtask)) {
	$webtask->output($errmsg);
	$webtask->Exited($errcode);
    }
    exit($errcode);
}

#
# Get idledata info from the clusters.
# 
sub DoIdleData()
{
    my $idledata;
    my $errmsg;
    my $errcode;
    my $exitcode = -1;
    my $response;
    my @aggregates = ();
    my %tempfiles = ();

    my $optlist     = "o:";
    my $filename;
    my $outfp;
    
    my %options = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }
    if (defined($options{"o"})) {
	$filename = $options{"o"}
    }
    usage()
	if (@ARGV);
    
    my $slice = $instance->GetGeniSlice();
    if (!defined($slice)) {
	fatal("No slice for instance!");
    }
    
    #
    # Cull out any aggregates with no nodes.
    #
    foreach my $aggregate ($instance->AggregateList()) {
	push(@aggregates, $aggregate)
	    if ($aggregate->physnode_count() || $aggregate->virtnode_count());
    }

    #
    # Open the output file for writing.
    #
    if (defined($filename)) {
	if (!open(FOUT, "> $filename")) {
	    fatal("Could not open $filename for writing: $!");
	}
	$outfp = *FOUT;
    }
    else {
	$outfp = *STDOUT;
    }

    #
    # If more then one aggregate, we pass the data back from the
    # parrun children via temp files, rather then go through the DB
    # via a webtask (the data can be very big). With one aggregate we
    # do not fork, so we can put the data directly into the webtask
    # that comes in on the command line.
    #
    if (@aggregates > 0) {
	foreach my $aggregate (@aggregates) {
	    my ($fp, $filename) = tempfile("/tmp/idledata.XXXXX", UNLINK => 1);
	    if (!defined($fp)) {
		fatal("Could not create temporary file for idle data");
	    }
	    $tempfiles{$aggregate->aggregate_urn()} = [$fp, $filename];
	}
    }

    #
    # Helper callback; if we get back the idledata write it to the
    # temporary file for the parent to pick up. 
    #
    # Clear the response structure to prevent the data from going to
    # database.
    #
    my $coderef = sub {
	my ($sliver) = @_;

	my $response = $sliver->IdleData();
	if ($response && $response->code() == GENIRESPONSE_SUCCESS) {
	    my $json = $response->value();
	    if ($debug) {
		print STDERR $json . "\n";
	    }
	    if (@aggregates > 0) {
		my ($fp) = @{ $tempfiles{$sliver->aggregate_urn()} };
		print $fp $json . "\n";
		close($fp);
	    }
	    $response->value(0);
	}
	return $response;
    };
    
    # Invoke on all clusters
    $errcode = CallMethodOnAggregates($coderef, 0, \$response, @aggregates);
    if ($errcode) {
	$errmsg = $response;
	goto bad;
    }

    #
    # Look at all the responses.
    #
    foreach my $agg (@aggregates) {
	my $response = shift(@{$response});
	my $code = $response->code();

	if ($code != GENIRESPONSE_SUCCESS) {
	    $errcode = $code;
	    if ($code == GENIRESPONSE_REFUSED) {
		$exitcode = 1;
		$errmsg   = $response->error();
	    }
	    else {
		($exitcode, $errmsg) = ResponseErrorMessage($agg, $response);
	    }
	    # Give up now.
	    last;
	}
	print $outfp "" .  $agg->aggregate_urn() . "\n";
	if (@aggregates > 0) {
	    my (undef, $filename) = @{ $tempfiles{$agg->aggregate_urn()} };
	    if (open(TEMP, $filename)) {
		while (<TEMP>) {
		    print $outfp $_;
		}
		close(TEMP);
	    }
	    else {
		$exitcode = -1;
		$errcode  = -1;
		$errmsg   = "Could not open temporary file to read idle data"; 
	    }
	}
    }
    goto bad
	if ($errcode);

    exit(0);
  bad:
    print STDERR $errmsg . "\n";
    if (defined($webtask)) {
	$webtask->output($errmsg);
	$webtask->Exited($errcode);
    }
    exit($exitcode);
}

#
# Use the idledata to determine if an experiment can be extended without
# admin intervention.
#
sub DoCheckAutoApprove()
{
    my $errmsg;
    my $errcode = 1;
    my $results;

    usage()
	if (!@ARGV);
    my $days = shift(@ARGV);

    $errcode = CheckAutoApprove($days * 24, \$results);
    if ($errcode) {
	goto bad;
    }
    print Dumper($results);
    exit($results->{'approve'});

  bad:
    print STDERR $errmsg . "\n" if (defined($errmsg));
    if (defined($webtask)) {
	$webtask->output($errmsg) if (defined($errmsg));
	$webtask->Exited($errcode);
    }
    exit($errcode);
}

sub CheckAutoApprove($$)
{
    my ($hours, $pref) = @_;
    my $errmsg;
    my $errcode = 1;
    my $utilization;
    my $idledata;
    my $loaddata      = {};
    my $slice         = $instance->GetGeniSlice();
    my $expires_time  = str2time($slice->expires());
    my $autoapprove_minloadavg = 0.25;
    my $autoapprove_minsamples = 12 * 18;
    my $autoapprove_ratio = 0.66;
    my $autoapprove_minfree = 0.1;

    #
    # We do not do auto extensions if more then 1000 physical node hours
    # in the request.
    #
    if ($hours * $instance->physnode_count() > 1000) {
	my $rval = {
	    "reason"  => "greater then 1000 node hours requested",
	    "metrics" => undef,
	    "approve" => 0,
	};
	$$pref = $rval;
	return 0;
    }
    # Only shared VMs, people can have them forever.
    if (!$instance->physnode_count()) {
	my $rval = {
	    "reason"  => "extension auto approved because no physical nodes",
	    "metrics" => undef,
	    "approve" => 1,
	};
	$$pref = $rval;
	return 0;
    }
    
    #
    # We do not do auto extensions if more then 1500 physical node hours
    # between current time and time at end of extension. This number needs
    # calibration.
    #
    my $diff = ($expires_time + ($hours * 3600)) - time();
    if ($diff < 0) {
	$errmsg = "Time is in the past. Hmm.\n";
	$errcode= -1;
	goto bad;
    }
    if ((($diff / 3600.0) / $instance->physnode_count()) > 1500) {
	my $rval = {
	    "reason"  => "granting extension would exceed 1500 node hours",
	    "metrics" => undef,
	    "approve" => 0,
	};
	$$pref = $rval;
	return 0;
    }
    
    #
    # We ask the clusters for utilization data which includes freecounts.
    # Cull out any aggregates with no nodes.
    #
    my @aggregates = ();

    foreach my $agg ($instance->AggregateList()) {
	push(@aggregates, $agg)
	    if ($agg->physnode_count() || $agg->virtnode_count());
    }

    $errcode = CallMethodOnAggregates("Utilization", 0,
				      \$utilization, @aggregates);
    if ($errcode) {
	$errmsg = $utilization;
	goto bad;
    }

    #
    # Look at all the responses.
    #
    foreach my $aggregate (@aggregates) {
	my $response = shift(@{$utilization});
	my $code = $response->code();

	if ($code != GENIRESPONSE_SUCCESS) {
	    $errcode = -1;
	    $errmsg  = $response->error();
	    goto bad;
	}
	my $blob = $response->value();
	foreach my $type (keys(%{ $blob->{'typeinfo'} })) {
	    my ($free,$total);
	    my $typeinfo = $blob->{'typeinfo'}->{$type};
	    if (exists($typeinfo->{'reserve_free'})) {
		$free = $typeinfo->{'reserve_free'};
	    }
	    else {
		$free = $typeinfo->{'free'};
	    }
	    $total = $typeinfo->{'total'};
	    # Skip if no data.
	    next
		if (!$total);
	    
	    if ($free / $total < $autoapprove_minfree) {
		my $rval = {
		    "reason"  => "Less then " . $autoapprove_minfree * 100 .
			"% of node type $type are free",
		    "metrics" => $typeinfo,
		    "approve" => 0,
		};
		$$pref = $rval;
		return 0;
	    }
	}
    }
    #
    # We need to know which nodes are physical, we do not worry about
    # the VMs; we want shared nodes to be used, and busy VMs should be
    # reflected in the load on the physical machines.
    #
    my $nodes = $instance->GetNodeDetails();
    if (!defined($nodes)) {
	$errmsg = "Could not get node details for instance\n";
	$errcode= -1;
	goto bad;
    }
    #
    # Ask the clusters for the idle stats. 
    #
    $errcode = CallMethodOnAggregates("IdleData", 0, \$idledata, @aggregates);
    if ($errcode) {
	$errmsg = $idledata;
	goto bad;
    }
    # We consider load average data only.
    foreach my $aggregate (@aggregates) {
	my $urn  = $aggregate->aggregate_urn();
	my $response = shift(@{$idledata});
	my $code = $response->code();

	if ($code != GENIRESPONSE_SUCCESS) {
	    $errcode = -1;
	    $errmsg  = $response->error();
	    goto bad;
	}
	my $json = $response->value();
	my $list = eval { decode_json($json); };
	if ($@) {
	    print STDERR "Could not decode json data\n";
	    next;
	}
	$loaddata->{$urn} = {};

	foreach my $ref (@{ $list }) {
	    my $node_id = $ref->{"node_id"};
	    
	    # Skip virtual nodes.
	    next
		if (!exists($nodes->{$urn}->{$node_id}) ||
		    $nodes->{$urn}->{$node_id}->{'isvirtnode'});

	    if (!exists($ref->{"main"}) ||
		ref($ref->{"main"}) ne "HASH" || 
		!exists($ref->{"main"}->{"AVG"})) {
		print STDERR "No data for $node_id\n";
		$loaddata->{$urn}->{$node_id} = undef;
		next;
	    }

	    #
	    # Look at the last 24 hour 5 minute load average samples on
	    # each node and count the number of samples greater the
	    # threshold.
	    #
	    my @samples = @{ $ref->{"main"}->{"AVG"} };
	    # Skip first one, its the labels.
	    shift(@samples);

	    my $now       = time();
	    my $timelimit = $now - (24 * 3600);	 # Last 24 hours.
	    my $total     = 0;
	    my $count     = 0;

	    # Oldest at the beginning of the list
	    while (@samples) {
		my $sample = pop(@samples);
		my ($stamp, undef, $load5) = @{$sample};
		last
		    if ($stamp < $timelimit);
		$total++;
		# We can get null samples (no data).
		next
		    if (!defined($load5));

		$count++ if ($load5 >= $autoapprove_minloadavg);
	    }
	    $loaddata->{$urn}->{$node_id} = {
		'samples' => $total,
		'busy'    => $count,
	    };
	}
    }
    #
    # Need at least 18 hours of samples on every node and 66% of them
    # have to be above the threshold.
    #
    my $message;
    foreach my $urn (keys(%{$nodes})) {
	foreach my $node_id (keys(%{ $nodes->{$urn} })) {
	    my $details = $nodes->{$urn}->{$node_id};
	    
	    next
		if ($details->{'isvirtnode'});
	    
	    # No data for a node is an error.
	    if (!defined($loaddata->{$urn}->{$node_id})) {
		$message = "No node data for some nodes";
		last;
	    }
	    my $samples = $loaddata->{$urn}->{$node_id}->{'samples'};
	    my $count   = $loaddata->{$urn}->{$node_id}->{'busy'};
	    # Must have 18 hours of samples.
	    if ($samples < $autoapprove_minsamples) {
		$message = "Not enough 5 minute samples for some nodes. ".
		    "(less then $autoapprove_minsamples)";
		last;
	    }
	    # 2/3 of samples greater then the threshold.
	    if ($count / $samples < $autoapprove_ratio) {
		$message = "Some nodes not busy enough in last day. ".
		    "(less then $autoapprove_ratio of ".
		    "$autoapprove_minsamples samples > ".
		    "$autoapprove_minloadavg load average)";
		last;
	    }
	}
	last
	    if (defined($message));
    }
    if (defined($message)) {
	my $rval = {
	    "reason"  => $message,
	    "metrics" => $loaddata,
	    "approve" => 0,
	};
	$$pref = $rval;
	return 0;
    }
    $$pref = {
	"reason"  => "extension auto approved",
	"metrics" => $loaddata,
	"approve" => 1,
    };
    return 0;
    
  bad:
    print STDERR $errmsg . "\n" if (defined($errmsg));
    #
    # We want to return this so that it goes into the record, otherwise
    # we will be confused as to why the auto approval has no data.
    #
    $$pref = {
	"reason"  => $errmsg,
	"metrics" => undef,
	"approve" => 0,
    };
    return $errcode;
}

#
# Schedule slice to terminate. This is an admin action. The lockdown bit
# is cleared, and the lockout bit is set (no more free extensions). The
# expiration is set, and we send email.
#
sub DoSchedTerminate()
{
    my $errcode  = 1;
    my $exitcode = 1;
    my $errmsg;
    my $days;
    my $reason;
    my $creator       = $instance->GetGeniUser();
    my $slice         = $instance->GetGeniSlice();
    my $name          = $instance->name();
    my $url           = $instance->webURL();
    my $clusters      = join(",", map { $_->domain() }
			     $instance->AggregateList());
    my $pcount        = $instance->physnode_count();
    my $expires_time  = str2time($slice->expires());
    my $created_time  = str2time($instance->started());
    my $extensions    = $instance->Brand()->ExtensionsEmailAddress();
    
    usage()
	if (!@ARGV);
    $days = shift(@ARGV);

    if (@ARGV == 2) {
	my $arg = shift(@ARGV);
	if ($arg eq "-m") {
	    $reason = shift(@ARGV);
	}
	else {
	    usage();
	}
    }
    elsif (@ARGV == 1) {
	my $filename = shift(@ARGV);
	if (! -e $filename) {
	    fatal("$filename does not exist");
	}
	open(MSG, $filename) or
	    fatal("Could not open $filename");
	
	$reason = "";
	while (<MSG>) {
	    $reason .= $_;
	}
	close(MSG);
    }
    #
    # Lock the slice in case it is doing something else, like taking
    # a disk image.
    #
    if ($slice->Lock()) {
	$errcode = GENIRESPONSE_BUSY;
	$errmsg  ="Experiment is busy, cannot lock it. Try again later.";
	if (defined($webtask)) {
	    $webtask->output($errmsg);
	    $webtask->Exited($errcode);
	}
	print STDERR "$errmsg\n";
	exit(1);
    }
    if ($instance->admin_lockdown()) {
	$errmsg  = "Must clear the admin lockdown first.";
	$errcode = 1;
	goto bad;
    }
    if (defined($reason) &&
	!TBcheck_dbslot($reason, "default", "fulltext",
			 TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	$errmsg  = "Illegal characters in your reason";
	$errcode = 1;
	goto bad;
    }
    if (!TBcheck_dbslot($days, "default", "int",
			 TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	$errmsg  = "Illegal integer for length";
	$errcode = 1;
	goto bad;
    }
    # No free time.
    $instance->Update({"extension_disabled" => 1});

    #
    # Need to set the new expiration before we clear the lockdown bit,
    # else it might get terminated at the cluster. But, if the
    # expiration is already beyond the desired termination point,
    # leave it alone, all we need to do is set our local expiration,
    # the daemon will take care of it. The reason we do this, is cause
    # it is unclear if setting the expiration backwards (at the CM) is
    # a legal thing to do (although our CM actually permits this).
    #
    if ($expires_time < time() + ($days * 3600 * 24)) {
	my $seconds;
	
	if ($slice->IsExpired()) {
	    # ExtendInternal handles expired slices differently.
	    $seconds = ($days * 3600 * 24);
	}
	else {
	    $seconds = (time() + ($days * 3600 * 24)) - $expires_time;
	}
	if ($errcode = ExtendInternal($slice, $seconds, 1, 1, 0, \$errmsg)) {
	    goto bad;
	}
    }
    else {
	$slice->SetExpiration(time() + ($days * 3600 * 24));
    }
    # Now we can clear this.
    if ($instance->user_lockdown()) {
	if (DoLockdownInternal("clear", "user", 0, \$errmsg)) {
	    $errcode = 1;
	    goto bad;
	}
    }
    my $expires = POSIX::strftime("20%y-%m-%d %H:%M:%S %Z",
				  localtime(str2time($slice->expires())));
    my $created = POSIX::strftime("20%y-%m-%d %H:%M:%S %Z",
				  localtime(str2time($instance->started())));
    my $message = "The site administrator has scheduled this experiment\n".
	($days ? "to terminate in $days days." : "for immediate termination!");
    my $subject = "Experiment Termination Warning: $name";

    #
    # New extension mechanism
    #
    my $extensionargs = {
	"action"   => "request",
	"wanted"   => $days,
	"granted"  => $days,
	"admin"    => 1,
	"uid"      => $this_user->uid(),
	"uid_idx"  => $this_user->uid_idx(),
	"message"  => $message,
    };
    if (defined($reason)) {
	$extensionargs->{"reason"} = $reason;
    }
    if (!defined(APT_Instance::ExtensionInfo->Create($instance,
						     $extensionargs))) {
	print STDERR "Could not create extension info object\n";
    }
    $instance->Brand()->SendEmail($creator->email(), $subject,
			$message . "\n\n" .
			(defined($reason) ? $reason . "\n\n" : "") .
			"Your experiment was started on $created\n".
			"Your experiment will now expire at $expires\n".
			"You are using $pcount physical nodes.\n".
			"It is running on $clusters\n\n".
			"$url\n",
			"$extensions",
			"BCC: $extensions");
    
    if (defined($webtask)) {
	$webtask->Exited(0);
    }
    $slice->UnLock();
    exit(0);
  bad:
    print STDERR $errmsg . "\n";
    if (defined($webtask)) {
	$webtask->output($errmsg);
	$webtask->Exited($errcode);
    }
    exit($exitcode);
}

#
# Grab a "top" for a node using the fast path. Maybe expand this later.
#
sub DoTop()
{
    my $errmsg;
    my $errcode;
    my $exitcode = -1;
    
    usage()
	if (@ARGV != 1);

    my $aggregate;
    my $component_id;

    foreach my $obj ($instance->AggregateList()) {
	my $manifest = GeniXML::Parse($obj->manifest());
	if (! defined($manifest)) {
	    fatal("Could not parse manifest");
	}
	my @nodes = (GeniXML::FindNodes("n:node", $manifest)->get_nodelist(),
		     GeniXML::FindNodesNS("n:vhost", $manifest,
					  $GeniXML::EMULAB_NS)->get_nodelist());
	foreach my $node (@nodes) {
	    my $client_id = GeniXML::GetVirtualId($node);
	    if ($client_id eq $ARGV[0]) {
		my $sliver_urn  = GeniXML::GetSliverId($node);
		my $manager_urn = GetManagerId($node);

		# No sliver urn or a different aggregate.
		next
		    if (! (defined($sliver_urn) &&
			   defined($manager_urn) &&
			   $manager_urn eq $obj->aggregate_urn()));

		$aggregate = $obj;
		$component_id = GeniXML::GetNodeId($node);
		last;
	    }
	}
	last
	    if (defined($aggregate));
    }
    if (!defined($aggregate)) {
	$errmsg   = "No such node in the experiment";
	$errcode  = GENIRESPONSE_BADARGS;
	$exitcode = 1;
	goto bad;
    }

    my $response = $aggregate->Top($component_id);
    if ($response->code()) {
	$errcode = $response->code();
	($exitcode, $errmsg) = ResponseErrorMessage($aggregate, $response);
	goto bad;
    }
    if (defined($webtask)) {
	$webtask->results($response->value());
	$webtask->Exited(0);
    }
    else {
	print Dumper($response->value());
    }
    exit(0);
  bad:
    print STDERR $errmsg . "\n";
    if (defined($webtask)) {
	$webtask->output($errmsg);
	$webtask->Exited($errcode);
    }
    exit($exitcode);
}

#
# Terminate with cause and optionally freeze user. Send email.
#
sub DoDestroy()
{
}

#
# Warn the user and the project leader, optionally terminate/freeze.
#
sub DoWarn()
{
    my $errcode    = 1;
    my $exitcode   = 1;
    my $freeze     = 0;
    my $terminate  = 0;
    my $panic      = 0;
    my $poweroff   = 0;
    my $errmsg;
    my $reason;
    my $logfile;
    my $brand      = $instance->Brand();
    my $creator    = $instance->GetGeniUser();
    my $slice      = $instance->GetGeniSlice();
    my $name       = $instance->name();
    my $pid        = $instance->pid();
    my $project    = $instance->GetProject();
    my $slice_uuid = $slice->uuid();
    my $weburl     = $instance->webURL();

    my $optlist = "f:FTQP";
    my %options = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }
    if (defined($options{"F"})) {
	$freeze = 1;
    }
    if (defined($options{"T"})) {
	$terminate = 1;
    }
    elsif (defined($options{"Q"})) {
	$panic = 1;
	if (defined($options{"P"})) {
	    $poweroff = 1;
	}
    }
    if (defined($options{"f"})) {
	my $filename = $options{"f"};
	if (! -e $filename) {
	    fatal("$filename does not exist");
	}
	open(MSG, $filename) or
	    fatal("Could not open $filename");
	
	$reason = "";
	while (<MSG>) {
	    $reason .= $_;
	}
	close(MSG);
    }
    if (!$freeze && !$terminate && !$panic && !$reason) {
	fatal("Must supply a message!");
    }
    if (!$this_user->IsAdmin()) {
	fatal("Only admins can destroy experiments");
    }
    if (defined($reason) &&
	!TBcheck_dbslot($reason, "default", "html_fulltext",
			 TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
	$errmsg  = "Illegal characters in your reason";
	$errcode = 1;
	goto bad;
    }

    #
    # Just a message.
    #
    if (!($terminate || $panic)) {
	# This will send email if it fails.
	if ($freeze) {
	    my $creator_uid = $instance->creator();
	    system("$TBACCT -u freeze $creator_uid");
	    if ($?) {
		fatal("Could not freeze the user. Email not sent");
	    }
	}
	$reason .= "\n\n";
	if ($freeze) {
	    $reason .=
		"Your account has been frozen until this is resolved.\n\n";
	}
	$reason .= $weburl . "\n";
	
	$brand->SendEmail($creator->email(),
			  "Your $pid/$name experiment",
			  $reason,
			  $brand->OpsEmailAddress(),
			  "X-Portal: Warned\n" .
			  "CC: " . $project->GetLeader()->email() . "\n" .
			  "BCC: " . $brand->OpsEmailAddress());

	if (defined($webtask)) {
	    $webtask->Exited(0);
	}
	exit(0);
    }
    if ($instance->admin_lockdown()) {
	$errmsg  = "Must clear the admin lockdown first.";
	$errcode = 1;
	goto bad;
    }
    
    #
    # Lock the slice in case it is doing something else, like taking
    # a disk image, since 
    #
    if ($slice->Lock()) {
	$errcode = GENIRESPONSE_BUSY;
	$errmsg  ="Experiment is busy, cannot lock it. Try again later.";
	if (defined($webtask)) {
	    $webtask->output($errmsg);
	    $webtask->Exited($errcode);
	}
	print STDERR "$errmsg\n";
	exit(1);
    }
    
    # No free time.
    $instance->Update({"extension_disabled" => 1});

    # Expiration is now, if terminating.
    if ($terminate) {
	$slice->SetExpiration(time());
    }

    # Now we can clear this.
    if ($instance->user_lockdown()) {
	if (DoLockdownInternal("clear", "user", 0, \$errmsg)) {
	    $slice->UnLock();
	    $errcode = 1;
	    goto bad;
	}
    }

    # Hurry up the terminate instead of waiting for the daemon to see it.
    if (!$debug) {
        $logfile = TBMakeLogname("destroy");
	
	if (my $childpid = TBBackGround($logfile)) {
	    my $status = 0;
	    #
	    # Wait a couple of seconds to see if there is going to be an
	    # immediate error. Then return and let it continue to run. This
	    # allows the web server to see quick errors. Later errors will
	    # have to be emailed. 
	    #
	    sleep(10);
	    my $foo = waitpid($childpid, &WNOHANG);
	    if ($foo) {
		$status = $? >> 8;
	    }
	    exit($status);
	}
    }
    if ($panic) {
	# We pass the lock through.
	system("$MANAGEINSTANCE " .
	       (defined($webtask) ? "-t $webtask_id " : "").
	       "  -- panic $uuid -f -L " . ($poweroff ? "-p " : "") . "set");
    }
    else {
	# We pass the lock through.
	system("$MANAGEINSTANCE " .
	       (defined($webtask) ? "-t $webtask_id " : "").
	       "  -d -- terminate $uuid -L");
    }

    #
    # We wait for this to finish since if its the local cluster, we cannot
    # freeze before termination is complete cause of PROTOGENI_LOCALUSER.
    # If there is an error terminating (other then busy), we are kinda
    # screwed.
    #
    if ($?) {
	$slice->UnLock();
	
	if ($debug) {
	    exit ($? >> 8);
	}
	if (defined($webtask)) {
	    $webtask->Refresh();
	    print STDERR $webtask->output() . "\n";
	    $exitcode = $webtask->exitcode();
	}
	else {
	    $exitcode = $? >> 8;
	}
	SENDMAIL($TBOPS,
		 ($panic ?
		  "Unable to quarantine instance with cause!" :
		  "Unable to terminate instance with cause!"),
		 "Pid:    $pid\n".
		 "Name:   $name\n".
		 "Slice:  $slice_uuid\n".
		 "URL:    $weburl\n".
		 "Reason:\n\n" . (defined($reason) ? $reason : "") . "\n",
		 $TBOPS, undef, $logfile);
	unlink($logfile) if (defined($logfile));
	exit($exitcode);
    }
    unlink($logfile) if (defined($logfile));

    my $message;
    my $subject;
    my $xheader;

    if ($panic) {
	$message = "Your experiment, $pid/$name, has been quarantined!\n";
	$subject = "Your experiment $name has been quarantined!";
	$xheader = "Quarantined";
    }
    else {
	$message = "Your experiment, $pid/$name, has been terminated!\n";
	$subject = "Your experiment $name has been terminated with cause!";
	$xheader = "Killed";
    }
    if ($freeze) {
	$message .= "Your account has been frozen until this is resolved.\n";
    }
    if (defined($reason)) {
	$message .= "Reason:\n\n" . $reason . "\n";
    }
    else {
	$message .= "You will be contacted shortly with an explaination.\n";
    }
    if ($panic) {
	$message .= "\n" . $weburl . "\n";
    }
    $brand->SendEmail($creator->email(),
		      $subject,
		      $message,
		      $brand->OpsEmailAddress(),
		      "X-Portal: $xheader\n" .
		      "CC: " . $project->GetLeader()->email() . "\n" .
		      "BCC: " . $brand->OpsEmailAddress());
		      
    # This will send email if it fails.
    if ($freeze) {
	my $creator_uid = $instance->creator();
	system("$TBACCT -u freeze $creator_uid");
	if ($?) {
	    exit($? >> 8);
	}
    }
    exit(0);
  bad:
    print STDERR $errmsg . "\n";
    if (defined($webtask)) {
	$webtask->output($errmsg);
	$webtask->Exited($errcode);
    }
  done:
    exit($exitcode);
}

#
# Relocate an image back here.
#
sub RelocateImage($$$$)
{
    my ($pid, $imagename, $urn, $url) = @_;
    my $this_uid = $this_user->uid();

    my $cmd = "$MANAGEIMAGES relocate ";
    $cmd .= "-d " if ($debug);
    $cmd .= "-s -p $pid -i '$imagename' '$urn' '$url'";
    if ($debug) {
	print "Running '$cmd'\n";
    }
    my $output = emutil::ExecQuiet($cmd);
    if ($?) {
	print $output;
	return -1;
    }
    return 0;
}

#
# Apply extension policies.
#
sub DoApplyExtensionPolicy()
{
    if ($instance->ApplyExtensionPolicies()) {
	fatal("Could not apply extension policies!");
    }
    $instance->Refresh();
    my $disabled = ($instance->extension_disabled() ? "disabled" : "enabled");

    print "Extensions are now $disabled\n";
}

#
# Display instance status.
#
sub DoStatus()
{
    my $asjson     = 0;
    my $refresh    = 0;
    my $doperms    = 1;
    my $status     = $instance->status();
    my $slice      = $instance->GetGeniSlice();
    my $slice_uuid = $instance->slice_uuid();
    my $blob;

    my $optlist = "jrX";
    my %options = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }
    if (defined($options{"j"})) {
	$asjson = 1;
    }
    if (defined($options{"X"})) {
	$doperms = 1;
    }
    if (defined($options{"r"})) {
	$refresh = 1;
    }

    #
    # NOTE: This is called from legacy XMLRPC server, so do a permission
    # check here for it. Only the creator on this path, the web interface
    # will suffice for anyone else.
    #
    if ($doperms) {
	my $creator = $instance->GetGeniUser();
	if (!defined($creator)) {
	    fatal("Cannot lookup creator");
	}
	if (!$this_user->SameUser($creator->emulab_user())) {
	    UserError("Not enough permission to get experiment status");
	}
    }

    # Watch for canceled, tell the user that.
    if ($instance->canceled()) {
	$status = "canceled";
    }
    elsif ($refresh) {
	system("$MANAGEINSTANCE " .
	       (defined($webtask) ? "-t $webtask_id " : "").
	       "  -d -- refresh $uuid");
    }

    if ($asjson) {
	$blob = {
	    "status"  => $status,
	    "uuid"    => $uuid,
	    "wbstore" => $slice_uuid,
	    "url"     => $instance->webURL(),
	    "expires" => TBDateStringGMT($instance->Expires()),
	}
    }
    else {
	print "Status: $status\n";
	print "UUID: $uuid\n";
	print "wbstore: $slice_uuid\n";
    }

    if ($status eq "failed") {
	my $instance_webtask = $instance->webtask();
	#
	# The exitcode provides more info.
	#
	if ($instance_webtask->HasExited()) {
	    $blob->{"failure_code"}    = $instance_webtask->exitcode();
	    $blob->{"failure_message"} = $instance_webtask->output();
	}
    }
    elsif ($status eq "ready") {
	my $total    = 0;
	my $running  = 0;
	my $failed   = 0;
	my $finished = 0;
	
	foreach my $ref ($instance->AggregateList()) {
	    my $sliverstatus = $ref->SliverStatus();

	    foreach my $status (values(%{$sliverstatus})) {
		my $client_id   = $status->{"client_id"};
		my $sliver_data = $status->{"sliver_data"};

		if (exists($sliver_data->{"execute_state"})) {
		    my $execute_state = $sliver_data->{"execute_state"};

		    if ($execute_state eq "exited") {
			my $execute_status = $sliver_data->{"execute_status"};
			if ($execute_status == 0) {
			    $finished++;
			}
			else {
			    $failed++;
			}
		    }
		    else {
			$running++;
		    }
		    $total++;
		}
	    }
	}
	if ($finished || $running || $failed) {
	    if ($asjson) {
		$blob->{"execute_status"} = {
		    "total"    => $total,
		    "running"  => $running,
		    "finished" => $finished,
		    "failed"   => $failed,
		}
	    }
	    else {
		print "Execute Services (running/finished/failed): ".
		    "$running/$finished/$failed\n";
	    }
	}
    }
    if ($asjson) {
	my $json = eval { encode_json($blob); };
	if ($@) {
	    fatal($@);
	}
	print $json;
    }
    return 0;
}

#
# Write instance credentials to files.
#
sub WriteCredentials()
{
    usage()
	if (!@ARGV);
    my $directory = shift(@ARGV);
    fatal("$directory does not exist")
	if (! -e $directory);
    fatal("$directory is not a directory")
	if (! -d $directory);

    return $instance->WriteCredentials($directory);
}

sub fatal($)
{
    my ($mesg) = @_;

    if (defined($webtask)) {
	$webtask->output($mesg);
	$webtask->Exited(-1);
    }
    print STDERR "*** $0:\n".
	         "    $mesg\n";

    # Helpful.
    if (defined($instance)) {
	print STDERR "\n\n" . $instance->webURL() . "\n";
	$instance->Unlock() if ($gotlock);
    }
    # Exit with negative status so web interface treats it as system error.
    exit(-1);
}

sub UserError($;$)
{
    my ($mesg,$code) = @_;
    $code = 1 if (!defined($code));

    if (defined($webtask)) {
	$webtask->output($mesg);
	$webtask->Exited($code);
    }
    print STDERR "*** $0:\n".
	         "    $mesg\n";
    exit($code);
}

#
# A macro to create standard error messages.
#
sub ResponseErrorMessage($$)
{
    my ($aggregate, $response) = @_;
    my $code = $response->code();
    my $errmsg;
    my $exitcode = 1;

    #
    # In general, these errors are to be expected by the caller.
    #
    if ($code == GENIRESPONSE_SEARCHFAILED) {
	$errmsg = "Experiment is gone at " . $aggregate->AptAggregateName();
    }
    elsif ($code == GENIRESPONSE_NOSPACE) {
	$errmsg = "You are over disk quota at " .
	    $aggregate->AptAggregateName() .
	    "; please log in and delete images you no longer need";
    }
    elsif ($code == GENIRESPONSE_BUSY) {
	$errmsg = "Experiment is busy at " . $aggregate->AptAggregateName() .
	    "; try again later";
    }
    elsif ($code == GENIRESPONSE_NETWORK_ERROR) {
	$errmsg = "The " . $aggregate->AptAggregateName() . " cluster " .
	    "cannot be reached; try again later";
    }
    elsif ($code == GENIRESPONSE_SERVER_UNAVAILABLE) {
	$errmsg = "The " . $aggregate->AptAggregateName() . " cluster ".
	    "is currently offline, please try again later";
    }    
    elsif ($code == GENIRESPONSE_RPCERROR ||
	   $code == GENIRESPONSE_SERVERERROR) {
	$errmsg = "Internal server error at the " .
	    $aggregate->AptAggregateName() . " cluster: " . $response->error();
	$exitcode = -1;
    }
    else {
	$errmsg = "The " . $aggregate->AptAggregateName() . " cluster ".
	    "reports: " . $response->error();
	$exitcode = -1;
    }
    return ($exitcode, $errmsg);
}

sub escapeshellarg($)
{
    my ($str) = @_;

    $str =~ s/[^[:alnum:]]/\\$&/g;
    return $str;
}

#
# Call a method at all of the aggregates (slivers) listed. 
#
sub CallMethodOnAggregates($$$@)
{
    my ($method, $retry, $prval, @aggregates) = @_;

    #
    # Create anonymous webtasks to return the value. Note that for the
    # single aggregate case (no parrun) we still create a webtask,
    # which which makes the interface a little bit more consistent
    # regardless of the number of aggregates. Also note that we do
    # not set AutoStore, in case the callee messes with it, we flush it
    # by hand below.
    #
    # NOTE: This also means we are independent of other calls that
    # are using anonymous webtasks instead of the instance webtask.
    # or per-aggregate webtask. No locking required.
    #
    my @webtasks = ();
    foreach my $agg (@aggregates) {
	my $webtask = WebTask->CreateAnonymous();
	if (!defined($webtask)) {
	    print STDERR "Could not create an anonymous webtask!\n";
	    return -1;
	}
	push(@webtasks, $webtask);
    }

    #
    # And tell the backend clusters to do it.
    #
    my $coderef = sub {
	my ($sliver, $method, $webtask) = @{ $_[0] };
	my $aggregate = $sliver->GetAptAggregate();
	my ($errmsg,$errcode);
	my $retries = $retry + 1;
	my $response;

	if (0) {
	    # Need unblessed ref to store into webtask.
	    $response =
		GeniResponse->Create(GENIRESPONSE_SERVER_UNAVAILABLE,
				     undef, "Testing mode");
	    $webtask->response($response);
	    $webtask->Store();
	    return -1;
	}

	#
	# Initial check on the aggregate. Bail if down. We do this in
	# the child since in most cases, we want to do the operation on
	# the clusters that are up (say, terminate). 
	#
	if ($aggregate->CheckStatus(\$errmsg)) {
	    # Need unblessed ref to store into webtask.
	    $response =
		GeniResponse->Create(GENIRESPONSE_SERVER_UNAVAILABLE,
				     undef, $errmsg);
	    $webtask->response($response);
	    $webtask->Store();
	    return -1;
	}
	while ($retries) {
	    #
	    # This can be a coderef for more complicated invocations.
	    #
	    if (ref($method) eq "CODE") {
		$response = &$method($sliver);
	    }
	    else {
		$response = $sliver->$method();
	    }
	    if (!defined($response)) {
		# We want to know about this, something is very wrong.
		$response =
		    GeniResponse->new(GENIRESPONSE_ERROR, -1,
				      "Internal error calling method on ".
				      "$sliver");
		last;
	    }
	    #print Dumper($response);
	    
	    # We can keep trying for these, but not an RPC error.
	    last
		if (! ($response->code() == GENIRESPONSE_BUSY ||
		       $response->code() == GENIRESPONSE_SERVER_UNAVAILABLE ||
		       ($response->code() == GENIRESPONSE_NETWORK_ERROR &&
			$response->value() ==
			GENIRESPONSE_NETWORK_ERROR_NOCONNECT)));
	    #
	    # Wait for a while and try again. 
	    #
	    $retries--;
	    if ($retries) {
		sleep(15);
	    }
	}
	# Need unblessed ref to store into webtask.
	$webtask->response($response->Unbless());
	$webtask->Store();
	return ($response->code() == GENIRESPONSE_SUCCESS ? 0 : -1);
    };
    my @return_codes  = ();
    my @return_values = ();
    
    #
    # Most of the time its just one aggregate, lets not use ParRun.
    #
    if (@aggregates == 1) {
	my $aggregate = $aggregates[0];
	my $webtask   = $webtasks[0];
	my $result;

	@return_codes = (&$coderef([$aggregate, $method, $webtask]));
    }
    else {
	my @tmp = ();
	for (my $i = 0; $i < scalar(@aggregates); $i++) {
	    push(@tmp, [$aggregates[$i], $method, $webtasks[$i]]);
	}
	if (ParRun({"maxwaittime" => 99999,
		    "maxchildren" => scalar(@aggregates)},
		   \@return_codes, $coderef, @tmp)) {
	    $$prval = "Internal error calling $method on $instance";
	    map { $_->Delete(); } @webtasks;
	    return -1;
	}
    }
    
    #
    # Generate a list of responses to return to caller.
    #
    for (my $i = 0; $i < scalar(@aggregates); $i++) {
	my $agg = $aggregates[$i];
	my $webtask = $webtasks[$i];

	# No need to refresh if we did not use ParRun above.
	$webtask->Refresh() if (@aggregates > 1);
	push(@return_values, GeniResponse->Bless($webtask->response()));
    }
    $$prval = \@return_values;
    map { $_->Delete(); } @webtasks;
    return 0;
}

sub PushManifestInternal($)
{
    my ($manifest) = @_;
    my $errmsg;
    my $errcode;
    my @aggregates = ();
    
    foreach my $aggregate ($instance->ActiveAggregateList()) {
	next
	    if (!defined($aggregate->manifest_needpush()));

	push(@aggregates, $aggregate);
    }
    return 0
	if (!@aggregates);

    #
    # Push the manifest out.
    #
    my $coderef = sub {
	my ($sliver) = @_;

	return $sliver->PushPortalManifest($manifest);
    };
    my $responses;

    my $oldtimeo   = Genixmlrpc->SetTimeout(30);
    $errcode = CallMethodOnAggregates($coderef, 0, \$responses, @aggregates);
    Genixmlrpc->SetTimeout($oldtimeo);
    if ($errcode) {
	print STDERR $responses . "\n";
	return -1;
    }
    my $hosed = 0;

    # Lets see which ones we were able to update.
    foreach my $aggregate (@aggregates) {
	my $response = shift(@{$responses});
	my $code     = $response->code();
	my $aptagg   = $aggregate->GetAptAggregate();

	if ($code) {
	    if ($code == GENIRESPONSE_NETWORK_ERROR ||
		$code == GENIRESPONSE_SERVER_UNAVAILABLE) {
		# Still out of contact, keep going.
		print STDERR "Manifest push failed at ". $aptagg->name() .
		    ": $aggregate is unreachable, skipping\n";
	    }
	    elsif ($response->code() == XMLRPC_NO_SUCH_METHOD) {
		print STDERR "Manifest push failed at ". $aptagg->name() .
		    ": does not support manifest push\n";
		$aggregate->ClearManifestPush();
	    }
	    elsif ($code == GENIRESPONSE_SEARCHFAILED) {
		print STDERR "Manifest push failed at ". $aptagg->name() .
		    ": slice does not exist\n";
		$aggregate->ClearManifestPush();
	    }
	    else {
		# All other errors mean we are hosed!
		(undef, $errmsg) = ResponseErrorMessage($aggregate, $response);
		print STDERR "Manifest push failed at ". $aptagg->name() .
		    ": $errmsg\n";
		$aggregate->ClearManifestPush();
		$hosed++;
	    }
	}
	else {
	    # Success, clear the push flag.
	    print "Successfully pushed the manifest to " .
		$aptagg->name() . "\n";
	    $aggregate->ClearManifestPush();
	}
    }
    if ($hosed) {
	return 1;
    }
    return 0;
}

#
# Push out the portal merged manifest.
#
sub DoPushManifest()
{
    my $slice    = $instance->GetGeniSlice();
    my $optlist  = "N";
    my $nolock   = 0;	# Caller holds the lock.

    my %options = ();
    if (! getopts($optlist, \%options)) {
	usage();
    }
    if (defined($options{"N"})) {
	$nolock = 1;
    }

    #
    # Lock the slice in case it is doing something else, like taking
    # a disk image, since 
    #
    if (!$nolock && $slice->Lock()) {
	my $errcode = GENIRESPONSE_BUSY;
	my $errmsg  ="Experiment is busy, cannot lock it. Try again later.";
	if (defined($webtask)) {
	    $webtask->output($errmsg);
	    $webtask->Exited($errcode);
	}
	print STDERR "$errmsg\n";
	exit(1);
    }
    # Might as well regen it since that will flag any new updates.
    if ($instance->MergeManifests()) {
	$slice->UnLock() if (!$nolock);
	fatal("Could not merge manifests");
    }
    my $manifest = $instance->manifest();
    $slice->UnLock() if (!$nolock);
    if ($instance->manifest() eq "") {
	print "No manifest to push\n";
	if (defined($webtask)) {
	    $webtask->Exited(0);
	}
	exit(0);
    }
    if (0 && scalar($instance->AggregateList()) == 1) {
	print "Only one aggregate, no need to push manifest\n";
	if (defined($webtask)) {
	    $webtask->Exited(0);
	}
	exit(0);
    }
    if (PushManifestInternal($manifest)) {
	exit(-1);
    }
    if (defined($webtask)) {
	$webtask->Exited(0);
    }
    exit(0);
}

