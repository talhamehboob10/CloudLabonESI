/*
 * Copyright (c) 2000-2013 University of Utah and the Flux Group.
 * 
 * {{{EMULAB-LICENSE
 * 
 * This file is part of the Emulab network testbed software.
 * 
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This file is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
 * License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this file.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * }}}
 */

/*
 * This is a program agent to manage programs from the event system.
 *
 * You can start, stop, and kill (signal) programs. 
 */

#include <config.h>

#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <netdb.h>
#include <unistd.h>
#include <paths.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/resource.h>
#if defined(__FreeBSD__)
#include <sys/rtprio.h>
#endif
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <pwd.h>
#include <grp.h>
#include <time.h>
#include <sched.h>
#include <assert.h>
#include "tbdefs.h"
#include "log.h"
#include "popenf.h"
#include "systemf.h"
#include "be_user.h"
#include "event.h"

#ifdef HAVE_ELVIN
#include <elvin/elvin.h>
#endif

#ifdef __CYGWIN__
#include <w32api/windows.h>
#include <sys/cygwin.h>
#endif /* __CYGWIN__ */

/**
 * We expressly do _not_ put the logs in /tmp since a reboot might clear them
 * out before we have a chance to get them off the node.  We also avoid /var
 * since a "chatty" program can fill it up, which might cause odd behavior to
 * happen.
 */
static char		*LOGDIR = "/local/logs";

/**
 * Maximum number of agents to be managed by this daemon.
 */
#define MAXAGENTS	250

/**
 * Maximum size of a tag name.
 */
#define MAX_TAG_SIZE	32

/**
 * Version information generated by the GNUmakefile and stored in version.c .
 */
extern char build_info[];

/**
 * The connection to the event system.
 */
static event_handle_t	handle;

/**
 * Debugging flag.
 */
static char		debug;

/**
 * Flag indicating the program agent is running on ops.
 */
static int		isops;

/**
 * The actual number of agents being managed by this daemon.
 */
static int		numagents;

/**
 * The name of the user that the daemon should switch to after the initial
 * setup steps have completed.
 */
static char		*user;

/**
 * Our vnode name, for subscribing to events for the program agent itself.
 */
static char		*vnode;

/**
 * Pipe used by the SIGCHLD handler to notify the main event loop that one or
 * more chld processes are ready to be reaped.
 */
static int		childpipe[2];

/**
 * The config file path.
 */
static char		*configfile;

/**
 * The environment file, which can be in a different place then configfile.
 */
static char		*envfile;

/**
 * The project and experiment ID that this daemon is running in.
 */
static char		*pideid;

/**
 * The name of the token file, which holds a completion token.
 */
static char		*tokenfile;

/**
 * Non-zero if this is a plab node
 * XXX hack to allow adjustment of NODE environment variable
 */
static int		isplab;

#ifdef HAVE_ELVIN
/**
 * Elvin error object.
 */
static elvin_error_t elvin_error;
#elif HAVE_PUBSUB
static pubsub_error_t pubsub_error;
#endif

/**
 * Flags for the proginfo structure.
 */
enum {
	PIB_TIMEOUT_FIRED,	/*< Indicates that the process was terminated
				  via a timeout and not a regular signal. */
	PIB_HALT_COMPLETION,
};

enum {
	PIF_TIMEOUT_FIRED   = (1L << PIB_TIMEOUT_FIRED),
	PIF_HALT_COMPLETION = (1L << PIB_HALT_COMPLETION),
};

/**
 * Structure used to track individual agents.
 */
struct proginfo {
	char		name[TBDB_FLEN_EVOBJNAME];
	
	char	       *initial_dir;
	char	       *dir;
	char	       *initial_cmdline;
	char	       *cmdline;
	char	       *initial_tag;
	char	       *tag;
	unsigned long	initial_timeout;
	unsigned long	timeout;
	int		initial_expected_exit_code;
	int		expected_exit_code;

#ifdef HAVE_ELVIN
	elvin_timeout_t	timeout_handle;
#elif HAVE_PUBSUB
	pubsub_timeout_t *timeout_handle;
#endif
	
	int		pid;
	struct timeval  started;
	unsigned long	token;
	unsigned long	halt_token;
	unsigned long	flags;
	struct proginfo *next;
};

/**
 * Refers to the head of the agent list.
 */
static struct proginfo *proginfos;

/**
 * Handler for program agent events.  This callback will take care of starting,
 * stopping, or signalling the child process.
 *
 * @param handle The connection to the event system.
 * @param notification The start/stop/kill event.
 * @param data NULL
 */
static void	callback(event_handle_t handle,
			 event_notification_t notification,
			 void *data);

/**
 * Handler for the TIME start event.  This callback will stop all running
 * programs, reset the agent configuration to the original version specified in
 * the config file, and delete all the files in the log directory.
 *
 * @param handle The connection to the event system.
 * @param notification The start event.
 * @param data NULL
 */
static void	start_callback(event_handle_t handle,
			       event_notification_t notification,
			       void *data);

/**
 * Handler for the RELOAD event, which tells the program agent to reload
 * its environment.
 *
 * @param handle The connection to the event system.
 * @param notification The start event.
 * @param data NULL
 */
static void	reload_callback(event_handle_t handle,
				  event_notification_t notification,
				  void *data);

/**
 * Start a program.
 *
 * @param pinfo The proginfo to attempt to start.
 * @param token The unique event token corresponding to this start event.
 * @param args The event arguments in "KEY=VALUE" form.
 */
static int	start_program(struct proginfo *pinfo,
			      unsigned long token,
			      char *args);

static void	set_program(struct proginfo *pinfo, char *args);

/**
 * Stop a running program.
 *
 * @param pinfo The proginfo to attempt to stop.
 * @param args The event arguments, should be empty, but is not enforced.
 */
static void	stop_program(struct proginfo *pinfo, char *args);

/**
 * Sends a signal to the given program.
 *
 * @param pinfo The proginfo to attempt to signal.
 * @param args The event arguments, which should contain a 'SIGNAL=<signame>'
 * value.
 */
static void	signal_program(struct proginfo *pinfo, char *args);

/**
 * Parse the configuration file containing the list of agents and their initial
 * settings.
 *
 * @param filename The name of the config file.
 * @return Zero on success, -1 otherwise.
 */
static int	parse_configfile(char *filename);
static int	parse_configfile_env(char *filename);

/**
 * Callback triggered when a program executes passed its timeout value.
 *
 * @param timeout The elvin timeout handle.
 * @param rock The proginfo that executed passed the timeout.
 * @param eerror The elvin error object to use.
 */
#ifdef HAVE_ELVIN
static int	timeout_callback(elvin_timeout_t timeout,
				 void *rock,
				 elvin_error_t eerror);
#elif HAVE_PUBSUB
static int	timeout_callback(pubsub_handle_t *handle,
				 pubsub_timeout_t *timeout,
				 void *rock,
				 pubsub_error_t *eerror);
#endif

/**
 * Callback triggered when there are children to be reaped.
 *
 * @param handler Elvin I/O handle.
 * @param fd The file descriptor that is readable.
 * @param rock NULL
 * @param elvin_error Elvin error structure.
 * @return zero
 */
#ifdef HAVE_ELVIN
static int	child_callback(elvin_io_handler_t handler,
			       int fd,
			       void *rock,
			       elvin_error_t eerror);
#elif HAVE_PUBSUB
static int	child_callback(pubsub_handle_t *handle,
			       pubsub_iohandler_t *handler,
			       int fd,
			       void *rock,
			       pubsub_error_t *eerror);
#endif

/**
 * Handler for SIGCHLD that writes a byte to "childpipe" in order to wake up
 * the event loop and trigger the main child reaping code.
 *
 * @param sig The actual signal number received.
 */
static void
sigchld(int sig)
{
	char dummy = 0;

	(void) write(childpipe[1], &dummy, sizeof(dummy));
}

#if defined(SIGINFO)
/* SIGINFO-related stuff */

/**
 * Variable used to tell the main loop that we received a SIGINFO.
 */
static int	got_siginfo = 0;

/**
 * Handler for SIGINFO that sets the got_siginfo variable and breaks the main
 * loop so we can really handle the signal.
 *
 * @param sig The actual signal number received.
 */
static void
siginfo(int sig)
{
	got_siginfo = 1;
	if (handle->do_loop)
		event_stop_main(handle);
}

/**
 * Dump the proginfos list to standard out.
 */
static void
dump_proginfos(void)
{
	struct proginfo *pi;

	for (pi = proginfos; pi != NULL; pi = pi->next) {
		printf("Agent: %s\n"
		       "  dir: %s\n"
		       "  cmdline: %s\n"
		       "  tag: %s\n"
		       "  timeout: %ld\n"
		       "  pid: %d\n"
		       "  started: %s"
		       "  expected_exit_code: %d\n"
		       "  token: %lu\n",
		       pi->name,
		       pi->dir ? pi->dir : _PATH_TMP,
		       pi->cmdline ? pi->cmdline : "(not set)",
		       pi->tag ? pi->tag : "(not set)",
		       pi->timeout,
		       pi->pid,
		       (pi->pid != 0) ?
		       ctime(&pi->started.tv_sec) : "(not running)\n",
		       pi->expected_exit_code,
		       pi->token);
	}
}
#endif

/**
 * Handler for SIGTERM that kills everything off and exits nicely.
 *
 * @param sig The actual signal number received.
 */
static void
sigterm(int sig)
{
	struct proginfo *pinfo;

	/*
	 * Stop all running programs so that their log files
	 * are complete.
	 */
	for (pinfo = proginfos; pinfo != NULL; pinfo = pinfo->next) {
		if (pinfo->pid != 0) {
			stop_program(pinfo, NULL);
		}
	}

	exit(0);
}

/**
 * Print the usage statement to standard error.
 *
 * @param progname The name of the program as given on the command line.
 */
void
usage(char *progname)
{
	assert(progname != NULL);
	
	fprintf(stderr,
		"Usage: %s [-hVd] [.. options ..] -e pid/eid -c configfile\n"
		"\n"
		"Event-based program executor/manager.\n"
		"\n"
		"Options:\n"
		"  -h\t\tThis help message.\n"
		"  -V\t\tShow version information.\n"
		"  -d\t\tTurn on debugging messages and do not daemonize.\n"
		"  -s server\tElvin server host name.\n"
		"  -p port\tElvin server port number.\n"
		"  -l file\tLog file name.\n"
		"  -k file\tPrivate key file location.\n"
		"  -u user\tUser name to switch to after initialization.\n"
		"  -i file\tPID file name. (Default: %s/progagent.pid)\n"
		"  -e pid/eid\tProject and experiment ID.\n"
		"  -c file\tConfiguration file path.\n"
		"\n"
		"Version: %s\n",
		progname,
		_PATH_VARRUN,
		build_info);
	exit(1);
}

int
main(int argc, char **argv)
{
	FILE *fp;
	address_tuple_t	tuple;
	char *progname;
	char *server = "localhost";
	char *port = NULL;
	char *logfile = NULL;
	char *pidfile = NULL;
	char *keyfile = NULL;
	char buf[BUFSIZ], agentlist[BUFSIZ];
	char pid[MAXHOSTNAMELEN], eid[MAXHOSTNAMELEN];
	struct proginfo *pinfo;
	struct sigaction sa;
	struct passwd *pw;
	struct group *gr;
	struct hostent *he;
	struct stat st;
	char *idx;
	int c;
	int remote = 0;

	progname = argv[0];
	bzero(agentlist, sizeof(agentlist));
	
	while ((c = getopt(argc, argv, "hVdrs:p:l:u:i:e:c:k:f:o:v:t:P")) != -1){
		switch (c) {
		case 'h':
			usage(progname);
			break;
		case 'V':
			fprintf(stderr, "%s\n", build_info);
			exit(0);
			break;
		case 'd':
			debug++;
			break;
		case 'r':
			remote++;
			break;
		case 's':
			server = optarg;
			break;
		case 'p':
			port = optarg;
			break;
		case 'l':
			logfile = optarg;
			break;
		case 'c':
			configfile = optarg;
			break;
		case 'f':
			envfile = optarg;
			break;
		case 'u':
			user = optarg;
			break;
		case 'o':
			LOGDIR = optarg;
			break;
		case 'i':
			pidfile = optarg;
			break;
		case 'e':
			pideid = optarg;
			if ((idx = strchr(pideid, '/')) == NULL) {
				fprintf(stderr,
					"error: malformed pid/eid argument - "
					"%s\n",
					pideid);
				usage(progname);
			}
			else if ((idx - pideid) >= sizeof(pid)) {
				fprintf(stderr,
					"error: pid is too long - %s\n",
					pideid);
				usage(progname);
			}
			else if (strlen(idx + 1) >= sizeof(eid)) {
				fprintf(stderr,
					"error: eid is too long - %s\n",
					pideid);
				usage(progname);
			}
			else {
				strncpy(pid, pideid, (idx - pideid));
				pid[idx - pideid] = '\0';
				strcpy(eid, idx + 1);
			}
			break;
		case 'k':
			keyfile = optarg;
			break;
		case 't':
			tokenfile = optarg;
			break;
		case 'v':
			vnode = optarg;
			if (strcmp(vnode, "ops") == 0)
				isops = 1;
			break;
		case 'P':
			isplab = 1;
			break;
		default:
			usage(progname);
		}
	}
	argc -= optind;
	argv += optind;

	if (!pideid || !configfile) {
		fprintf(stderr,
			"error: pid/eid and config file flags are required\n");
		usage(progname);
	}
	if (!envfile)
	        envfile = configfile;
	
	if (parse_configfile(configfile) != 0)
		exit(1);
	if (!getuid() && !user) {
		fprintf(stderr, "error: cannot run as root with no -u flag\n");
		usage(progname);
	}

	/*
	 * Bump the agent's priority so it has a good chance of receiving
	 * events, particularly the STOP and KILL ones.
	 */
#if defined(__FreeBSD__)
	{
	    struct rtprio rtp;
	    
	    rtp.type = RTP_PRIO_REALTIME;
	    rtp.prio = 15;
	    if (getuid() != 0) {
		warning("main: not running as root, "
			"cannot set real-time priority\n");
	    }
	    else if (rtprio(RTP_SET, 0, &rtp) < 0) {
		pwarning("main: cannot set real-time priority");
	    }
	}
#elif defined(linux)
	{
	    struct sched_param sp;

	    sp.sched_priority = sched_get_priority_max(SCHED_FIFO);
	    if (sched_setscheduler(0, SCHED_FIFO, &sp) < 0) {
		pwarning("main: cannot set real-time priority");
	    }
	}
#endif
	
	if (debug) 
		loginit(0, logfile);
	else {
		/* Become a daemon */
		if (!remote && daemon(0, 0))
			fatal("Cannot daemonize");

		if (logfile)
			loginit(0, logfile);
		else
			loginit(1, "program-agent");
	}
	signal(SIGTERM, sigterm);
	
	/*
	 * Must be a valid user of course.
	 */
	if ((pw = getpwnam(user)) == NULL) {
		fatal("invalid user: %s", user);
	}
	
	if ((gr = getgrgid(pw->pw_gid)) == NULL) {
		fatal("invalid group: %d", pw->pw_gid);
	}

	/*
	 * Cons up the agentlist for subscription below.
	 */
	pinfo = proginfos;
	while (pinfo) {
		info("AGENT: %s, CMD: %s\n", pinfo->name, pinfo->cmdline);

		if (numagents >= MAXAGENTS)
			fatal("Too many agents listed");

		numagents++;
		if (strlen(agentlist))
			strcat(agentlist, ",");
		strcat(agentlist, pinfo->name);
		
		pinfo = pinfo->next;
	}
	info("agentlist: %s\n", agentlist);
	info("user: %s\n", user);

	if (stat(LOGDIR, &st) < 0) {
		sprintf(buf, "mkdir -p -m 0775 %s", LOGDIR);
	    
		if (system(buf) != 0) {
			fatal("Could not make directory: %s", LOGDIR);
		}

		(void) stat(LOGDIR, &st);
	}

	if (st.st_uid != pw->pw_uid || st.st_gid != pw->pw_gid) {
		(void)chown(LOGDIR, pw->pw_uid, pw->pw_gid);
	}

	if (st.st_mode != 0775) {
		chmod(LOGDIR, 0775);
	}
	
	/*
	 * Write out a pidfile if root.
	 */
	if (!getuid()) {
		if (pidfile)
			strcpy(buf, pidfile);
		else
			sprintf(buf, "%s/progagent.pid", _PATH_VARRUN);
		fp = fopen(buf, "w");
		if (fp != NULL) {
			fprintf(fp, "%d\n", getpid());
			(void) fclose(fp);
		}
	}
	
	/*
	 * Flip to the user, but only if we are currently root.
	 */
	be_user(user);

	if (access(LOGDIR, W_OK) < 0) {
		fatal("Cannot write to log directory: %s", LOGDIR);
	}
	
	/*
	 * Make sure the environment is sane.
	 */
	setenv("PATH",
	       _PATH_STDPATH ":/usr/local/bin:/usr/local/sbin:" CLIENT_BINDIR,
	       1);
	snprintf(buf, sizeof(buf), "/proj/%s/exp/%s", pid, eid); // XXX
	setenv("EXPDIR", buf, 1);
	setenv("LOGDIR", LOGDIR, 1);
	setenv("USER", pw->pw_name, 1);
	setenv("GROUP", gr->gr_name, 1);
	setenv("HOME", pw->pw_dir, 1);
	setenv("PID", pid, 1);
	setenv("EID", eid, 1);

	/*
	 * Find the host's control net name/IP.  This will always be the
	 * fully qualified name.  Note that if we cannot resolve the FQN
	 * (which often happens on planetlab nodes) we dig the IP out of
	 * the Emulab DB info.
	 */
	gethostname(buf, sizeof(buf));
	if ((he = gethostbyname(buf)) == NULL) {
		/* XXX should not be hardwired */
		char *ipfile = "/var/emulab/boot/myip";

		warning("WARNING: cannot resolve hostname '%s'"
			" to obtain IP address, reading IP from %s instead\n",
			buf, ipfile);
		fp = fopen(ipfile, "r");
		if (fp == NULL)
			warning("WARNING: cannot get IP address for hostname '%s',"
				" assuming no network links available\n", buf);
		else {
			char ipbuf[BUFSIZ];

			(void) fgets(ipbuf, sizeof(ipbuf), fp);
			(void) fclose(fp);
			if ((idx = strchr(ipbuf, '\n')) != NULL)
				*idx = '\0';
			setenv("NODECNETIP", ipbuf, 1);
		}
	}
	else {
	    struct in_addr ia;

	    memcpy(&ia, he->h_addr, he->h_length);
	    setenv("NODECNETIP", inet_ntoa(ia), 1);	    
	}

#ifdef NOMORE
	/*
	 * XXX for planetlab, hostname is the official hostname as opposed
	 * to the per-experiment Emulab alias.  To be consistent, we want
	 * NODECNET (and hence NODE) to reflect the Emulab name.
	 */
	if (isplab) {
		/* XXX should not be hardwired */
		char *alfile = "/var/emulab/boot/nickname";

		fp = fopen(alfile, "r");
		if (fp != NULL) {
			fgets(buf, sizeof(buf), fp);
			(void) fclose(fp);
			if ((idx = strchr(buf, '\n')) != NULL) {
				*idx++ = '.';
				strncat(buf, OURDOMAIN,
					sizeof(buf) - (idx - buf) - 1);
			}
			setenv("NODECNET", buf, 1);
		}
	} else
		setenv("NODECNET", buf, 1);
#endif
	/*
	 * Now find "the default" experimental network interface by stripping
	 * the domain qualifier and looking that up.  If the short name fails
	 * to resolve, we assume there are no experimental interfaces.
	 *
	 * XXX for backwards compat, we always set NODE even if it does not
	 * resolve.  It might still be useful as a tag.
	 */
	if ((idx = strchr(buf, '.')) != NULL) {
	    *idx = '\0';
	}
	setenv("NODE", buf, 1);
	if ((he = gethostbyname(buf)) != NULL) {
		struct in_addr ia;

		memcpy(&ia, he->h_addr, he->h_length);
		setenv("NODEIP", inet_ntoa(ia), 1);	    
	}

	/* XXX Need to eval the ENV parts of the config file after we've
	 * setup the environment.
	 */
	if (parse_configfile_env(envfile) != 0)
		exit(1);
	
	/*
	 * Change to the temp directory, this will be inherited by any children
	 * that do not have their own directory setting.
	 */
	(void) chdir(_PATH_TMP);

	/*
	 * Install our SIGCHLD handler so that we can send the COMPLETE event
	 * and do other cleanup work.
	 */
	sa.sa_handler = sigchld;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
#if defined(SA_NOCLDSTOP)
	sa.sa_flags = SA_NOCLDSTOP; // We don't care if the child is stopped.
#endif
	sigaction(SIGCHLD, &sa, NULL);

#if defined(SIGINFO)
	signal(SIGINFO, siginfo);
#endif
	
	/*
	 * Convert server/port to elvin thing.
	 *
	 * XXX This elvin string stuff should be moved down a layer. 
	 */
	if (server) {
		snprintf(buf, sizeof(buf), "elvin://%s%s%s",
			 server,
			 (port ? ":"  : ""),
			 (port ? port : ""));
		server = buf;
	}

	/*
	 * Register with the event system. 
	 */
#if 0
	if (remote) {
	        handle = event_register_withkeyfile_withretry(server, 0, 
							      keyfile, 3);
	} else
#endif
	{
	        handle = event_register_withkeyfile(server, 0, keyfile);
	}
	if (handle == NULL) {
		fatal("could not register with event system");
	}
	
	if (remote) event_set_idle_period(handle, 60);

	/*
	 * XXX We need to send COMPLETE events when the children die, so we
	 * have to either use a thread to wait(2) or catch SIGCHLD and hook
	 * into the event loop.  I'm not big on using another thread, so we
	 * catch SIGCHLD wake up the event loop.  Unfortunately, the testbed
	 * event interface doesn't provide a way to wake up the event loop, so
	 * we just cheat and use elvin directly by adding an I/O handler for
	 * a pipe.
	 */
	if (pipe(childpipe) < 0) {
		fatal("could not create pipe");
	}
#ifdef HAVE_ELVIN
	else if ((elvin_error = elvin_error_alloc()) == NULL) {
		fatal("could not allocate elvin error");
	}
	else if (elvin_sync_add_io_handler(NULL,
					   childpipe[0],
					   ELVIN_READ_MASK,
					   child_callback,
					   NULL,
					   elvin_error) == NULL) {
		fatal("could not register I/O callback");
	}
#elif HAVE_PUBSUB
	else if (pubsub_add_iohandler(handle->server,
				      NULL,
				      childpipe[0],
				      0,
				      child_callback,
				      NULL,
				      &pubsub_error) == NULL) {
		fatal("could not register I/O callback");
	}
#endif
	fcntl(childpipe[0], F_SETFL, O_NONBLOCK);
	/* Don't leak the descriptors into the children. */
	fcntl(childpipe[0], F_SETFD, FD_CLOEXEC);
	fcntl(childpipe[1], F_SETFD, FD_CLOEXEC);
	
	/*
	 * Construct an address tuple for subscribing to events for
	 * this node.
	 */
	tuple = address_tuple_alloc();
	if (tuple == NULL) {
		fatal("could not allocate an address tuple");
	}
	/*
	 * Ask for just the program agents we care about. 
	 */
	tuple->expt      = pideid;
	tuple->objtype   = TBDB_OBJECTTYPE_PROGRAM;
	tuple->objname   = agentlist;
	tuple->eventtype =
		TBDB_EVENTTYPE_RUN ","
		TBDB_EVENTTYPE_START ","
		TBDB_EVENTTYPE_STOP ","
		TBDB_EVENTTYPE_HALT ","
		TBDB_EVENTTYPE_KILL;

	/*
	 * Subscribe to the event we specified above.
	 */
	if (! event_subscribe(handle, callback, tuple, NULL)) {
		fatal("could not subscribe to event");
	}

	tuple->objtype   = TBDB_OBJECTTYPE_TIME;
	tuple->objname   = ADDRESSTUPLE_ANY;
	tuple->eventtype = TBDB_EVENTTYPE_START;

	/*
	 * Subscribe to the TIME start event we specified above.
	 */
	if (! event_subscribe(handle, start_callback, tuple, NULL)) {
		fatal("could not subscribe to event");
	}

	snprintf(buf, sizeof(buf), "__%s_program-agent", vnode);
			 
	tuple->objtype   = TBDB_OBJECTTYPE_PROGRAM;
	tuple->objname   = buf;
	tuple->eventtype = TBDB_EVENTTYPE_RELOAD;

	if (tokenfile && access(tokenfile, R_OK) == 0) {
		FILE	*fp;
		unsigned long	token = ~0;
		
		if ((fp = fopen(tokenfile, "r")) != NULL) {
			if (fscanf(fp, "%lu", &token) == 1) {
				event_do(handle,
					 EA_Experiment, pideid,
					 EA_Type, TBDB_OBJECTTYPE_PROGRAM,
					 EA_Name, buf,
					 EA_Event, TBDB_EVENTTYPE_COMPLETE,
					 EA_ArgInteger, "ERROR", 0,
					 EA_ArgInteger, "CTOKEN", token,
					 EA_TAG_DONE);
			}
			else {
				error("tokenfile could not be parsed!\n");
			}
		}
		else {
			errorc("Could not open token file for reading!");
		}
	}

	/*
	 * Subscribe to the RELOAD start event we specified above.
	 */
	if (! event_subscribe(handle, reload_callback, tuple, NULL)) {
		fatal("could not subscribe to reload event");
	}

	/*
	 * Begin the event loop, waiting to receive event notifications:
	 */
	while (1) {
		event_main(handle);

#if defined(SIGINFO)
		if (got_siginfo) {
			dump_proginfos();
			got_siginfo = 0;
		}
#endif
	}

	/*
	 * Unregister with the event system:
	 */
	if (event_unregister(handle) == 0) {
		fatal("could not unregister with event system");
	}

	return 0;
}

static struct proginfo *
find_agent(char *name)
{
	struct proginfo *pinfo, *retval = NULL;
	
	pinfo = proginfos;
	while (pinfo) {
		if (! strcmp(pinfo->name, name)) {
			retval = pinfo;
			break;
		}
		pinfo = pinfo->next;
	}

	return retval;
}

/**
 * Find a program agent with the given PID.
 *
 * @param pid The PID to search for.
 * @return The proginfo object that matches the given PID or NULL, if a match
 * could not be found.
 */
static struct proginfo *
find_agent_pid(pid_t pid)
{
	struct proginfo *pi, *retval = NULL;

	assert(pid > 0);
	
	for (pi = proginfos; (pi != NULL) && (retval == NULL); pi = pi->next) {
		if (pi->pid == pid)
			retval = pi;
	}

	assert((retval == NULL) || (retval->pid == pid));
	
	return retval;
}

static void
callback(event_handle_t handle, event_notification_t notification, void *data)
{
	char		objname[TBDB_FLEN_EVOBJTYPE];
	char		event[TBDB_FLEN_EVEVENTTYPE];
	char		args[BUFSIZ];
	struct proginfo *pinfo;
	struct timeval	now;
	unsigned long	token;
	int32_t		itoken = ~0;

	assert(handle != NULL);
	assert(notification != NULL);
	assert(data == NULL);
	
	gettimeofday(&now, NULL);

	/* Suck out the event information from the notification. */
	if (! event_notification_get_objname(handle, notification,
					     objname, sizeof(objname))) {
		error("Could not get objname from notification!\n");
		return;
	}

	if (! event_notification_get_eventtype(handle, notification,
					       event, sizeof(event))) {
		error("Could not get event from notification!\n");
		return;
	}

	event_notification_get_arguments(handle,
					 notification, args, sizeof(args));

	info("Event: %lu:%d %s %s %s\n", now.tv_sec, now.tv_usec,
	     objname, event, args);

	/* Find the agent and */
	pinfo = find_agent(objname);
	if (!pinfo) {
		error("Invalid program agent: %s\n", objname);
		return;
	}

	event_notification_get_int32(handle, notification,
				     "TOKEN", &itoken);
	token = itoken;

	/* ... dispatch the event. */
	if (strcmp(event, TBDB_EVENTTYPE_START) == 0 ||
	    strcmp(event, TBDB_EVENTTYPE_RUN) == 0) {
		if (start_program(pinfo, token, args) != 0) {
			event_do(handle,
				 EA_Experiment, pideid,
				 EA_Type, TBDB_OBJECTTYPE_PROGRAM,
				 EA_Name, pinfo->name,
				 EA_Event, TBDB_EVENTTYPE_COMPLETE,
				 EA_ArgInteger, "ERROR", -1,
				 EA_ArgInteger, "CTOKEN", token,
				 EA_TAG_DONE);
			pinfo->token = ~0;
			pinfo->flags &= ~(PIF_TIMEOUT_FIRED);
		}
	}
	else if (strcmp(event, TBDB_EVENTTYPE_STOP) == 0) {
		stop_program(pinfo, args);
	}
	else if (strcmp(event, TBDB_EVENTTYPE_HALT) == 0) {
		/*
		 * HALT is special; it sends an event to the caller when
		 * the program actually exits.
		 */
		if (! pinfo->pid) {
			event_do(handle,
				 EA_Experiment, pideid,
				 EA_Type, TBDB_OBJECTTYPE_PROGRAM,
				 EA_Name, pinfo->name,
				 EA_Event, TBDB_EVENTTYPE_COMPLETE,
				 EA_ArgInteger, "ERROR", 0,
				 EA_ArgInteger, "CTOKEN", token,
				 EA_TAG_DONE);
			return;
		}
		pinfo->halt_token = token;
		pinfo->flags |= PIF_HALT_COMPLETION;
		
		stop_program(pinfo, args);
	}
	else if (strcmp(event, TBDB_EVENTTYPE_KILL) == 0) {
		signal_program(pinfo, args);
	}
	else if (strcmp(event, TBDB_EVENTTYPE_MODIFY) == 0) {
		set_program(pinfo, args);
	}
	else {
		error("Invalid event: %s\n", event);
		return;
	}
}

/**
 * Find the file extension of the given path while ignoring any numerical
 * extensions.  For example, calling this function with "foo.zip.1" and
 * "foo.zip" will return a pointer to "zip.1" and "zip" respectively.
 *
 * @param path The path to search for a file extension within.
 * @return NULL if no extension could be found, otherwise a pointer to the
 * first character of the extension.
 */
static char *fileext(char *path)
{
	int has_token = 0, lpc, len;
	char *retval = NULL;
	
	assert(path != NULL);
	
	len = strlen(path);
	for (lpc = len - 1; (lpc > 0) && (retval == NULL); lpc--) {
		if (path[lpc] == '.') {
			int dummy;
			
			if (has_token)
				retval = &path[lpc + 1];
			else if (sscanf(&path[lpc + 1], "%d", &dummy) == 1)
				has_token = 1;
			else
				retval = &path[lpc + 1];
		}
	}
	
	return retval;
}

static void
start_callback(event_handle_t handle,
	       event_notification_t notification,
	       void *data)
{
	char		event[TBDB_FLEN_EVEVENTTYPE];

	assert(handle != NULL);
	assert(notification != NULL);
	assert(data == NULL);

	if (! event_notification_get_eventtype(handle, notification,
					       event, sizeof(event))) {
		error("Could not get event from notification!\n");
		return;
	}

	if (strcmp(event, TBDB_EVENTTYPE_START) == 0) {
		struct proginfo *pinfo;
		DIR *dir;

		for (pinfo = proginfos; pinfo != NULL; pinfo = pinfo->next) {
			if (pinfo->pid != 0) {
				stop_program(pinfo, NULL);
			}

			if (pinfo->cmdline != pinfo->initial_cmdline) {
				free(pinfo->cmdline);
				pinfo->cmdline = pinfo->initial_cmdline;
			}
			if (pinfo->dir != pinfo->initial_dir) {
				free(pinfo->dir);
				pinfo->dir = pinfo->initial_dir;
			}
			if (pinfo->tag != pinfo->initial_tag) {
				free(pinfo->tag);
				pinfo->tag = pinfo->initial_tag;
			}
			pinfo->timeout = pinfo->initial_timeout;
		}

		if ((dir = opendir(LOGDIR)) == NULL) {
			errorc("Cannot clean log directory: %s", dir);
		}
		else {
			struct dirent *de;

			while ((de = readdir(dir)) != NULL) {
				char *ext = NULL;
				char path[1024];
				int len = strlen(de->d_name);
				int got_path = 0, file_or_link = 0;
				if ((len > 0) && (len < sizeof(path)))
				    got_path = sscanf(de->d_name,
						      "%1024[^.].",
						      path) == 1;
#ifndef __CYGWIN__
				file_or_link = (de->d_type == DT_REG) ||
				  (de->d_type == DT_LNK);
#else  /* __CYGWIN__ */
				/* Cygwin struct dirent doesn't have d_type. */
				struct stat st;		/* Use stat instead. */
				file_or_link = got_path && 
				  (stat(path, &st) == 0) &&
				  ((st.st_mode == S_IFREG) ||
				    (st.st_mode == S_IFLNK));
#endif /* __CYGWIN__ */
				if (file_or_link && got_path &&
				    (find_agent(path) != NULL) &&
				    ((ext = fileext(de->d_name)) != NULL) &&
				    ((strncmp(ext, "out", 3) == 0) ||
				     (strncmp(ext, "err", 3) == 0) ||
				     (strncmp(ext, "status", 6) == 0))) {
					snprintf(path,
						 sizeof(path),
						 "%s/%s",
						 LOGDIR,
						 de->d_name);
					unlink(path);
				}
			}
			closedir(dir);
			dir = NULL;
		}
	}
}

static void
reload_callback(event_handle_t handle,
		  event_notification_t notification,
		  void *data)
{
	char		event[TBDB_FLEN_EVEVENTTYPE];
	char		objname[TBDB_FLEN_EVOBJTYPE];
	unsigned long	token;
	int32_t		itoken = ~0;

	assert(handle != NULL);
	assert(notification != NULL);
	assert(data == NULL);

	if (! event_notification_get_eventtype(handle, notification,
					       event, sizeof(event))) {
		error("Could not get event from notification!\n");
		return;
	}
	if (! event_notification_get_objname(handle, notification,
					     objname, sizeof(objname))) {
		error("Could not get objname from notification!\n");
		return;
	}
	event_notification_get_int32(handle, notification,
				     "TOKEN", &itoken);
	token = itoken;

	if (strcmp(event, TBDB_EVENTTYPE_RELOAD) == 0) {
		info("startrun_callback: Got a reload event.\n");

		/*
		 * Ops is special since the file is local and there is no
		 * tmcd or wrapper.
		 */
		if (isops) {
			parse_configfile_env(envfile);

			event_do(handle,
				 EA_Experiment, pideid,
				 EA_Type, TBDB_OBJECTTYPE_PROGRAM,
				 EA_Name, objname,
				 EA_Event, TBDB_EVENTTYPE_COMPLETE,
				 EA_ArgInteger, "ERROR", 0,
				 EA_ArgInteger, "CTOKEN", token,
				 EA_TAG_DONE);

			return;
		}
		
		/*
		 * Wrapper will restart us but first write the token to a
		 * file so that we can send a completion upon restart.
		 */
		if (tokenfile) {
			FILE	*fp;
			
			if ((fp = fopen(tokenfile, "w")) == NULL) {
				errorc("Could not open token file");
				exit(-1);
			}
			fprintf(fp, "%lu\n", token);
			fflush(fp);
			fclose(fp);
		}
		exit(45);
	}
}

/*
 * There are three commands:
 *
 * START	args string is the command to invoke.
 * STOP		no args string.
 * KILL		args string holds the signal *name* to send.
 */

/**
 * Open a new log file for a program agent and update the symlink used to refer
 * to the latest invocation of the agent.
 *
 * @param pinfo The proginfo we are opening the logs for.
 * @param type The log type: "out" for standard out and "err" for standard
 * error.
 * @return The new file descriptor or -1 if there was a failure.
 */
static int
open_logfile(struct proginfo *pinfo, const char *type)
{
	char buf[BUFSIZ], buf2[BUFSIZ];
	int error = 0, retval;

	assert(pinfo != NULL);
	assert(type != NULL);
	assert((strcmp(type, "out") == 0) || (strcmp(type, "err") == 0));

	/*
	 * Construct the name of the log file, which is made up of the program
	 * agent name, the event token, and the type (e.g. out, err).
	 */
	snprintf(buf, sizeof(buf),
		 "%s/%s.%s.%lu",
		 LOGDIR, pinfo->name, type, pinfo->token);
	if ((retval = open(buf, O_WRONLY|O_CREAT|O_TRUNC, 0640)) < 0) {
		errorc("could not create log file %s\n", buf);
	}
	else {
		/*
		 * We've successfully created the file, now create the
		 * symlinks to that refer to the last run and a tagged run.
		 */
		snprintf(buf, sizeof(buf),
			 "./%s.%s.%lu",
			 pinfo->name, type, pinfo->token);
		snprintf(buf2, sizeof(buf2),
			 "%s/%s.%s",
			 LOGDIR, pinfo->name, type);
		if ((unlink(buf2) < 0) && (errno != ENOENT)) {
			error = 1;
			errorc("could not unlink old last run link %s\n",
			       buf2);
		}
		else if (symlink(buf, buf2) < 0) {
			error = 1;
			errorc("could not symlink last run %s\n", buf);
		}
		if (pinfo->tag != NULL) {
			snprintf(buf2, sizeof(buf2),
				 "%s/%s.%s.%s",
				 LOGDIR, pinfo->name, pinfo->tag, type);
			if ((unlink(buf2) < 0) && (errno != ENOENT)) {
				error = 1;
				errorc("could not unlink old tag link %s\n",
				       buf2);
			}
			else if (symlink(buf, buf2) < 0) {
				error = 1;
				errorc("could not symlink tagged run %s\n",
				       buf);
			}
		}
	}

	if (error) {
		close(retval);
		retval = -1;
	}

	return retval;
}

static void
set_program(struct proginfo *pinfo, char *args)
{
	assert(pinfo != NULL);
	assert(args != NULL);
	
	/*
	 * The args string holds the command line to execute. We allow
	 * this to be reset in dynamic events, but is optional; the cuurent
	 * command will be used by default, which initially comes from tmcd.
	 */
	if (args && (strlen(args) > 0)) {
		char *value;
		int rc;

		/*
		 * COMMAND is special. For backward compat it can contain
		 * whitespace but need not be quoted.  In fact, if the string
		 * is quoted, we just pass the quotes through to the program.
		 */
		if ((rc = event_arg_get(args, "COMMAND", &value)) > 0) {
			if (pinfo->cmdline != NULL) {
				if (pinfo->cmdline != pinfo->initial_cmdline) {
					free(pinfo->cmdline);
					pinfo->cmdline = NULL;
				}
			}
			/*
			 * XXX event_arg_get will return a pointer beyond
			 * any initial quote character.  We need to back the
			 * pointer up if that is the case.
			 */
			if (value[-1] == '\'' || value[-1] == '{')
				value--;
			asprintf(&pinfo->cmdline, "%s", value);
			value = NULL;
		}
		if ((rc = event_arg_dup(args, "DIR", &value)) >= 0) {
			if (pinfo->dir != NULL) {
				if (pinfo->dir != pinfo->initial_dir)
					free(pinfo->dir);
			}
			if (rc == 0) {
				pinfo->dir = NULL;
				free(value);
			}
			else if (rc > 0) {
				pinfo->dir = value;
			}
			else {
				assert(0);
			}
			value = NULL;
		}
		if ((rc = event_arg_dup(args, "TAG", &value)) >= 0) {
			if (rc >= MAX_TAG_SIZE) {
				warning("TAG value too large\n");
				free(value);
				value = NULL;
			}
			else {
				if (pinfo->tag != pinfo->initial_tag)
					free(pinfo->tag);
				pinfo->tag = value;
				value = NULL;
			}
		}
		if ((rc = event_arg_get(args,
					"EXPECTED_EXIT_CODE",
					&value)) > 0) {
			if (sscanf(value,
				   "%d",
				   &pinfo->expected_exit_code) != 1) {
				error("EXPECTED_EXIT_CODE is not an int %s",
				      value);
			}
			value = NULL;
		}
		if ((rc = event_arg_get(args, "TIMEOUT", &value)) > 0) {
			if (sscanf(value, "%lu", &pinfo->timeout) != 1) {
				error("TIMEOUT is not an int %s", value);
			}
			value = NULL;
		}
	}
}

static int
start_program(struct proginfo *pinfo, unsigned long token, char *args)
{
	int		pid, in_fd, out_fd = -1, err_fd = -1;
	
	if (pinfo->pid != 0) {
		warning("start_program: %s is still running: %d\n",
			pinfo->name, pinfo->pid);
		return -1;
	}

	set_program(pinfo, args);

	gettimeofday(&pinfo->started, NULL);
	pinfo->token = token;

#ifdef HAVE_ELVIN
	if ((pinfo->timeout > 0) &&
	    (pinfo->timeout_handle =
	     elvin_sync_add_timeout(NULL,
				    pinfo->timeout * 1000,
				    timeout_callback,
				    pinfo,
				    elvin_error)) == NULL) {
		error("Could not add timeout for %s!", pinfo->name);
		return -1;
	}
#elif HAVE_PUBSUB
	if ((pinfo->timeout > 0) &&
	    (pinfo->timeout_handle =
	     pubsub_add_timeout(handle->server,
				NULL,
				pinfo->timeout * 1000,
				timeout_callback,
				pinfo,
				&pubsub_error)) == NULL) {
		error("Could not add timeout for %s!", pinfo->name);
		return -1;
	}
#endif
	
	/*
	 * The command is going to be run via the shell. 
	 * We do not know anything about the command line, so we reinit
	 * the log file so that any output goes into a different file. If
	 * the user command line includes a redirection, that will get the
	 * output since the sh will set up the descriptors appropriately.
	 */
	if (((out_fd = open_logfile(pinfo, "out")) < 0) ||
	    ((err_fd = open_logfile(pinfo, "err")) < 0)) {
		if (out_fd >= 0)
			close(out_fd);
		if (err_fd >= 0)
			close(err_fd);
		
		errorc("could not setup log files");
		return -1;
	}

	/*
	 * Fork a child to run the command in and return to get
	 * more events. 
	 */
	if ((pid = fork()) < 0) {
		error("fork() failed: %s\n", strerror(errno));
		return -1;
	}
	if (pid) {
		info("start_program: %s (pid:%d) starting\n", pinfo->name,pid);
		pinfo->pid = pid;
		close(out_fd);
		close(err_fd);
		return 0;
	}

	if (out_fd != STDOUT_FILENO) {
		dup2(out_fd, STDOUT_FILENO);
		close(out_fd);
	}
	if (err_fd != STDERR_FILENO) {
		dup2(err_fd, STDERR_FILENO);
		close(err_fd);
	}
	
	close(STDIN_FILENO);
	if ((in_fd = open(_PATH_DEVNULL, O_RDONLY)) >= 0) {
		if (in_fd != STDIN_FILENO) {
			dup2(in_fd, STDIN_FILENO);
			close(in_fd);
		}
	}
	
	/*
	 * Drop from the inherited real-time priority to something normal.
	 */
#if defined(__FreeBSD__)
	{
	    /*
	     * XXX Alas, FreeBSD's sched_setscheduler function only works if
	     * you are root, so we cannot drop our priority.  Fortunately, the
	     * rtprio(2) interface works.
	     */
	    struct rtprio rtp;

	    rtp.type = RTP_PRIO_NORMAL;
	    rtp.prio = 0;
	    if (rtprio(RTP_SET, 0, &rtp) < 0) {
		pfatal("Could not drop real-time priority?");
	    }
	}
#elif defined(linux)
	{
	    struct sched_param sp;

	    sp.sched_priority = 0;
	    if (sched_setscheduler(0, SCHED_OTHER, &sp) < 0) {
		pfatal("Could not drop real-time priority?");
	    }
	}
#endif
	
	if (pinfo->dir != NULL) {
		if (chdir(pinfo->dir) < 0) {
			pfatal("Could not change directory to: %s",
			       pinfo->dir);
		}
	}

	/* Make sure parent and child are fully disconnected */
	if (setsid() == -1) {
		pfatal("setsid() failed: %s\n", strerror(errno));
	}

	/*
	 * Exec the shell.  We will reap children by catching SIGCHLD and
	 * causing an Elvin I/O handler to fire.
	 */
#ifndef _PATH_CSHELL
#define _PATH_CSHELL "/bin/csh"
#endif
	execl(_PATH_CSHELL, "csh", "-f", "-c", pinfo->cmdline, (char *)NULL);

	/* Ug */
	pfatal("start_program: exec failed: %s", pinfo->cmdline);
}

static void
stop_program(struct proginfo *pinfo, char *args)
{
	if (!pinfo->pid) {
		warning("stop_program: %s is not running!\n", pinfo->name);
		return;
	}
	if (killpg(pinfo->pid, SIGTERM) < 0 &&
	    killpg(pinfo->pid, SIGKILL) < 0 &&
	    /* The program might've been started with 'sudo'. */
	    systemf("sudo kill -- -%d", pinfo->pid) != 0) {
		error("stop_program: killpg(%d) failed: %s!\n",
		      pinfo->pid,
		      strerror(errno));
	}
}

/*
 * Signal a program.
 */
#ifdef linux
#undef NSIG
#define NSIG 32
const char *const sys_signame[NSIG] = {
	"Signal 0",
	"hup",				/* SIGHUP */
	"int",				/* SIGINT */
	"quit",				/* SIGQUIT */
	"ill",				/* SIGILL */
	"trap",				/* SIGTRAP */
	"abrt",				/* SIGABRT */
	"bus",				/* SIGBUS */
	"fpe",				/* SIGFPE */
	"kill",				/* SIGKILL */
	"usr1",				/* SIGUSR1 */
	"segv",				/* SIGSEGV */
	"usr2",				/* SIGUSR2 */
	"pipe",				/* SIGPIPE */
	"alrm",				/* SIGALRM */
	"term",				/* SIGTERM */
	"stkflt",			/* SIGSTKFLT */
	"chld",				/* SIGCHLD */
	"cont",				/* SIGCONT */
	"stop",				/* SIGSTOP */
	"tstp",				/* SIGTSTP */
	"ttin",				/* SIGTTIN */
	"ttou",				/* SIGTTOU */
	"urg",				/* SIGURG */
	"xcpu",				/* SIGXCPU */
	"xfsz",				/* SIGXFSZ */
	"vtalrm",			/* SIGVTALRM */
	"prof",				/* SIGPROF */
	"winch",			/* SIGWINCH */
	"io",				/* SIGIO */
	"pwr",				/* SIGPWR */
	"sys",				/* SIGSYS */
};
#endif
#ifdef __CYGWIN__
#undef NSIG
#define NSIG 32
const char *const sys_signame[NSIG] = {
	"Signal 0",
	"hup",				/* SIGHUP */
	"int",				/* SIGINT */
	"quit",				/* SIGQUIT */
	"ill",				/* SIGILL */
	"trap",				/* SIGTRAP */
	"abrt",				/* SIGABRT */
	"emt",				/* SIGEMT */
	"fpe",				/* SIGFPE */
	"kill",				/* SIGKILL */
	"bus",				/* SIGBUS */
	"segv",				/* SIGSEGV */
	"sys",				/* SIGSYS */
	"pipe",				/* SIGPIPE */
	"alrm",				/* SIGALRM */
	"term",				/* SIGTERM */
	"urg",				/* SIGURG */
	"stop",				/* SIGSTOP */
	"tstp",				/* SIGTSTP */
	"cont",				/* SIGCONT */
	"chld",				/* SIGCHLD */
	"ttin",				/* SIGTTIN */
	"ttou",				/* SIGTTOU */
	"io",				/* SIGIO */
	"xcpu",				/* SIGXCPU */
	"xfsz",				/* SIGXFSZ */
	"vtalrm",			/* SIGVTALRM */
	"prof",				/* SIGPROF */
	"winch",			/* SIGWINCH */
	"lost",				/* SIGLOST */
	"usr1",				/* SIGUSR1 */
	"usr2",				/* SIGUSR2 */
};
#endif

static void
signal_program(struct proginfo *pinfo, char *args)
{
	char		buf[BUFSIZ], *bp;
	int		i;
	
	if (!pinfo->pid) {
		warning("signal_program: %s is not running!\n", pinfo->name);
		return;
	}

	/*
	 * args string holds the signal number. We can just sccanf it out.
	 */
	if (sscanf(args, "SIGNAL=%s", buf) == 0) {
		error("signal_program: malformed arguments: %s\n", args);
		return;
	}
	bp = buf;

	if (!strncasecmp(buf, "sig", 3))
		bp += 3;
	
	for (i = 1; i < NSIG; i++) {
		if (!strcasecmp(sys_signame[i], bp))
			break;
	}
	if (i == NSIG) {
		error("signal_program: invalid signal: %s\n", buf);
		return;
	}
	
	if (kill(pinfo->pid, i) < 0 &&
	    systemf("sudo kill -%d %d", i, pinfo->pid) != 0) {
		error("signal_program: kill(%d) failed: %s!\n", i,
		      strerror(errno));
	}
}

static int
parse_configfile(char *filename)
{
	FILE	*fp;
	char	buf[BUFSIZ];
	struct proginfo *pinfo;

	assert(filename != NULL);
	assert(strlen(filename) > 0);
	
	if ((fp = fopen(filename, "r")) == NULL) {
		errorc("could not open configfile %s", filename);
		return -1;
	}
	
	while (fgets(buf, sizeof(buf), fp)) {
		int cc = strlen(buf);
		if (buf[cc-1] == '\n')
			buf[cc-1] = '\0';

		if (!strncmp(buf, "UID=", 4)) {
			if (user) {
				info("User already set; ignoring: %s\n", buf);
				continue;
			}
			user = strdup(&buf[4]);
			if (!user) {
				error("parse_configfile: out of memory\n");
				goto bad;
			}
			continue;
		}
		if (!strncmp(buf, "AGENT=", 6)) {
			char *value;
			int rc;
			
			pinfo = (struct proginfo *) calloc(1, sizeof(*pinfo));

			if (!pinfo) {
				error("parse_configfile: out of memory\n");
				goto bad;
			}

			if ((rc = event_arg_get(buf, "AGENT", &value)) <= 0) {
				errorc("parse_configfile: bad agent name");
				goto bad;
			}
			else if (rc >= sizeof(pinfo->name)) {
				error("parse_configfile: "
				      "agent name is too long");
				goto bad;
			}
			strncpy(pinfo->name, value, rc);
			pinfo->name[rc] = '\0';
			
			if ((rc = event_arg_get(buf,
						"COMMAND",
						&pinfo->cmdline)) >= 0) {
				pinfo->cmdline[strlen(pinfo->cmdline) - 1] =
					'\0'; // remove trailing single quote
				/* Prepend exec to replace the 'csh' */
				asprintf(&pinfo->cmdline,
					 "%s",
					 pinfo->cmdline);
			}
			else {
				errorc("parse_configfile: "
				       "malformed command: %s\n",
				       buf);
				goto bad;
			}
			pinfo->initial_cmdline = pinfo->cmdline;
			
			if (((rc = event_arg_get(buf,
						 "TIMEOUT",
						 &value)) > 0) &&
			    (sscanf(value, "%lu", &pinfo->timeout) != 1)) {
				errorc("parse_configfile: "
				       "malformed command: %s\n",
				       buf);
				goto bad;
			}
			pinfo->initial_timeout = pinfo->timeout;
			
			if (((rc = event_arg_get(buf,
						 "EXPECTED_EXIT_CODE",
						 &value)) > 0) &&
			    (sscanf(value,
				    "%d",
				    &pinfo->expected_exit_code) != 1)) {
				errorc("parse_configfile: "
				       "malformed command: %s\n",
				       buf);
				goto bad;
			}
			pinfo->initial_expected_exit_code =
				pinfo->expected_exit_code;
			
			if (event_arg_dup(buf, "DIR", &pinfo->dir) == 0) {
				free(pinfo->dir);
				pinfo->dir = NULL;
			}
			pinfo->initial_dir = pinfo->dir;
			
			if (event_arg_dup(buf, "TAG", &pinfo->tag) == 0) {
				free(pinfo->tag);
				pinfo->tag = NULL;
			}
			pinfo->initial_tag = pinfo->tag;

			pinfo->next = proginfos;
			proginfos   = pinfo;
			continue;
		}
		if (!strncmp(buf, "ENV ", 4)) {
			continue;
		}
		error("parse_configfile: malformed: %s\n", buf);
		goto bad;
	}
	fclose(fp);
	return 0;
 bad:
	fclose(fp);
	return -1;
}

static int
parse_configfile_env(char *filename)
{
	FILE	*fp;
	char	buf[BUFSIZ];

	assert(filename != NULL);
	assert(strlen(filename) > 0);
	
	if ((fp = fopen(filename, "r")) == NULL) {
		errorc("could not open configfile %s", filename);
		return -1;
	}
	
	while (fgets(buf, sizeof(buf), fp)) {
		int cc = strlen(buf);
		char *bp;
		FILE *file;
		
		if (buf[cc-1] == '\n')
			buf[cc-1] = '\0';

		if (isops)
			bp = buf;
		else if (!strncmp(buf, "ENV ", 4))
			bp = &buf[4];
		else
			continue;
		
		/* XXX Kind of a stupid way to eval any variables. */
		if ((file = popenf("echo %s", "r", bp)) != NULL) {
			if (fgets(buf, sizeof(buf), file) != NULL) {
				char *idx;

				if ((idx = strchr(buf, '\n')) != NULL)
					*idx = '\0';
				if ((idx = strchr(buf, '=')) != NULL) {
					*idx = '\0';
					setenv(strdup(buf), idx + 1, 1);
				}
			}
			pclose(file);
		}
	}
	
	fclose(fp);
	return 0;
}

#ifdef HAVE_ELVIN
static int
timeout_callback(elvin_timeout_t timeout, void *rock, elvin_error_t eerror)
#elif HAVE_PUBSUB
static int
timeout_callback(pubsub_handle_t *handle,
		 pubsub_timeout_t *timeout,
		 void *rock,
		 pubsub_error_t *eerror)
#endif
{
	struct proginfo *pi = (struct proginfo *)rock;
	int retval = 0;

	assert(timeout != NULL);
	assert(rock != NULL);

	info("timeout: %s (pid:%d) stopping...\n", pi->name, pi->pid);

	pi->flags |= PIF_TIMEOUT_FIRED;
	pi->timeout_handle = NULL; // Elvin frees this after we return.
	stop_program(pi, "");
	
	return retval;
}

#ifdef HAVE_ELVIN
static int
child_callback(elvin_io_handler_t handler,
	       int fd,
	       void *rock,
	       elvin_error_t eerror)
#elif HAVE_PUBSUB
static int
child_callback(pubsub_handle_t *pshandle,
	       pubsub_iohandler_t *handler,
	       int fd,
	       void *rock,
	       pubsub_error_t *eerror)
#endif
{
	struct timeval now;
	struct rusage ru;
	pid_t child_pid;
	int status;

	assert(handler != NULL);
	assert(fd >= 0);
	assert(rock == NULL);

	gettimeofday(&now, NULL);

	/* Drain the pipe and then */
	while (read(fd, &status, sizeof(status)) > 0) {
	}

	/* ... start reaping children. */
	while ((child_pid = wait3(&status, WNOHANG, &ru)) > 0) {
		struct proginfo *pi;

		if ((pi = find_agent_pid(child_pid)) == NULL) {
			error("wait returned an unknown child! %d\n",
			      child_pid);
		}
		else if (!WIFSTOPPED(status)) {
			char path[MAXPATHLEN], path2[MAXPATHLEN];
			struct stat outst = { .st_size = -1 };
			struct stat errst = { .st_size = -1 };
			int exit_code;
			FILE *file;
			
			pi->pid = 0;
			if (WIFEXITED(status)) {
				if (WEXITSTATUS(status) ==
				    pi->expected_exit_code) {
					exit_code = 0;
				}
				else {
					exit_code = WEXITSTATUS(status);
				}
			}
			else {
				if (status == pi->expected_exit_code)
					exit_code = 0;
				else
					exit_code = status;
			}

			snprintf(path, sizeof(path),
				 "%s/%s.out.%lu",
				 LOGDIR, pi->name, pi->token);
			outst.st_mtime = -1;
			stat(path, &outst);
			snprintf(path, sizeof(path),
				 "%s/%s.err.%lu",
				 LOGDIR, pi->name, pi->token);
			errst.st_mtime = -1;
			stat(path, &errst);
			
			/* Dump a status file and */
			snprintf(path, sizeof(path),
				 "%s/%s.status.%lu",
				 LOGDIR,
				 pi->name,
				 pi->token);
			if ((file = fopen(path, "w")) == NULL) {
				error("unable to create status file");
			}
			else {
				struct timeval total_cpu_time;
				char end_time[64];

				timeradd(&ru.ru_utime,
					 &ru.ru_stime,
					 &total_cpu_time);
				strcpy(end_time, ctime(&now.tv_sec));
				fprintf(file,
					"NAME=%s\n"
					"DIR=%s\n"
					"TIMEOUT=%ld\n"
					"TIMEOUT_FIRED=%d\n"
					"COMMAND=%s\n"
					"TAG=%s\n"
					"TOKEN=%lu\n"
					"OUTMTIME=%ld\n"
					"ERRMTIME=%ld\n"
					"OUTSIZE=%lld\n"
					"ERRSIZE=%lld\n"
					"START_TIME_SECS=%ld\n"
					"START_TIME=%s"
					"END_TIME_SECS=%ld\n"
					"END_TIME=%s"
					"EXIT_CODE=%d\n"
					"EXPECTED_EXIT_CODE=%d\n"
					"CPU_TIME=%ld.%ld\n"
					"MAXRSS=%ld\n",
					pi->name,
					pi->dir ? pi->dir : _PATH_TMP,
					pi->timeout,
					(pi->flags & PIF_TIMEOUT_FIRED) != 0,
					pi->cmdline,
					pi->tag ? pi->tag : "",
					pi->token,
					outst.st_mtime,
					errst.st_mtime,
					(long long)outst.st_size,
					(long long)errst.st_size,
					pi->started.tv_sec,
					ctime(&pi->started.tv_sec),
					now.tv_sec,
					end_time,
					exit_code,
					pi->expected_exit_code,
					total_cpu_time.tv_sec,
					total_cpu_time.tv_usec,
					ru.ru_maxrss);
				fclose(file);
				file = NULL;
			}
			snprintf(path,
				 sizeof(path),
				 "./%s.status.%lu",
				 pi->name,
				 pi->token);
			snprintf(path2,
				 sizeof(path),
				 "%s/%s.status",
				 LOGDIR,
				 pi->name);
			unlink(path2);
			(void) symlink(path, path2);
			if (pi->tag != NULL) {
				snprintf(path2,
					 sizeof(path),
					 "%s/%s.%s.status",
					 LOGDIR, pi->name, pi->tag);
				unlink(path2);
				(void) symlink(path, path2);
			}

			/* ... notify the scheduler of the completion. */
			event_do(handle,
				 EA_Experiment, pideid,
				 EA_Type, TBDB_OBJECTTYPE_PROGRAM,
				 EA_Name, pi->name,
				 EA_Event, TBDB_EVENTTYPE_COMPLETE,
				 EA_ArgInteger, "ERROR", exit_code,
				 EA_ArgInteger, "CTOKEN", pi->token,
				 EA_TAG_DONE);
			
			pi->token = ~0;
			pi->flags &= ~(PIF_TIMEOUT_FIRED);
			
			if (pi->flags & PIF_HALT_COMPLETION) {
				event_do(handle,
					 EA_Experiment, pideid,
					 EA_Type, TBDB_OBJECTTYPE_PROGRAM,
					 EA_Name, pi->name,
					 EA_Event, TBDB_EVENTTYPE_COMPLETE,
					 EA_ArgInteger, "ERROR", exit_code,
					 EA_ArgInteger, "CTOKEN",
					    pi->halt_token,
					 EA_TAG_DONE);
				pi->flags &= ~(PIF_HALT_COMPLETION);
			}
			if (pi->timeout_handle != NULL) {
#ifdef HAVE_ELVIN
				elvin_sync_remove_timeout(pi->timeout_handle,
							  eerror);
#elif HAVE_PUBSUB
				pubsub_remove_timeout(pshandle,
						      pi->timeout_handle,
						      eerror);
#endif
				pi->timeout_handle = NULL;
			}

		}
	}
	
	return 0;
}
